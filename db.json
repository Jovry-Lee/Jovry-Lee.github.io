{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/princess.jpg","path":"images/princess.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/FastCGI和PHP-FPM的关系.md","hash":"f669280b73738dfd9ae55b6adb6734c3c90dbe20","modified":1598791356923},{"_id":"source/_posts/PHP7内核-Cli.md","hash":"0b4a9111589d5564d4a372ea06244bee5f493778","modified":1598791356923},{"_id":"source/_posts/PHP7内核-FPM.md","hash":"ac2a826542c492bd9237f61a7d44072478da13b1","modified":1598791356923},{"_id":"source/_posts/PHP7内核-内存管理-GC机制.md","hash":"61e476df4502059d21a242e78f2abd9b58270d5e","modified":1598791356923},{"_id":"source/_posts/PHP7内核-内存管理-内存池.md","hash":"9f25cab4f28be74781ea804c77298c98321e4b26","modified":1598791356923},{"_id":"source/_posts/PHP7内核-变量.md","hash":"a9b5ab98f428a7fd8ad273c9f259e6306af1ba54","modified":1598791356923},{"_id":"source/_posts/Protobuf简介及安装.md","hash":"25c229ae42ef6ea6e2ba8d7a9b19ebfc080b7371","modified":1598791356923},{"_id":"source/_posts/Ubuntu16-04-Github配置及使用.md","hash":"81e5bb4612a283c618bc4f5f1b8f31c6283837a0","modified":1598791356923},{"_id":"source/_posts/Ubuntu16-04-搭建Hexo-Blog.md","hash":"28923d96e12500422267277d6bae986df2ac48f1","modified":1598791356923},{"_id":"source/_posts/Ubuntu16-04-Nodejs安装.md","hash":"e725e313832c4137ff2a2ac4276eba4571380d7b","modified":1598791356923},{"_id":"source/_posts/Ubuntu16-04-设置SSH密钥.md","hash":"990bfe70f61d8408efee31e03054b14d6d3bdee8","modified":1598791356923},{"_id":"source/about/index.md","hash":"8be2f2c38ce0acac1dec63a2e72c1b563705b25c","modified":1598791356923},{"_id":"source/categories/index.md","hash":"01a1708e13b00d653fa0c83748da326f2a0cc4bd","modified":1598791356923},{"_id":"source/tags/index.md","hash":"c8218dc6d63771c380dd0bb657bbf55290300844","modified":1598791356923},{"_id":"source/_posts/Redis设计与实现-数据结构.md","hash":"086e19c307e187f365f3c88ba3fedd2d352ee589","modified":1598865291187},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1598791356931},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1598791356931},{"_id":"themes/next/.npmignore","hash":"b5753ace1856548855d1f2c31c05da85781629e6","modified":1598791356931},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1598791356931},{"_id":"themes/next/LICENSE.md","hash":"63ea7df5a8dc1b23cc92ca9de3ed16d53367f360","modified":1598791356931},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1598791356931},{"_id":"themes/next/_vendors.yml","hash":"6620a40231c6d90334dd938939fe7e10a8429a70","modified":1598791356931},{"_id":"themes/next/.gitignore","hash":"10fa9758d8f934669c1781564ed9ce83436b11f7","modified":1598791356931},{"_id":"themes/next/package.json","hash":"632f07c15b39584217015f97d37badf201abb7e9","modified":1598791356935},{"_id":"themes/next/README.md","hash":"d5559b6910919a69bbde2e72e504a470d84afbe2","modified":1598791356931},{"_id":"themes/next/_config.yml","hash":"8ec00ec054135a0fd17404ede5bc06da24a1bc03","modified":1598791356931},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1598791356931},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"81dbb25800165f68c21859cd3c09276b9f4cc417","modified":1598791356931},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"eefd073dfb68884cd946f7ec6d3b3619031d7650","modified":1598791356931},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1598791356931},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1598791356931},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1598791356935},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1598791356931},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1598791356931},{"_id":"themes/next/scripts/renderer.js","hash":"c53dbede2ad5f68d7349bc5ed8ac7157d723e987","modified":1598791356935},{"_id":"themes/next/.github/labeler.yml","hash":"a45e489c62bf5bb5eb1866371af331b8cb9c6320","modified":1598791356931},{"_id":"themes/next/.github/release-drafter.yml","hash":"7662e31224a24154c4fe06b95ccbdff51ab8f2cc","modified":1598791356931},{"_id":"themes/next/.github/stale.yml","hash":"0e40b9975455152a690eaf7047135be348966e39","modified":1598791356931},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1598791356931},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1598791356931},{"_id":"themes/next/docs/LICENSE.txt","hash":"8ef5fc1147c196680b06e1accab80c8d236ab951","modified":1598791356931},{"_id":"themes/next/layout/_layout.njk","hash":"bf7e6ca826b6c3f85e14da61d56d7b836d2414c4","modified":1598791356931},{"_id":"themes/next/layout/archive.njk","hash":"08885f48d5878c92c910f8c41e3209eb07b9b80e","modified":1598791356935},{"_id":"themes/next/layout/category.njk","hash":"434fc2b27120ebae91522002eb40e16f2158bd4f","modified":1598791356935},{"_id":"themes/next/layout/index.njk","hash":"d8fa14549fa061e7bdba4ec1472cb45ecea96382","modified":1598791356935},{"_id":"themes/next/layout/page.njk","hash":"4f8f377e4f5511e27de1c2e4a1c13374b6a5d9bd","modified":1598791356935},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1598791356935},{"_id":"themes/next/layout/tag.njk","hash":"09075c80b53b06826e7eb9ce838bca9dc363fac1","modified":1598791356935},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1598791356931},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1598791356931},{"_id":"themes/next/languages/de.yml","hash":"2986eac01218406f45bbd46f98769e1826822b56","modified":1598791356931},{"_id":"themes/next/languages/en.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1598791356931},{"_id":"themes/next/languages/default.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1598791356931},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1598791356931},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1598791356931},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1598791356931},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1598791356931},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1598791356931},{"_id":"themes/next/languages/ja.yml","hash":"a4208ac966fa7c740b4acf72faaec025d8d6e57b","modified":1598791356931},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1598791356931},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1598791356931},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1598791356931},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1598791356931},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1598791356931},{"_id":"themes/next/languages/tr.yml","hash":"cea795fb74bfd48d5aa2dd10a5aff2242f703c65","modified":1598791356931},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1598791356931},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1598791356931},{"_id":"themes/next/languages/zh-CN.yml","hash":"1a1ec7aa00340cefdec5e3241de2d8c8efb29f54","modified":1598791356931},{"_id":"themes/next/languages/zh-HK.yml","hash":"59ed4f9e879004f0f4e2f56acce4ad0f8031c172","modified":1598791356931},{"_id":"themes/next/languages/zh-TW.yml","hash":"e4a6326a97fa72127325179a563dd0bbfc6d565e","modified":1598791356931},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fb2046f2a865e649fe96cb27096d622e4275da1a","modified":1598791356931},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"0200bed29dad088a192ce8e9497980ce86d33002","modified":1598791356931},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"2cd96d9033b77e4496dc4d0efd1873dfc1b0031a","modified":1598791356931},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"7eb808d9b534a9d9d4d3dfc4e38ad63f59b942b8","modified":1598791356931},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"b6d8162264dc4d6d31f1f9c2a940718f12cff874","modified":1598791356931},{"_id":"themes/next/.github/workflows/linter.yml","hash":"f499ad31aea9ec598308475ef0b19b7e4177103c","modified":1598791356931},{"_id":"themes/next/.github/workflows/lock.yml","hash":"70bd0be3f33774e4b0ada3a59c901f8f9cff1013","modified":1598791356931},{"_id":"themes/next/scripts/events/index.js","hash":"89091bc943cd8b8c63b8af3d26fb0a027048e9ba","modified":1598791356935},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1598791356935},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"3acd5189488e720f23e904f2d9d24cf4b15ac1de","modified":1598791356931},{"_id":"themes/next/scripts/filters/minify.js","hash":"be0574c64a38210e449c99d38a760452015060a3","modified":1598791356935},{"_id":"themes/next/scripts/filters/locals.js","hash":"fa1e558f058f93455acdd553ab1be30b26f137e4","modified":1598791356935},{"_id":"themes/next/scripts/filters/post.js","hash":"bac5646993153f9f6a630c9f0052bb17fa760a9c","modified":1598791356935},{"_id":"themes/next/scripts/helpers/engine.js","hash":"2861b738b6f03114b6f922e794fe2b20090d1438","modified":1598791356935},{"_id":"themes/next/scripts/helpers/font.js","hash":"9cf01a3cf62d9b5a1a0db8145088774bf94045c8","modified":1598791356935},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"3b2261da74c7b33cabfbc82cbb3ce9c8046314d4","modified":1598791356935},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"577c510374cf9bcfa8d3a1027e42411a9324805e","modified":1598791356935},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"2f4152bb450dc4ca8e802e78a21c1858fae298b9","modified":1598791356935},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1598791356935},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1598791356935},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9836e3212f889e94ada4c354c7b83f7d7caa9aa7","modified":1598791356935},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1598791356935},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1598791356935},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1598791356935},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"9e2c58d1a4d1dd84fa86144e5b4576b2fd10a37f","modified":1598791356935},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"464effc08e757ce8e1bb094707d06ad829af9d62","modified":1598791356935},{"_id":"themes/next/scripts/tags/note.js","hash":"05be417a17385a31e1a021e1a54b15046cfd8408","modified":1598791356935},{"_id":"themes/next/scripts/tags/pdf.js","hash":"27129fc4014d723ba93ac77b11342da2ee445d96","modified":1598791356935},{"_id":"themes/next/scripts/tags/tabs.js","hash":"2bf00d56b3b289a7dd27e9b5820430a2457a19f3","modified":1598791356935},{"_id":"themes/next/scripts/tags/video.js","hash":"911851fb3a56570b761d133a6e1531ebf864ea83","modified":1598791356935},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1598791356931},{"_id":"themes/next/.github/workflows/tester.yml","hash":"f0fe6d5c4242135d9cde0d830d407094ddf7c062","modified":1598791356931},{"_id":"themes/next/docs/ru/README.md","hash":"f0255b119e28102aef403609c29a605f15b95b70","modified":1598791356931},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"0e204dde6d21f100cba6ca7751de71848490759e","modified":1598791356931},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"8ee5ca39ac4a372a5c0f16e344bbe578af4aeae4","modified":1598791356931},{"_id":"themes/next/docs/zh-CN/README.md","hash":"fc9df0ab84387f0468baa0f4a53c7dd9931dbc6d","modified":1598791356931},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1598791356931},{"_id":"themes/next/layout/_macro/post.njk","hash":"f381d4c485ae484a114040d5654db648e4ac7473","modified":1598791356931},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"3481594d36df9eb5e220a6b981d3e5630376a597","modified":1598791356931},{"_id":"themes/next/layout/_partials/comments.njk","hash":"334e8d8117a46c8c097788811322a62627952219","modified":1598791356931},{"_id":"themes/next/layout/_partials/footer.njk","hash":"9c69b85c9ad86ef5c11d2245f91d98f1be248c40","modified":1598791356931},{"_id":"themes/next/layout/_partials/languages.njk","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1598791356931},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1598791356931},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"24eb5b683310810f93c1d7f68f8f70f1a29fd217","modified":1598791356935},{"_id":"themes/next/layout/_scripts/index.njk","hash":"48cbbca0e4f97b8c25f2a5c408071603cd257a65","modified":1598791356935},{"_id":"themes/next/layout/_scripts/noscript.njk","hash":"4f250d0bf80be06dd2c95c1d4c2ba2624b59cf2a","modified":1598791356935},{"_id":"themes/next/layout/_scripts/pjax.njk","hash":"28a3bcb1ce50924a5a48b0f3756ac3a8736867f1","modified":1598791356935},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"bada07da2a47ed6de6081796367b19dd9e906cfb","modified":1598791356935},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1598791356939},{"_id":"themes/next/layout/_third-party/baidu-push.njk","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1598791356935},{"_id":"themes/next/layout/_third-party/index.njk","hash":"dc4d2dec2f726b8c5c9f5ac7d6dd0eef0814a0d0","modified":1598791356935},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"294b7f6a4fa566e369d8be0ce7b28f35b6c14563","modified":1598791356935},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1598791356935},{"_id":"themes/next/source/css/_colors.styl","hash":"b37f9847d2f95632e911df670b51921a7d748068","modified":1598791356935},{"_id":"themes/next/source/css/_mixins.styl","hash":"b9c3d3087a917c94cf34ffd6621528d377af8fc9","modified":1598791356935},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1598791356939},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1598791356939},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1598791356939},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1598791356939},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1598791356939},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1598791356939},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1598791356939},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1598791356939},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1598791356939},{"_id":"themes/next/source/images/princess.jpg","hash":"a762fc4359785d54e0845f8656b17679af45d40c","modified":1598791356939},{"_id":"themes/next/source/js/algolia-search.js","hash":"a6f78c4cfffa976e4b8043e3486ce99aaba02bda","modified":1598791356939},{"_id":"themes/next/source/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1598791356939},{"_id":"themes/next/source/js/local-search.js","hash":"d57be5b0349610b5b0de303a9574117365d6d554","modified":1598791356939},{"_id":"themes/next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1598791356939},{"_id":"themes/next/source/js/next-boot.js","hash":"da67f3eed604dcdc4e89280c9db69fe1f62818e9","modified":1598791356939},{"_id":"themes/next/source/js/schedule.js","hash":"ababd67895ce49049271601c6928fce56a1c6bbb","modified":1598791356939},{"_id":"themes/next/source/js/utils.js","hash":"eed4ec020dbf499b6479cbe4e1a90b0b4fe4d1e8","modified":1598791356939},{"_id":"themes/next/test/helpers/font.js","hash":"8930b1f16facc18dc6764bf6efd753ca50d3f1cb","modified":1598791356939},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1598791356939},{"_id":"themes/next/test/helpers/next-url.js","hash":"abc4ee5149df6172b2c36b6e85d1993ec748ddea","modified":1598791356939},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1598791356939},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1598791356939},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1598791356939},{"_id":"themes/next/test/tags/group-pictures.js","hash":"caf9f6b9a72e41fb30aa24468a54496fba1fcdd8","modified":1598791356939},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1598791356939},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1598791356939},{"_id":"themes/next/test/tags/link-grid.js","hash":"88ec69e4dc1d493d21254ed9296a2514e91f0f8b","modified":1598791356939},{"_id":"themes/next/test/tags/mermaid.js","hash":"ed5b5a70ee49842501c952c4d62483f1fc8eba6b","modified":1598791356939},{"_id":"themes/next/test/tags/note.js","hash":"1b6bac741212e7ca763ab7f92ed2d4e2868126f4","modified":1598791356939},{"_id":"themes/next/test/tags/pdf.js","hash":"bac003317e5bb5e046848522c5c4a7cf231e53f6","modified":1598791356939},{"_id":"themes/next/scripts/events/lib/config.js","hash":"545ebbd9f5aeb9f7a8e23737664c1f7d701275e1","modified":1598791356935},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1598791356935},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"7b0ea8d28ced63977dc6539920eb044b1098adcb","modified":1598791356935},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"e227174a8ebab8d5b6e8e26faf4fd66c43f045ca","modified":1598791356935},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"f76c7e13fc4304f86260068c9d83d3477b64ee4b","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"199fa9a70914d0019cf0e47f55491183d53d1533","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"a9b18b7447cd5a56cb692c574463a27356eb7fa6","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7b8ce8e9a71cf083f5337fb7c9586be8f7c316e8","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"387e59cd396c62fe095b388c8ff8d4191cfbdeb9","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"1198cb63375a53400431c2e65e3361416cdf8eb6","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"c67984fc868d4799b3aa6d3b3cd060e5260b3a98","modified":1598791356935},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1598791356939},{"_id":"themes/next/test/tags/video.js","hash":"43aaebbc60f19aa69c03b212afff4c4a3fc3b862","modified":1598791356939},{"_id":"themes/next/test/validate/index.js","hash":"ef716c1db8e3c93c320f73b6da4010e03b4eb0ae","modified":1598791356939},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"37bdf020591feb0cf72327c9efd755bf78a0afd6","modified":1598791356931},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"6b502f9e682d1e0083abe229a2f48523ff852c62","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"c082a16163d1fb5d7cf858fb7522fca9d18f1ba6","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"1b6f08cd884081cc67f02c09ce4696c2df4a9d20","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"789915339a6234d6dd7c710cc1f8e728d9b81d35","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"9d650333160ad1977fe42d9770869ff1660a95fe","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"1d1eba50a28518dea5bba34b2737cfb9b0f2cf49","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"fbdb5cdbd80970f201f5c75369eaa00aea369235","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"a9bb52d0537d27cfe670d80e716da6780786ab8a","modified":1598791356935},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"c2ccaac9caeea1a43dc31f4f8368f8f548aab0af","modified":1598791356935},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"b7a66a465e897c27624f0c441375c95c4cb7a5aa","modified":1598791356935},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"f1f5be7b5c40a0b611a50e52d27fa4cc82e01bd9","modified":1598791356935},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"a27b994ab99c684765895ffebf72ae30dcfa0703","modified":1598791356935},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1598791356935},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1598791356935},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"ad197fd728dd7ac90f910fdf80ce848eab3ff187","modified":1598791356935},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"d87df68dff14cfb4d91a77230cd1ac795c2a22d5","modified":1598791356935},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1598791356935},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5c2cd9b6f02bcb6248d3f18638a58e329fe8c0d1","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"cc1450d62d76e59968bdd25836694b8339207384","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"54eab4840443262432ec7c47e56e9859ace2a902","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"ec0474e23ca122b34858ffb0bb8c99f241749c61","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"6252b0353c6a36d03c68ebec1073293442221bd1","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/valine.njk","hash":"ae2cca696dba96dda7958f0d2b642257599dc11c","modified":1598791356935},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"b0efe26601037e621b5cb16f0fe2f347ee27acdb","modified":1598791356935},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"b6746dfad32cc8a46ff8f4194a7a16ca41744803","modified":1598791356935},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"4193e659b5f742f61dcab7d8a36bf3feb546307a","modified":1598791356935},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"97035261aa85c7d39c6ce1211cdefc6248c0446d","modified":1598791356935},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1598791356935},{"_id":"themes/next/layout/_third-party/search/swiftype.njk","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.njk","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"b70157965285a8c1e003c570cfd4b40bcc1fa719","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"8b956fb56284e8fa4a4731b1efd1f25e1b2b4a78","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"7f01be99413143c5158bda6d83d72bfae6ea5864","modified":1598791356935},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"67d80a57f6b2cf23d56276ca8f30f25e3e8707e9","modified":1598791356935},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"007da98b913a62946c03a87f8fa25b3db856caa1","modified":1598791356935},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f2bd7a213c35b37233c687bd4ce0fc1de37bc988","modified":1598791356935},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1598791356935},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1598791356935},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1598791356935},{"_id":"themes/next/source/css/_variables/base.styl","hash":"0bda922162bca08b0191e5b54857772e4bdabe3a","modified":1598791356935},{"_id":"themes/next/source/js/schemes/muse.js","hash":"d7a6c12bb534810eb748d0ba28aff67cccf0bb3f","modified":1598791356939},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d4809783ded05625675b1b4bbd9e99d7f5f7d7f9","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"92915560810c0311dada43ed629b8fc4ff0fc7a4","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"1c75a837faae9aa2d0a5f30d2078aa8d2ccc2552","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"ee8fb8348aa76a9b346927ba4cae5666d8d777f7","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"28368ac06d04ccf0bbf3dc9e0dfcf341c200b28c","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"0c9f72ad98807521cbdcee7b5bbe2e884311db39","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"ea96e86b6bcb160351c18a7edc4a561918a820cb","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"a472fb1afc6486266b85f773501a290e0a80c370","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e1c85ab2831fd7d4bb84aea1850a0160be0023e8","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7ad04d5a02a7618ebb09c1d5a435d46c4df2c620","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"06786e1ed8774f8f08cbfc711296cf189aaf1b8c","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f6d165dae928c12bde3f271d299a93b334116433","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"0c4390d3a394c5ba96daec864b118fd0c4a934ff","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c706733f5196776fe2657a9bebe0a727cf8fe8e5","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"c435cfd858bf82726fff2c85d384e2207bea0370","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"826c7f523f1b3a95fedbae7ef3b13ae2f5d41231","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"78f0b6edc296a9ed5144da9f9752c0b96bebfaa5","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"19fc5ca0784f5d2befddb9d8bc463b916c5c2518","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"5d61dedb3bec1021d52894f9b379e4d0953f6a35","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8998a07acf0dbd10811835c8dfc91d92e680bcae","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"76d0dfb3a8b873a6180604ac6daecf38b6a963a2","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"8a2e724df3d5cd14765eb951f0a9e1dba399fd35","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"d6ecc5dfd15c588782ba5e1df9f915b305622aef","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cf6540e12c2de5befcfb7e92d915e3b75fd53dfa","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"27001ad06f69ff035639210ab2f614861b21a4f4","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"b3fa752f72ca1413289b76c56fbd33a00e3d25d7","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"48ee817d05ddc788423d7f10e9823e23fda81d04","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"2c534d2b2dbc932ad65d335a720a7ba9612bac04","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2896840ab8ac8ab2a7f76d18df893f290ac31625","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"5d8fc91cdb7ee313eb367dcec7d5b2429f98242f","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"f11dca93e334b68a29e792f7abe682993fab7568","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"8cb89864e8245a356d08ef0fee3133810f646fea","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"254e781e7b25e31a1a589c8b38dc608802f1cc6e","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"f1778d2c56974b96dae429456d5c55be325c4946","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"6d8afd8e23c40bb2b2a2edbe4eb0d2671cd81188","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"57e6b5d82a2d85cabfc7275eb0ac758f3c06991d","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"9c8abc55c9d94d384a245013951aba5ecca2f4fe","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"66782e68f1c74a7d0aecef20e2ca16bbe6b52592","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"521b36ea7bb3a843029cbfbb6b5e76e91c40a19f","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"55060cade4547779ba5996643d93763373b5127c","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"469855a72d2c2b63a21df8fbcb8cc41d32cb9bde","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"432e73bc4f99322af6af1852e0ea6e674919c31a","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"43f7d37948232553873ee346d625457bfe704e74","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"77398b426f182823776f38071de3c839e401fbe0","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"920f21dc03b28f006aef7e9d0fd444c2cd283efc","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"15a5e273a8137550c93c8d2a60f9fcf86e04a89e","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"f09bc97e3681d73c38d7d3c5c271486c2c6537e2","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"acfdec45e56cdd6a5ea61e0154f8a6d1bc068214","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"3c029a003e9bf747e1b9cc7c0c127f6028374876","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"29bef220307d86b1eafbb3714381df32d48b5a60","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"be5c46b983df08b9dbac1b4749b1a101b54b6b50","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"dcf426c2a4836386c0c27235de3f9a95c5de67cc","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"cef4e779473daa3761709958243c6b8a57bbd814","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"e1550114d6f5e828d791831153ef0912a14b4d49","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1598791356935},{"_id":"public/about/index.html","hash":"de8f864af190ebd3e2d9031eacc30a056b00025c","modified":1599191615927},{"_id":"public/categories/index.html","hash":"769efe99d8dbebcf9542a2d97b584ce0e59efc2a","modified":1599191615927},{"_id":"public/tags/index.html","hash":"04163596900201815e6fba443467f1cf7069b241","modified":1599191615927},{"_id":"public/archives/index.html","hash":"f9ed30e9e51e8b2094e9a9b03b2e67107495926a","modified":1599191615927},{"_id":"public/archives/page/2/index.html","hash":"3790e5747bc66f704b531542e9fcc766fdbb3964","modified":1599191615927},{"_id":"public/archives/2020/index.html","hash":"ea77085a8bce81e70375bcb89531ea0552712e8f","modified":1599191615927},{"_id":"public/archives/2020/page/2/index.html","hash":"51bb688cd74e5efab088b91d0cdb2d459f21cab5","modified":1599191615927},{"_id":"public/archives/2020/08/index.html","hash":"cd132b2bacb9be0dcc3c027a03de0e666bfa3fa5","modified":1599191615927},{"_id":"public/archives/2020/08/page/2/index.html","hash":"a633ac89885cdf47a05532c9d6c8e24beb58905e","modified":1599191615927},{"_id":"public/categories/PHP/index.html","hash":"15110cc2c82555c26be14551c74f5f6654cb2434","modified":1599191615927},{"_id":"public/categories/Protobuf/index.html","hash":"407073eea4b70135865a9f330ed9ff4b6bad0b61","modified":1599191615927},{"_id":"public/categories/Ubuntu/index.html","hash":"0f3ef0d4619d67cb408d0b2d515967f5173858ab","modified":1599191615927},{"_id":"public/categories/Ubuntu/Config/index.html","hash":"79762346a7633b14286f3482a099c0cfd13386c3","modified":1599191615927},{"_id":"public/categories/Redis/index.html","hash":"5318ec3ff38c7187c969c00f0b0972f86de64061","modified":1599191615927},{"_id":"public/categories/Redis/Note/index.html","hash":"a0df846b373d501f43ee5dd9a71bcb3e2b966050","modified":1599191615927},{"_id":"public/categories/Redis/Note/Redis设计与实现/index.html","hash":"da7312c205a3cad1b27e375d4f27424044f6822d","modified":1599191615927},{"_id":"public/page/2/index.html","hash":"58d3e61cbad8c5b970dd31ead5ca4731cff2b523","modified":1599191615927},{"_id":"public/tags/PHP/index.html","hash":"b11e3043dca5124508fe38faa60e38bf414d9235","modified":1599191615927},{"_id":"public/tags/Protobuf/index.html","hash":"e09d8c67f2c71295f553807163e8f6c7029b5b23","modified":1599191615927},{"_id":"public/tags/Ubuntu/index.html","hash":"ed7c6d32f496a273d44b708beb77864ea708eb7a","modified":1599191615927},{"_id":"public/tags/Config/index.html","hash":"85fbe08045a2c8b59623291a0b01ac78bff41734","modified":1599191615927},{"_id":"public/tags/Git/index.html","hash":"cf502105d443def86d1c2f3c0b6bd5a4b3367782","modified":1599191615927},{"_id":"public/tags/Node-js/index.html","hash":"c48051c93fab28c1f452dbb3809696f241b671cb","modified":1599191615927},{"_id":"public/tags/SSH/index.html","hash":"0652867d7225d729feec30d2d1ddab22b40af0e0","modified":1599191615927},{"_id":"public/tags/Redis/index.html","hash":"d61fc58f379e9d0185fa6cc049b31cc556b2617b","modified":1599191615927},{"_id":"public/tags/Note/index.html","hash":"56437a66014d12186b6cd069e4ce863b6d9ce24b","modified":1599191615927},{"_id":"public/tags/Hexo/index.html","hash":"ff4737d9912596f5796fc099d0e5afece9d67e6c","modified":1599191615927},{"_id":"public/2020/08/25/Redis设计与实现-数据结构/index.html","hash":"6bfb59933e4b896c46bed01607fe9782fefebfcd","modified":1599191615927},{"_id":"public/2020/08/25/Protobuf简介及安装/index.html","hash":"0bc5707dff5e75b53c18315b664bcfeac07bce5a","modified":1599191615927},{"_id":"public/2020/08/25/PHP7内核-内存管理-内存池/index.html","hash":"04acbad409f9a7c01f7ae953b1f5e03eb342dc80","modified":1599191615927},{"_id":"public/2020/08/25/PHP7内核-内存管理-GC机制/index.html","hash":"5187018dcd83a49b911f17cfbe2b8788fb36cda3","modified":1599191615927},{"_id":"public/2020/08/25/FastCGI和PHP-FPM的关系/index.html","hash":"1966bd9868a257a5f17c014a190c5339426a064b","modified":1599191615927},{"_id":"public/2020/08/21/PHP7内核-FPM/index.html","hash":"f18688463c879c4fbcc41de8edfcd15fe73b1751","modified":1599191615927},{"_id":"public/2020/08/21/PHP7内核-Cli/index.html","hash":"e11e3de5a35a7ab2ebf646b4e07a945f896dc31e","modified":1599191615927},{"_id":"public/2020/08/21/PHP7内核-变量/index.html","hash":"7d0c94367041bb04060408ebd761e8d49df6d6cb","modified":1599191615927},{"_id":"public/2020/08/21/Ubuntu16-04-Nodejs安装/index.html","hash":"8209a6029895afba0dbfe04ba42ebbd5174f2d99","modified":1599191615927},{"_id":"public/2020/08/20/Ubuntu16-04-搭建Hexo-Blog/index.html","hash":"e59b630666e603f9df05b3121d5d3812ef65e44f","modified":1599191615927},{"_id":"public/2020/08/19/Ubuntu16-04-设置SSH密钥/index.html","hash":"7919b81cce2c3b94edc260fc741741677ec04d44","modified":1599191615927},{"_id":"public/2020/08/18/Ubuntu16-04-Github配置及使用/index.html","hash":"92fb4cfe402be30f1f1b2a22884622b456dfd8a0","modified":1599191615927},{"_id":"public/index.html","hash":"9fabacf41665feca5d31d6a7496a89953accf3d3","modified":1599191615927},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1598863768558},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1598863768558},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1598863768558},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1598863768558},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1598863768558},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1598863768558},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1598863768558},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1598863768558},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1598863768558},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1598863768558},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1598863768558},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1598863768558},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1598863768558},{"_id":"public/images/princess.jpg","hash":"a762fc4359785d54e0845f8656b17679af45d40c","modified":1598863768558},{"_id":"public/js/algolia-search.js","hash":"a6f78c4cfffa976e4b8043e3486ce99aaba02bda","modified":1598863768558},{"_id":"public/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1598863768558},{"_id":"public/js/local-search.js","hash":"d57be5b0349610b5b0de303a9574117365d6d554","modified":1598863768558},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1598863768558},{"_id":"public/js/next-boot.js","hash":"da67f3eed604dcdc4e89280c9db69fe1f62818e9","modified":1598863768558},{"_id":"public/js/schedule.js","hash":"ababd67895ce49049271601c6928fce56a1c6bbb","modified":1598863768558},{"_id":"public/js/utils.js","hash":"eed4ec020dbf499b6479cbe4e1a90b0b4fe4d1e8","modified":1598863768558},{"_id":"public/js/schemes/muse.js","hash":"d7a6c12bb534810eb748d0ba28aff67cccf0bb3f","modified":1598863768558},{"_id":"public/css/main.css","hash":"042dbc5b680aec10c3b1b04fc633a62d009ebcd4","modified":1598863768558},{"_id":"source/_posts/Redis设计与实现-Redis对象.md","hash":"d6b032f51ce6b8d4fb0dfa61d7393ef714bb7e07","modified":1599119062900},{"_id":"public/2020/08/31/Redis设计与实现-Redis对象/index.html","hash":"d0fdf86ed926c8c6b6869c5fb0f7ca43802e9340","modified":1599191615927},{"_id":"source/_posts/Redis设计与实现-Redis键过期及删除策略.md","hash":"3a37c9ff97762ef79af55cf14463c78af022ff57","modified":1599119104060},{"_id":"source/_posts/redis设计与实现-单机数据库的实现.md","hash":"3e965340cc09a809be9ba992338a3c0e09555822","modified":1599119136184},{"_id":"public/archives/2020/09/index.html","hash":"743d8af6c077a3540d8a1260c909ecc0b8598547","modified":1599191615927},{"_id":"public/2020/09/03/Redis设计与实现-Redis键过期及删除策略/index.html","hash":"41f4a7a18a56cdb2688480da124b702ffb7fb928","modified":1599191615927},{"_id":"public/2020/09/03/redis设计与实现-单机数据库的实现/index.html","hash":"40b218c851e9b17fde2d397774bde6a4e63134be","modified":1599191615927},{"_id":"source/_posts/Redis设计与实现-RDB持久化.md","hash":"83dcb16e1d7badc1d61e5f36ba678104e91e520a","modified":1599187536130},{"_id":"public/2020/09/03/Redis设计与实现-RDB持久化/index.html","hash":"b73ee49cdcb5d6c2f8a003f5e899840d2a011d10","modified":1599191615927},{"_id":"source/_posts/Redis-踩坑记录.md","hash":"1d1161d30b9d409f71cd19ec75ea8fffd4177b63","modified":1599191585917},{"_id":"public/2020/09/04/Redis-踩坑记录/index.html","hash":"86903b98546e6e5a75d3dba9252218877d966eb5","modified":1599191615927}],"Category":[{"name":"PHP","_id":"ckeia7fst00040sg36k1k4zjs"},{"name":"Protobuf","_id":"ckeia7ft2000e0sg398d4fxk2"},{"name":"Ubuntu","_id":"ckeia7ft4000j0sg31nvj6b83"},{"name":"Config","parent":"ckeia7ft4000j0sg31nvj6b83","_id":"ckeia7ft6000r0sg3avrjdlrk"},{"name":"Redis","_id":"ckeia7ftl001s0sg3hrbkbr89"},{"name":"Note","parent":"ckeia7ftl001s0sg3hrbkbr89","_id":"ckeia7ftn001x0sg36sz1hwiq"},{"name":"Redis设计与实现","parent":"ckeia7ftn001x0sg36sz1hwiq","_id":"ckeia7fto00220sg3fw6e9i73"}],"Data":[],"Page":[{"title":"about","date":"2020-08-30T10:41:26.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-08-30 18:41:26\n---\n","updated":"2020-08-30T12:42:36.923Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckeia7fsa00000sg3bj4p0zwy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2020-08-30T10:41:50.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-08-30 18:41:50\ntype: \"categories\"\n---\n","updated":"2020-08-30T12:42:36.923Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckeia7fsr00020sg364z2bvdo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-08-30T10:41:43.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-08-30 18:41:43\ntype: tags\n---\n","updated":"2020-08-30T12:42:36.923Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckeia7fsv00060sg3fdeuggv3","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"FastCGI和PHP-FPM的关系","date":"2020-08-25T02:11:05.000Z","_content":"\n#### 1 相关概念\n\n##### 1.1 CGI\n\n`CGI`（Common Gateway Interface, 通用网关接口）是`WEB服务器`与`WEB Application`进行通信的工具，用于保证WEB Server传递的数据是标准格式的，是一种协议，其程序运行在服务器上，CGI可以用任何一种语言编写，只要该语言具有标准输入、输出和环境变量，如PHP、Perl等。\n\n<!--more-->\n\n<u>WEB Server只是内容的分发者</u>。CGI规定要传输哪些数据，以什么格式传递给后方处理。\n\n- 若客户端请求的是**静态数据**（如：`/index.html`），那么WEB Server会取文件系统中找到这个文件，并发送给浏览器，其流程如下所示：\n![客户端请求静态数据](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/客户端请求静态数据.png)\n\n- 若请求的是**非静态数据**（如：`/index.php`），根据配置文件，WEB Server（如：Nginx）知道这个不是静态文件，那么Nginx将会把该请求简单处理后交给PHP解析器。比如：URL、查询字符串、POST数据、HTTP Header等。PHP解析器收到数据首先会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程。WEB Server再把结果返回给浏览器。其流程如下所示：\n\n![客户端请求动态数据](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/客户端请求非静态数据.png)\n\n**缺陷**：<u>CGI只是个协议，与进程没有关系，PHP解析器在每次请求都会解析php.ini文件，初始化执行环境。所以处理时间耗时较长。</u>\n\n\n\n##### 1.2 FastCGI\n\n`FastCGI`（Fast Common Gateway Interface，快速通用网关接口）是一种让交互程序与WEB服务器通信的协议。FastCGI是CGI的增强版，通过常驻（Long-live）进程解决了CGI的Fork-Execute的缺点，减少Web服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。\n\n**FastCGI的实现**：FastCGI通过FastCGI进程管理器管理进程，在其自身初始化时，会fork多个FastCGI进程，并等待WEB服务器的连接。当一个请求来时，Web服务器将环境变量和页面请求通过socket或TCP连接传递给FastCGI进程。响应通过相同的连接从进程返回到WEB服务器，再传递给客户端。\n\n（*注：每次请求连接可能在相应结束时关闭，但WEB服务器和FastCGI服务进程都将持续，不会销毁。*）\n\n![FastCGI处理过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/FastCGI处理过程.png)\n\n**FastCGI优点**：\n\n- ①、每个单独的FastCGI进程在其生命周期内可以处理多个请求，从而避免每个请求进程创建和终止的开销。\n\n- ②、并发处理多个请求稳定性和可扩展性（配置多个FastCGI服务器）。\n\n\n\n**FastCGI的缺点**：\n\n- 由于FastCGI是多进程的，所以相比CGI多进程消耗更多服务器内存（如：PHP-CGI解释器每进程消耗7~25M内存，将这个数乘以50或100将是很大的内存数。）\n\n\n\n##### 1.3 PHP-CGI\n\n`php-cgi`是早期php官方出品的FastCGI管理器。\n\n缺点：\n\n①、PHP-CGI更改了php.ini配置后需要重启php-cgi才能让配置生效，不支持平滑重启。\n\n②、直接杀死PHP-CGI进程，PHP就不能运行了。而PHP-FPM和SPAWN-FCGI在杀掉进程后，守护进程会平滑重新生成子进程。\n\n③、不支持动态worker调度，只能一开始指定要起几个worker。\n\n\n\n##### 1.4 PHP-FPM\n\nPHP-CGI是使用PHP语言实现的了FastCGI的一个程序，后来被PHP官方收了。\n\nPHP-FPM加入了动态调度功能，可以根据请求来访压力变化动态增加worker进程数量来支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置\n\n\n\n#### 2 Web Server传递数据给Web Application（PHP应用）的方法\n\nPHP使用SAPI提供的2种连接方法与WEB Server通信：`mod_php`和`mod_fastcgi`。其中Apache通过mod_php来解析PHP，Nginx通过mod_fastcgi来解析。\n\n##### 2.1 Mod_php模式\n\nmod_php通过嵌入PHP解释器到Web Server进程中，只能与WEB Server配合使用。以Apache为例，其调用PHP执行过程如下：\n\n![Mod_php处理过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/Mod_php模式.png)\n\n`Apache->httpd->php5_module->sapi->php`\n\n**缺点**：\n\n- ①、该种模式下，WEB服务器每接收一个请求，都会产生一个进程通过sapi接连PHP完成请求，若用户过多，并发量大时，服务器会承受不住。\n\n- ②、内存占用大，无论是否用到PHP解释器都会将其加在到内存中，典型的就是处理CSS、JS之类的静态文件是完全没有必要加载解释器。\n\n- ③、把mod_php编进Web服务器时，出问题很难定位是php的问题还是WEB服务器的问题。\n\n\n\n**2.2 Mod_FastCGI模式**\n\n`mod_fastcgi`以独立的进程形式出现，只要对应的WEB Server（如：Nginx）实现了cgi/fastCgi协议，就能处理PHP请求。\n\n\n\n##### 2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】\n\n- ①、若仅在Web服务器上运行PHP，那么Apache相较Nginx有更高的性能，若看到明显的性能差异，则应检查AllowOverride是否打开（httpd.conf），然后重试。\n\n- ②、若运行混合内容（例如添加CSS,JS和图像），则Nginx将提供更好的总体性能，但不会更快地运行PHP。另外Nginx在拒绝服务攻击及减轻CDN风险做的更好。\n\n#### 3 总结\n\n简单的来说，`PHP-FPM`是实现了`FastCGI协议`的一个`进程管理器`。它通过常驻内存的方式解决了早期CGI实现每次都需要解析php.ini及初始化执行环境导致的耗时长的问题，支持平滑启动及动态Worker调度。\n\n\n\n#### 参考资料\n\n1. [搞不清FastCGI与PHP-FPM之间是个什么样的关系？](https://segmentfault.com/q/1010000000256516)\n\n2. [概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM](http://www.nowamagic.net/librarys/veda/detail/1319)\n3. [在Nginx中理解和实现FastCGI代理](https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx)\n\n4. [php中fastcgi和php-fpm是什么东西](https://zhuanlan.zhihu.com/p/101433025)\n\n5. [FastCGI](https://zh.wikipedia.org/wiki/FastCGI)\n6. [php-cgi和php-fpm有什么关系？](https://segmentfault.com/q/1010000008356979)\n\n7. [WHY IS FASTCGI /W NGINX SO MUCH FASTER THAN APACHE /W MOD_PHP?](https://www.eschrade.com/page/why-is-fastcgi-w-nginx-so-much-faster-than-apache-w-mod_php/)\n8. [CGI、FastCGI和PHP-FPM关系图解](https://www.awaimai.com/371.html)","source":"_posts/FastCGI和PHP-FPM的关系.md","raw":"---\ntitle: FastCGI和PHP-FPM的关系\ndate: 2020-08-25 10:11:05\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n#### 1 相关概念\n\n##### 1.1 CGI\n\n`CGI`（Common Gateway Interface, 通用网关接口）是`WEB服务器`与`WEB Application`进行通信的工具，用于保证WEB Server传递的数据是标准格式的，是一种协议，其程序运行在服务器上，CGI可以用任何一种语言编写，只要该语言具有标准输入、输出和环境变量，如PHP、Perl等。\n\n<!--more-->\n\n<u>WEB Server只是内容的分发者</u>。CGI规定要传输哪些数据，以什么格式传递给后方处理。\n\n- 若客户端请求的是**静态数据**（如：`/index.html`），那么WEB Server会取文件系统中找到这个文件，并发送给浏览器，其流程如下所示：\n![客户端请求静态数据](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/客户端请求静态数据.png)\n\n- 若请求的是**非静态数据**（如：`/index.php`），根据配置文件，WEB Server（如：Nginx）知道这个不是静态文件，那么Nginx将会把该请求简单处理后交给PHP解析器。比如：URL、查询字符串、POST数据、HTTP Header等。PHP解析器收到数据首先会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程。WEB Server再把结果返回给浏览器。其流程如下所示：\n\n![客户端请求动态数据](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/客户端请求非静态数据.png)\n\n**缺陷**：<u>CGI只是个协议，与进程没有关系，PHP解析器在每次请求都会解析php.ini文件，初始化执行环境。所以处理时间耗时较长。</u>\n\n\n\n##### 1.2 FastCGI\n\n`FastCGI`（Fast Common Gateway Interface，快速通用网关接口）是一种让交互程序与WEB服务器通信的协议。FastCGI是CGI的增强版，通过常驻（Long-live）进程解决了CGI的Fork-Execute的缺点，减少Web服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。\n\n**FastCGI的实现**：FastCGI通过FastCGI进程管理器管理进程，在其自身初始化时，会fork多个FastCGI进程，并等待WEB服务器的连接。当一个请求来时，Web服务器将环境变量和页面请求通过socket或TCP连接传递给FastCGI进程。响应通过相同的连接从进程返回到WEB服务器，再传递给客户端。\n\n（*注：每次请求连接可能在相应结束时关闭，但WEB服务器和FastCGI服务进程都将持续，不会销毁。*）\n\n![FastCGI处理过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/FastCGI处理过程.png)\n\n**FastCGI优点**：\n\n- ①、每个单独的FastCGI进程在其生命周期内可以处理多个请求，从而避免每个请求进程创建和终止的开销。\n\n- ②、并发处理多个请求稳定性和可扩展性（配置多个FastCGI服务器）。\n\n\n\n**FastCGI的缺点**：\n\n- 由于FastCGI是多进程的，所以相比CGI多进程消耗更多服务器内存（如：PHP-CGI解释器每进程消耗7~25M内存，将这个数乘以50或100将是很大的内存数。）\n\n\n\n##### 1.3 PHP-CGI\n\n`php-cgi`是早期php官方出品的FastCGI管理器。\n\n缺点：\n\n①、PHP-CGI更改了php.ini配置后需要重启php-cgi才能让配置生效，不支持平滑重启。\n\n②、直接杀死PHP-CGI进程，PHP就不能运行了。而PHP-FPM和SPAWN-FCGI在杀掉进程后，守护进程会平滑重新生成子进程。\n\n③、不支持动态worker调度，只能一开始指定要起几个worker。\n\n\n\n##### 1.4 PHP-FPM\n\nPHP-CGI是使用PHP语言实现的了FastCGI的一个程序，后来被PHP官方收了。\n\nPHP-FPM加入了动态调度功能，可以根据请求来访压力变化动态增加worker进程数量来支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置\n\n\n\n#### 2 Web Server传递数据给Web Application（PHP应用）的方法\n\nPHP使用SAPI提供的2种连接方法与WEB Server通信：`mod_php`和`mod_fastcgi`。其中Apache通过mod_php来解析PHP，Nginx通过mod_fastcgi来解析。\n\n##### 2.1 Mod_php模式\n\nmod_php通过嵌入PHP解释器到Web Server进程中，只能与WEB Server配合使用。以Apache为例，其调用PHP执行过程如下：\n\n![Mod_php处理过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/Mod_php模式.png)\n\n`Apache->httpd->php5_module->sapi->php`\n\n**缺点**：\n\n- ①、该种模式下，WEB服务器每接收一个请求，都会产生一个进程通过sapi接连PHP完成请求，若用户过多，并发量大时，服务器会承受不住。\n\n- ②、内存占用大，无论是否用到PHP解释器都会将其加在到内存中，典型的就是处理CSS、JS之类的静态文件是完全没有必要加载解释器。\n\n- ③、把mod_php编进Web服务器时，出问题很难定位是php的问题还是WEB服务器的问题。\n\n\n\n**2.2 Mod_FastCGI模式**\n\n`mod_fastcgi`以独立的进程形式出现，只要对应的WEB Server（如：Nginx）实现了cgi/fastCgi协议，就能处理PHP请求。\n\n\n\n##### 2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】\n\n- ①、若仅在Web服务器上运行PHP，那么Apache相较Nginx有更高的性能，若看到明显的性能差异，则应检查AllowOverride是否打开（httpd.conf），然后重试。\n\n- ②、若运行混合内容（例如添加CSS,JS和图像），则Nginx将提供更好的总体性能，但不会更快地运行PHP。另外Nginx在拒绝服务攻击及减轻CDN风险做的更好。\n\n#### 3 总结\n\n简单的来说，`PHP-FPM`是实现了`FastCGI协议`的一个`进程管理器`。它通过常驻内存的方式解决了早期CGI实现每次都需要解析php.ini及初始化执行环境导致的耗时长的问题，支持平滑启动及动态Worker调度。\n\n\n\n#### 参考资料\n\n1. [搞不清FastCGI与PHP-FPM之间是个什么样的关系？](https://segmentfault.com/q/1010000000256516)\n\n2. [概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM](http://www.nowamagic.net/librarys/veda/detail/1319)\n3. [在Nginx中理解和实现FastCGI代理](https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx)\n\n4. [php中fastcgi和php-fpm是什么东西](https://zhuanlan.zhihu.com/p/101433025)\n\n5. [FastCGI](https://zh.wikipedia.org/wiki/FastCGI)\n6. [php-cgi和php-fpm有什么关系？](https://segmentfault.com/q/1010000008356979)\n\n7. [WHY IS FASTCGI /W NGINX SO MUCH FASTER THAN APACHE /W MOD_PHP?](https://www.eschrade.com/page/why-is-fastcgi-w-nginx-so-much-faster-than-apache-w-mod_php/)\n8. [CGI、FastCGI和PHP-FPM关系图解](https://www.awaimai.com/371.html)","slug":"FastCGI和PHP-FPM的关系","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7fso00010sg3bgyf6qqv","content":"<h4 id=\"1-相关概念\"><a href=\"#1-相关概念\" class=\"headerlink\" title=\"1 相关概念\"></a>1 相关概念</h4><h5 id=\"1-1-CGI\"><a href=\"#1-1-CGI\" class=\"headerlink\" title=\"1.1 CGI\"></a>1.1 CGI</h5><p><code>CGI</code>（Common Gateway Interface, 通用网关接口）是<code>WEB服务器</code>与<code>WEB Application</code>进行通信的工具，用于保证WEB Server传递的数据是标准格式的，是一种协议，其程序运行在服务器上，CGI可以用任何一种语言编写，只要该语言具有标准输入、输出和环境变量，如PHP、Perl等。</p>\n<a id=\"more\"></a>\n\n<p><u>WEB Server只是内容的分发者</u>。CGI规定要传输哪些数据，以什么格式传递给后方处理。</p>\n<ul>\n<li><p>若客户端请求的是<strong>静态数据</strong>（如：<code>/index.html</code>），那么WEB Server会取文件系统中找到这个文件，并发送给浏览器，其流程如下所示：<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE.png\" alt=\"客户端请求静态数据\"></p>\n</li>\n<li><p>若请求的是<strong>非静态数据</strong>（如：<code>/index.php</code>），根据配置文件，WEB Server（如：Nginx）知道这个不是静态文件，那么Nginx将会把该请求简单处理后交给PHP解析器。比如：URL、查询字符串、POST数据、HTTP Header等。PHP解析器收到数据首先会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程。WEB Server再把结果返回给浏览器。其流程如下所示：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E9%9D%9E%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE.png\" alt=\"客户端请求动态数据\"></p>\n<p><strong>缺陷</strong>：<u>CGI只是个协议，与进程没有关系，PHP解析器在每次请求都会解析php.ini文件，初始化执行环境。所以处理时间耗时较长。</u></p>\n<h5 id=\"1-2-FastCGI\"><a href=\"#1-2-FastCGI\" class=\"headerlink\" title=\"1.2 FastCGI\"></a>1.2 FastCGI</h5><p><code>FastCGI</code>（Fast Common Gateway Interface，快速通用网关接口）是一种让交互程序与WEB服务器通信的协议。FastCGI是CGI的增强版，通过常驻（Long-live）进程解决了CGI的Fork-Execute的缺点，减少Web服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。</p>\n<p><strong>FastCGI的实现</strong>：FastCGI通过FastCGI进程管理器管理进程，在其自身初始化时，会fork多个FastCGI进程，并等待WEB服务器的连接。当一个请求来时，Web服务器将环境变量和页面请求通过socket或TCP连接传递给FastCGI进程。响应通过相同的连接从进程返回到WEB服务器，再传递给客户端。</p>\n<p>（<em>注：每次请求连接可能在相应结束时关闭，但WEB服务器和FastCGI服务进程都将持续，不会销毁。</em>）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/FastCGI%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png\" alt=\"FastCGI处理过程\"></p>\n<p><strong>FastCGI优点</strong>：</p>\n<ul>\n<li><p>①、每个单独的FastCGI进程在其生命周期内可以处理多个请求，从而避免每个请求进程创建和终止的开销。</p>\n</li>\n<li><p>②、并发处理多个请求稳定性和可扩展性（配置多个FastCGI服务器）。</p>\n</li>\n</ul>\n<p><strong>FastCGI的缺点</strong>：</p>\n<ul>\n<li>由于FastCGI是多进程的，所以相比CGI多进程消耗更多服务器内存（如：PHP-CGI解释器每进程消耗7~25M内存，将这个数乘以50或100将是很大的内存数。）</li>\n</ul>\n<h5 id=\"1-3-PHP-CGI\"><a href=\"#1-3-PHP-CGI\" class=\"headerlink\" title=\"1.3 PHP-CGI\"></a>1.3 PHP-CGI</h5><p><code>php-cgi</code>是早期php官方出品的FastCGI管理器。</p>\n<p>缺点：</p>\n<p>①、PHP-CGI更改了php.ini配置后需要重启php-cgi才能让配置生效，不支持平滑重启。</p>\n<p>②、直接杀死PHP-CGI进程，PHP就不能运行了。而PHP-FPM和SPAWN-FCGI在杀掉进程后，守护进程会平滑重新生成子进程。</p>\n<p>③、不支持动态worker调度，只能一开始指定要起几个worker。</p>\n<h5 id=\"1-4-PHP-FPM\"><a href=\"#1-4-PHP-FPM\" class=\"headerlink\" title=\"1.4 PHP-FPM\"></a>1.4 PHP-FPM</h5><p>PHP-CGI是使用PHP语言实现的了FastCGI的一个程序，后来被PHP官方收了。</p>\n<p>PHP-FPM加入了动态调度功能，可以根据请求来访压力变化动态增加worker进程数量来支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置</p>\n<h4 id=\"2-Web-Server传递数据给Web-Application（PHP应用）的方法\"><a href=\"#2-Web-Server传递数据给Web-Application（PHP应用）的方法\" class=\"headerlink\" title=\"2 Web Server传递数据给Web Application（PHP应用）的方法\"></a>2 Web Server传递数据给Web Application（PHP应用）的方法</h4><p>PHP使用SAPI提供的2种连接方法与WEB Server通信：<code>mod_php</code>和<code>mod_fastcgi</code>。其中Apache通过mod_php来解析PHP，Nginx通过mod_fastcgi来解析。</p>\n<h5 id=\"2-1-Mod-php模式\"><a href=\"#2-1-Mod-php模式\" class=\"headerlink\" title=\"2.1 Mod_php模式\"></a>2.1 Mod_php模式</h5><p>mod_php通过嵌入PHP解释器到Web Server进程中，只能与WEB Server配合使用。以Apache为例，其调用PHP执行过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/Mod_php%E6%A8%A1%E5%BC%8F.png\" alt=\"Mod_php处理过程\"></p>\n<p><code>Apache-&gt;httpd-&gt;php5_module-&gt;sapi-&gt;php</code></p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><p>①、该种模式下，WEB服务器每接收一个请求，都会产生一个进程通过sapi接连PHP完成请求，若用户过多，并发量大时，服务器会承受不住。</p>\n</li>\n<li><p>②、内存占用大，无论是否用到PHP解释器都会将其加在到内存中，典型的就是处理CSS、JS之类的静态文件是完全没有必要加载解释器。</p>\n</li>\n<li><p>③、把mod_php编进Web服务器时，出问题很难定位是php的问题还是WEB服务器的问题。</p>\n</li>\n</ul>\n<p><strong>2.2 Mod_FastCGI模式</strong></p>\n<p><code>mod_fastcgi</code>以独立的进程形式出现，只要对应的WEB Server（如：Nginx）实现了cgi/fastCgi协议，就能处理PHP请求。</p>\n<h5 id=\"2-3-Apache（php-mod）与Nginx-性能对比【参考资料7】\"><a href=\"#2-3-Apache（php-mod）与Nginx-性能对比【参考资料7】\" class=\"headerlink\" title=\"2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】\"></a>2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】</h5><ul>\n<li><p>①、若仅在Web服务器上运行PHP，那么Apache相较Nginx有更高的性能，若看到明显的性能差异，则应检查AllowOverride是否打开（httpd.conf），然后重试。</p>\n</li>\n<li><p>②、若运行混合内容（例如添加CSS,JS和图像），则Nginx将提供更好的总体性能，但不会更快地运行PHP。另外Nginx在拒绝服务攻击及减轻CDN风险做的更好。</p>\n</li>\n</ul>\n<h4 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h4><p>简单的来说，<code>PHP-FPM</code>是实现了<code>FastCGI协议</code>的一个<code>进程管理器</code>。它通过常驻内存的方式解决了早期CGI实现每次都需要解析php.ini及初始化执行环境导致的耗时长的问题，支持平滑启动及动态Worker调度。</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><p><a href=\"https://segmentfault.com/q/1010000000256516\">搞不清FastCGI与PHP-FPM之间是个什么样的关系？</a></p>\n</li>\n<li><p><a href=\"http://www.nowamagic.net/librarys/veda/detail/1319\">概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM</a></p>\n</li>\n<li><p><a href=\"https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx\">在Nginx中理解和实现FastCGI代理</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/101433025\">php中fastcgi和php-fpm是什么东西</a></p>\n</li>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/FastCGI\">FastCGI</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/q/1010000008356979\">php-cgi和php-fpm有什么关系？</a></p>\n</li>\n<li><p><a href=\"https://www.eschrade.com/page/why-is-fastcgi-w-nginx-so-much-faster-than-apache-w-mod_php/\">WHY IS FASTCGI /W NGINX SO MUCH FASTER THAN APACHE /W MOD_PHP?</a></p>\n</li>\n<li><p><a href=\"https://www.awaimai.com/371.html\">CGI、FastCGI和PHP-FPM关系图解</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-相关概念\"><a href=\"#1-相关概念\" class=\"headerlink\" title=\"1 相关概念\"></a>1 相关概念</h4><h5 id=\"1-1-CGI\"><a href=\"#1-1-CGI\" class=\"headerlink\" title=\"1.1 CGI\"></a>1.1 CGI</h5><p><code>CGI</code>（Common Gateway Interface, 通用网关接口）是<code>WEB服务器</code>与<code>WEB Application</code>进行通信的工具，用于保证WEB Server传递的数据是标准格式的，是一种协议，其程序运行在服务器上，CGI可以用任何一种语言编写，只要该语言具有标准输入、输出和环境变量，如PHP、Perl等。</p>","more":"<p><u>WEB Server只是内容的分发者</u>。CGI规定要传输哪些数据，以什么格式传递给后方处理。</p>\n<ul>\n<li><p>若客户端请求的是<strong>静态数据</strong>（如：<code>/index.html</code>），那么WEB Server会取文件系统中找到这个文件，并发送给浏览器，其流程如下所示：<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE.png\" alt=\"客户端请求静态数据\"></p>\n</li>\n<li><p>若请求的是<strong>非静态数据</strong>（如：<code>/index.php</code>），根据配置文件，WEB Server（如：Nginx）知道这个不是静态文件，那么Nginx将会把该请求简单处理后交给PHP解析器。比如：URL、查询字符串、POST数据、HTTP Header等。PHP解析器收到数据首先会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程。WEB Server再把结果返回给浏览器。其流程如下所示：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E9%9D%9E%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE.png\" alt=\"客户端请求动态数据\"></p>\n<p><strong>缺陷</strong>：<u>CGI只是个协议，与进程没有关系，PHP解析器在每次请求都会解析php.ini文件，初始化执行环境。所以处理时间耗时较长。</u></p>\n<h5 id=\"1-2-FastCGI\"><a href=\"#1-2-FastCGI\" class=\"headerlink\" title=\"1.2 FastCGI\"></a>1.2 FastCGI</h5><p><code>FastCGI</code>（Fast Common Gateway Interface，快速通用网关接口）是一种让交互程序与WEB服务器通信的协议。FastCGI是CGI的增强版，通过常驻（Long-live）进程解决了CGI的Fork-Execute的缺点，减少Web服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。</p>\n<p><strong>FastCGI的实现</strong>：FastCGI通过FastCGI进程管理器管理进程，在其自身初始化时，会fork多个FastCGI进程，并等待WEB服务器的连接。当一个请求来时，Web服务器将环境变量和页面请求通过socket或TCP连接传递给FastCGI进程。响应通过相同的连接从进程返回到WEB服务器，再传递给客户端。</p>\n<p>（<em>注：每次请求连接可能在相应结束时关闭，但WEB服务器和FastCGI服务进程都将持续，不会销毁。</em>）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/FastCGI%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png\" alt=\"FastCGI处理过程\"></p>\n<p><strong>FastCGI优点</strong>：</p>\n<ul>\n<li><p>①、每个单独的FastCGI进程在其生命周期内可以处理多个请求，从而避免每个请求进程创建和终止的开销。</p>\n</li>\n<li><p>②、并发处理多个请求稳定性和可扩展性（配置多个FastCGI服务器）。</p>\n</li>\n</ul>\n<p><strong>FastCGI的缺点</strong>：</p>\n<ul>\n<li>由于FastCGI是多进程的，所以相比CGI多进程消耗更多服务器内存（如：PHP-CGI解释器每进程消耗7~25M内存，将这个数乘以50或100将是很大的内存数。）</li>\n</ul>\n<h5 id=\"1-3-PHP-CGI\"><a href=\"#1-3-PHP-CGI\" class=\"headerlink\" title=\"1.3 PHP-CGI\"></a>1.3 PHP-CGI</h5><p><code>php-cgi</code>是早期php官方出品的FastCGI管理器。</p>\n<p>缺点：</p>\n<p>①、PHP-CGI更改了php.ini配置后需要重启php-cgi才能让配置生效，不支持平滑重启。</p>\n<p>②、直接杀死PHP-CGI进程，PHP就不能运行了。而PHP-FPM和SPAWN-FCGI在杀掉进程后，守护进程会平滑重新生成子进程。</p>\n<p>③、不支持动态worker调度，只能一开始指定要起几个worker。</p>\n<h5 id=\"1-4-PHP-FPM\"><a href=\"#1-4-PHP-FPM\" class=\"headerlink\" title=\"1.4 PHP-FPM\"></a>1.4 PHP-FPM</h5><p>PHP-CGI是使用PHP语言实现的了FastCGI的一个程序，后来被PHP官方收了。</p>\n<p>PHP-FPM加入了动态调度功能，可以根据请求来访压力变化动态增加worker进程数量来支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置</p>\n<h4 id=\"2-Web-Server传递数据给Web-Application（PHP应用）的方法\"><a href=\"#2-Web-Server传递数据给Web-Application（PHP应用）的方法\" class=\"headerlink\" title=\"2 Web Server传递数据给Web Application（PHP应用）的方法\"></a>2 Web Server传递数据给Web Application（PHP应用）的方法</h4><p>PHP使用SAPI提供的2种连接方法与WEB Server通信：<code>mod_php</code>和<code>mod_fastcgi</code>。其中Apache通过mod_php来解析PHP，Nginx通过mod_fastcgi来解析。</p>\n<h5 id=\"2-1-Mod-php模式\"><a href=\"#2-1-Mod-php模式\" class=\"headerlink\" title=\"2.1 Mod_php模式\"></a>2.1 Mod_php模式</h5><p>mod_php通过嵌入PHP解释器到Web Server进程中，只能与WEB Server配合使用。以Apache为例，其调用PHP执行过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/Mod_php%E6%A8%A1%E5%BC%8F.png\" alt=\"Mod_php处理过程\"></p>\n<p><code>Apache-&gt;httpd-&gt;php5_module-&gt;sapi-&gt;php</code></p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><p>①、该种模式下，WEB服务器每接收一个请求，都会产生一个进程通过sapi接连PHP完成请求，若用户过多，并发量大时，服务器会承受不住。</p>\n</li>\n<li><p>②、内存占用大，无论是否用到PHP解释器都会将其加在到内存中，典型的就是处理CSS、JS之类的静态文件是完全没有必要加载解释器。</p>\n</li>\n<li><p>③、把mod_php编进Web服务器时，出问题很难定位是php的问题还是WEB服务器的问题。</p>\n</li>\n</ul>\n<p><strong>2.2 Mod_FastCGI模式</strong></p>\n<p><code>mod_fastcgi</code>以独立的进程形式出现，只要对应的WEB Server（如：Nginx）实现了cgi/fastCgi协议，就能处理PHP请求。</p>\n<h5 id=\"2-3-Apache（php-mod）与Nginx-性能对比【参考资料7】\"><a href=\"#2-3-Apache（php-mod）与Nginx-性能对比【参考资料7】\" class=\"headerlink\" title=\"2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】\"></a>2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】</h5><ul>\n<li><p>①、若仅在Web服务器上运行PHP，那么Apache相较Nginx有更高的性能，若看到明显的性能差异，则应检查AllowOverride是否打开（httpd.conf），然后重试。</p>\n</li>\n<li><p>②、若运行混合内容（例如添加CSS,JS和图像），则Nginx将提供更好的总体性能，但不会更快地运行PHP。另外Nginx在拒绝服务攻击及减轻CDN风险做的更好。</p>\n</li>\n</ul>\n<h4 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h4><p>简单的来说，<code>PHP-FPM</code>是实现了<code>FastCGI协议</code>的一个<code>进程管理器</code>。它通过常驻内存的方式解决了早期CGI实现每次都需要解析php.ini及初始化执行环境导致的耗时长的问题，支持平滑启动及动态Worker调度。</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><p><a href=\"https://segmentfault.com/q/1010000000256516\">搞不清FastCGI与PHP-FPM之间是个什么样的关系？</a></p>\n</li>\n<li><p><a href=\"http://www.nowamagic.net/librarys/veda/detail/1319\">概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM</a></p>\n</li>\n<li><p><a href=\"https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx\">在Nginx中理解和实现FastCGI代理</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/101433025\">php中fastcgi和php-fpm是什么东西</a></p>\n</li>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/FastCGI\">FastCGI</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/q/1010000008356979\">php-cgi和php-fpm有什么关系？</a></p>\n</li>\n<li><p><a href=\"https://www.eschrade.com/page/why-is-fastcgi-w-nginx-so-much-faster-than-apache-w-mod_php/\">WHY IS FASTCGI /W NGINX SO MUCH FASTER THAN APACHE /W MOD_PHP?</a></p>\n</li>\n<li><p><a href=\"https://www.awaimai.com/371.html\">CGI、FastCGI和PHP-FPM关系图解</a></p>\n</li>\n</ol>"},{"title":"PHP7内核-Cli","date":"2020-08-21T10:06:04.000Z","_content":"\n\n\n#### 1 简介\nCli（Command line Interface），命令行接口，用于在命令行下执行PHP脚本，类似于Shell那样，是执行PHP脚本最简便的一种方式。\n\n<!--more-->\n\nCli模式通过执行变异的PHP二进制程序即可启动，它定义了很多命令行参数，不同的参数对应不同的处理，例如：\n- 获取cli的参数的帮助文档：`-h参数`\n```\nphp -h\n```\n- 执行PHP脚本文件：`php  脚本名.php`\n```\nphp script.php\n```\n- 直接执行PHP代码： `-r参数`(代码需用引号括起来)\n```\nphp -r \"phpinfo();\"\n```\n- 输出PHP版本：`-v参数`\n```\nphp -v\n```\n- 输出已安装的扩展：`-m参数`\n```php\nphp -m\n```\n- 交互模式运行PHP：`-a参数`\n```php\n$ php -a\nInteractive mode enabled\n\n\nphp > $a = 1;\nphp > $b = 2;\nphp > echo $a + $b;\n3\n```\n#### 2 执行流程\n<u>Cli是单进程模式，处理完请求后就直接关闭了</u>，**生命周期**为：\n\n- ①、`module startup`\n- ②、`request startup`\n- ③、`execute script`\n- ④、`request shutdown`\n- ⑤、`module shurdown`\n\n\n\n处理的关键过程为：\nmain()->php_cli_startup()->do_cli()->php_module_shutdown()\n\n*注：若是查询系统信息之类的请求，如：-v、-m、-i之类的，则不需要经历PHP请求的生命周期。*\n\n\n\n#### 3 Cli模式下获取要运行的PHP代码\n\n##### 3.1 让PHP运行指定文件\n以下两种方法（使用或不使用 -f 参数）都能够运行给定的 my_script.php 文件。可以选择任何文件来运行，**指定的PHP脚本并非必须要以 .php 为扩展名**，它们可以有任意的文件名和扩展名。\n```\nphp my_script.php\n\nphp -f my_script.php\n```\n##### 3.2 载明两行直接运行PHP代码\n使用-r参数引用要执行的代码, 其中代码需要`使用引号括起来`。  \n*注：此种方式下php代码不能添加开始和结束标记符。*\n\n```\nphp -r 'print_r(get_defined_constants());'\n```\n\n##### 3.3 通过标准输入（stdin）提供需要运行的php代码\n使用该方式，可以动态地生成PHP代码并通过命令行运行这些代码\n```\n$ some_application | some_filter | php | sort -u >final_output.txt\n```\n\n##### 3.5 将php脚本作为shell脚本使用\n写一个php脚本，并在第一行以`#！/usr/bin/php`开头，在其后加上以 PHP 开始和结尾标记符包含的正常的 PHP 代码，然后为该文件设置正确的运行属性（例如：`chmod +x test`）。该方法可以使得该文件能够像Shell脚本或 Perl 脚本一样被直接执行。\n\n```\n#!/usr/bin/php\n<?php\n    var_dump($argv);\n?>\n```\n\n假设文件名为test，并放置在当前目录下：\n```\n$ chomod +x test\n$ ./test --foo\narray(2) {\n  [0] =>\n  string(6) \"./test\"\n  [1] =>\n  string(5) \"--foo\"\n}\n\n```\n\n#### 4 内置web服务器\n从PHP5.4.0开始，Cli SAPI提供了一个内置web服务器，这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。  \n详见：[内置Web Server](https://www.php.net/manual/zh/features.commandline.webserver.php)","source":"_posts/PHP7内核-Cli.md","raw":"---\ntitle: PHP7内核-Cli\ndate: 2020-08-21 18:06:04\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n\n\n#### 1 简介\nCli（Command line Interface），命令行接口，用于在命令行下执行PHP脚本，类似于Shell那样，是执行PHP脚本最简便的一种方式。\n\n<!--more-->\n\nCli模式通过执行变异的PHP二进制程序即可启动，它定义了很多命令行参数，不同的参数对应不同的处理，例如：\n- 获取cli的参数的帮助文档：`-h参数`\n```\nphp -h\n```\n- 执行PHP脚本文件：`php  脚本名.php`\n```\nphp script.php\n```\n- 直接执行PHP代码： `-r参数`(代码需用引号括起来)\n```\nphp -r \"phpinfo();\"\n```\n- 输出PHP版本：`-v参数`\n```\nphp -v\n```\n- 输出已安装的扩展：`-m参数`\n```php\nphp -m\n```\n- 交互模式运行PHP：`-a参数`\n```php\n$ php -a\nInteractive mode enabled\n\n\nphp > $a = 1;\nphp > $b = 2;\nphp > echo $a + $b;\n3\n```\n#### 2 执行流程\n<u>Cli是单进程模式，处理完请求后就直接关闭了</u>，**生命周期**为：\n\n- ①、`module startup`\n- ②、`request startup`\n- ③、`execute script`\n- ④、`request shutdown`\n- ⑤、`module shurdown`\n\n\n\n处理的关键过程为：\nmain()->php_cli_startup()->do_cli()->php_module_shutdown()\n\n*注：若是查询系统信息之类的请求，如：-v、-m、-i之类的，则不需要经历PHP请求的生命周期。*\n\n\n\n#### 3 Cli模式下获取要运行的PHP代码\n\n##### 3.1 让PHP运行指定文件\n以下两种方法（使用或不使用 -f 参数）都能够运行给定的 my_script.php 文件。可以选择任何文件来运行，**指定的PHP脚本并非必须要以 .php 为扩展名**，它们可以有任意的文件名和扩展名。\n```\nphp my_script.php\n\nphp -f my_script.php\n```\n##### 3.2 载明两行直接运行PHP代码\n使用-r参数引用要执行的代码, 其中代码需要`使用引号括起来`。  \n*注：此种方式下php代码不能添加开始和结束标记符。*\n\n```\nphp -r 'print_r(get_defined_constants());'\n```\n\n##### 3.3 通过标准输入（stdin）提供需要运行的php代码\n使用该方式，可以动态地生成PHP代码并通过命令行运行这些代码\n```\n$ some_application | some_filter | php | sort -u >final_output.txt\n```\n\n##### 3.5 将php脚本作为shell脚本使用\n写一个php脚本，并在第一行以`#！/usr/bin/php`开头，在其后加上以 PHP 开始和结尾标记符包含的正常的 PHP 代码，然后为该文件设置正确的运行属性（例如：`chmod +x test`）。该方法可以使得该文件能够像Shell脚本或 Perl 脚本一样被直接执行。\n\n```\n#!/usr/bin/php\n<?php\n    var_dump($argv);\n?>\n```\n\n假设文件名为test，并放置在当前目录下：\n```\n$ chomod +x test\n$ ./test --foo\narray(2) {\n  [0] =>\n  string(6) \"./test\"\n  [1] =>\n  string(5) \"--foo\"\n}\n\n```\n\n#### 4 内置web服务器\n从PHP5.4.0开始，Cli SAPI提供了一个内置web服务器，这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。  \n详见：[内置Web Server](https://www.php.net/manual/zh/features.commandline.webserver.php)","slug":"PHP7内核-Cli","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7fsr00030sg30appcwzh","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>Cli（Command line Interface），命令行接口，用于在命令行下执行PHP脚本，类似于Shell那样，是执行PHP脚本最简便的一种方式。</p>\n<a id=\"more\"></a>\n\n<p>Cli模式通过执行变异的PHP二进制程序即可启动，它定义了很多命令行参数，不同的参数对应不同的处理，例如：</p>\n<ul>\n<li><p>获取cli的参数的帮助文档：<code>-h参数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -h</span><br></pre></td></tr></table></figure></li>\n<li><p>执行PHP脚本文件：<code>php  脚本名.php</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php script.php</span><br></pre></td></tr></table></figure></li>\n<li><p>直接执行PHP代码： <code>-r参数</code>(代码需用引号括起来)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &quot;phpinfo();&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>输出PHP版本：<code>-v参数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -v</span><br></pre></td></tr></table></figure></li>\n<li><p>输出已安装的扩展：<code>-m参数</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -m</span><br></pre></td></tr></table></figure></li>\n<li><p>交互模式运行PHP：<code>-a参数</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ php -a</span><br><span class=\"line\">Interactive mode enabled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">php &gt; $a = <span class=\"number\">1</span>;</span><br><span class=\"line\">php &gt; $b = <span class=\"number\">2</span>;</span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> $a + $b;</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-执行流程\"><a href=\"#2-执行流程\" class=\"headerlink\" title=\"2 执行流程\"></a>2 执行流程</h4><p><u>Cli是单进程模式，处理完请求后就直接关闭了</u>，<strong>生命周期</strong>为：</p>\n</li>\n<li><p>①、<code>module startup</code></p>\n</li>\n<li><p>②、<code>request startup</code></p>\n</li>\n<li><p>③、<code>execute script</code></p>\n</li>\n<li><p>④、<code>request shutdown</code></p>\n</li>\n<li><p>⑤、<code>module shurdown</code></p>\n</li>\n</ul>\n<p>处理的关键过程为：<br>main()-&gt;php_cli_startup()-&gt;do_cli()-&gt;php_module_shutdown()</p>\n<p><em>注：若是查询系统信息之类的请求，如：-v、-m、-i之类的，则不需要经历PHP请求的生命周期。</em></p>\n<h4 id=\"3-Cli模式下获取要运行的PHP代码\"><a href=\"#3-Cli模式下获取要运行的PHP代码\" class=\"headerlink\" title=\"3 Cli模式下获取要运行的PHP代码\"></a>3 Cli模式下获取要运行的PHP代码</h4><h5 id=\"3-1-让PHP运行指定文件\"><a href=\"#3-1-让PHP运行指定文件\" class=\"headerlink\" title=\"3.1 让PHP运行指定文件\"></a>3.1 让PHP运行指定文件</h5><p>以下两种方法（使用或不使用 -f 参数）都能够运行给定的 my_script.php 文件。可以选择任何文件来运行，<strong>指定的PHP脚本并非必须要以 .php 为扩展名</strong>，它们可以有任意的文件名和扩展名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php my_script.php</span><br><span class=\"line\"></span><br><span class=\"line\">php -f my_script.php</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-载明两行直接运行PHP代码\"><a href=\"#3-2-载明两行直接运行PHP代码\" class=\"headerlink\" title=\"3.2 载明两行直接运行PHP代码\"></a>3.2 载明两行直接运行PHP代码</h5><p>使用-r参数引用要执行的代码, 其中代码需要<code>使用引号括起来</code>。<br><em>注：此种方式下php代码不能添加开始和结束标记符。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &#39;print_r(get_defined_constants());&#39;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-3-通过标准输入（stdin）提供需要运行的php代码\"><a href=\"#3-3-通过标准输入（stdin）提供需要运行的php代码\" class=\"headerlink\" title=\"3.3 通过标准输入（stdin）提供需要运行的php代码\"></a>3.3 通过标准输入（stdin）提供需要运行的php代码</h5><p>使用该方式，可以动态地生成PHP代码并通过命令行运行这些代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ some_application | some_filter | php | sort -u &gt;final_output.txt</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-5-将php脚本作为shell脚本使用\"><a href=\"#3-5-将php脚本作为shell脚本使用\" class=\"headerlink\" title=\"3.5 将php脚本作为shell脚本使用\"></a>3.5 将php脚本作为shell脚本使用</h5><p>写一个php脚本，并在第一行以<code>#！/usr/bin/php</code>开头，在其后加上以 PHP 开始和结尾标记符包含的正常的 PHP 代码，然后为该文件设置正确的运行属性（例如：<code>chmod +x test</code>）。该方法可以使得该文件能够像Shell脚本或 Perl 脚本一样被直接执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">    var_dump($argv);</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>假设文件名为test，并放置在当前目录下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chomod +x test</span><br><span class=\"line\">$ .&#x2F;test --foo</span><br><span class=\"line\">array(2) &#123;</span><br><span class=\"line\">  [0] &#x3D;&gt;</span><br><span class=\"line\">  string(6) &quot;.&#x2F;test&quot;</span><br><span class=\"line\">  [1] &#x3D;&gt;</span><br><span class=\"line\">  string(5) &quot;--foo&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-内置web服务器\"><a href=\"#4-内置web服务器\" class=\"headerlink\" title=\"4 内置web服务器\"></a>4 内置web服务器</h4><p>从PHP5.4.0开始，Cli SAPI提供了一个内置web服务器，这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。<br>详见：<a href=\"https://www.php.net/manual/zh/features.commandline.webserver.php\">内置Web Server</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>Cli（Command line Interface），命令行接口，用于在命令行下执行PHP脚本，类似于Shell那样，是执行PHP脚本最简便的一种方式。</p>","more":"<p>Cli模式通过执行变异的PHP二进制程序即可启动，它定义了很多命令行参数，不同的参数对应不同的处理，例如：</p>\n<ul>\n<li><p>获取cli的参数的帮助文档：<code>-h参数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -h</span><br></pre></td></tr></table></figure></li>\n<li><p>执行PHP脚本文件：<code>php  脚本名.php</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php script.php</span><br></pre></td></tr></table></figure></li>\n<li><p>直接执行PHP代码： <code>-r参数</code>(代码需用引号括起来)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &quot;phpinfo();&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>输出PHP版本：<code>-v参数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -v</span><br></pre></td></tr></table></figure></li>\n<li><p>输出已安装的扩展：<code>-m参数</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -m</span><br></pre></td></tr></table></figure></li>\n<li><p>交互模式运行PHP：<code>-a参数</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ php -a</span><br><span class=\"line\">Interactive mode enabled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">php &gt; $a = <span class=\"number\">1</span>;</span><br><span class=\"line\">php &gt; $b = <span class=\"number\">2</span>;</span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> $a + $b;</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-执行流程\"><a href=\"#2-执行流程\" class=\"headerlink\" title=\"2 执行流程\"></a>2 执行流程</h4><p><u>Cli是单进程模式，处理完请求后就直接关闭了</u>，<strong>生命周期</strong>为：</p>\n</li>\n<li><p>①、<code>module startup</code></p>\n</li>\n<li><p>②、<code>request startup</code></p>\n</li>\n<li><p>③、<code>execute script</code></p>\n</li>\n<li><p>④、<code>request shutdown</code></p>\n</li>\n<li><p>⑤、<code>module shurdown</code></p>\n</li>\n</ul>\n<p>处理的关键过程为：<br>main()-&gt;php_cli_startup()-&gt;do_cli()-&gt;php_module_shutdown()</p>\n<p><em>注：若是查询系统信息之类的请求，如：-v、-m、-i之类的，则不需要经历PHP请求的生命周期。</em></p>\n<h4 id=\"3-Cli模式下获取要运行的PHP代码\"><a href=\"#3-Cli模式下获取要运行的PHP代码\" class=\"headerlink\" title=\"3 Cli模式下获取要运行的PHP代码\"></a>3 Cli模式下获取要运行的PHP代码</h4><h5 id=\"3-1-让PHP运行指定文件\"><a href=\"#3-1-让PHP运行指定文件\" class=\"headerlink\" title=\"3.1 让PHP运行指定文件\"></a>3.1 让PHP运行指定文件</h5><p>以下两种方法（使用或不使用 -f 参数）都能够运行给定的 my_script.php 文件。可以选择任何文件来运行，<strong>指定的PHP脚本并非必须要以 .php 为扩展名</strong>，它们可以有任意的文件名和扩展名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php my_script.php</span><br><span class=\"line\"></span><br><span class=\"line\">php -f my_script.php</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-载明两行直接运行PHP代码\"><a href=\"#3-2-载明两行直接运行PHP代码\" class=\"headerlink\" title=\"3.2 载明两行直接运行PHP代码\"></a>3.2 载明两行直接运行PHP代码</h5><p>使用-r参数引用要执行的代码, 其中代码需要<code>使用引号括起来</code>。<br><em>注：此种方式下php代码不能添加开始和结束标记符。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &#39;print_r(get_defined_constants());&#39;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-3-通过标准输入（stdin）提供需要运行的php代码\"><a href=\"#3-3-通过标准输入（stdin）提供需要运行的php代码\" class=\"headerlink\" title=\"3.3 通过标准输入（stdin）提供需要运行的php代码\"></a>3.3 通过标准输入（stdin）提供需要运行的php代码</h5><p>使用该方式，可以动态地生成PHP代码并通过命令行运行这些代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ some_application | some_filter | php | sort -u &gt;final_output.txt</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-5-将php脚本作为shell脚本使用\"><a href=\"#3-5-将php脚本作为shell脚本使用\" class=\"headerlink\" title=\"3.5 将php脚本作为shell脚本使用\"></a>3.5 将php脚本作为shell脚本使用</h5><p>写一个php脚本，并在第一行以<code>#！/usr/bin/php</code>开头，在其后加上以 PHP 开始和结尾标记符包含的正常的 PHP 代码，然后为该文件设置正确的运行属性（例如：<code>chmod +x test</code>）。该方法可以使得该文件能够像Shell脚本或 Perl 脚本一样被直接执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">    var_dump($argv);</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>假设文件名为test，并放置在当前目录下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chomod +x test</span><br><span class=\"line\">$ .&#x2F;test --foo</span><br><span class=\"line\">array(2) &#123;</span><br><span class=\"line\">  [0] &#x3D;&gt;</span><br><span class=\"line\">  string(6) &quot;.&#x2F;test&quot;</span><br><span class=\"line\">  [1] &#x3D;&gt;</span><br><span class=\"line\">  string(5) &quot;--foo&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-内置web服务器\"><a href=\"#4-内置web服务器\" class=\"headerlink\" title=\"4 内置web服务器\"></a>4 内置web服务器</h4><p>从PHP5.4.0开始，Cli SAPI提供了一个内置web服务器，这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。<br>详见：<a href=\"https://www.php.net/manual/zh/features.commandline.webserver.php\">内置Web Server</a></p>"},{"title":"Protobuf简介及安装","date":"2020-08-25T08:14:48.000Z","_content":"\n#### 1 简介\n\n​       protobuf是谷歌的开源序列化协议框架，结构类似于XML，JSON这种，显著的特点是二进制的，效率高，主要用于通信协议和数据存储等方面，算是一种结构化数据的表示方法。\n\n<!--more-->\n\n#### 2 安装方法\n\n##### 2.1 Ubuntu下安装\n\n- 要编译安装protobuf，首先需要安装以下必要的工具.\n\n  安装方法：\n\n```bash\nsudo apt-get install autoconf automake libtool curl make g++ unzip\n```\n\n- 获取源文件\n\n  - 方法一：直接下载发行版\n\n    [下载地址](https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4)\n\n  - 方法二：通过git clone下载 \n\n    ```bash\n    git clone https://github.com/protocolbuffers/protobuf.git cd protobuf git submodule update --init --recursive ./autogen.sh\n    ```\n\n  - 编译安装C++ Protocal Buffer运行时和Protocal Buffer编译器（protoc）\n\n    ```bash\n    ./configure make make check sudo make install sudo ldconfig # refresh shared library cache.\n    ```\n\n    *注：默认安装位置为：*\n\n    ```bash\n    /usr/local\n    ```\n\n    可通过以下命令指定安装路径\n\n    ```bash\n    ./configure --prefix=/usr\n    ```\n\n  - 查看是否安装成功\n  \n    ```bash\n    protoc --version\n    ```\n  \n\n\n#### 参考资料\n\n1. [protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf/tree/master/php)\n\n2. [Protobuf 小试牛刀](https://www.cnblogs.com/52fhy/p/11106670.html)\n\n3. [protobuf简单介绍和ubuntu 16.04环境下安装](https://blog.csdn.net/kdchxue/article/details/81046192)","source":"_posts/Protobuf简介及安装.md","raw":"---\ntitle: Protobuf简介及安装\ndate: 2020-08-25 16:14:48\ntags: [\"Protobuf\"]\ncategories: [\"Protobuf\"]\n---\n\n#### 1 简介\n\n​       protobuf是谷歌的开源序列化协议框架，结构类似于XML，JSON这种，显著的特点是二进制的，效率高，主要用于通信协议和数据存储等方面，算是一种结构化数据的表示方法。\n\n<!--more-->\n\n#### 2 安装方法\n\n##### 2.1 Ubuntu下安装\n\n- 要编译安装protobuf，首先需要安装以下必要的工具.\n\n  安装方法：\n\n```bash\nsudo apt-get install autoconf automake libtool curl make g++ unzip\n```\n\n- 获取源文件\n\n  - 方法一：直接下载发行版\n\n    [下载地址](https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4)\n\n  - 方法二：通过git clone下载 \n\n    ```bash\n    git clone https://github.com/protocolbuffers/protobuf.git cd protobuf git submodule update --init --recursive ./autogen.sh\n    ```\n\n  - 编译安装C++ Protocal Buffer运行时和Protocal Buffer编译器（protoc）\n\n    ```bash\n    ./configure make make check sudo make install sudo ldconfig # refresh shared library cache.\n    ```\n\n    *注：默认安装位置为：*\n\n    ```bash\n    /usr/local\n    ```\n\n    可通过以下命令指定安装路径\n\n    ```bash\n    ./configure --prefix=/usr\n    ```\n\n  - 查看是否安装成功\n  \n    ```bash\n    protoc --version\n    ```\n  \n\n\n#### 参考资料\n\n1. [protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf/tree/master/php)\n\n2. [Protobuf 小试牛刀](https://www.cnblogs.com/52fhy/p/11106670.html)\n\n3. [protobuf简单介绍和ubuntu 16.04环境下安装](https://blog.csdn.net/kdchxue/article/details/81046192)","slug":"Protobuf简介及安装","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7fsw00070sg3b903bz8g","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>​       protobuf是谷歌的开源序列化协议框架，结构类似于XML，JSON这种，显著的特点是二进制的，效率高，主要用于通信协议和数据存储等方面，算是一种结构化数据的表示方法。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"2-安装方法\"><a href=\"#2-安装方法\" class=\"headerlink\" title=\"2 安装方法\"></a>2 安装方法</h4><h5 id=\"2-1-Ubuntu下安装\"><a href=\"#2-1-Ubuntu下安装\" class=\"headerlink\" title=\"2.1 Ubuntu下安装\"></a>2.1 Ubuntu下安装</h5><ul>\n<li><p>要编译安装protobuf，首先需要安装以下必要的工具.</p>\n<p>安装方法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install autoconf automake libtool curl make g++ unzip</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>获取源文件</p>\n<ul>\n<li><p>方法一：直接下载发行版</p>\n<p><a href=\"https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4\">下载地址</a></p>\n</li>\n<li><p>方法二：通过git clone下载 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/protocolbuffers/protobuf.git <span class=\"built_in\">cd</span> protobuf git submodule update --init --recursive ./autogen.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译安装C++ Protocal Buffer运行时和Protocal Buffer编译器（protoc）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure make make check sudo make install sudo ldconfig <span class=\"comment\"># refresh shared library cache.</span></span><br></pre></td></tr></table></figure>\n\n<p><em>注：默认安装位置为：</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/<span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n\n<p>可通过以下命令指定安装路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --version</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><p><a href=\"https://github.com/protocolbuffers/protobuf/tree/master/php\">protocolbuffers/protobuf</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/52fhy/p/11106670.html\">Protobuf 小试牛刀</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/kdchxue/article/details/81046192\">protobuf简单介绍和ubuntu 16.04环境下安装</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>​       protobuf是谷歌的开源序列化协议框架，结构类似于XML，JSON这种，显著的特点是二进制的，效率高，主要用于通信协议和数据存储等方面，算是一种结构化数据的表示方法。</p>","more":"<h4 id=\"2-安装方法\"><a href=\"#2-安装方法\" class=\"headerlink\" title=\"2 安装方法\"></a>2 安装方法</h4><h5 id=\"2-1-Ubuntu下安装\"><a href=\"#2-1-Ubuntu下安装\" class=\"headerlink\" title=\"2.1 Ubuntu下安装\"></a>2.1 Ubuntu下安装</h5><ul>\n<li><p>要编译安装protobuf，首先需要安装以下必要的工具.</p>\n<p>安装方法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install autoconf automake libtool curl make g++ unzip</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>获取源文件</p>\n<ul>\n<li><p>方法一：直接下载发行版</p>\n<p><a href=\"https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4\">下载地址</a></p>\n</li>\n<li><p>方法二：通过git clone下载 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/protocolbuffers/protobuf.git <span class=\"built_in\">cd</span> protobuf git submodule update --init --recursive ./autogen.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译安装C++ Protocal Buffer运行时和Protocal Buffer编译器（protoc）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure make make check sudo make install sudo ldconfig <span class=\"comment\"># refresh shared library cache.</span></span><br></pre></td></tr></table></figure>\n\n<p><em>注：默认安装位置为：</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/<span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n\n<p>可通过以下命令指定安装路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --version</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><p><a href=\"https://github.com/protocolbuffers/protobuf/tree/master/php\">protocolbuffers/protobuf</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/52fhy/p/11106670.html\">Protobuf 小试牛刀</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/kdchxue/article/details/81046192\">protobuf简单介绍和ubuntu 16.04环境下安装</a></p>\n</li>\n</ol>"},{"title":"Ubuntu16.04-Github配置及使用","date":"2020-08-18T09:50:49.000Z","_content":"\n#### 一、Git安装\n\n安装命令：\n```\nsudo apt-get install git\n```\n\n<!--more-->\n\n#### 二、Github账号\n\n##### 2.1 注册GitHub账号\n注册地址：[官网](https://github.com/)\n\n##### 2.2 SSH配置\n配置方式参考：Ubuntu 16.04-设置SSH密钥.md\n\n##### 2.3 GitHub配置\n- 去登录github账户，在右上角点击头像找到Settings\n- 点进去后点击左侧栏中的SSH and GPG keys\n- 点击右侧New SSH key\n- 随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来\n- 保存即可\n\n##### 2.4 连接测试\n终端输入以下命令：\n```\n$ ssh -T git@github.com\nHi Jovry-Lee! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n表示github配置完成。\n\n#### 三、配置本地Git个人信息\n    Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。\n##### 3.1 配置全局个人信息\n```\n$ git config --global user.name \"your github name\"\n$ git config --global user.email \"youraddress@youremail.com\"\n```\n\n##### 3.2 配置单个项目个人信息\n    设置单个项目信息\n```\n$ git config user.name \"your github name\"\n$ git config user.email \"youraddress@youremail.com\"\n```\n\n#### 四、上传本地项目到GitHub\n##### 4.1 创建远程代码仓库\n- 点击右上角“＋”旁边的小三角，选择“New repository”；\n- 填写代码仓库信息；\n- 点击“Create repository”。\n\n##### 4.2 设置本地仓库\n```\n#把这个目录变成Git可以管理的仓库\ngit init\n# 文件添加到仓库\ngit add README.md\n# 添加所有文件.\ngit add .\n# 提交文件到仓库\ngit commit -m \"first commit\"\n# 管理远程仓库\ngit remote add origin <仓库地址>\n# 将本地库的所有内容推送到远程库上\ngit push -u origin master\n```\n---\n#### 参考文档\n1. [Ubuntu 16.04下Github配置](https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/)\n2. [github入门到上传本地项目](https://www.cnblogs.com/specter45/p/github.html)","source":"_posts/Ubuntu16-04-Github配置及使用.md","raw":"---\ntitle: Ubuntu16.04-Github配置及使用\ndate: 2020-08-18 17:50:49\ntags: [\"Ubuntu\", \"Config\", \"Git\"]\ncategories: [\"Ubuntu\", \"Config\"]\n---\n\n#### 一、Git安装\n\n安装命令：\n```\nsudo apt-get install git\n```\n\n<!--more-->\n\n#### 二、Github账号\n\n##### 2.1 注册GitHub账号\n注册地址：[官网](https://github.com/)\n\n##### 2.2 SSH配置\n配置方式参考：Ubuntu 16.04-设置SSH密钥.md\n\n##### 2.3 GitHub配置\n- 去登录github账户，在右上角点击头像找到Settings\n- 点进去后点击左侧栏中的SSH and GPG keys\n- 点击右侧New SSH key\n- 随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来\n- 保存即可\n\n##### 2.4 连接测试\n终端输入以下命令：\n```\n$ ssh -T git@github.com\nHi Jovry-Lee! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n表示github配置完成。\n\n#### 三、配置本地Git个人信息\n    Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。\n##### 3.1 配置全局个人信息\n```\n$ git config --global user.name \"your github name\"\n$ git config --global user.email \"youraddress@youremail.com\"\n```\n\n##### 3.2 配置单个项目个人信息\n    设置单个项目信息\n```\n$ git config user.name \"your github name\"\n$ git config user.email \"youraddress@youremail.com\"\n```\n\n#### 四、上传本地项目到GitHub\n##### 4.1 创建远程代码仓库\n- 点击右上角“＋”旁边的小三角，选择“New repository”；\n- 填写代码仓库信息；\n- 点击“Create repository”。\n\n##### 4.2 设置本地仓库\n```\n#把这个目录变成Git可以管理的仓库\ngit init\n# 文件添加到仓库\ngit add README.md\n# 添加所有文件.\ngit add .\n# 提交文件到仓库\ngit commit -m \"first commit\"\n# 管理远程仓库\ngit remote add origin <仓库地址>\n# 将本地库的所有内容推送到远程库上\ngit push -u origin master\n```\n---\n#### 参考文档\n1. [Ubuntu 16.04下Github配置](https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/)\n2. [github入门到上传本地项目](https://www.cnblogs.com/specter45/p/github.html)","slug":"Ubuntu16-04-Github配置及使用","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7fsx00080sg39jap1ybi","content":"<h4 id=\"一、Git安装\"><a href=\"#一、Git安装\" class=\"headerlink\" title=\"一、Git安装\"></a>一、Git安装</h4><p>安装命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h4 id=\"二、Github账号\"><a href=\"#二、Github账号\" class=\"headerlink\" title=\"二、Github账号\"></a>二、Github账号</h4><h5 id=\"2-1-注册GitHub账号\"><a href=\"#2-1-注册GitHub账号\" class=\"headerlink\" title=\"2.1 注册GitHub账号\"></a>2.1 注册GitHub账号</h5><p>注册地址：<a href=\"https://github.com/\">官网</a></p>\n<h5 id=\"2-2-SSH配置\"><a href=\"#2-2-SSH配置\" class=\"headerlink\" title=\"2.2 SSH配置\"></a>2.2 SSH配置</h5><p>配置方式参考：Ubuntu 16.04-设置SSH密钥.md</p>\n<h5 id=\"2-3-GitHub配置\"><a href=\"#2-3-GitHub配置\" class=\"headerlink\" title=\"2.3 GitHub配置\"></a>2.3 GitHub配置</h5><ul>\n<li>去登录github账户，在右上角点击头像找到Settings</li>\n<li>点进去后点击左侧栏中的SSH and GPG keys</li>\n<li>点击右侧New SSH key</li>\n<li>随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来</li>\n<li>保存即可</li>\n</ul>\n<h5 id=\"2-4-连接测试\"><a href=\"#2-4-连接测试\" class=\"headerlink\" title=\"2.4 连接测试\"></a>2.4 连接测试</h5><p>终端输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\">Hi Jovry-Lee! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p>表示github配置完成。</p>\n<h4 id=\"三、配置本地Git个人信息\"><a href=\"#三、配置本地Git个人信息\" class=\"headerlink\" title=\"三、配置本地Git个人信息\"></a>三、配置本地Git个人信息</h4><pre><code>Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。</code></pre>\n<h5 id=\"3-1-配置全局个人信息\"><a href=\"#3-1-配置全局个人信息\" class=\"headerlink\" title=\"3.1 配置全局个人信息\"></a>3.1 配置全局个人信息</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;your github name&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;youraddress@youremail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-配置单个项目个人信息\"><a href=\"#3-2-配置单个项目个人信息\" class=\"headerlink\" title=\"3.2 配置单个项目个人信息\"></a>3.2 配置单个项目个人信息</h5><pre><code>设置单个项目信息</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config user.name &quot;your github name&quot;</span><br><span class=\"line\">$ git config user.email &quot;youraddress@youremail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"四、上传本地项目到GitHub\"><a href=\"#四、上传本地项目到GitHub\" class=\"headerlink\" title=\"四、上传本地项目到GitHub\"></a>四、上传本地项目到GitHub</h4><h5 id=\"4-1-创建远程代码仓库\"><a href=\"#4-1-创建远程代码仓库\" class=\"headerlink\" title=\"4.1 创建远程代码仓库\"></a>4.1 创建远程代码仓库</h5><ul>\n<li>点击右上角“＋”旁边的小三角，选择“New repository”；</li>\n<li>填写代码仓库信息；</li>\n<li>点击“Create repository”。</li>\n</ul>\n<h5 id=\"4-2-设置本地仓库\"><a href=\"#4-2-设置本地仓库\" class=\"headerlink\" title=\"4.2 设置本地仓库\"></a>4.2 设置本地仓库</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#把这个目录变成Git可以管理的仓库</span><br><span class=\"line\">git init</span><br><span class=\"line\"># 文件添加到仓库</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\"># 添加所有文件.</span><br><span class=\"line\">git add .</span><br><span class=\"line\"># 提交文件到仓库</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br><span class=\"line\"># 管理远程仓库</span><br><span class=\"line\">git remote add origin &lt;仓库地址&gt;</span><br><span class=\"line\"># 将本地库的所有内容推送到远程库上</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><ol>\n<li><a href=\"https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/\">Ubuntu 16.04下Github配置</a></li>\n<li><a href=\"https://www.cnblogs.com/specter45/p/github.html\">github入门到上传本地项目</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"一、Git安装\"><a href=\"#一、Git安装\" class=\"headerlink\" title=\"一、Git安装\"></a>一、Git安装</h4><p>安装命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"二、Github账号\"><a href=\"#二、Github账号\" class=\"headerlink\" title=\"二、Github账号\"></a>二、Github账号</h4><h5 id=\"2-1-注册GitHub账号\"><a href=\"#2-1-注册GitHub账号\" class=\"headerlink\" title=\"2.1 注册GitHub账号\"></a>2.1 注册GitHub账号</h5><p>注册地址：<a href=\"https://github.com/\">官网</a></p>\n<h5 id=\"2-2-SSH配置\"><a href=\"#2-2-SSH配置\" class=\"headerlink\" title=\"2.2 SSH配置\"></a>2.2 SSH配置</h5><p>配置方式参考：Ubuntu 16.04-设置SSH密钥.md</p>\n<h5 id=\"2-3-GitHub配置\"><a href=\"#2-3-GitHub配置\" class=\"headerlink\" title=\"2.3 GitHub配置\"></a>2.3 GitHub配置</h5><ul>\n<li>去登录github账户，在右上角点击头像找到Settings</li>\n<li>点进去后点击左侧栏中的SSH and GPG keys</li>\n<li>点击右侧New SSH key</li>\n<li>随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来</li>\n<li>保存即可</li>\n</ul>\n<h5 id=\"2-4-连接测试\"><a href=\"#2-4-连接测试\" class=\"headerlink\" title=\"2.4 连接测试\"></a>2.4 连接测试</h5><p>终端输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\">Hi Jovry-Lee! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p>表示github配置完成。</p>\n<h4 id=\"三、配置本地Git个人信息\"><a href=\"#三、配置本地Git个人信息\" class=\"headerlink\" title=\"三、配置本地Git个人信息\"></a>三、配置本地Git个人信息</h4><pre><code>Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。</code></pre>\n<h5 id=\"3-1-配置全局个人信息\"><a href=\"#3-1-配置全局个人信息\" class=\"headerlink\" title=\"3.1 配置全局个人信息\"></a>3.1 配置全局个人信息</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;your github name&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;youraddress@youremail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-配置单个项目个人信息\"><a href=\"#3-2-配置单个项目个人信息\" class=\"headerlink\" title=\"3.2 配置单个项目个人信息\"></a>3.2 配置单个项目个人信息</h5><pre><code>设置单个项目信息</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config user.name &quot;your github name&quot;</span><br><span class=\"line\">$ git config user.email &quot;youraddress@youremail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"四、上传本地项目到GitHub\"><a href=\"#四、上传本地项目到GitHub\" class=\"headerlink\" title=\"四、上传本地项目到GitHub\"></a>四、上传本地项目到GitHub</h4><h5 id=\"4-1-创建远程代码仓库\"><a href=\"#4-1-创建远程代码仓库\" class=\"headerlink\" title=\"4.1 创建远程代码仓库\"></a>4.1 创建远程代码仓库</h5><ul>\n<li>点击右上角“＋”旁边的小三角，选择“New repository”；</li>\n<li>填写代码仓库信息；</li>\n<li>点击“Create repository”。</li>\n</ul>\n<h5 id=\"4-2-设置本地仓库\"><a href=\"#4-2-设置本地仓库\" class=\"headerlink\" title=\"4.2 设置本地仓库\"></a>4.2 设置本地仓库</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#把这个目录变成Git可以管理的仓库</span><br><span class=\"line\">git init</span><br><span class=\"line\"># 文件添加到仓库</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\"># 添加所有文件.</span><br><span class=\"line\">git add .</span><br><span class=\"line\"># 提交文件到仓库</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br><span class=\"line\"># 管理远程仓库</span><br><span class=\"line\">git remote add origin &lt;仓库地址&gt;</span><br><span class=\"line\"># 将本地库的所有内容推送到远程库上</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><ol>\n<li><a href=\"https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/\">Ubuntu 16.04下Github配置</a></li>\n<li><a href=\"https://www.cnblogs.com/specter45/p/github.html\">github入门到上传本地项目</a></li>\n</ol>"},{"title":"Ubuntu16.04-Nodejs安装","date":"2020-08-21T07:28:42.000Z","_content":"\n\n\n#### 下载 \n\n- ①、下载安装包\n\n  在ubuntu环境下，前往[nodejs官网](https://nodejs.org/en/)，nodejs官网能自动检测自己的系统版本，推荐出合适的nodejs版本。\n\n  <!--more-->\n\n- ②、解压安装包\n\n```bash\n$ tar xvJf node-v12.18.3-linux-x64.tar.xz\n```\n\n- ③、拷贝安装文件到指定路径\n\n```bash\nsudo cp -r node-v12.18.3-linux-x64 /usr/local/\n```\n\n#### 配置\n\n- 修改~/.bashrc文件\n\n```\n#set Node.js\nexport NODE_HOME=/usr/local/node-v12.18.3-linux-x64\nexport PATH=$NODE_HOME/bin:$PATH\n```\n\n- 执行source命令\n\n```\n$ source ~/.bashrc\n```\n\n- 3、添加软连接\n\n```\nln -s /usr/local/node-v12.18.3-linux-x64/bin/node /usr/bin/node\nln -s /usr/local/node-v12.18.3-linux-x64/bin/npm /usr/bin/npm\n```\n\n- 4、查看node版本\n\n```\n$ node -v\nv12.18.3\n$ npm -v\n6.14.6\n```\n\n能查看版本,即表示安装成功.\n\n#### 参考资料\n\n[Ubuntu 16.04环境下nodejs的安装和配置](https://blog.csdn.net/qq_36272282/article/details/88887360)","source":"_posts/Ubuntu16-04-Nodejs安装.md","raw":"---\ntitle: Ubuntu16.04-Nodejs安装\ndate: 2020-08-21 15:28:42\ntags: [\"Ubuntu\",\"Config\",\"Node.js\"]\ncategories: [\"Ubuntu\", \"Config\"]\n---\n\n\n\n#### 下载 \n\n- ①、下载安装包\n\n  在ubuntu环境下，前往[nodejs官网](https://nodejs.org/en/)，nodejs官网能自动检测自己的系统版本，推荐出合适的nodejs版本。\n\n  <!--more-->\n\n- ②、解压安装包\n\n```bash\n$ tar xvJf node-v12.18.3-linux-x64.tar.xz\n```\n\n- ③、拷贝安装文件到指定路径\n\n```bash\nsudo cp -r node-v12.18.3-linux-x64 /usr/local/\n```\n\n#### 配置\n\n- 修改~/.bashrc文件\n\n```\n#set Node.js\nexport NODE_HOME=/usr/local/node-v12.18.3-linux-x64\nexport PATH=$NODE_HOME/bin:$PATH\n```\n\n- 执行source命令\n\n```\n$ source ~/.bashrc\n```\n\n- 3、添加软连接\n\n```\nln -s /usr/local/node-v12.18.3-linux-x64/bin/node /usr/bin/node\nln -s /usr/local/node-v12.18.3-linux-x64/bin/npm /usr/bin/npm\n```\n\n- 4、查看node版本\n\n```\n$ node -v\nv12.18.3\n$ npm -v\n6.14.6\n```\n\n能查看版本,即表示安装成功.\n\n#### 参考资料\n\n[Ubuntu 16.04环境下nodejs的安装和配置](https://blog.csdn.net/qq_36272282/article/details/88887360)","slug":"Ubuntu16-04-Nodejs安装","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7fsy00090sg33ay9c94w","content":"<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><ul>\n<li><p>①、下载安装包</p>\n<p>在ubuntu环境下，前往<a href=\"https://nodejs.org/en/\">nodejs官网</a>，nodejs官网能自动检测自己的系统版本，推荐出合适的nodejs版本。</p>\n<a id=\"more\"></a>\n</li>\n<li><p>②、解压安装包</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar xvJf node-v12.18.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>③、拷贝安装文件到指定路径</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp -r node-v12.18.3-linux-x64 /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><ul>\n<li>修改~/.bashrc文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#set Node.js</span><br><span class=\"line\">export NODE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64</span><br><span class=\"line\">export PATH&#x3D;$NODE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行source命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3、添加软连接</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;bin&#x2F;node</span><br><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4、查看node版本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">v12.18.3</span><br><span class=\"line\">$ npm -v</span><br><span class=\"line\">6.14.6</span><br></pre></td></tr></table></figure>\n\n<p>能查看版本,即表示安装成功.</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://blog.csdn.net/qq_36272282/article/details/88887360\">Ubuntu 16.04环境下nodejs的安装和配置</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><ul>\n<li><p>①、下载安装包</p>\n<p>在ubuntu环境下，前往<a href=\"https://nodejs.org/en/\">nodejs官网</a>，nodejs官网能自动检测自己的系统版本，推荐出合适的nodejs版本。</p>","more":"</li>\n<li><p>②、解压安装包</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar xvJf node-v12.18.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>③、拷贝安装文件到指定路径</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp -r node-v12.18.3-linux-x64 /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><ul>\n<li>修改~/.bashrc文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#set Node.js</span><br><span class=\"line\">export NODE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64</span><br><span class=\"line\">export PATH&#x3D;$NODE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行source命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3、添加软连接</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;bin&#x2F;node</span><br><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4、查看node版本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">v12.18.3</span><br><span class=\"line\">$ npm -v</span><br><span class=\"line\">6.14.6</span><br></pre></td></tr></table></figure>\n\n<p>能查看版本,即表示安装成功.</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://blog.csdn.net/qq_36272282/article/details/88887360\">Ubuntu 16.04环境下nodejs的安装和配置</a></p>"},{"title":"Ubuntu16.04-设置SSH密钥","date":"2020-08-19T07:20:20.000Z","_content":"\n#### 1 简介\nSSH（Secure shell）适用于管理服务器与服务器通信的加密协议。\n\n<!--more-->\n\n#### 2 设置步骤\n##### 2.1 创建RSA密钥对\n```\nssh-keygen\n```\n①、默认情况下，ssh-keygen将会创建一个2048位的RSA密钥对，此时已经足够安全，若有特殊需求，可以选择传入-b 4096标志来创建更大的4096位的密钥。\n\n②、执行命令后，终端将会输出一下内容，按ENTER键将密钥保存到.ssh/主目录的子目录中，或指定备用路径。\n```\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/seven/.ssh/id_rsa):\n```\n③、若在此之前已经生成了ssh密钥对，则可能看到以下提示,此时若选择覆盖磁盘上的密钥，则无法使用以前的密钥进行身份验证（==这是一个无法逆转的破坏性过程==）\n```\n/home/seven/.ssh/id_rsa already exists.\nOverwrite (y/n)?\n```\n④、然后会看到以下输出，此处可以选择输入安全密码，建议使用。密码短语增加了额外的安全层，以防未经授权的用户登录。\n\n##### 2.2 将公钥复制到Ubuntu服务器\n###### 2.2.1 方法一 使用实用程序ssh-copy-id\n使用实用程序ssh-copy-id，只需要指定要连接的远程主机，以及具有ssh访问密码的用户账户即可。\n```\nssh-copy-id username@remote_host\n```\n\n###### 2.2.2 方法二 使用ssh复制公钥\n使用cat命令读取本地计算机上的公钥内容，并通过ssh连接到远程服务器来管理它。（==注：使用cat命令，而不要使用vim去复制，可能会复制出奇怪的字符进去==）\n```\ncat ~/.ssh/id_rsa.pub | ssh username@remote_host \"mkdir -p ~/.ssh && touch ~/.ssh/authorized_keys && chmod -R go= ~/.ssh && cat >> ~/.ssh/authorized_keys\"\n```\n\n###### 2.2.3 方法三 手动复制公钥\n```\ncat ~/.ssh/id_rsa.pub\n```\n复制公钥，再登录服务器，执行以下命令\n```\necho public_key_string >> ~/.ssh/authrized_keys\n```\n其中，public_key_string为复制的公钥\n\n#### 3 使用SSH密钥对Ubuntu服务器进行身份验证\n以上配置完成后，则可以在没有远程账户密码的情况下登录远程主机。\n登录命令：\n```\nssh username@remote_host\n```\n若是在第一次连接此主机，则可能会出现以下内容,这表示当前本地计算机无法识别远程主机，直接输入YES，然后按ENTER继续。\n```\nOutput\nThe authenticity of host '203.0.113.1 (203.0.113.1)' can't be established.\nECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.\nAre you sure you want to continue connecting (yes/no)? yes\n```\n\n若步骤一中创建RSA密钥对时没有提供密码，则可以继续登录。若提供了密码，则需要输入密码。\n\n#### 4 在服务器上禁用密码身份验证\n详情见参考文献1.\n\n\n---\n#### 参考资料\n1. [如何在Ubuntu 16.04上设置SSH密钥](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604)\n\n","source":"_posts/Ubuntu16-04-设置SSH密钥.md","raw":"---\ntitle: Ubuntu16.04-设置SSH密钥\ndate: 2020-08-19 15:20:20\ntags: [\"Ubuntu\",\"Config\", \"SSH\"]\ncategories: [\"Ubuntu\", \"Config\"]\n---\n\n#### 1 简介\nSSH（Secure shell）适用于管理服务器与服务器通信的加密协议。\n\n<!--more-->\n\n#### 2 设置步骤\n##### 2.1 创建RSA密钥对\n```\nssh-keygen\n```\n①、默认情况下，ssh-keygen将会创建一个2048位的RSA密钥对，此时已经足够安全，若有特殊需求，可以选择传入-b 4096标志来创建更大的4096位的密钥。\n\n②、执行命令后，终端将会输出一下内容，按ENTER键将密钥保存到.ssh/主目录的子目录中，或指定备用路径。\n```\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/seven/.ssh/id_rsa):\n```\n③、若在此之前已经生成了ssh密钥对，则可能看到以下提示,此时若选择覆盖磁盘上的密钥，则无法使用以前的密钥进行身份验证（==这是一个无法逆转的破坏性过程==）\n```\n/home/seven/.ssh/id_rsa already exists.\nOverwrite (y/n)?\n```\n④、然后会看到以下输出，此处可以选择输入安全密码，建议使用。密码短语增加了额外的安全层，以防未经授权的用户登录。\n\n##### 2.2 将公钥复制到Ubuntu服务器\n###### 2.2.1 方法一 使用实用程序ssh-copy-id\n使用实用程序ssh-copy-id，只需要指定要连接的远程主机，以及具有ssh访问密码的用户账户即可。\n```\nssh-copy-id username@remote_host\n```\n\n###### 2.2.2 方法二 使用ssh复制公钥\n使用cat命令读取本地计算机上的公钥内容，并通过ssh连接到远程服务器来管理它。（==注：使用cat命令，而不要使用vim去复制，可能会复制出奇怪的字符进去==）\n```\ncat ~/.ssh/id_rsa.pub | ssh username@remote_host \"mkdir -p ~/.ssh && touch ~/.ssh/authorized_keys && chmod -R go= ~/.ssh && cat >> ~/.ssh/authorized_keys\"\n```\n\n###### 2.2.3 方法三 手动复制公钥\n```\ncat ~/.ssh/id_rsa.pub\n```\n复制公钥，再登录服务器，执行以下命令\n```\necho public_key_string >> ~/.ssh/authrized_keys\n```\n其中，public_key_string为复制的公钥\n\n#### 3 使用SSH密钥对Ubuntu服务器进行身份验证\n以上配置完成后，则可以在没有远程账户密码的情况下登录远程主机。\n登录命令：\n```\nssh username@remote_host\n```\n若是在第一次连接此主机，则可能会出现以下内容,这表示当前本地计算机无法识别远程主机，直接输入YES，然后按ENTER继续。\n```\nOutput\nThe authenticity of host '203.0.113.1 (203.0.113.1)' can't be established.\nECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.\nAre you sure you want to continue connecting (yes/no)? yes\n```\n\n若步骤一中创建RSA密钥对时没有提供密码，则可以继续登录。若提供了密码，则需要输入密码。\n\n#### 4 在服务器上禁用密码身份验证\n详情见参考文献1.\n\n\n---\n#### 参考资料\n1. [如何在Ubuntu 16.04上设置SSH密钥](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604)\n\n","slug":"Ubuntu16-04-设置SSH密钥","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7ft1000d0sg3128zdzbn","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>SSH（Secure shell）适用于管理服务器与服务器通信的加密协议。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"2-设置步骤\"><a href=\"#2-设置步骤\" class=\"headerlink\" title=\"2 设置步骤\"></a>2 设置步骤</h4><h5 id=\"2-1-创建RSA密钥对\"><a href=\"#2-1-创建RSA密钥对\" class=\"headerlink\" title=\"2.1 创建RSA密钥对\"></a>2.1 创建RSA密钥对</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure>\n<p>①、默认情况下，ssh-keygen将会创建一个2048位的RSA密钥对，此时已经足够安全，若有特殊需求，可以选择传入-b 4096标志来创建更大的4096位的密钥。</p>\n<p>②、执行命令后，终端将会输出一下内容，按ENTER键将密钥保存到.ssh/主目录的子目录中，或指定备用路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generating public&#x2F;private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (&#x2F;home&#x2F;seven&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>\n<p>③、若在此之前已经生成了ssh密钥对，则可能看到以下提示,此时若选择覆盖磁盘上的密钥，则无法使用以前的密钥进行身份验证（==这是一个无法逆转的破坏性过程==）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;home&#x2F;seven&#x2F;.ssh&#x2F;id_rsa already exists.</span><br><span class=\"line\">Overwrite (y&#x2F;n)?</span><br></pre></td></tr></table></figure>\n<p>④、然后会看到以下输出，此处可以选择输入安全密码，建议使用。密码短语增加了额外的安全层，以防未经授权的用户登录。</p>\n<h5 id=\"2-2-将公钥复制到Ubuntu服务器\"><a href=\"#2-2-将公钥复制到Ubuntu服务器\" class=\"headerlink\" title=\"2.2 将公钥复制到Ubuntu服务器\"></a>2.2 将公钥复制到Ubuntu服务器</h5><h6 id=\"2-2-1-方法一-使用实用程序ssh-copy-id\"><a href=\"#2-2-1-方法一-使用实用程序ssh-copy-id\" class=\"headerlink\" title=\"2.2.1 方法一 使用实用程序ssh-copy-id\"></a>2.2.1 方法一 使用实用程序ssh-copy-id</h6><p>使用实用程序ssh-copy-id，只需要指定要连接的远程主机，以及具有ssh访问密码的用户账户即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-2-2-方法二-使用ssh复制公钥\"><a href=\"#2-2-2-方法二-使用ssh复制公钥\" class=\"headerlink\" title=\"2.2.2 方法二 使用ssh复制公钥\"></a>2.2.2 方法二 使用ssh复制公钥</h6><p>使用cat命令读取本地计算机上的公钥内容，并通过ssh连接到远程服务器来管理它。（==注：使用cat命令，而不要使用vim去复制，可能会复制出奇怪的字符进去==）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub | ssh username@remote_host &quot;mkdir -p ~&#x2F;.ssh &amp;&amp; touch ~&#x2F;.ssh&#x2F;authorized_keys &amp;&amp; chmod -R go&#x3D; ~&#x2F;.ssh &amp;&amp; cat &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys&quot;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-2-3-方法三-手动复制公钥\"><a href=\"#2-2-3-方法三-手动复制公钥\" class=\"headerlink\" title=\"2.2.3 方法三 手动复制公钥\"></a>2.2.3 方法三 手动复制公钥</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>复制公钥，再登录服务器，执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo public_key_string &gt;&gt; ~&#x2F;.ssh&#x2F;authrized_keys</span><br></pre></td></tr></table></figure>\n<p>其中，public_key_string为复制的公钥</p>\n<h4 id=\"3-使用SSH密钥对Ubuntu服务器进行身份验证\"><a href=\"#3-使用SSH密钥对Ubuntu服务器进行身份验证\" class=\"headerlink\" title=\"3 使用SSH密钥对Ubuntu服务器进行身份验证\"></a>3 使用SSH密钥对Ubuntu服务器进行身份验证</h4><p>以上配置完成后，则可以在没有远程账户密码的情况下登录远程主机。<br>登录命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@remote_host</span><br></pre></td></tr></table></figure>\n<p>若是在第一次连接此主机，则可能会出现以下内容,这表示当前本地计算机无法识别远程主机，直接输入YES，然后按ENTER继续。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">The authenticity of host &#39;203.0.113.1 (203.0.113.1)&#39; can&#39;t be established.</span><br><span class=\"line\">ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes&#x2F;no)? yes</span><br></pre></td></tr></table></figure>\n\n<p>若步骤一中创建RSA密钥对时没有提供密码，则可以继续登录。若提供了密码，则需要输入密码。</p>\n<h4 id=\"4-在服务器上禁用密码身份验证\"><a href=\"#4-在服务器上禁用密码身份验证\" class=\"headerlink\" title=\"4 在服务器上禁用密码身份验证\"></a>4 在服务器上禁用密码身份验证</h4><p>详情见参考文献1.</p>\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604\">如何在Ubuntu 16.04上设置SSH密钥</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>SSH（Secure shell）适用于管理服务器与服务器通信的加密协议。</p>","more":"<h4 id=\"2-设置步骤\"><a href=\"#2-设置步骤\" class=\"headerlink\" title=\"2 设置步骤\"></a>2 设置步骤</h4><h5 id=\"2-1-创建RSA密钥对\"><a href=\"#2-1-创建RSA密钥对\" class=\"headerlink\" title=\"2.1 创建RSA密钥对\"></a>2.1 创建RSA密钥对</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure>\n<p>①、默认情况下，ssh-keygen将会创建一个2048位的RSA密钥对，此时已经足够安全，若有特殊需求，可以选择传入-b 4096标志来创建更大的4096位的密钥。</p>\n<p>②、执行命令后，终端将会输出一下内容，按ENTER键将密钥保存到.ssh/主目录的子目录中，或指定备用路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generating public&#x2F;private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (&#x2F;home&#x2F;seven&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>\n<p>③、若在此之前已经生成了ssh密钥对，则可能看到以下提示,此时若选择覆盖磁盘上的密钥，则无法使用以前的密钥进行身份验证（==这是一个无法逆转的破坏性过程==）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;home&#x2F;seven&#x2F;.ssh&#x2F;id_rsa already exists.</span><br><span class=\"line\">Overwrite (y&#x2F;n)?</span><br></pre></td></tr></table></figure>\n<p>④、然后会看到以下输出，此处可以选择输入安全密码，建议使用。密码短语增加了额外的安全层，以防未经授权的用户登录。</p>\n<h5 id=\"2-2-将公钥复制到Ubuntu服务器\"><a href=\"#2-2-将公钥复制到Ubuntu服务器\" class=\"headerlink\" title=\"2.2 将公钥复制到Ubuntu服务器\"></a>2.2 将公钥复制到Ubuntu服务器</h5><h6 id=\"2-2-1-方法一-使用实用程序ssh-copy-id\"><a href=\"#2-2-1-方法一-使用实用程序ssh-copy-id\" class=\"headerlink\" title=\"2.2.1 方法一 使用实用程序ssh-copy-id\"></a>2.2.1 方法一 使用实用程序ssh-copy-id</h6><p>使用实用程序ssh-copy-id，只需要指定要连接的远程主机，以及具有ssh访问密码的用户账户即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-2-2-方法二-使用ssh复制公钥\"><a href=\"#2-2-2-方法二-使用ssh复制公钥\" class=\"headerlink\" title=\"2.2.2 方法二 使用ssh复制公钥\"></a>2.2.2 方法二 使用ssh复制公钥</h6><p>使用cat命令读取本地计算机上的公钥内容，并通过ssh连接到远程服务器来管理它。（==注：使用cat命令，而不要使用vim去复制，可能会复制出奇怪的字符进去==）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub | ssh username@remote_host &quot;mkdir -p ~&#x2F;.ssh &amp;&amp; touch ~&#x2F;.ssh&#x2F;authorized_keys &amp;&amp; chmod -R go&#x3D; ~&#x2F;.ssh &amp;&amp; cat &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys&quot;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-2-3-方法三-手动复制公钥\"><a href=\"#2-2-3-方法三-手动复制公钥\" class=\"headerlink\" title=\"2.2.3 方法三 手动复制公钥\"></a>2.2.3 方法三 手动复制公钥</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>复制公钥，再登录服务器，执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo public_key_string &gt;&gt; ~&#x2F;.ssh&#x2F;authrized_keys</span><br></pre></td></tr></table></figure>\n<p>其中，public_key_string为复制的公钥</p>\n<h4 id=\"3-使用SSH密钥对Ubuntu服务器进行身份验证\"><a href=\"#3-使用SSH密钥对Ubuntu服务器进行身份验证\" class=\"headerlink\" title=\"3 使用SSH密钥对Ubuntu服务器进行身份验证\"></a>3 使用SSH密钥对Ubuntu服务器进行身份验证</h4><p>以上配置完成后，则可以在没有远程账户密码的情况下登录远程主机。<br>登录命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@remote_host</span><br></pre></td></tr></table></figure>\n<p>若是在第一次连接此主机，则可能会出现以下内容,这表示当前本地计算机无法识别远程主机，直接输入YES，然后按ENTER继续。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">The authenticity of host &#39;203.0.113.1 (203.0.113.1)&#39; can&#39;t be established.</span><br><span class=\"line\">ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes&#x2F;no)? yes</span><br></pre></td></tr></table></figure>\n\n<p>若步骤一中创建RSA密钥对时没有提供密码，则可以继续登录。若提供了密码，则需要输入密码。</p>\n<h4 id=\"4-在服务器上禁用密码身份验证\"><a href=\"#4-在服务器上禁用密码身份验证\" class=\"headerlink\" title=\"4 在服务器上禁用密码身份验证\"></a>4 在服务器上禁用密码身份验证</h4><p>详情见参考文献1.</p>\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604\">如何在Ubuntu 16.04上设置SSH密钥</a></li>\n</ol>"},{"title":"PHP7内核-FPM","date":"2020-08-21T10:15:16.000Z","_content":"\n\n\n### 1 概述\nFPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其<u>核心功能是进程管理</u>。  \nFastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。<u>注：FastCGI只是一种协议</u>。\n\n<!--more-->\n\nPHP处理Http请求过程：`PHP接收请求`、`解析协议`，`处理完成返回请求`。  \n在网络应用场景下，PHP实现了FastCGI协议，然后与web服务器配合实现了http的处理，web服务器处理http请求，然后将解析的结果通过FastCGI协议转发给处理程序，处理程序处理完成后将结果返回给web服务器，web服务器再返回给用户，如下图所示：\n![fastcgi](https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4)\n\n<u>PHP实现了FastCGI协议的解析，但未具体实现网络处理</u>，一般的处理模型：`多进程`，`多线程`。\n\n- **多进程模型**：主进程只负责管理子进程，而基本的网络事件由各个子进程处理，例如：nginx、fpm。\n- **多线程模型**：与多进程类似，只是它是线程粒度，这种模式通常由主线程监听、接收请求，然后交给子线程处理，例如：memcache。有的也用多进程的那种模式——主线程只负责管理子线程，各个子线程负责监听、接收、处理请求，例如：memcache使用udp协议的情况。\n\n*进程拥有独立的地址空间及资源，而线程没有，线程之间共享进程的地址空间及资源，所以在资源管理上多进程模型比较简单，而多线程模型需考虑不同线程之间的资源冲突，及线程安全。*\n\n### 2 基本实现\nFPM是一个`多进程模型`，它由`一个master进程`和`多个worker进程`组成。master会创建一个socket，但不会接口处理进程，而是由fork出的worker进程处理接收请求和处理。\n\n- **master进程**：master进程的主要工作是管理worker进程，负责fork或kill掉worker进程。\n- **worker进程**：worker进程的主要工作是处理请求，其生命周期为：`accept请求->解析FastCGI->执行相应脚本->关闭请求->等待新的请求`。  \n*注：Fpm为阻塞式模型，即一个进程只会同时链接一个请求。（目的是为了简化PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突）*\n\n**FPM的实现概括**：创建一个master进程，在master进程中创建并监听socket， 然后fork出多个子进程，这些子进程各自accept请求，有请求达到后开始读取请求数据，读取完成后开始处理然后返回。<u>（子进程启动后阻塞在accept上，直到有请求到达，且子进程同时只能响应一个请求。）</u>\n\nFPM的master进程与worker进程之间不会直接进行通信，master通过`共享内存`获取worker进程的信息（worker当前状态、已处理请求数等），当master进程要kill一个worker进程则通过`发信号的方式`通知worker进程（**master进程管理woker进程通过发信号的方式**）。\n\n<u>FPM可以监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程。</u>\n![worker_pool](https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd)\n\n在`php-fpm.conf`（php-fpm.conf路径：`/etc/php/7.1/fpm/php-fpm.conf`）中通过[pool name]声明一个worker pool：  \n（php-fpm.conf文件中include了多个pool配置，相关配置在（`/etc/php/7.1/fpm/pool.d/*.conf`））\n\n```\n[web1]\nlisten = 127.0.0.1:9000\n...\n\n[web2]\nlisten = 127.0.0.1:9001\n...\n```\n\n启动fpm后查看进程：ps -aux|grep fpm\n```\nroot     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (/usr/local/php7/etc/php-fpm.conf)\nnobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1\nnobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1\nnobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2\nnobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2\n```\n\n**具体实现**：\n`worker pool`通过`fpm_worker_pool_s`这个结构表示，多个`worker pool`组成一个**单链表**:\n\n```c\nstruct fpm_worker_pool_s {\n    struct fpm_worker_pool_s *next; //指向下一个worker pool\n    struct fpm_worker_pool_config_s *config; //conf配置:pm、max_children、start_servers...\n    int listening_socket; //监听的套接字\n    ...\n\n    struct fpm_child_s *children; // 当前pool的worker链表，每一个worker对应一个fpm_child_s结构\n    int running_children; //当前pool的worker运行总数\n    int idle_spawn_rate;\n    int warn_max_children;\n\n    struct fpm_scoreboard_s *scoreboard; //记录worker的运行信息，比如空闲、忙碌worker数\n    ...\n}\n```\n\n#### 2.1 FPM的初始化\nFpm在启动后首先会进行`SAPI的注册操作`，接着会进入PHP生命周期的`module startup`阶段，在这个阶段会调用各个扩展定义的MINT钩子函数，然后进行一系列的初始化操作，最后master，worker进程进入不同的处理环节。\n\n<u>fpm的启动流程：</u>\n\n```c\n//sapi/fpm/fpm/fpm_main.c\nint main(int argc, char *argv[])\n{\n    ...\n    //注册SAPI:将全局变量sapi_module设置为cgi_sapi_module\n    sapi_startup(&cgi_sapi_module);\n    ...\n    //执行php_module_starup()\n    if (cgi_sapi_module.startup(&cgi_sapi_module) == FAILURE) {\n        return FPM_EXIT_SOFTWARE;\n    }\n    ...\n    //初始化\n    if(0 > fpm_init(...)){\n        ...\n    }\n    ...\n    fpm_is_running = 1;\n\n    fcgi_fd = fpm_run(&max_requests);//后面都是worker进程的操作，master进程不会走到下面\n    parent = 0;\n    ...\n}\n```\n`fpm_init()`主要有以下几个关键操作：\n\n- fpm_conf_init_main():  解析php-fpm.conf配置文件.\n解析`php-fpm.conf`配置文件，分配worker pool内存结构并保存到全局变量中：fpm_worker_all_pools，各worker pool配置解析到`fpm_worker_pool_s->config`中，以下为config中的几个常用配置：\n```c\nstruct fpm_worker_pool_config_s {\n\tchar *name; // pool名称，即配置：[pool name]\n\tchar *user; // Fpm的启动用户：配置：user\n\tchar *group; // 配置：group\n\tchar *listen_address; // 监听的地址，配置：listen\n\t...\n\tint pm; // 进程模型：static、dynamic、ondemand\n\tint pm_max_children; // 最大worker进程数\n\tint pm_start_servers; // 启动时初始化的worker数\n\tint pm_min_spare_servers; // 最小空闲worker数\n\tint pm_max_spare_servers; // 最大空闲worker数\n\tint pm_process_idle_timeout; // worker空闲时间\n\tint pm_max_requests; // worker处理的最多请求数，超多这个值worker将被kill\n    ...\n};\n```\n\n- fpm_scoreboard_init_main():  分配用于记录worker进行运行信息的共享内存.\n分配用于`记录worker进程运行信息的共享内存`。按照worker pool的最大worker进程数分配，每个worker pool分配一个**fpm_scoreboard_s**结构，pool下对应的每个worker进程分配一个**fpm_scoreboard_proc_s**结构，各结构的对应关系如下图。\n![worker_pool_struct](https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738)\n\n- fpm_signals_init_mian():  mataer进行创建管道及注册信号管理worker进程.\n```c\nstatic int sp[2];\n\nint fpm_signals_init_main()\n{\n    struct sigaction act;\n\n    //创建一个全双工管道，该管道不是用于master与worker进程通信的，只在master进程中使用。\n    if (0 > socketpair(AF_UNIX, SOCK_STREAM, 0, sp)) {\n        return -1;\n    }\n    //注册信号处理handler\n    act.sa_handler = sig_handler;\n    sigfillset(&act.sa_mask);\n    if (0 > sigaction(SIGTERM,  &act, 0) ||\n        0 > sigaction(SIGINT,   &act, 0) ||\n        0 > sigaction(SIGUSR1,  &act, 0) ||\n        0 > sigaction(SIGUSR2,  &act, 0) ||\n        0 > sigaction(SIGCHLD,  &act, 0) ||\n        0 > sigaction(SIGQUIT,  &act, 0)) {\n        return -1;\n    }\n    return 0;\n}\n```\n通过**socketpair()**创建一个管道，此管道只在master进程中使用。另外设置master的信号处理handler，当master收到SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT这些信号时将调用sig_handler()处理：\n```c\nstatic void sig_handler(int signo)\n{\n    static const char sig_chars[NSIG + 1] = {\n        [SIGTERM] = 'T',\n        [SIGINT]  = 'I',\n        [SIGUSR1] = '1',\n        [SIGUSR2] = '2',\n        [SIGQUIT] = 'Q',\n        [SIGCHLD] = 'C'\n    };\n    char s;\n    ...\n    s = sig_chars[signo];\n    //将信号通知写入管道sp[1]端\n    write(sp[1], &s, sizeof(s));\n    ...\n}\n```\n\n- fpm_sockets_init_main():  创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。\n- fpm_event_init_main():  启动master的事件管理.\n启动master的事件管理，fpm实现了一个事件管理器用于管理IO、定时事件，其中IO事件通过kqueue、epoll、poll、select等管理，定时事件就是定时器，一定时间后触发某个事件。\n\n\n\n在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将fork子进程，启动进程管理器，另外master进程将不会再返回，只有各worker进程会返回，也就是说fpm_run()之后的操作均是worker进程的。\n\n```c\nint fpm_run(int *max_requests)\n{\n    struct fpm_worker_pool_s *wp;\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        //调用fpm_children_make() fork子进程\n        is_parent = fpm_children_create_initial(wp);\n        \n        if (!is_parent) {\n            goto run_child;\n        }\n    }\n    //master进程将进入event循环，不再往下走\n    fpm_event_loop(0);\n\nrun_child: //只有worker进程会到这里\n\n    *max_requests = fpm_globals.max_requests;\n    return fpm_globals.listening_socket; //返回监听的套接字\n}\n```\n\n在fork后worker进程返回了监听的套接字继续main()后面的处理，而master将永远阻塞在fpm_event_loop().\n\n\n#### 2.2 worker-请求处理\nfpm_run()执行后将fork出worker进程，worker进程返回main()中继续向下执行，后面的流程就是worker进程不断accept请求，然后执行PHP脚本并返回。整体流程如下：\n- **等待请求**： worker进程阻塞在fcgi_accept_request()等待请求。\n- **解析请求**： fastcgi请求到达后被worker接收，然后开始接受并解析请求数据，直到request数据完全到达。\n- **请求初始化**：执行php_request_startup(), 此阶段会调用每个扩展的PHP_RINI_FUNCTION();\n- **编译、执行**：php_execute_script()完成PHP脚本的编译、执行。\n- **关闭请求**：请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。\n```c\nint main(int argc, char *argv[])\n{\n    ...\n    fcgi_fd = fpm_run(&max_requests);\n    parent = 0;\n\n    //初始化fastcgi请求\n    request = fpm_init_request(fcgi_fd);\n    \n    //worker进程将阻塞在这，等待请求\n    while (EXPECTED(fcgi_accept_request(request) >= 0)) {\n        SG(server_context) = (void *) request;\n        init_request_info();\n        \n        //请求开始\n        if (UNEXPECTED(php_request_startup() == FAILURE)) {\n            ...\n        }\n        ...\n\n        fpm_request_executing();\n        //编译、执行PHP脚本\n        php_execute_script(&file_handle);\n        ...\n        //请求结束\n        php_request_shutdown((void *) 0);\n        ...\n    }\n    ...\n    //worker进程退出\n    php_module_shutdown();\n    ...\n}\n```\nworker进程一次请求的处理被划分为5个阶段：\n\n- **FPM_REQUEST_ACCEPTING**: 等待请求阶段\n- **FPM_REQUEST_READING_HEADERS**: 读取fastcgi请求header阶段\n- **FPM_REQUEST_INFO**: 获取请求信息阶段，此阶段是将请求的method、query stirng、request uri等信息保存到各worker进程的fpm_scoreboard_proc_s结构中，此操作需要加锁，因为master进程也会操作此结构\n- **FPM_REQUEST_EXECUTING**: 执行请求阶段\n- **FPM_REQUEST_END**: 没有使用\n- **FPM_REQUEST_FINISHED**: 请求处理完成  \nworker处理到各个阶段时将会把当前阶段更新到==fpm_scoreboard_proc_s->request_stage==，master进程正是通过这个标识判断worker进程是否空闲的。\n\n#### 2.3 master-进程管理\n<u>master进程管理woker进程管理方式:</u>\n\n- **static**  \nworker进程数固定不变。在启动时master按照pm.max_children配置fork出相应数量的worker进程。\n- **dynamic**  \n动态进程管理。 \n    - 首先fpm启动时按照pm.start_servers初始化一定数量的worker（*默认情况为：pm.min_spare_servers + (max_spare_servers - min_spare_servers) / 2*）。\n    - 运行期间若master发现空闲的worker数低于pm.min_spare_servers(最小空闲数)配置数（请求较多，worker处理不过来）则会fork进程，但总worker数不能超过pm.max_children(最大进程数)；\n    - 若空闲worker数超过pm.max_spare_servers(最大空闲数)（空闲worker数过多），则kill掉一些wokrer，避免占用资源过多。\n```\npm.start_servers: 初始worker数\npm.min_spare_servers: 最小空闲worker数量\npm.max_spare_servers: 最大空闲worker数量\npm.max_children: 最大worker数\n```\n- **ondemand**  \n在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。\n```\npm.max_children: 最大worker数\npm.process_idle_timeout: 空闲超时时间\n```\n\n\n\nmaster整体的处理，其进程管理主要依赖注册的几个事件：\n\n```c\nvoid fpm_event_loop(int err)\n{\n    //创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]\n    //当sp[0]可读时将回调fpm_got_signal()\n    fpm_event_set(&signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &fpm_got_signal, NULL);\n    fpm_event_add(&signal_fd_event, 0);\n\n    //如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查\n    if (fpm_globals.heartbeat > 0) {\n        fpm_pctl_heartbeat(NULL, 0, NULL);\n    }\n    //定时触发进程管理\n    fpm_pctl_perform_idle_server_maintenance_heartbeat(NULL, 0, NULL);\n    \n    //进入事件循环，master进程将阻塞在此\n    while (1) {\n        ...\n        //等待IO事件\n        ret = module->wait(fpm_event_queue_fd, timeout);\n        ...\n        //检查定时器事件\n        ...\n    }\n}\n```\n##### 2.3.1. sp[1]管道可读事件：\n在fpm_init()阶段master曾创建了一个全双工的管道：`sp`，然后在这里创建了一个sp[0]可读的事件，当sp[0]可读时将交由fpm_got_signal()处理，向sp[1]写数据时sp[0]才会可读，那么什么时机会向sp[1]写数据呢？前面已经提到了：当master收到注册的那几种信号时会写入sp[1]端，这个时候将触发sp[0]可读事件。\n![master_event_1](https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec)\n信号用途：\n\n- SIGINT/SIGTERM/SIGQUIT:**退出fpm**，在master收到退出信号后将向所有的worker进程发送退出信号，然后master退出.\n- SIGUSR1:**重新加载日志文件**，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果fpm不重新加载将无法继续写入日志，这个时候就需要向master发送一个USR1的信号\n- SIGUSR2:**重启fpm**，首先master也是会向所有的worker进程发送退出信号，然后master会调用execvp()重新启动fpm，最后旧的master退出\n- SIGCHLD:这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用wait或者waitpid函数查询子进程退出状态后子进程才告终止，fpm中当worker进程因为异常原因(比如coredump了)退出而非master主动杀掉时master将受到此信号，这个时候父进程将调用waitpid()查下子进程的退出，然后检查下是不是需要重新fork新的worker\n\n##### 2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():\n这是进程管理实现的主要事件，master启动了一个定时器，每隔**1s**触发一次，主要用于dynamic、ondemand模式下的worker管理，master会定时检查各worker pool的worker进程数，通过此定时器实现worker数量的控制\n\n```\nstatic void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)\n{\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        struct fpm_child_s *last_idle_child = NULL; //空闲时间最久的worker\n        int idle = 0; //空闲worker数\n        int active = 0; //忙碌worker数\n        \n        for (child = wp->children; child; child = child->next) {\n            //根据worker进程的fpm_scoreboard_proc_s->request_stage判断\n            if (fpm_request_is_idle(child)) {\n                //找空闲时间最久的worker\n                ...\n                idle++;\n            }else{\n                active++;\n            }\n        }\n        ...\n        //ondemand模式\n        if (wp->config->pm == PM_STYLE_ONDEMAND) {\n            if (!last_idle_child) continue;\n\n            fpm_request_last_activity(last_idle_child, &last);\n            fpm_clock_get(&now);\n            if (last.tv_sec < now.tv_sec - wp->config->pm_process_idle_timeout) {\n                //如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker\n                last_idle_child->idle_kill = 1;\n                fpm_pctl_kill(last_idle_child->pid, FPM_PCTL_QUIT);\n            } \n            continue;\n        }\n        //dynamic\n        if (wp->config->pm != PM_STYLE_DYNAMIC) continue;\n        if (idle > wp->config->pm_max_spare_servers && last_idle_child) {\n            //空闲worker太多了，杀掉\n            last_idle_child->idle_kill = 1;\n            fpm_pctl_kill(last_idle_child->pid, FPM_PCTL_QUIT);\n            wp->idle_spawn_rate = 1;\n            continue;\n        }\n        if (idle < wp->config->pm_min_spare_servers) {\n            //空闲worker太少了，如果总worker数未达到max数则fork\n            ...\n        }\n    }\n}\n```\n##### 2.3.3 fpm_pctl_heartbeat():\n这个事件是用于限制worker处理单个请求最大耗时的，php-fpm.conf中有一个request_terminate_timeout的配置项，如果worker处理一个请求的总时长超过了这个值那么master将会向此worker进程发送kill -TERM信号杀掉worker进程，此配置单位为秒，默认值为0表示关闭此机制，另外fpm打印的slow log也是在这里完成的。\n```\nstatic void fpm_pctl_check_request_timeout(struct timeval *now)\n{   \n    struct fpm_worker_pool_s *wp;\n\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        int terminate_timeout = wp->config->request_terminate_timeout;\n        int slowlog_timeout = wp->config->request_slowlog_timeout;\n        struct fpm_child_s *child;\n\n        if (terminate_timeout || slowlog_timeout) { \n            for (child = wp->children; child; child = child->next) {\n                //检查当前当前worker处理的请求是否超时\n                fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);\n            }\n        }\n    }\n}\n```\n注：*ondemand模式下master监听的新请求到达的事件，因为ondemand模式下fpm启动时是不会预创建worker的，有请求时才会生成子进程，所以请求到达时需要通知master进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()。*\n\n\n\n\n---\n参考文档：  \n1、php内核剖析： http://www.php.cn/manual/view/32905.html  \n2、php7-integernal：https://github.com/pangudashu/php7-internal","source":"_posts/PHP7内核-FPM.md","raw":"---\ntitle: PHP7内核-FPM\ndate: 2020-08-21 18:15:16\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n\n\n### 1 概述\nFPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其<u>核心功能是进程管理</u>。  \nFastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。<u>注：FastCGI只是一种协议</u>。\n\n<!--more-->\n\nPHP处理Http请求过程：`PHP接收请求`、`解析协议`，`处理完成返回请求`。  \n在网络应用场景下，PHP实现了FastCGI协议，然后与web服务器配合实现了http的处理，web服务器处理http请求，然后将解析的结果通过FastCGI协议转发给处理程序，处理程序处理完成后将结果返回给web服务器，web服务器再返回给用户，如下图所示：\n![fastcgi](https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4)\n\n<u>PHP实现了FastCGI协议的解析，但未具体实现网络处理</u>，一般的处理模型：`多进程`，`多线程`。\n\n- **多进程模型**：主进程只负责管理子进程，而基本的网络事件由各个子进程处理，例如：nginx、fpm。\n- **多线程模型**：与多进程类似，只是它是线程粒度，这种模式通常由主线程监听、接收请求，然后交给子线程处理，例如：memcache。有的也用多进程的那种模式——主线程只负责管理子线程，各个子线程负责监听、接收、处理请求，例如：memcache使用udp协议的情况。\n\n*进程拥有独立的地址空间及资源，而线程没有，线程之间共享进程的地址空间及资源，所以在资源管理上多进程模型比较简单，而多线程模型需考虑不同线程之间的资源冲突，及线程安全。*\n\n### 2 基本实现\nFPM是一个`多进程模型`，它由`一个master进程`和`多个worker进程`组成。master会创建一个socket，但不会接口处理进程，而是由fork出的worker进程处理接收请求和处理。\n\n- **master进程**：master进程的主要工作是管理worker进程，负责fork或kill掉worker进程。\n- **worker进程**：worker进程的主要工作是处理请求，其生命周期为：`accept请求->解析FastCGI->执行相应脚本->关闭请求->等待新的请求`。  \n*注：Fpm为阻塞式模型，即一个进程只会同时链接一个请求。（目的是为了简化PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突）*\n\n**FPM的实现概括**：创建一个master进程，在master进程中创建并监听socket， 然后fork出多个子进程，这些子进程各自accept请求，有请求达到后开始读取请求数据，读取完成后开始处理然后返回。<u>（子进程启动后阻塞在accept上，直到有请求到达，且子进程同时只能响应一个请求。）</u>\n\nFPM的master进程与worker进程之间不会直接进行通信，master通过`共享内存`获取worker进程的信息（worker当前状态、已处理请求数等），当master进程要kill一个worker进程则通过`发信号的方式`通知worker进程（**master进程管理woker进程通过发信号的方式**）。\n\n<u>FPM可以监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程。</u>\n![worker_pool](https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd)\n\n在`php-fpm.conf`（php-fpm.conf路径：`/etc/php/7.1/fpm/php-fpm.conf`）中通过[pool name]声明一个worker pool：  \n（php-fpm.conf文件中include了多个pool配置，相关配置在（`/etc/php/7.1/fpm/pool.d/*.conf`））\n\n```\n[web1]\nlisten = 127.0.0.1:9000\n...\n\n[web2]\nlisten = 127.0.0.1:9001\n...\n```\n\n启动fpm后查看进程：ps -aux|grep fpm\n```\nroot     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (/usr/local/php7/etc/php-fpm.conf)\nnobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1\nnobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1\nnobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2\nnobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2\n```\n\n**具体实现**：\n`worker pool`通过`fpm_worker_pool_s`这个结构表示，多个`worker pool`组成一个**单链表**:\n\n```c\nstruct fpm_worker_pool_s {\n    struct fpm_worker_pool_s *next; //指向下一个worker pool\n    struct fpm_worker_pool_config_s *config; //conf配置:pm、max_children、start_servers...\n    int listening_socket; //监听的套接字\n    ...\n\n    struct fpm_child_s *children; // 当前pool的worker链表，每一个worker对应一个fpm_child_s结构\n    int running_children; //当前pool的worker运行总数\n    int idle_spawn_rate;\n    int warn_max_children;\n\n    struct fpm_scoreboard_s *scoreboard; //记录worker的运行信息，比如空闲、忙碌worker数\n    ...\n}\n```\n\n#### 2.1 FPM的初始化\nFpm在启动后首先会进行`SAPI的注册操作`，接着会进入PHP生命周期的`module startup`阶段，在这个阶段会调用各个扩展定义的MINT钩子函数，然后进行一系列的初始化操作，最后master，worker进程进入不同的处理环节。\n\n<u>fpm的启动流程：</u>\n\n```c\n//sapi/fpm/fpm/fpm_main.c\nint main(int argc, char *argv[])\n{\n    ...\n    //注册SAPI:将全局变量sapi_module设置为cgi_sapi_module\n    sapi_startup(&cgi_sapi_module);\n    ...\n    //执行php_module_starup()\n    if (cgi_sapi_module.startup(&cgi_sapi_module) == FAILURE) {\n        return FPM_EXIT_SOFTWARE;\n    }\n    ...\n    //初始化\n    if(0 > fpm_init(...)){\n        ...\n    }\n    ...\n    fpm_is_running = 1;\n\n    fcgi_fd = fpm_run(&max_requests);//后面都是worker进程的操作，master进程不会走到下面\n    parent = 0;\n    ...\n}\n```\n`fpm_init()`主要有以下几个关键操作：\n\n- fpm_conf_init_main():  解析php-fpm.conf配置文件.\n解析`php-fpm.conf`配置文件，分配worker pool内存结构并保存到全局变量中：fpm_worker_all_pools，各worker pool配置解析到`fpm_worker_pool_s->config`中，以下为config中的几个常用配置：\n```c\nstruct fpm_worker_pool_config_s {\n\tchar *name; // pool名称，即配置：[pool name]\n\tchar *user; // Fpm的启动用户：配置：user\n\tchar *group; // 配置：group\n\tchar *listen_address; // 监听的地址，配置：listen\n\t...\n\tint pm; // 进程模型：static、dynamic、ondemand\n\tint pm_max_children; // 最大worker进程数\n\tint pm_start_servers; // 启动时初始化的worker数\n\tint pm_min_spare_servers; // 最小空闲worker数\n\tint pm_max_spare_servers; // 最大空闲worker数\n\tint pm_process_idle_timeout; // worker空闲时间\n\tint pm_max_requests; // worker处理的最多请求数，超多这个值worker将被kill\n    ...\n};\n```\n\n- fpm_scoreboard_init_main():  分配用于记录worker进行运行信息的共享内存.\n分配用于`记录worker进程运行信息的共享内存`。按照worker pool的最大worker进程数分配，每个worker pool分配一个**fpm_scoreboard_s**结构，pool下对应的每个worker进程分配一个**fpm_scoreboard_proc_s**结构，各结构的对应关系如下图。\n![worker_pool_struct](https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738)\n\n- fpm_signals_init_mian():  mataer进行创建管道及注册信号管理worker进程.\n```c\nstatic int sp[2];\n\nint fpm_signals_init_main()\n{\n    struct sigaction act;\n\n    //创建一个全双工管道，该管道不是用于master与worker进程通信的，只在master进程中使用。\n    if (0 > socketpair(AF_UNIX, SOCK_STREAM, 0, sp)) {\n        return -1;\n    }\n    //注册信号处理handler\n    act.sa_handler = sig_handler;\n    sigfillset(&act.sa_mask);\n    if (0 > sigaction(SIGTERM,  &act, 0) ||\n        0 > sigaction(SIGINT,   &act, 0) ||\n        0 > sigaction(SIGUSR1,  &act, 0) ||\n        0 > sigaction(SIGUSR2,  &act, 0) ||\n        0 > sigaction(SIGCHLD,  &act, 0) ||\n        0 > sigaction(SIGQUIT,  &act, 0)) {\n        return -1;\n    }\n    return 0;\n}\n```\n通过**socketpair()**创建一个管道，此管道只在master进程中使用。另外设置master的信号处理handler，当master收到SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT这些信号时将调用sig_handler()处理：\n```c\nstatic void sig_handler(int signo)\n{\n    static const char sig_chars[NSIG + 1] = {\n        [SIGTERM] = 'T',\n        [SIGINT]  = 'I',\n        [SIGUSR1] = '1',\n        [SIGUSR2] = '2',\n        [SIGQUIT] = 'Q',\n        [SIGCHLD] = 'C'\n    };\n    char s;\n    ...\n    s = sig_chars[signo];\n    //将信号通知写入管道sp[1]端\n    write(sp[1], &s, sizeof(s));\n    ...\n}\n```\n\n- fpm_sockets_init_main():  创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。\n- fpm_event_init_main():  启动master的事件管理.\n启动master的事件管理，fpm实现了一个事件管理器用于管理IO、定时事件，其中IO事件通过kqueue、epoll、poll、select等管理，定时事件就是定时器，一定时间后触发某个事件。\n\n\n\n在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将fork子进程，启动进程管理器，另外master进程将不会再返回，只有各worker进程会返回，也就是说fpm_run()之后的操作均是worker进程的。\n\n```c\nint fpm_run(int *max_requests)\n{\n    struct fpm_worker_pool_s *wp;\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        //调用fpm_children_make() fork子进程\n        is_parent = fpm_children_create_initial(wp);\n        \n        if (!is_parent) {\n            goto run_child;\n        }\n    }\n    //master进程将进入event循环，不再往下走\n    fpm_event_loop(0);\n\nrun_child: //只有worker进程会到这里\n\n    *max_requests = fpm_globals.max_requests;\n    return fpm_globals.listening_socket; //返回监听的套接字\n}\n```\n\n在fork后worker进程返回了监听的套接字继续main()后面的处理，而master将永远阻塞在fpm_event_loop().\n\n\n#### 2.2 worker-请求处理\nfpm_run()执行后将fork出worker进程，worker进程返回main()中继续向下执行，后面的流程就是worker进程不断accept请求，然后执行PHP脚本并返回。整体流程如下：\n- **等待请求**： worker进程阻塞在fcgi_accept_request()等待请求。\n- **解析请求**： fastcgi请求到达后被worker接收，然后开始接受并解析请求数据，直到request数据完全到达。\n- **请求初始化**：执行php_request_startup(), 此阶段会调用每个扩展的PHP_RINI_FUNCTION();\n- **编译、执行**：php_execute_script()完成PHP脚本的编译、执行。\n- **关闭请求**：请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。\n```c\nint main(int argc, char *argv[])\n{\n    ...\n    fcgi_fd = fpm_run(&max_requests);\n    parent = 0;\n\n    //初始化fastcgi请求\n    request = fpm_init_request(fcgi_fd);\n    \n    //worker进程将阻塞在这，等待请求\n    while (EXPECTED(fcgi_accept_request(request) >= 0)) {\n        SG(server_context) = (void *) request;\n        init_request_info();\n        \n        //请求开始\n        if (UNEXPECTED(php_request_startup() == FAILURE)) {\n            ...\n        }\n        ...\n\n        fpm_request_executing();\n        //编译、执行PHP脚本\n        php_execute_script(&file_handle);\n        ...\n        //请求结束\n        php_request_shutdown((void *) 0);\n        ...\n    }\n    ...\n    //worker进程退出\n    php_module_shutdown();\n    ...\n}\n```\nworker进程一次请求的处理被划分为5个阶段：\n\n- **FPM_REQUEST_ACCEPTING**: 等待请求阶段\n- **FPM_REQUEST_READING_HEADERS**: 读取fastcgi请求header阶段\n- **FPM_REQUEST_INFO**: 获取请求信息阶段，此阶段是将请求的method、query stirng、request uri等信息保存到各worker进程的fpm_scoreboard_proc_s结构中，此操作需要加锁，因为master进程也会操作此结构\n- **FPM_REQUEST_EXECUTING**: 执行请求阶段\n- **FPM_REQUEST_END**: 没有使用\n- **FPM_REQUEST_FINISHED**: 请求处理完成  \nworker处理到各个阶段时将会把当前阶段更新到==fpm_scoreboard_proc_s->request_stage==，master进程正是通过这个标识判断worker进程是否空闲的。\n\n#### 2.3 master-进程管理\n<u>master进程管理woker进程管理方式:</u>\n\n- **static**  \nworker进程数固定不变。在启动时master按照pm.max_children配置fork出相应数量的worker进程。\n- **dynamic**  \n动态进程管理。 \n    - 首先fpm启动时按照pm.start_servers初始化一定数量的worker（*默认情况为：pm.min_spare_servers + (max_spare_servers - min_spare_servers) / 2*）。\n    - 运行期间若master发现空闲的worker数低于pm.min_spare_servers(最小空闲数)配置数（请求较多，worker处理不过来）则会fork进程，但总worker数不能超过pm.max_children(最大进程数)；\n    - 若空闲worker数超过pm.max_spare_servers(最大空闲数)（空闲worker数过多），则kill掉一些wokrer，避免占用资源过多。\n```\npm.start_servers: 初始worker数\npm.min_spare_servers: 最小空闲worker数量\npm.max_spare_servers: 最大空闲worker数量\npm.max_children: 最大worker数\n```\n- **ondemand**  \n在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。\n```\npm.max_children: 最大worker数\npm.process_idle_timeout: 空闲超时时间\n```\n\n\n\nmaster整体的处理，其进程管理主要依赖注册的几个事件：\n\n```c\nvoid fpm_event_loop(int err)\n{\n    //创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]\n    //当sp[0]可读时将回调fpm_got_signal()\n    fpm_event_set(&signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &fpm_got_signal, NULL);\n    fpm_event_add(&signal_fd_event, 0);\n\n    //如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查\n    if (fpm_globals.heartbeat > 0) {\n        fpm_pctl_heartbeat(NULL, 0, NULL);\n    }\n    //定时触发进程管理\n    fpm_pctl_perform_idle_server_maintenance_heartbeat(NULL, 0, NULL);\n    \n    //进入事件循环，master进程将阻塞在此\n    while (1) {\n        ...\n        //等待IO事件\n        ret = module->wait(fpm_event_queue_fd, timeout);\n        ...\n        //检查定时器事件\n        ...\n    }\n}\n```\n##### 2.3.1. sp[1]管道可读事件：\n在fpm_init()阶段master曾创建了一个全双工的管道：`sp`，然后在这里创建了一个sp[0]可读的事件，当sp[0]可读时将交由fpm_got_signal()处理，向sp[1]写数据时sp[0]才会可读，那么什么时机会向sp[1]写数据呢？前面已经提到了：当master收到注册的那几种信号时会写入sp[1]端，这个时候将触发sp[0]可读事件。\n![master_event_1](https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec)\n信号用途：\n\n- SIGINT/SIGTERM/SIGQUIT:**退出fpm**，在master收到退出信号后将向所有的worker进程发送退出信号，然后master退出.\n- SIGUSR1:**重新加载日志文件**，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果fpm不重新加载将无法继续写入日志，这个时候就需要向master发送一个USR1的信号\n- SIGUSR2:**重启fpm**，首先master也是会向所有的worker进程发送退出信号，然后master会调用execvp()重新启动fpm，最后旧的master退出\n- SIGCHLD:这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用wait或者waitpid函数查询子进程退出状态后子进程才告终止，fpm中当worker进程因为异常原因(比如coredump了)退出而非master主动杀掉时master将受到此信号，这个时候父进程将调用waitpid()查下子进程的退出，然后检查下是不是需要重新fork新的worker\n\n##### 2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():\n这是进程管理实现的主要事件，master启动了一个定时器，每隔**1s**触发一次，主要用于dynamic、ondemand模式下的worker管理，master会定时检查各worker pool的worker进程数，通过此定时器实现worker数量的控制\n\n```\nstatic void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)\n{\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        struct fpm_child_s *last_idle_child = NULL; //空闲时间最久的worker\n        int idle = 0; //空闲worker数\n        int active = 0; //忙碌worker数\n        \n        for (child = wp->children; child; child = child->next) {\n            //根据worker进程的fpm_scoreboard_proc_s->request_stage判断\n            if (fpm_request_is_idle(child)) {\n                //找空闲时间最久的worker\n                ...\n                idle++;\n            }else{\n                active++;\n            }\n        }\n        ...\n        //ondemand模式\n        if (wp->config->pm == PM_STYLE_ONDEMAND) {\n            if (!last_idle_child) continue;\n\n            fpm_request_last_activity(last_idle_child, &last);\n            fpm_clock_get(&now);\n            if (last.tv_sec < now.tv_sec - wp->config->pm_process_idle_timeout) {\n                //如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker\n                last_idle_child->idle_kill = 1;\n                fpm_pctl_kill(last_idle_child->pid, FPM_PCTL_QUIT);\n            } \n            continue;\n        }\n        //dynamic\n        if (wp->config->pm != PM_STYLE_DYNAMIC) continue;\n        if (idle > wp->config->pm_max_spare_servers && last_idle_child) {\n            //空闲worker太多了，杀掉\n            last_idle_child->idle_kill = 1;\n            fpm_pctl_kill(last_idle_child->pid, FPM_PCTL_QUIT);\n            wp->idle_spawn_rate = 1;\n            continue;\n        }\n        if (idle < wp->config->pm_min_spare_servers) {\n            //空闲worker太少了，如果总worker数未达到max数则fork\n            ...\n        }\n    }\n}\n```\n##### 2.3.3 fpm_pctl_heartbeat():\n这个事件是用于限制worker处理单个请求最大耗时的，php-fpm.conf中有一个request_terminate_timeout的配置项，如果worker处理一个请求的总时长超过了这个值那么master将会向此worker进程发送kill -TERM信号杀掉worker进程，此配置单位为秒，默认值为0表示关闭此机制，另外fpm打印的slow log也是在这里完成的。\n```\nstatic void fpm_pctl_check_request_timeout(struct timeval *now)\n{   \n    struct fpm_worker_pool_s *wp;\n\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        int terminate_timeout = wp->config->request_terminate_timeout;\n        int slowlog_timeout = wp->config->request_slowlog_timeout;\n        struct fpm_child_s *child;\n\n        if (terminate_timeout || slowlog_timeout) { \n            for (child = wp->children; child; child = child->next) {\n                //检查当前当前worker处理的请求是否超时\n                fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);\n            }\n        }\n    }\n}\n```\n注：*ondemand模式下master监听的新请求到达的事件，因为ondemand模式下fpm启动时是不会预创建worker的，有请求时才会生成子进程，所以请求到达时需要通知master进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()。*\n\n\n\n\n---\n参考文档：  \n1、php内核剖析： http://www.php.cn/manual/view/32905.html  \n2、php7-integernal：https://github.com/pangudashu/php7-internal","slug":"PHP7内核-FPM","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7fte001f0sg37itwgqmr","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>FPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其<u>核心功能是进程管理</u>。<br>FastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。<u>注：FastCGI只是一种协议</u>。</p>\n<a id=\"more\"></a>\n\n<p>PHP处理Http请求过程：<code>PHP接收请求</code>、<code>解析协议</code>，<code>处理完成返回请求</code>。<br>在网络应用场景下，PHP实现了FastCGI协议，然后与web服务器配合实现了http的处理，web服务器处理http请求，然后将解析的结果通过FastCGI协议转发给处理程序，处理程序处理完成后将结果返回给web服务器，web服务器再返回给用户，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4\" alt=\"fastcgi\"></p>\n<p><u>PHP实现了FastCGI协议的解析，但未具体实现网络处理</u>，一般的处理模型：<code>多进程</code>，<code>多线程</code>。</p>\n<ul>\n<li><strong>多进程模型</strong>：主进程只负责管理子进程，而基本的网络事件由各个子进程处理，例如：nginx、fpm。</li>\n<li><strong>多线程模型</strong>：与多进程类似，只是它是线程粒度，这种模式通常由主线程监听、接收请求，然后交给子线程处理，例如：memcache。有的也用多进程的那种模式——主线程只负责管理子线程，各个子线程负责监听、接收、处理请求，例如：memcache使用udp协议的情况。</li>\n</ul>\n<p><em>进程拥有独立的地址空间及资源，而线程没有，线程之间共享进程的地址空间及资源，所以在资源管理上多进程模型比较简单，而多线程模型需考虑不同线程之间的资源冲突，及线程安全。</em></p>\n<h3 id=\"2-基本实现\"><a href=\"#2-基本实现\" class=\"headerlink\" title=\"2 基本实现\"></a>2 基本实现</h3><p>FPM是一个<code>多进程模型</code>，它由<code>一个master进程</code>和<code>多个worker进程</code>组成。master会创建一个socket，但不会接口处理进程，而是由fork出的worker进程处理接收请求和处理。</p>\n<ul>\n<li><strong>master进程</strong>：master进程的主要工作是管理worker进程，负责fork或kill掉worker进程。</li>\n<li><strong>worker进程</strong>：worker进程的主要工作是处理请求，其生命周期为：<code>accept请求-&gt;解析FastCGI-&gt;执行相应脚本-&gt;关闭请求-&gt;等待新的请求</code>。  </li>\n</ul>\n<p><em>注：Fpm为阻塞式模型，即一个进程只会同时链接一个请求。（目的是为了简化PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突）</em></p>\n<p><strong>FPM的实现概括</strong>：创建一个master进程，在master进程中创建并监听socket， 然后fork出多个子进程，这些子进程各自accept请求，有请求达到后开始读取请求数据，读取完成后开始处理然后返回。<u>（子进程启动后阻塞在accept上，直到有请求到达，且子进程同时只能响应一个请求。）</u></p>\n<p>FPM的master进程与worker进程之间不会直接进行通信，master通过<code>共享内存</code>获取worker进程的信息（worker当前状态、已处理请求数等），当master进程要kill一个worker进程则通过<code>发信号的方式</code>通知worker进程（<strong>master进程管理woker进程通过发信号的方式</strong>）。</p>\n<p><u>FPM可以监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程。</u><br><img src=\"https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd\" alt=\"worker_pool\"></p>\n<p>在<code>php-fpm.conf</code>（php-fpm.conf路径：<code>/etc/php/7.1/fpm/php-fpm.conf</code>）中通过[pool name]声明一个worker pool：<br>（php-fpm.conf文件中include了多个pool配置，相关配置在（<code>/etc/php/7.1/fpm/pool.d/*.conf</code>））</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[web1]</span><br><span class=\"line\">listen &#x3D; 127.0.0.1:9000</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">[web2]</span><br><span class=\"line\">listen &#x3D; 127.0.0.1:9001</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>启动fpm后查看进程：ps -aux|grep fpm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (&#x2F;usr&#x2F;local&#x2F;php7&#x2F;etc&#x2F;php-fpm.conf)</span><br><span class=\"line\">nobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class=\"line\">nobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class=\"line\">nobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br><span class=\"line\">nobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br></pre></td></tr></table></figure>\n\n<p><strong>具体实现</strong>：<br><code>worker pool</code>通过<code>fpm_worker_pool_s</code>这个结构表示，多个<code>worker pool</code>组成一个<strong>单链表</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">//指向下一个worker pool</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_config_s</span> *<span class=\"title\">config</span>;</span> <span class=\"comment\">//conf配置:pm、max_children、start_servers...</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listening_socket; <span class=\"comment\">//监听的套接字</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_child_s</span> *<span class=\"title\">children</span>;</span> <span class=\"comment\">// 当前pool的worker链表，每一个worker对应一个fpm_child_s结构</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> running_children; <span class=\"comment\">//当前pool的worker运行总数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idle_spawn_rate;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> warn_max_children;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_scoreboard_s</span> *<span class=\"title\">scoreboard</span>;</span> <span class=\"comment\">//记录worker的运行信息，比如空闲、忙碌worker数</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-FPM的初始化\"><a href=\"#2-1-FPM的初始化\" class=\"headerlink\" title=\"2.1 FPM的初始化\"></a>2.1 FPM的初始化</h4><p>Fpm在启动后首先会进行<code>SAPI的注册操作</code>，接着会进入PHP生命周期的<code>module startup</code>阶段，在这个阶段会调用各个扩展定义的MINT钩子函数，然后进行一系列的初始化操作，最后master，worker进程进入不同的处理环节。</p>\n<p><u>fpm的启动流程：</u></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sapi/fpm/fpm/fpm_main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//注册SAPI:将全局变量sapi_module设置为cgi_sapi_module</span></span><br><span class=\"line\">    sapi_startup(&amp;cgi_sapi_module);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//执行php_module_starup()</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cgi_sapi_module.startup(&amp;cgi_sapi_module) == FAILURE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FPM_EXIT_SOFTWARE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &gt; fpm_init(...))&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    fpm_is_running = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    fcgi_fd = fpm_run(&amp;max_requests);<span class=\"comment\">//后面都是worker进程的操作，master进程不会走到下面</span></span><br><span class=\"line\">    parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>fpm_init()</code>主要有以下几个关键操作：</p>\n<ul>\n<li><p>fpm_conf_init_main():  解析php-fpm.conf配置文件.<br>解析<code>php-fpm.conf</code>配置文件，分配worker pool内存结构并保存到全局变量中：fpm_worker_all_pools，各worker pool配置解析到<code>fpm_worker_pool_s-&gt;config</code>中，以下为config中的几个常用配置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_config_s</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *name; <span class=\"comment\">// pool名称，即配置：[pool name]</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *user; <span class=\"comment\">// Fpm的启动用户：配置：user</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *group; <span class=\"comment\">// 配置：group</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *listen_address; <span class=\"comment\">// 监听的地址，配置：listen</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm; <span class=\"comment\">// 进程模型：static、dynamic、ondemand</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_children; <span class=\"comment\">// 最大worker进程数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_start_servers; <span class=\"comment\">// 启动时初始化的worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_min_spare_servers; <span class=\"comment\">// 最小空闲worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_spare_servers; <span class=\"comment\">// 最大空闲worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_process_idle_timeout; <span class=\"comment\">// worker空闲时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_requests; <span class=\"comment\">// worker处理的最多请求数，超多这个值worker将被kill</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fpm_scoreboard_init_main():  分配用于记录worker进行运行信息的共享内存.<br>分配用于<code>记录worker进程运行信息的共享内存</code>。按照worker pool的最大worker进程数分配，每个worker pool分配一个<strong>fpm_scoreboard_s</strong>结构，pool下对应的每个worker进程分配一个<strong>fpm_scoreboard_proc_s</strong>结构，各结构的对应关系如下图。<br><img src=\"https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738\" alt=\"worker_pool_struct\"></p>\n</li>\n<li><p>fpm_signals_init_mian():  mataer进行创建管道及注册信号管理worker进程.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sp[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fpm_signals_init_main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建一个全双工管道，该管道不是用于master与worker进程通信的，只在master进程中使用。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &gt; socketpair(AF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>, sp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//注册信号处理handler</span></span><br><span class=\"line\">    act.sa_handler = sig_handler;</span><br><span class=\"line\">    sigfillset(&amp;act.sa_mask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &gt; sigaction(SIGTERM,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGINT,   &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGUSR1,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGUSR2,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGCHLD,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGQUIT,  &amp;act, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过**socketpair()**创建一个管道，此管道只在master进程中使用。另外设置master的信号处理handler，当master收到SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT这些信号时将调用sig_handler()处理：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sig_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> signo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> sig_chars[NSIG + <span class=\"number\">1</span>] = &#123;</span><br><span class=\"line\">        [SIGTERM] = <span class=\"string\">&#x27;T&#x27;</span>,</span><br><span class=\"line\">        [SIGINT]  = <span class=\"string\">&#x27;I&#x27;</span>,</span><br><span class=\"line\">        [SIGUSR1] = <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">        [SIGUSR2] = <span class=\"string\">&#x27;2&#x27;</span>,</span><br><span class=\"line\">        [SIGQUIT] = <span class=\"string\">&#x27;Q&#x27;</span>,</span><br><span class=\"line\">        [SIGCHLD] = <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    s = sig_chars[signo];</span><br><span class=\"line\">    <span class=\"comment\">//将信号通知写入管道sp[1]端</span></span><br><span class=\"line\">    write(sp[<span class=\"number\">1</span>], &amp;s, <span class=\"keyword\">sizeof</span>(s));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fpm_sockets_init_main():  创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。</p>\n</li>\n<li><p>fpm_event_init_main():  启动master的事件管理.<br>启动master的事件管理，fpm实现了一个事件管理器用于管理IO、定时事件，其中IO事件通过kqueue、epoll、poll、select等管理，定时事件就是定时器，一定时间后触发某个事件。</p>\n</li>\n</ul>\n<p>在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将fork子进程，启动进程管理器，另外master进程将不会再返回，只有各worker进程会返回，也就是说fpm_run()之后的操作均是worker进程的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fpm_run</span><span class=\"params\">(<span class=\"keyword\">int</span> *max_requests)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> *<span class=\"title\">wp</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (wp = fpm_worker_all_pools; wp; wp = wp-&gt;next) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用fpm_children_make() fork子进程</span></span><br><span class=\"line\">        is_parent = fpm_children_create_initial(wp);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!is_parent) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> run_child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//master进程将进入event循环，不再往下走</span></span><br><span class=\"line\">    fpm_event_loop(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">run_child: <span class=\"comment\">//只有worker进程会到这里</span></span><br><span class=\"line\"></span><br><span class=\"line\">    *max_requests = fpm_globals.max_requests;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fpm_globals.listening_socket; <span class=\"comment\">//返回监听的套接字</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在fork后worker进程返回了监听的套接字继续main()后面的处理，而master将永远阻塞在fpm_event_loop().</p>\n<h4 id=\"2-2-worker-请求处理\"><a href=\"#2-2-worker-请求处理\" class=\"headerlink\" title=\"2.2 worker-请求处理\"></a>2.2 worker-请求处理</h4><p>fpm_run()执行后将fork出worker进程，worker进程返回main()中继续向下执行，后面的流程就是worker进程不断accept请求，然后执行PHP脚本并返回。整体流程如下：</p>\n<ul>\n<li><p><strong>等待请求</strong>： worker进程阻塞在fcgi_accept_request()等待请求。</p>\n</li>\n<li><p><strong>解析请求</strong>： fastcgi请求到达后被worker接收，然后开始接受并解析请求数据，直到request数据完全到达。</p>\n</li>\n<li><p><strong>请求初始化</strong>：执行php_request_startup(), 此阶段会调用每个扩展的PHP_RINI_FUNCTION();</p>\n</li>\n<li><p><strong>编译、执行</strong>：php_execute_script()完成PHP脚本的编译、执行。</p>\n</li>\n<li><p><strong>关闭请求</strong>：请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    fcgi_fd = fpm_run(&amp;max_requests);</span><br><span class=\"line\">    parent = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化fastcgi请求</span></span><br><span class=\"line\">    request = fpm_init_request(fcgi_fd);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//worker进程将阻塞在这，等待请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (EXPECTED(fcgi_accept_request(request) &gt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        SG(server_context) = (<span class=\"keyword\">void</span> *) request;</span><br><span class=\"line\">        init_request_info();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//请求开始</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNEXPECTED(php_request_startup() == FAILURE)) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        fpm_request_executing();</span><br><span class=\"line\">        <span class=\"comment\">//编译、执行PHP脚本</span></span><br><span class=\"line\">        php_execute_script(&amp;file_handle);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//请求结束</span></span><br><span class=\"line\">        php_request_shutdown((<span class=\"keyword\">void</span> *) <span class=\"number\">0</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//worker进程退出</span></span><br><span class=\"line\">    php_module_shutdown();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>worker进程一次请求的处理被划分为5个阶段：</p>\n</li>\n<li><p><strong>FPM_REQUEST_ACCEPTING</strong>: 等待请求阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_READING_HEADERS</strong>: 读取fastcgi请求header阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_INFO</strong>: 获取请求信息阶段，此阶段是将请求的method、query stirng、request uri等信息保存到各worker进程的fpm_scoreboard_proc_s结构中，此操作需要加锁，因为master进程也会操作此结构</p>\n</li>\n<li><p><strong>FPM_REQUEST_EXECUTING</strong>: 执行请求阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_END</strong>: 没有使用</p>\n</li>\n<li><p><strong>FPM_REQUEST_FINISHED</strong>: 请求处理完成<br>worker处理到各个阶段时将会把当前阶段更新到==fpm_scoreboard_proc_s-&gt;request_stage==，master进程正是通过这个标识判断worker进程是否空闲的。</p>\n</li>\n</ul>\n<h4 id=\"2-3-master-进程管理\"><a href=\"#2-3-master-进程管理\" class=\"headerlink\" title=\"2.3 master-进程管理\"></a>2.3 master-进程管理</h4><p><u>master进程管理woker进程管理方式:</u></p>\n<ul>\n<li><strong>static</strong><br>worker进程数固定不变。在启动时master按照pm.max_children配置fork出相应数量的worker进程。</li>\n<li><strong>dynamic</strong><br>动态进程管理。 <ul>\n<li>首先fpm启动时按照pm.start_servers初始化一定数量的worker（<em>默认情况为：pm.min_spare_servers + (max_spare_servers - min_spare_servers) / 2</em>）。</li>\n<li>运行期间若master发现空闲的worker数低于pm.min_spare_servers(最小空闲数)配置数（请求较多，worker处理不过来）则会fork进程，但总worker数不能超过pm.max_children(最大进程数)；</li>\n<li>若空闲worker数超过pm.max_spare_servers(最大空闲数)（空闲worker数过多），则kill掉一些wokrer，避免占用资源过多。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.start_servers: 初始worker数</span><br><span class=\"line\">pm.min_spare_servers: 最小空闲worker数量</span><br><span class=\"line\">pm.max_spare_servers: 最大空闲worker数量</span><br><span class=\"line\">pm.max_children: 最大worker数</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>ondemand</strong><br>在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.max_children: 最大worker数</span><br><span class=\"line\">pm.process_idle_timeout: 空闲超时时间</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p>master整体的处理，其进程管理主要依赖注册的几个事件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fpm_event_loop</span><span class=\"params\">(<span class=\"keyword\">int</span> err)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]</span></span><br><span class=\"line\">    <span class=\"comment\">//当sp[0]可读时将回调fpm_got_signal()</span></span><br><span class=\"line\">    fpm_event_set(&amp;signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &amp;fpm_got_signal, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    fpm_event_add(&amp;signal_fd_event, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fpm_globals.heartbeat &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        fpm_pctl_heartbeat(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//定时触发进程管理</span></span><br><span class=\"line\">    fpm_pctl_perform_idle_server_maintenance_heartbeat(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//进入事件循环，master进程将阻塞在此</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//等待IO事件</span></span><br><span class=\"line\">        ret = <span class=\"keyword\">module</span>-&gt;wait(fpm_event_queue_fd, timeout);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//检查定时器事件</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-1-sp-1-管道可读事件：\"><a href=\"#2-3-1-sp-1-管道可读事件：\" class=\"headerlink\" title=\"2.3.1. sp[1]管道可读事件：\"></a>2.3.1. sp[1]管道可读事件：</h5><p>在fpm_init()阶段master曾创建了一个全双工的管道：<code>sp</code>，然后在这里创建了一个sp[0]可读的事件，当sp[0]可读时将交由fpm_got_signal()处理，向sp[1]写数据时sp[0]才会可读，那么什么时机会向sp[1]写数据呢？前面已经提到了：当master收到注册的那几种信号时会写入sp[1]端，这个时候将触发sp[0]可读事件。<br><img src=\"https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec\" alt=\"master_event_1\"><br>信号用途：</p>\n<ul>\n<li>SIGINT/SIGTERM/SIGQUIT:<strong>退出fpm</strong>，在master收到退出信号后将向所有的worker进程发送退出信号，然后master退出.</li>\n<li>SIGUSR1:<strong>重新加载日志文件</strong>，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果fpm不重新加载将无法继续写入日志，这个时候就需要向master发送一个USR1的信号</li>\n<li>SIGUSR2:<strong>重启fpm</strong>，首先master也是会向所有的worker进程发送退出信号，然后master会调用execvp()重新启动fpm，最后旧的master退出</li>\n<li>SIGCHLD:这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用wait或者waitpid函数查询子进程退出状态后子进程才告终止，fpm中当worker进程因为异常原因(比如coredump了)退出而非master主动杀掉时master将受到此信号，这个时候父进程将调用waitpid()查下子进程的退出，然后检查下是不是需要重新fork新的worker</li>\n</ul>\n<h5 id=\"2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat\"><a href=\"#2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat\" class=\"headerlink\" title=\"2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():\"></a>2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():</h5><p>这是进程管理实现的主要事件，master启动了一个定时器，每隔<strong>1s</strong>触发一次，主要用于dynamic、ondemand模式下的worker管理，master会定时检查各worker pool的worker进程数，通过此定时器实现worker数量的控制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class=\"line\">        struct fpm_child_s *last_idle_child &#x3D; NULL; &#x2F;&#x2F;空闲时间最久的worker</span><br><span class=\"line\">        int idle &#x3D; 0; &#x2F;&#x2F;空闲worker数</span><br><span class=\"line\">        int active &#x3D; 0; &#x2F;&#x2F;忙碌worker数</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;根据worker进程的fpm_scoreboard_proc_s-&gt;request_stage判断</span><br><span class=\"line\">            if (fpm_request_is_idle(child)) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;找空闲时间最久的worker</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                idle++;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                active++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#x2F;&#x2F;ondemand模式</span><br><span class=\"line\">        if (wp-&gt;config-&gt;pm &#x3D;&#x3D; PM_STYLE_ONDEMAND) &#123;</span><br><span class=\"line\">            if (!last_idle_child) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">            fpm_request_last_activity(last_idle_child, &amp;last);</span><br><span class=\"line\">            fpm_clock_get(&amp;now);</span><br><span class=\"line\">            if (last.tv_sec &lt; now.tv_sec - wp-&gt;config-&gt;pm_process_idle_timeout) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker</span><br><span class=\"line\">                last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class=\"line\">                fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;dynamic</span><br><span class=\"line\">        if (wp-&gt;config-&gt;pm !&#x3D; PM_STYLE_DYNAMIC) continue;</span><br><span class=\"line\">        if (idle &gt; wp-&gt;config-&gt;pm_max_spare_servers &amp;&amp; last_idle_child) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;空闲worker太多了，杀掉</span><br><span class=\"line\">            last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class=\"line\">            fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class=\"line\">            wp-&gt;idle_spawn_rate &#x3D; 1;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (idle &lt; wp-&gt;config-&gt;pm_min_spare_servers) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;空闲worker太少了，如果总worker数未达到max数则fork</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-3-fpm-pctl-heartbeat\"><a href=\"#2-3-3-fpm-pctl-heartbeat\" class=\"headerlink\" title=\"2.3.3 fpm_pctl_heartbeat():\"></a>2.3.3 fpm_pctl_heartbeat():</h5><p>这个事件是用于限制worker处理单个请求最大耗时的，php-fpm.conf中有一个request_terminate_timeout的配置项，如果worker处理一个请求的总时长超过了这个值那么master将会向此worker进程发送kill -TERM信号杀掉worker进程，此配置单位为秒，默认值为0表示关闭此机制，另外fpm打印的slow log也是在这里完成的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void fpm_pctl_check_request_timeout(struct timeval *now)</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    struct fpm_worker_pool_s *wp;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class=\"line\">        int terminate_timeout &#x3D; wp-&gt;config-&gt;request_terminate_timeout;</span><br><span class=\"line\">        int slowlog_timeout &#x3D; wp-&gt;config-&gt;request_slowlog_timeout;</span><br><span class=\"line\">        struct fpm_child_s *child;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (terminate_timeout || slowlog_timeout) &#123; </span><br><span class=\"line\">            for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;检查当前当前worker处理的请求是否超时</span><br><span class=\"line\">                fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：<em>ondemand模式下master监听的新请求到达的事件，因为ondemand模式下fpm启动时是不会预创建worker的，有请求时才会生成子进程，所以请求到达时需要通知master进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()。</em></p>\n<hr>\n<p>参考文档：<br>1、php内核剖析： <a href=\"http://www.php.cn/manual/view/32905.html\">http://www.php.cn/manual/view/32905.html</a><br>2、php7-integernal：<a href=\"https://github.com/pangudashu/php7-internal\">https://github.com/pangudashu/php7-internal</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>FPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其<u>核心功能是进程管理</u>。<br>FastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。<u>注：FastCGI只是一种协议</u>。</p>","more":"<p>PHP处理Http请求过程：<code>PHP接收请求</code>、<code>解析协议</code>，<code>处理完成返回请求</code>。<br>在网络应用场景下，PHP实现了FastCGI协议，然后与web服务器配合实现了http的处理，web服务器处理http请求，然后将解析的结果通过FastCGI协议转发给处理程序，处理程序处理完成后将结果返回给web服务器，web服务器再返回给用户，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4\" alt=\"fastcgi\"></p>\n<p><u>PHP实现了FastCGI协议的解析，但未具体实现网络处理</u>，一般的处理模型：<code>多进程</code>，<code>多线程</code>。</p>\n<ul>\n<li><strong>多进程模型</strong>：主进程只负责管理子进程，而基本的网络事件由各个子进程处理，例如：nginx、fpm。</li>\n<li><strong>多线程模型</strong>：与多进程类似，只是它是线程粒度，这种模式通常由主线程监听、接收请求，然后交给子线程处理，例如：memcache。有的也用多进程的那种模式——主线程只负责管理子线程，各个子线程负责监听、接收、处理请求，例如：memcache使用udp协议的情况。</li>\n</ul>\n<p><em>进程拥有独立的地址空间及资源，而线程没有，线程之间共享进程的地址空间及资源，所以在资源管理上多进程模型比较简单，而多线程模型需考虑不同线程之间的资源冲突，及线程安全。</em></p>\n<h3 id=\"2-基本实现\"><a href=\"#2-基本实现\" class=\"headerlink\" title=\"2 基本实现\"></a>2 基本实现</h3><p>FPM是一个<code>多进程模型</code>，它由<code>一个master进程</code>和<code>多个worker进程</code>组成。master会创建一个socket，但不会接口处理进程，而是由fork出的worker进程处理接收请求和处理。</p>\n<ul>\n<li><strong>master进程</strong>：master进程的主要工作是管理worker进程，负责fork或kill掉worker进程。</li>\n<li><strong>worker进程</strong>：worker进程的主要工作是处理请求，其生命周期为：<code>accept请求-&gt;解析FastCGI-&gt;执行相应脚本-&gt;关闭请求-&gt;等待新的请求</code>。  </li>\n</ul>\n<p><em>注：Fpm为阻塞式模型，即一个进程只会同时链接一个请求。（目的是为了简化PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突）</em></p>\n<p><strong>FPM的实现概括</strong>：创建一个master进程，在master进程中创建并监听socket， 然后fork出多个子进程，这些子进程各自accept请求，有请求达到后开始读取请求数据，读取完成后开始处理然后返回。<u>（子进程启动后阻塞在accept上，直到有请求到达，且子进程同时只能响应一个请求。）</u></p>\n<p>FPM的master进程与worker进程之间不会直接进行通信，master通过<code>共享内存</code>获取worker进程的信息（worker当前状态、已处理请求数等），当master进程要kill一个worker进程则通过<code>发信号的方式</code>通知worker进程（<strong>master进程管理woker进程通过发信号的方式</strong>）。</p>\n<p><u>FPM可以监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程。</u><br><img src=\"https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd\" alt=\"worker_pool\"></p>\n<p>在<code>php-fpm.conf</code>（php-fpm.conf路径：<code>/etc/php/7.1/fpm/php-fpm.conf</code>）中通过[pool name]声明一个worker pool：<br>（php-fpm.conf文件中include了多个pool配置，相关配置在（<code>/etc/php/7.1/fpm/pool.d/*.conf</code>））</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[web1]</span><br><span class=\"line\">listen &#x3D; 127.0.0.1:9000</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">[web2]</span><br><span class=\"line\">listen &#x3D; 127.0.0.1:9001</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>启动fpm后查看进程：ps -aux|grep fpm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (&#x2F;usr&#x2F;local&#x2F;php7&#x2F;etc&#x2F;php-fpm.conf)</span><br><span class=\"line\">nobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class=\"line\">nobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class=\"line\">nobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br><span class=\"line\">nobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br></pre></td></tr></table></figure>\n\n<p><strong>具体实现</strong>：<br><code>worker pool</code>通过<code>fpm_worker_pool_s</code>这个结构表示，多个<code>worker pool</code>组成一个<strong>单链表</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">//指向下一个worker pool</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_config_s</span> *<span class=\"title\">config</span>;</span> <span class=\"comment\">//conf配置:pm、max_children、start_servers...</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listening_socket; <span class=\"comment\">//监听的套接字</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_child_s</span> *<span class=\"title\">children</span>;</span> <span class=\"comment\">// 当前pool的worker链表，每一个worker对应一个fpm_child_s结构</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> running_children; <span class=\"comment\">//当前pool的worker运行总数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idle_spawn_rate;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> warn_max_children;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_scoreboard_s</span> *<span class=\"title\">scoreboard</span>;</span> <span class=\"comment\">//记录worker的运行信息，比如空闲、忙碌worker数</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-FPM的初始化\"><a href=\"#2-1-FPM的初始化\" class=\"headerlink\" title=\"2.1 FPM的初始化\"></a>2.1 FPM的初始化</h4><p>Fpm在启动后首先会进行<code>SAPI的注册操作</code>，接着会进入PHP生命周期的<code>module startup</code>阶段，在这个阶段会调用各个扩展定义的MINT钩子函数，然后进行一系列的初始化操作，最后master，worker进程进入不同的处理环节。</p>\n<p><u>fpm的启动流程：</u></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sapi/fpm/fpm/fpm_main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//注册SAPI:将全局变量sapi_module设置为cgi_sapi_module</span></span><br><span class=\"line\">    sapi_startup(&amp;cgi_sapi_module);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//执行php_module_starup()</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cgi_sapi_module.startup(&amp;cgi_sapi_module) == FAILURE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FPM_EXIT_SOFTWARE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &gt; fpm_init(...))&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    fpm_is_running = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    fcgi_fd = fpm_run(&amp;max_requests);<span class=\"comment\">//后面都是worker进程的操作，master进程不会走到下面</span></span><br><span class=\"line\">    parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>fpm_init()</code>主要有以下几个关键操作：</p>\n<ul>\n<li><p>fpm_conf_init_main():  解析php-fpm.conf配置文件.<br>解析<code>php-fpm.conf</code>配置文件，分配worker pool内存结构并保存到全局变量中：fpm_worker_all_pools，各worker pool配置解析到<code>fpm_worker_pool_s-&gt;config</code>中，以下为config中的几个常用配置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_config_s</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *name; <span class=\"comment\">// pool名称，即配置：[pool name]</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *user; <span class=\"comment\">// Fpm的启动用户：配置：user</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *group; <span class=\"comment\">// 配置：group</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *listen_address; <span class=\"comment\">// 监听的地址，配置：listen</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm; <span class=\"comment\">// 进程模型：static、dynamic、ondemand</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_children; <span class=\"comment\">// 最大worker进程数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_start_servers; <span class=\"comment\">// 启动时初始化的worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_min_spare_servers; <span class=\"comment\">// 最小空闲worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_spare_servers; <span class=\"comment\">// 最大空闲worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_process_idle_timeout; <span class=\"comment\">// worker空闲时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_requests; <span class=\"comment\">// worker处理的最多请求数，超多这个值worker将被kill</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fpm_scoreboard_init_main():  分配用于记录worker进行运行信息的共享内存.<br>分配用于<code>记录worker进程运行信息的共享内存</code>。按照worker pool的最大worker进程数分配，每个worker pool分配一个<strong>fpm_scoreboard_s</strong>结构，pool下对应的每个worker进程分配一个<strong>fpm_scoreboard_proc_s</strong>结构，各结构的对应关系如下图。<br><img src=\"https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738\" alt=\"worker_pool_struct\"></p>\n</li>\n<li><p>fpm_signals_init_mian():  mataer进行创建管道及注册信号管理worker进程.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sp[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fpm_signals_init_main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建一个全双工管道，该管道不是用于master与worker进程通信的，只在master进程中使用。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &gt; socketpair(AF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>, sp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//注册信号处理handler</span></span><br><span class=\"line\">    act.sa_handler = sig_handler;</span><br><span class=\"line\">    sigfillset(&amp;act.sa_mask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &gt; sigaction(SIGTERM,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGINT,   &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGUSR1,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGUSR2,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGCHLD,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGQUIT,  &amp;act, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过**socketpair()**创建一个管道，此管道只在master进程中使用。另外设置master的信号处理handler，当master收到SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT这些信号时将调用sig_handler()处理：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sig_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> signo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> sig_chars[NSIG + <span class=\"number\">1</span>] = &#123;</span><br><span class=\"line\">        [SIGTERM] = <span class=\"string\">&#x27;T&#x27;</span>,</span><br><span class=\"line\">        [SIGINT]  = <span class=\"string\">&#x27;I&#x27;</span>,</span><br><span class=\"line\">        [SIGUSR1] = <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">        [SIGUSR2] = <span class=\"string\">&#x27;2&#x27;</span>,</span><br><span class=\"line\">        [SIGQUIT] = <span class=\"string\">&#x27;Q&#x27;</span>,</span><br><span class=\"line\">        [SIGCHLD] = <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    s = sig_chars[signo];</span><br><span class=\"line\">    <span class=\"comment\">//将信号通知写入管道sp[1]端</span></span><br><span class=\"line\">    write(sp[<span class=\"number\">1</span>], &amp;s, <span class=\"keyword\">sizeof</span>(s));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fpm_sockets_init_main():  创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。</p>\n</li>\n<li><p>fpm_event_init_main():  启动master的事件管理.<br>启动master的事件管理，fpm实现了一个事件管理器用于管理IO、定时事件，其中IO事件通过kqueue、epoll、poll、select等管理，定时事件就是定时器，一定时间后触发某个事件。</p>\n</li>\n</ul>\n<p>在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将fork子进程，启动进程管理器，另外master进程将不会再返回，只有各worker进程会返回，也就是说fpm_run()之后的操作均是worker进程的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fpm_run</span><span class=\"params\">(<span class=\"keyword\">int</span> *max_requests)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> *<span class=\"title\">wp</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (wp = fpm_worker_all_pools; wp; wp = wp-&gt;next) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用fpm_children_make() fork子进程</span></span><br><span class=\"line\">        is_parent = fpm_children_create_initial(wp);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!is_parent) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> run_child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//master进程将进入event循环，不再往下走</span></span><br><span class=\"line\">    fpm_event_loop(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">run_child: <span class=\"comment\">//只有worker进程会到这里</span></span><br><span class=\"line\"></span><br><span class=\"line\">    *max_requests = fpm_globals.max_requests;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fpm_globals.listening_socket; <span class=\"comment\">//返回监听的套接字</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在fork后worker进程返回了监听的套接字继续main()后面的处理，而master将永远阻塞在fpm_event_loop().</p>\n<h4 id=\"2-2-worker-请求处理\"><a href=\"#2-2-worker-请求处理\" class=\"headerlink\" title=\"2.2 worker-请求处理\"></a>2.2 worker-请求处理</h4><p>fpm_run()执行后将fork出worker进程，worker进程返回main()中继续向下执行，后面的流程就是worker进程不断accept请求，然后执行PHP脚本并返回。整体流程如下：</p>\n<ul>\n<li><p><strong>等待请求</strong>： worker进程阻塞在fcgi_accept_request()等待请求。</p>\n</li>\n<li><p><strong>解析请求</strong>： fastcgi请求到达后被worker接收，然后开始接受并解析请求数据，直到request数据完全到达。</p>\n</li>\n<li><p><strong>请求初始化</strong>：执行php_request_startup(), 此阶段会调用每个扩展的PHP_RINI_FUNCTION();</p>\n</li>\n<li><p><strong>编译、执行</strong>：php_execute_script()完成PHP脚本的编译、执行。</p>\n</li>\n<li><p><strong>关闭请求</strong>：请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    fcgi_fd = fpm_run(&amp;max_requests);</span><br><span class=\"line\">    parent = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化fastcgi请求</span></span><br><span class=\"line\">    request = fpm_init_request(fcgi_fd);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//worker进程将阻塞在这，等待请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (EXPECTED(fcgi_accept_request(request) &gt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        SG(server_context) = (<span class=\"keyword\">void</span> *) request;</span><br><span class=\"line\">        init_request_info();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//请求开始</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNEXPECTED(php_request_startup() == FAILURE)) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        fpm_request_executing();</span><br><span class=\"line\">        <span class=\"comment\">//编译、执行PHP脚本</span></span><br><span class=\"line\">        php_execute_script(&amp;file_handle);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//请求结束</span></span><br><span class=\"line\">        php_request_shutdown((<span class=\"keyword\">void</span> *) <span class=\"number\">0</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//worker进程退出</span></span><br><span class=\"line\">    php_module_shutdown();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>worker进程一次请求的处理被划分为5个阶段：</p>\n</li>\n<li><p><strong>FPM_REQUEST_ACCEPTING</strong>: 等待请求阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_READING_HEADERS</strong>: 读取fastcgi请求header阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_INFO</strong>: 获取请求信息阶段，此阶段是将请求的method、query stirng、request uri等信息保存到各worker进程的fpm_scoreboard_proc_s结构中，此操作需要加锁，因为master进程也会操作此结构</p>\n</li>\n<li><p><strong>FPM_REQUEST_EXECUTING</strong>: 执行请求阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_END</strong>: 没有使用</p>\n</li>\n<li><p><strong>FPM_REQUEST_FINISHED</strong>: 请求处理完成<br>worker处理到各个阶段时将会把当前阶段更新到==fpm_scoreboard_proc_s-&gt;request_stage==，master进程正是通过这个标识判断worker进程是否空闲的。</p>\n</li>\n</ul>\n<h4 id=\"2-3-master-进程管理\"><a href=\"#2-3-master-进程管理\" class=\"headerlink\" title=\"2.3 master-进程管理\"></a>2.3 master-进程管理</h4><p><u>master进程管理woker进程管理方式:</u></p>\n<ul>\n<li><strong>static</strong><br>worker进程数固定不变。在启动时master按照pm.max_children配置fork出相应数量的worker进程。</li>\n<li><strong>dynamic</strong><br>动态进程管理。 <ul>\n<li>首先fpm启动时按照pm.start_servers初始化一定数量的worker（<em>默认情况为：pm.min_spare_servers + (max_spare_servers - min_spare_servers) / 2</em>）。</li>\n<li>运行期间若master发现空闲的worker数低于pm.min_spare_servers(最小空闲数)配置数（请求较多，worker处理不过来）则会fork进程，但总worker数不能超过pm.max_children(最大进程数)；</li>\n<li>若空闲worker数超过pm.max_spare_servers(最大空闲数)（空闲worker数过多），则kill掉一些wokrer，避免占用资源过多。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.start_servers: 初始worker数</span><br><span class=\"line\">pm.min_spare_servers: 最小空闲worker数量</span><br><span class=\"line\">pm.max_spare_servers: 最大空闲worker数量</span><br><span class=\"line\">pm.max_children: 最大worker数</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>ondemand</strong><br>在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.max_children: 最大worker数</span><br><span class=\"line\">pm.process_idle_timeout: 空闲超时时间</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p>master整体的处理，其进程管理主要依赖注册的几个事件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fpm_event_loop</span><span class=\"params\">(<span class=\"keyword\">int</span> err)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]</span></span><br><span class=\"line\">    <span class=\"comment\">//当sp[0]可读时将回调fpm_got_signal()</span></span><br><span class=\"line\">    fpm_event_set(&amp;signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &amp;fpm_got_signal, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    fpm_event_add(&amp;signal_fd_event, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fpm_globals.heartbeat &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        fpm_pctl_heartbeat(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//定时触发进程管理</span></span><br><span class=\"line\">    fpm_pctl_perform_idle_server_maintenance_heartbeat(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//进入事件循环，master进程将阻塞在此</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//等待IO事件</span></span><br><span class=\"line\">        ret = <span class=\"keyword\">module</span>-&gt;wait(fpm_event_queue_fd, timeout);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//检查定时器事件</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-1-sp-1-管道可读事件：\"><a href=\"#2-3-1-sp-1-管道可读事件：\" class=\"headerlink\" title=\"2.3.1. sp[1]管道可读事件：\"></a>2.3.1. sp[1]管道可读事件：</h5><p>在fpm_init()阶段master曾创建了一个全双工的管道：<code>sp</code>，然后在这里创建了一个sp[0]可读的事件，当sp[0]可读时将交由fpm_got_signal()处理，向sp[1]写数据时sp[0]才会可读，那么什么时机会向sp[1]写数据呢？前面已经提到了：当master收到注册的那几种信号时会写入sp[1]端，这个时候将触发sp[0]可读事件。<br><img src=\"https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec\" alt=\"master_event_1\"><br>信号用途：</p>\n<ul>\n<li>SIGINT/SIGTERM/SIGQUIT:<strong>退出fpm</strong>，在master收到退出信号后将向所有的worker进程发送退出信号，然后master退出.</li>\n<li>SIGUSR1:<strong>重新加载日志文件</strong>，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果fpm不重新加载将无法继续写入日志，这个时候就需要向master发送一个USR1的信号</li>\n<li>SIGUSR2:<strong>重启fpm</strong>，首先master也是会向所有的worker进程发送退出信号，然后master会调用execvp()重新启动fpm，最后旧的master退出</li>\n<li>SIGCHLD:这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用wait或者waitpid函数查询子进程退出状态后子进程才告终止，fpm中当worker进程因为异常原因(比如coredump了)退出而非master主动杀掉时master将受到此信号，这个时候父进程将调用waitpid()查下子进程的退出，然后检查下是不是需要重新fork新的worker</li>\n</ul>\n<h5 id=\"2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat\"><a href=\"#2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat\" class=\"headerlink\" title=\"2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():\"></a>2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():</h5><p>这是进程管理实现的主要事件，master启动了一个定时器，每隔<strong>1s</strong>触发一次，主要用于dynamic、ondemand模式下的worker管理，master会定时检查各worker pool的worker进程数，通过此定时器实现worker数量的控制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class=\"line\">        struct fpm_child_s *last_idle_child &#x3D; NULL; &#x2F;&#x2F;空闲时间最久的worker</span><br><span class=\"line\">        int idle &#x3D; 0; &#x2F;&#x2F;空闲worker数</span><br><span class=\"line\">        int active &#x3D; 0; &#x2F;&#x2F;忙碌worker数</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;根据worker进程的fpm_scoreboard_proc_s-&gt;request_stage判断</span><br><span class=\"line\">            if (fpm_request_is_idle(child)) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;找空闲时间最久的worker</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                idle++;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                active++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#x2F;&#x2F;ondemand模式</span><br><span class=\"line\">        if (wp-&gt;config-&gt;pm &#x3D;&#x3D; PM_STYLE_ONDEMAND) &#123;</span><br><span class=\"line\">            if (!last_idle_child) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">            fpm_request_last_activity(last_idle_child, &amp;last);</span><br><span class=\"line\">            fpm_clock_get(&amp;now);</span><br><span class=\"line\">            if (last.tv_sec &lt; now.tv_sec - wp-&gt;config-&gt;pm_process_idle_timeout) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker</span><br><span class=\"line\">                last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class=\"line\">                fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;dynamic</span><br><span class=\"line\">        if (wp-&gt;config-&gt;pm !&#x3D; PM_STYLE_DYNAMIC) continue;</span><br><span class=\"line\">        if (idle &gt; wp-&gt;config-&gt;pm_max_spare_servers &amp;&amp; last_idle_child) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;空闲worker太多了，杀掉</span><br><span class=\"line\">            last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class=\"line\">            fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class=\"line\">            wp-&gt;idle_spawn_rate &#x3D; 1;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (idle &lt; wp-&gt;config-&gt;pm_min_spare_servers) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;空闲worker太少了，如果总worker数未达到max数则fork</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-3-fpm-pctl-heartbeat\"><a href=\"#2-3-3-fpm-pctl-heartbeat\" class=\"headerlink\" title=\"2.3.3 fpm_pctl_heartbeat():\"></a>2.3.3 fpm_pctl_heartbeat():</h5><p>这个事件是用于限制worker处理单个请求最大耗时的，php-fpm.conf中有一个request_terminate_timeout的配置项，如果worker处理一个请求的总时长超过了这个值那么master将会向此worker进程发送kill -TERM信号杀掉worker进程，此配置单位为秒，默认值为0表示关闭此机制，另外fpm打印的slow log也是在这里完成的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void fpm_pctl_check_request_timeout(struct timeval *now)</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    struct fpm_worker_pool_s *wp;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class=\"line\">        int terminate_timeout &#x3D; wp-&gt;config-&gt;request_terminate_timeout;</span><br><span class=\"line\">        int slowlog_timeout &#x3D; wp-&gt;config-&gt;request_slowlog_timeout;</span><br><span class=\"line\">        struct fpm_child_s *child;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (terminate_timeout || slowlog_timeout) &#123; </span><br><span class=\"line\">            for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;检查当前当前worker处理的请求是否超时</span><br><span class=\"line\">                fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：<em>ondemand模式下master监听的新请求到达的事件，因为ondemand模式下fpm启动时是不会预创建worker的，有请求时才会生成子进程，所以请求到达时需要通知master进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()。</em></p>\n<hr>\n<p>参考文档：<br>1、php内核剖析： <a href=\"http://www.php.cn/manual/view/32905.html\">http://www.php.cn/manual/view/32905.html</a><br>2、php7-integernal：<a href=\"https://github.com/pangudashu/php7-internal\">https://github.com/pangudashu/php7-internal</a></p>"},{"title":"PHP7内核-内存管理-GC机制","date":"2020-08-25T03:20:09.000Z","_content":"\n##### 1 简介\n\nC/C++语言中，如果想在`堆`上分配变量，需要手动进行内存的分配与释放，变量的内存管理是见非常繁琐的事，稍有不慎就可能导致不可域值的错误。 PHP实现了自动GC机制，由语言自行管理。PHP中的变量是不需要手动释放的，内核帮我们实现了变量的内存管理，包括内存的分配与回收。\n\n<!--more-->\n\n**自动GC最简单的实现方式**：在函数中定义变量时分配一块内存，用于保存zval及对应的value结构，在函数返回时再将内存释放，若函数执行期间改变来凝固作为参数调用了其他函数或复制给了其他变量，则把变量复制一份，变量之间相互独立，不会出现冲突。\n（<u>问题：深拷贝可能造成内存浪费，比如定义一个变量赋值给另一个变量，后面是只读操作的情况</u>）\n\n\n\n**解决方式（PHP采用此种方式）:** `引用计数`+`写时复制`。\n\n- 当变量赋值、传递时多个变量公用一个value，引用计数用来记录value有多少个变量在使用；\n- 当变量的value发生改变时，进行深拷贝。\n\n注：long、double类型是使用的硬拷贝。\n\n\n\n##### 2 引用计数\n\n引用计数用来记录当前有多少`zval`指向同一个`zend_value`.\n引用计数：<u>指在value中增加一个字段refcount记录指向当前value的数量，变量复制、函数传参时并不直接硬拷贝一份value数据，而是将refcount++，变量销毁时将refcount--，等到refcount减为0时表示已经没有变量引用这个value，将它销毁即可。</u>\n\n**PHP7中将变量的引用计数保存在zend_value中**（与之前版本不同）\n\n之前变量中不同类型的结构体中都有一个相同的成员：gc，该结构用于保存引用计数的,其定义如下：\n\n```c\n// zend_type.h\ntypedef struct _zend_refcounted_h {\n    // 引用计数\n\tuint32_t         refcount;\t\t\t/* reference counter 32-bit */\n\tunion {\n\t\tstruct {\n\t\t\tZEND_ENDIAN_LOHI_3(\n\t\t\t    // 类型\n\t\t\t\tzend_uchar    type,\n\t\t\t\tzend_uchar    flags,    /* used for strings & objects */\n\t\t\t\t// 垃圾回收时用到\n\t\t\t\tuint16_t      gc_info)  /* keeps GC root number (or 0) and color */\n\t\t} v;\n\t\tuint32_t type_info;\n\t} u;\n} zend_refcounted_h;\n```\n\n例1：\n\n```php\n$a = \"time:\" . time();   //$a       ->  zend_string_1(refcount=1)\n$b = $a;                 //$a,$b    ->  zend_string_1(refcount=2)\n$c = $b;                 //$a,$b,$c ->  zend_string_1(refcount=3)\n\nunset($b);               //$b = IS_UNDEF  $a,$c ->  zend_string_1(refcount=2)\n```\n\n例2：\n\n```php\n$a = array();   // $a       -> zend_array(refcount=1)\n$b = $a;        // $a,$b    ->zend_array(refcount=2)\n$c = $b;        // $a,$b,$c -> zend_array(refcount=3)\nunset($b);      // $a,$c    -> zend_array(refcount=2)  $b = IS_UNDEF\n```\n\n\n\n**问: 是所有变量类型会用到引用计数吗?如果不是,那么那些情况不会用到呢?**\n\n不是, 其中不会用到引用计数的情况如下:\n\n- ①、没有具体value结构的类型是不会用到的，比如：整型、浮点型、布尔型、NULL，他们的值直接通过zval保存，赋值时采用<u>深拷贝</u>。\n- ②、interned string：内部字符串，在PHP中写的函数名、类名、变量名、静态字符串等都是这种类型，定义:$a = \"hi~\";后面的字符串内容是唯一不变的，这些字符串等同于C语言中定义在静态变量区的字符串：char *a = \"hi~\";，这些字符串的生命周期为request期间，request完成后会统一销毁释放，自然也就无需在运行期间通过引用计数管理内存。\n  （注：*内部字符串与普通字符串的类型都是IS_STRING，它们并不是通过type进行区分的，而是通过zend_refcount_h.u.v.flag区分，内部字符串的flag值将包含IS_STR_INTERNED*）\n- ③、immutable array：不可变数组，只有在用opcache的时候才会用到这种类型，不清楚具体实现，暂时忽略。\n\n除了以上几种情况, 其余类型将会用到引用计数。\n\n\n\n**问: PHP内核是怎样区分value是否支持引用计数的呢?**\n\n使用`zval.u1`中的类型掩码`type_flag`字段， 这个字段除了标识value是否支持引用计数外还有其它几个标识位，按位分割\n*注：type_flag与zval.value->gc.u.flag不是一个值。*\n\n支持引用计数的value类型是`zval.u1.type_flag & IS_TYPE_REFCOUNTED`。\n\n```c\n// IS_TYPE_REFCOUNTED = 4\n#define IS_TYPE_REFCOUNTED          (1<<2)\n```\n\n下列类型会使用引用计数机制：\n\n```\n|     type       | refcounted |\n+----------------+------------+\n|simple types    |            |\n|string          |      Y     |\n|interned string |            |\n|array           |      Y     |\n|immutable array |            |\n|object          |      Y     |\n|resource        |      Y     |\n|reference       |      Y     |\n```\n\n\n\n##### 3 写时复制\n\n写时复制机制，它只有在必要的时候（即发生写的时候）才会进行深拷贝，可以很好地提升效率。\n\n具体过程：<u>变量使用了引用计数，当出现其中一个变量修改value的情况，这个时候就需要对value进行分离，发生改变的变量恢复至一份数据出来进行修改，同时断开原来value的指向，指向新的value。</u>\n\n例1：\n\n```php\n$a = array(1,2);\n$b = &$a;\n$c = $a;\n\n//发生分离\n$b[] = 3;\n```\n\n![zval_sep](https://note.youdao.com/yws/api/personal/file/F0B25584D691443AB81AB2C8EA60C941?method=download&shareKey=98bf888bb661490664329007cb8b939c&ynotemdtimestamp=1598325595262)\n\n例2：\n\n```php\n$a = array(1,2);\n$b = &$a;\n$c = $a;\n\n//发生分离\n$c[] = 3;\n```\n\n![a、b、c发生写时复制的过程](https://note.youdao.com/yws/api/personal/file/4CDEAFB9332D4EEE9443D527A09934BF?method=download&shareKey=26b4c24edc932c27e427583bc422d2e3&ynotemdtimestamp=1598325595262)\n\n注：不是所有类型都可以copy的，比如<u>对象、资源就无法进行复制，也就是无法进行分离，如果多个变量指向同一个对象，当其中一个变量修改对象时，其修改将反映到所有变量上</u>。事实上**只有string、array两种支持value的分离**，与引用计数相同，也是通过`zval.u1.type_flag`标识value是否可复制的。\n\n```c\n// IS_TYPE_COPYABLE = 16\n#define IS_TYPE_COPYABLE         (1<<4)\n|     type       |  copyable  |\n+----------------+------------+\n|simple types    |            |\n|string          |      Y     |\n|interned string |            |\n|array           |      Y     |\n|immutable array |            |\n|object          |            |\n|resource        |            |\n|reference       |            |\n```\n\n\n\n##### 4 变量回收\n\nPHP变量回收方式：\n\n- 主动销毁：指的就是 unset。\n- 自动销毁：指PHP的自动管理机制（GC机制).\n  - 在return时减掉局部变量的refcount，即使没有显式的return，PHP也会自动给加上这个操作;\n  - 写时复制时也会断开原来value的指向，这时候也会检查断开后旧value的refcount。\n\n\n\n变量回收时机： zval断开value的指向时，若发现refcount=0则会直接释放value。其中发生断开的情况包括：\n\n- 修改变量：修改变量时会断开原有value的指向\n- 函数返回：函数返回时会释放所有的局部变量，也就是把所有局部变量的引用计数减1.\n\n\n\n##### 5 垃圾回收\n\nPHP用过引用计数实现了变量的自动GC机制，还是会有一种情况GC机制无法解决，从而导致变量无法回首导致内存始终得不到释放，造成内存泄露。\n\n造成内存泄漏的情况：<u>循环引用</u>\n\n**问: 什么是循环引用?**\n循环引用就是变量的内部成员引用了变量自身，比如数组中某个元素指向了数组，这样一来数组的引用计数中就有一个来自自身成员，当所有外部引用断开时，数组的refcount仍然大于0而得不到释放，但实际上这种变量不可能再被使用了。\n\n**垃圾收集器收集的时机**：<u>refcount减少时，即每次refcount减少都会试图收集</u>\n\n\n\n示例：\n\n```php\n$a = array(1);\n$a[] = &$a;\nunset($a);\n```\n\nunset($a)前，变量a的类型为引用，该引用的refcount=2，一个来自于$a,一个来自于$a[1];示意图如下： ![unset($a)前的引用关系](https://note.youdao.com/yws/api/personal/file/8C22AE1A04B249948E9ADECA4F6D9865?method=download&shareKey=90e64014943ead9d4294b592037d0484&ynotemdtimestamp=1598325595262)\n\nunset($a)后，减少了一次该引用的refcount，此时已经没有任何外部引用了，但是数组中仍然有一个元素指向该引用，如下图所示： ![unset($a)后的引用关系](https://note.youdao.com/yws/api/personal/file/74E94E6D9F384C0A9E9F44FF5F086CC9?method=download&shareKey=1ef849b379e45a8729679844f572119d&ynotemdtimestamp=1598325595262)\n\n这种因为循环引用而导致无法释放的变量称之为垃圾，PHP引入了另一种机制来对这些垃圾进行回收，即**垃圾回收器**。\n\n- 若一个变量value的refcount减少到0，那么此vlaue可以被释放掉，不属于垃圾。\n- 若一个变量value的refcount减少之后大于0，那么此vlaue还不能被释放，此value<u>可能</u>成为一个垃圾。\n\n\n\n垃圾回收器会将可能成为垃圾的value收集起来，等到达一定数量后开始启动垃圾鉴定程序，将真正的垃圾释放掉。\n\n**当前垃圾只会出现在array、object两种类型中**\n\n- array：数组中的某个成员指向了数组\n- object：对象的成员属性引用对象本身\n\n\n\n**问：垃圾回收器怎样判断当前类型是否可回收？** \n\n垃圾回收器不是通过变量类型进行判断的，而是通过`zval.u1.type_flag`标识进行判断，只有包含`IS_TYPE_COLLECTABLE`标识的变量类型才会被收集。\n\n```c\n// IS_TYPE_COLLECTABLE = 8\n# define IS_TYPE_COLLECTABLE  (1<<3)\n```\n\n###### 5.1 回收算法\n\n垃圾回收器把收集到的可能垃圾保存到一个buffer缓冲区中，当到达一定数量后就会启动垃圾鉴定、回收程序。\n回收算法的原理：<u>既然垃圾是由于成员引用自身导致的，那么就对value的所有成员减一遍引用计数，如果发现value本身refcount变为了0，则表明引用全部来自自身成员。</u>\n\n###### 5.2 具体实现\n\n垃圾回收器主要通过`zend_gc_globals`这个这结构对垃圾进行管理，收集到的可能成为垃圾的vlaue就保存在这个结构的buf中，即`垃圾缓冲区`。\n\n```c\n// zend_gc.h\ntypedef struct _zend_gc_globals {\n    // 是否启用gc（php.ini中zend.enable_gc设置是否开启，默认是开启的）\n\tzend_bool         gc_enabled;\n\t// 是否在垃圾检查过程中\n\tzend_bool         gc_active;\n\t// 缓存区是否已满\n\tzend_bool         gc_full;\n    // 启动时分配的用于保存可能垃圾的缓存区(初始化时，一次性分配了10001个gc_root_buffer,其中第一个被保留)\n\tgc_root_buffer   *buf;\t\t\t\t/* preallocated arrays of buffers   */\n\t// 指向buf中最新加入的一个可能垃圾（root是一个双向链表的头部）\n\tgc_root_buffer    roots;\t\t\t/* list of possible roots of cycles */\n\t// 指向bug中没有使用的buffer（用于管理buf中开始加入后面又删除的结点，是一个单链表）\n\tgc_root_buffer   *unused;\t\t\t/* list of unused buffers           */\n\t// 指向buf中第一个没有使用的buffer\n\tgc_root_buffer   *first_unused;\t\t/* pointer to first unused buffer   */\n\t// 指向buf尾部\n\tgc_root_buffer   *last_unused;\t\t/* pointer to last unused buffer    */\n    // 待释放的垃圾\n\tgc_root_buffer    to_free;\t\t\t/* list to free                     */\n\tgc_root_buffer   *next_to_free;\n    // 统计gc运行次数\n\tuint32_t gc_runs;\n\t// 统计已回收的垃圾数\n\tuint32_t collected;\n\n#if GC_BENCH\n\tuint32_t root_buf_length;\n\tuint32_t root_buf_peak;\n\tuint32_t zval_possible_root;\n\tuint32_t zval_buffered;\n\tuint32_t zval_remove_from_buffer;\n\tuint32_t zval_marked_grey;\n#endif\n\n\tgc_additional_buffer *additional_buffer;\n\n} zend_gc_globals;\n```\n\n- buf用于保存收集到的value，他是一个数组，在垃圾回收器初始化时一次性分配了10001个gc_root_buffer，其中第一个buffer被保留，插入vlaue时直接取出可用结点即可。\n- roots指向buf中最新加入的一个结点，root是一个双向链表的头部，之所以是一个双向链表，是因为bug数组中保存的只是有可能成为垃圾的vlaue吗，其中有些value在加入之后又被删除了，这样bug数组中就会出现一些空隙。\n- first_unused一开始指向bug的第一个位置，有些元素插入roots时如果first_unused还没有到达buf尾部，则返回first_unused给最新的元素，然后执行first_unused++,直到last_unused.\n\n下图为已经加入了2个gc的结构： ![buf缓冲区的可用节点](https://note.youdao.com/yws/api/personal/file/0A2236A0CF6442A0BB985383709DB5B7?method=download&shareKey=6656570e92c3731c6f1ce8572522a2d0&ynotemdtimestamp=1598325595262)\n\n- unused成员，他的含义与first_unused类似，用来管理buf中开始加入后面又删除的结点，是一个单链表结构。也就是说first_unused是一直往后偏移的，直到buf的结尾，buf中间由于value删除而重新空闲的结点则由unused串起来。下次有新的value插入roots时优先使用unused的这些节点，其次才是first_unused的结点。\n\n下图为移除了buf[1]的结构： ![buf[1]移除缓存去后的可用结点](https://note.youdao.com/yws/api/personal/file/B788660EE8EE43DDB952F0DC408264B7?method=download&shareKey=3896ffff3a8a0ab653a5c4fd197426da&ynotemdtimestamp=1598325595262)\n\n- 第一步，初始化 gc_init()初始化垃圾回收器：分配buf数组内存、设置first_unused/unused等\n\n```c\nZEND_API void gc_init(void)\n{\n\tif (GC_G(buf) == NULL && GC_G(gc_enabled)) {\n\t    // 分配buf缓冲区内存，大小为GC_ROOT_BUFFER_MAX_ENTERIES(10001),其中第1个保留不被使用。\n\t\tGC_G(buf) = (gc_root_buffer*) malloc(sizeof(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);\n\t\tGC_G(last_unused) = &GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];\n\t\t// 进行GC_G的初始化，其中：GC_G(first_unused) = GC_G(buf) + 1;从第二个开始，保留第一个。\n\t\tgc_reset();\n\t}\n}\n```\n\n- 第二步，垃圾回收，在Zend执行过程中如果销毁一个变量就会判断是否需要加入垃圾收集器。销毁一个zval会调用i_zval_ptr_dtor()进行处理。\n\n```c\n// file:zend_variables.h\nstatic zend_always_inline void i_zval_ptr_dtor(zval *zval_ptr ZEND_FILE_LINE_DC)\n{\n    // 不使用引用计数的类型不需要进行回收（整型、浮点型、布尔型，null）\n\tif (Z_REFCOUNTED_P(zval_ptr)) {\n\t    // refcount减一\n\t\tif (!Z_DELREF_P(zval_ptr)) {\n\t\t    // refcount减一后变为0，不是垃圾，正常回收\n\t\t\t_zval_dtor_func_for_ptr(Z_COUNTED_P(zval_ptr) ZEND_FILE_LINE_RELAY_CC);\n\t\t} else {\n\t\t    // refcount减一后仍然大于0，表示该变量可能是一个垃圾，被垃圾回收器回收。\n\t\t\tGC_ZVAL_CHECK_POSSIBLE_ROOT(zval_ptr);\n\t\t}\n\t}\n}\n// file:zend_gc.h\n#define GC_ZVAL_CHECK_POSSIBLE_ROOT(z) \\\n\tgc_check_possible_root((z))\n\nstatic zend_always_inline void gc_check_possible_root(zval *z)\n{\n\tZVAL_DEREF(z);\n\t// 判断是否是可收集（检查变量类型掩码zval.u1.type_flag是否包含IS_TYPE_COLLECTABLE,即数组、对象）以及是否已经收集过了（通过zend_refcount_h.v.u.gc_info来判断，第一次收集后会把这个值设置为GC_PURPLE来避免重复收集）\n\tif (Z_COLLECTABLE_P(z) && UNEXPECTED(!Z_GC_INFO_P(z))) {\n\t\tgc_possible_root(Z_COUNTED_P(z));\n\t}\n}\n```\n\n收集时首先会从buf中选择一个空闲节点，然后将vlaue的gc保存到这个结点中，若没有空闲节点则表明回收器已经满了，这个时候就会触发垃圾鉴定、回收程序。\n\n```c\n// file:zend_gc.c\nZEND_API void ZEND_FASTCALL gc_possible_root(zend_refcounted *ref)\n{\n\tgc_root_buffer *newRoot;\n\n\tif (UNEXPECTED(CG(unclean_shutdown)) || UNEXPECTED(GC_G(gc_active))) {\n\t\treturn;\n\t}\n\n\tZEND_ASSERT(GC_TYPE(ref) == IS_ARRAY || GC_TYPE(ref) == IS_OBJECT);\n\t// 插入的结点必须是GC_BLACK,防止重复插入\n\tZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(ref) == GC_BLACK));\n\tZEND_ASSERT(!GC_ADDRESS(GC_INFO(ref)));\n\n\tGC_BENCH_INC(zval_possible_root);\n\n    // 首先看一下unused中又没有可用的。\n\tnewRoot = GC_G(unused);\n\tif (newRoot) {\n\t    // 有的话先用unused的，然后将GC_G(unused)指向单链表的下一个\n\t\tGC_G(unused) = newRoot->prev;\n\t} else if (GC_G(first_unused) != GC_G(last_unused)) {\n\t    // unused没有可用的，且bug中还有可用\n\t\tnewRoot = GC_G(first_unused);\n\t\tGC_G(first_unused)++;\n\t} else {\n\t    // buf缓存区已满，这时需要启动垃圾鉴定、回收程序。\n\t\t...\n\t}\n    // 将插入的red标位紫色，防止重复插入\n\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);\n\t// 将该节点在buf中的位置保存到gc_info中，目的在于当后续value的refcount变为了0，需要将其从buf中删除时可以知道该value保存在那个gc_root_buffer中，如果没有这个信息，在删除vlaue时无法获取gc_root_buffer的位置。\n\tGC_INFO(ref) = (newRoot - GC_G(buf)) | GC_PURPLE;\n\tnewRoot->ref = ref;\n    // 插入roots链表头部\n\tnewRoot->next = GC_G(roots).next;\n\tnewRoot->prev = &GC_G(roots);\n\tGC_G(roots).next->prev = newRoot;\n\tGC_G(roots).next = newRoot;\n\n\tGC_BENCH_INC(zval_buffered);\n\tGC_BENCH_INC(root_buf_length);\n\tGC_BENCH_PEAK(root_buf_peak, root_buf_length);\n}\n```\n\n- 第三步，删除 删除的操作通过GC_REMOVE_FROM_BUFFER()完成。\n\n```c\n// file:zend_gc.h\n#define GC_REMOVE_FROM_BUFFER(p) do { \\\n\t\tzend_refcounted *_p = (zend_refcounted*)(p); \\\n\t\tif (GC_ADDRESS(GC_INFO(_p))) { \\\n\t\t\tgc_remove_from_buffer(_p); \\\n\t\t} \\\n\t} while (0)\n\t\n#define GC_ADDRESS(v) \\\n\t((v) & ~GC_COLOR)\n```\n\n删除时，先根据gc_info取到gc_root_buffer，然后再从buf中移除，删除后再把空的gc_root_buffer插入到unused单链表尾部。\n\n```c\n// file:zend_gc.c\nZEND_API void ZEND_FASTCALL gc_remove_from_buffer(zend_refcounted *ref)\n{\n\tgc_root_buffer *root;\n\n\tZEND_ASSERT(GC_ADDRESS(GC_INFO(ref)));\n\n\tGC_BENCH_INC(zval_remove_from_buffer);\n\n\tif (EXPECTED(GC_ADDRESS(GC_INFO(ref)) < GC_ROOT_BUFFER_MAX_ENTRIES)) {\n\t\troot = GC_G(buf) + GC_ADDRESS(GC_INFO(ref));\n\t\tgc_remove_from_roots(root);\n\t} else {\n\t\troot = gc_find_additional_buffer(ref);\n\t\tgc_remove_from_additional_roots(root);\n\t}\n\tif (GC_REF_GET_COLOR(ref) != GC_BLACK) {\n\t\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);\n\t}\n\tGC_INFO(ref) = 0;\n\n\t/* updete next root that is going to be freed */\n\tif (GC_G(next_to_free) == root) {\n\t\tGC_G(next_to_free) = root->next;\n\t}\n}\n```\n\n当buf缓存区满了执行垃圾回收的过程如下：\n\n```c\nZEND_API int zend_gc_collect_cycles(void)\n{\n\t    ...\n\t    // (1)遍历roots链表，对当前结点vlaue的所有成员（如数组元素、成员变量）进行深度优先遍历，把成员refcount减1.\n\t\tgc_mark_roots();\n\t\tGC_TRACE(\"Scanning roots\");\n\t\t// (2)再次遍历roots链表，检查各结点当前refcount是否为0，是的话标为white，表示是垃圾，不是的话需要还原（1），吧refcount再加回去\n\t\tgc_scan_roots();\n\n#if ZEND_GC_DEBUG\n\t\torig_gc_full = GC_G(gc_full);\n\t\tGC_G(gc_full) = 0;\n#endif\n\n\t\tGC_TRACE(\"Collecting roots\");\n\t\tadditional_buffer_snapshot = GC_G(additional_buffer);\n\t\t// 将roots链表中的非白色结点删除，之后roots链表中全部是真正的垃圾，将垃圾链表转到to_free等待释放\n\t  \n\t  ...\n\t  \n\t\t\n\t\t// 释放垃圾\n\t\tcurrent = to_free.next;\n\t\twhile (current != &to_free) {\n\t\t\tnext = current->next;\n\t\t\tp = current->ref;\n\t\t\tif (EXPECTED(current >= GC_G(buf) && current < GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) {\n\t\t\t\tcurrent->prev = GC_G(unused);\n\t\t\t\tGC_G(unused) = current;\n\t\t\t}\n\t\t\tefree(p);\n\t\t\tcurrent = next;\n\t\t}\n\n\t...\n}\n```","source":"_posts/PHP7内核-内存管理-GC机制.md","raw":"---\ntitle: PHP7内核-内存管理-GC机制\ndate: 2020-08-25 11:20:09\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n##### 1 简介\n\nC/C++语言中，如果想在`堆`上分配变量，需要手动进行内存的分配与释放，变量的内存管理是见非常繁琐的事，稍有不慎就可能导致不可域值的错误。 PHP实现了自动GC机制，由语言自行管理。PHP中的变量是不需要手动释放的，内核帮我们实现了变量的内存管理，包括内存的分配与回收。\n\n<!--more-->\n\n**自动GC最简单的实现方式**：在函数中定义变量时分配一块内存，用于保存zval及对应的value结构，在函数返回时再将内存释放，若函数执行期间改变来凝固作为参数调用了其他函数或复制给了其他变量，则把变量复制一份，变量之间相互独立，不会出现冲突。\n（<u>问题：深拷贝可能造成内存浪费，比如定义一个变量赋值给另一个变量，后面是只读操作的情况</u>）\n\n\n\n**解决方式（PHP采用此种方式）:** `引用计数`+`写时复制`。\n\n- 当变量赋值、传递时多个变量公用一个value，引用计数用来记录value有多少个变量在使用；\n- 当变量的value发生改变时，进行深拷贝。\n\n注：long、double类型是使用的硬拷贝。\n\n\n\n##### 2 引用计数\n\n引用计数用来记录当前有多少`zval`指向同一个`zend_value`.\n引用计数：<u>指在value中增加一个字段refcount记录指向当前value的数量，变量复制、函数传参时并不直接硬拷贝一份value数据，而是将refcount++，变量销毁时将refcount--，等到refcount减为0时表示已经没有变量引用这个value，将它销毁即可。</u>\n\n**PHP7中将变量的引用计数保存在zend_value中**（与之前版本不同）\n\n之前变量中不同类型的结构体中都有一个相同的成员：gc，该结构用于保存引用计数的,其定义如下：\n\n```c\n// zend_type.h\ntypedef struct _zend_refcounted_h {\n    // 引用计数\n\tuint32_t         refcount;\t\t\t/* reference counter 32-bit */\n\tunion {\n\t\tstruct {\n\t\t\tZEND_ENDIAN_LOHI_3(\n\t\t\t    // 类型\n\t\t\t\tzend_uchar    type,\n\t\t\t\tzend_uchar    flags,    /* used for strings & objects */\n\t\t\t\t// 垃圾回收时用到\n\t\t\t\tuint16_t      gc_info)  /* keeps GC root number (or 0) and color */\n\t\t} v;\n\t\tuint32_t type_info;\n\t} u;\n} zend_refcounted_h;\n```\n\n例1：\n\n```php\n$a = \"time:\" . time();   //$a       ->  zend_string_1(refcount=1)\n$b = $a;                 //$a,$b    ->  zend_string_1(refcount=2)\n$c = $b;                 //$a,$b,$c ->  zend_string_1(refcount=3)\n\nunset($b);               //$b = IS_UNDEF  $a,$c ->  zend_string_1(refcount=2)\n```\n\n例2：\n\n```php\n$a = array();   // $a       -> zend_array(refcount=1)\n$b = $a;        // $a,$b    ->zend_array(refcount=2)\n$c = $b;        // $a,$b,$c -> zend_array(refcount=3)\nunset($b);      // $a,$c    -> zend_array(refcount=2)  $b = IS_UNDEF\n```\n\n\n\n**问: 是所有变量类型会用到引用计数吗?如果不是,那么那些情况不会用到呢?**\n\n不是, 其中不会用到引用计数的情况如下:\n\n- ①、没有具体value结构的类型是不会用到的，比如：整型、浮点型、布尔型、NULL，他们的值直接通过zval保存，赋值时采用<u>深拷贝</u>。\n- ②、interned string：内部字符串，在PHP中写的函数名、类名、变量名、静态字符串等都是这种类型，定义:$a = \"hi~\";后面的字符串内容是唯一不变的，这些字符串等同于C语言中定义在静态变量区的字符串：char *a = \"hi~\";，这些字符串的生命周期为request期间，request完成后会统一销毁释放，自然也就无需在运行期间通过引用计数管理内存。\n  （注：*内部字符串与普通字符串的类型都是IS_STRING，它们并不是通过type进行区分的，而是通过zend_refcount_h.u.v.flag区分，内部字符串的flag值将包含IS_STR_INTERNED*）\n- ③、immutable array：不可变数组，只有在用opcache的时候才会用到这种类型，不清楚具体实现，暂时忽略。\n\n除了以上几种情况, 其余类型将会用到引用计数。\n\n\n\n**问: PHP内核是怎样区分value是否支持引用计数的呢?**\n\n使用`zval.u1`中的类型掩码`type_flag`字段， 这个字段除了标识value是否支持引用计数外还有其它几个标识位，按位分割\n*注：type_flag与zval.value->gc.u.flag不是一个值。*\n\n支持引用计数的value类型是`zval.u1.type_flag & IS_TYPE_REFCOUNTED`。\n\n```c\n// IS_TYPE_REFCOUNTED = 4\n#define IS_TYPE_REFCOUNTED          (1<<2)\n```\n\n下列类型会使用引用计数机制：\n\n```\n|     type       | refcounted |\n+----------------+------------+\n|simple types    |            |\n|string          |      Y     |\n|interned string |            |\n|array           |      Y     |\n|immutable array |            |\n|object          |      Y     |\n|resource        |      Y     |\n|reference       |      Y     |\n```\n\n\n\n##### 3 写时复制\n\n写时复制机制，它只有在必要的时候（即发生写的时候）才会进行深拷贝，可以很好地提升效率。\n\n具体过程：<u>变量使用了引用计数，当出现其中一个变量修改value的情况，这个时候就需要对value进行分离，发生改变的变量恢复至一份数据出来进行修改，同时断开原来value的指向，指向新的value。</u>\n\n例1：\n\n```php\n$a = array(1,2);\n$b = &$a;\n$c = $a;\n\n//发生分离\n$b[] = 3;\n```\n\n![zval_sep](https://note.youdao.com/yws/api/personal/file/F0B25584D691443AB81AB2C8EA60C941?method=download&shareKey=98bf888bb661490664329007cb8b939c&ynotemdtimestamp=1598325595262)\n\n例2：\n\n```php\n$a = array(1,2);\n$b = &$a;\n$c = $a;\n\n//发生分离\n$c[] = 3;\n```\n\n![a、b、c发生写时复制的过程](https://note.youdao.com/yws/api/personal/file/4CDEAFB9332D4EEE9443D527A09934BF?method=download&shareKey=26b4c24edc932c27e427583bc422d2e3&ynotemdtimestamp=1598325595262)\n\n注：不是所有类型都可以copy的，比如<u>对象、资源就无法进行复制，也就是无法进行分离，如果多个变量指向同一个对象，当其中一个变量修改对象时，其修改将反映到所有变量上</u>。事实上**只有string、array两种支持value的分离**，与引用计数相同，也是通过`zval.u1.type_flag`标识value是否可复制的。\n\n```c\n// IS_TYPE_COPYABLE = 16\n#define IS_TYPE_COPYABLE         (1<<4)\n|     type       |  copyable  |\n+----------------+------------+\n|simple types    |            |\n|string          |      Y     |\n|interned string |            |\n|array           |      Y     |\n|immutable array |            |\n|object          |            |\n|resource        |            |\n|reference       |            |\n```\n\n\n\n##### 4 变量回收\n\nPHP变量回收方式：\n\n- 主动销毁：指的就是 unset。\n- 自动销毁：指PHP的自动管理机制（GC机制).\n  - 在return时减掉局部变量的refcount，即使没有显式的return，PHP也会自动给加上这个操作;\n  - 写时复制时也会断开原来value的指向，这时候也会检查断开后旧value的refcount。\n\n\n\n变量回收时机： zval断开value的指向时，若发现refcount=0则会直接释放value。其中发生断开的情况包括：\n\n- 修改变量：修改变量时会断开原有value的指向\n- 函数返回：函数返回时会释放所有的局部变量，也就是把所有局部变量的引用计数减1.\n\n\n\n##### 5 垃圾回收\n\nPHP用过引用计数实现了变量的自动GC机制，还是会有一种情况GC机制无法解决，从而导致变量无法回首导致内存始终得不到释放，造成内存泄露。\n\n造成内存泄漏的情况：<u>循环引用</u>\n\n**问: 什么是循环引用?**\n循环引用就是变量的内部成员引用了变量自身，比如数组中某个元素指向了数组，这样一来数组的引用计数中就有一个来自自身成员，当所有外部引用断开时，数组的refcount仍然大于0而得不到释放，但实际上这种变量不可能再被使用了。\n\n**垃圾收集器收集的时机**：<u>refcount减少时，即每次refcount减少都会试图收集</u>\n\n\n\n示例：\n\n```php\n$a = array(1);\n$a[] = &$a;\nunset($a);\n```\n\nunset($a)前，变量a的类型为引用，该引用的refcount=2，一个来自于$a,一个来自于$a[1];示意图如下： ![unset($a)前的引用关系](https://note.youdao.com/yws/api/personal/file/8C22AE1A04B249948E9ADECA4F6D9865?method=download&shareKey=90e64014943ead9d4294b592037d0484&ynotemdtimestamp=1598325595262)\n\nunset($a)后，减少了一次该引用的refcount，此时已经没有任何外部引用了，但是数组中仍然有一个元素指向该引用，如下图所示： ![unset($a)后的引用关系](https://note.youdao.com/yws/api/personal/file/74E94E6D9F384C0A9E9F44FF5F086CC9?method=download&shareKey=1ef849b379e45a8729679844f572119d&ynotemdtimestamp=1598325595262)\n\n这种因为循环引用而导致无法释放的变量称之为垃圾，PHP引入了另一种机制来对这些垃圾进行回收，即**垃圾回收器**。\n\n- 若一个变量value的refcount减少到0，那么此vlaue可以被释放掉，不属于垃圾。\n- 若一个变量value的refcount减少之后大于0，那么此vlaue还不能被释放，此value<u>可能</u>成为一个垃圾。\n\n\n\n垃圾回收器会将可能成为垃圾的value收集起来，等到达一定数量后开始启动垃圾鉴定程序，将真正的垃圾释放掉。\n\n**当前垃圾只会出现在array、object两种类型中**\n\n- array：数组中的某个成员指向了数组\n- object：对象的成员属性引用对象本身\n\n\n\n**问：垃圾回收器怎样判断当前类型是否可回收？** \n\n垃圾回收器不是通过变量类型进行判断的，而是通过`zval.u1.type_flag`标识进行判断，只有包含`IS_TYPE_COLLECTABLE`标识的变量类型才会被收集。\n\n```c\n// IS_TYPE_COLLECTABLE = 8\n# define IS_TYPE_COLLECTABLE  (1<<3)\n```\n\n###### 5.1 回收算法\n\n垃圾回收器把收集到的可能垃圾保存到一个buffer缓冲区中，当到达一定数量后就会启动垃圾鉴定、回收程序。\n回收算法的原理：<u>既然垃圾是由于成员引用自身导致的，那么就对value的所有成员减一遍引用计数，如果发现value本身refcount变为了0，则表明引用全部来自自身成员。</u>\n\n###### 5.2 具体实现\n\n垃圾回收器主要通过`zend_gc_globals`这个这结构对垃圾进行管理，收集到的可能成为垃圾的vlaue就保存在这个结构的buf中，即`垃圾缓冲区`。\n\n```c\n// zend_gc.h\ntypedef struct _zend_gc_globals {\n    // 是否启用gc（php.ini中zend.enable_gc设置是否开启，默认是开启的）\n\tzend_bool         gc_enabled;\n\t// 是否在垃圾检查过程中\n\tzend_bool         gc_active;\n\t// 缓存区是否已满\n\tzend_bool         gc_full;\n    // 启动时分配的用于保存可能垃圾的缓存区(初始化时，一次性分配了10001个gc_root_buffer,其中第一个被保留)\n\tgc_root_buffer   *buf;\t\t\t\t/* preallocated arrays of buffers   */\n\t// 指向buf中最新加入的一个可能垃圾（root是一个双向链表的头部）\n\tgc_root_buffer    roots;\t\t\t/* list of possible roots of cycles */\n\t// 指向bug中没有使用的buffer（用于管理buf中开始加入后面又删除的结点，是一个单链表）\n\tgc_root_buffer   *unused;\t\t\t/* list of unused buffers           */\n\t// 指向buf中第一个没有使用的buffer\n\tgc_root_buffer   *first_unused;\t\t/* pointer to first unused buffer   */\n\t// 指向buf尾部\n\tgc_root_buffer   *last_unused;\t\t/* pointer to last unused buffer    */\n    // 待释放的垃圾\n\tgc_root_buffer    to_free;\t\t\t/* list to free                     */\n\tgc_root_buffer   *next_to_free;\n    // 统计gc运行次数\n\tuint32_t gc_runs;\n\t// 统计已回收的垃圾数\n\tuint32_t collected;\n\n#if GC_BENCH\n\tuint32_t root_buf_length;\n\tuint32_t root_buf_peak;\n\tuint32_t zval_possible_root;\n\tuint32_t zval_buffered;\n\tuint32_t zval_remove_from_buffer;\n\tuint32_t zval_marked_grey;\n#endif\n\n\tgc_additional_buffer *additional_buffer;\n\n} zend_gc_globals;\n```\n\n- buf用于保存收集到的value，他是一个数组，在垃圾回收器初始化时一次性分配了10001个gc_root_buffer，其中第一个buffer被保留，插入vlaue时直接取出可用结点即可。\n- roots指向buf中最新加入的一个结点，root是一个双向链表的头部，之所以是一个双向链表，是因为bug数组中保存的只是有可能成为垃圾的vlaue吗，其中有些value在加入之后又被删除了，这样bug数组中就会出现一些空隙。\n- first_unused一开始指向bug的第一个位置，有些元素插入roots时如果first_unused还没有到达buf尾部，则返回first_unused给最新的元素，然后执行first_unused++,直到last_unused.\n\n下图为已经加入了2个gc的结构： ![buf缓冲区的可用节点](https://note.youdao.com/yws/api/personal/file/0A2236A0CF6442A0BB985383709DB5B7?method=download&shareKey=6656570e92c3731c6f1ce8572522a2d0&ynotemdtimestamp=1598325595262)\n\n- unused成员，他的含义与first_unused类似，用来管理buf中开始加入后面又删除的结点，是一个单链表结构。也就是说first_unused是一直往后偏移的，直到buf的结尾，buf中间由于value删除而重新空闲的结点则由unused串起来。下次有新的value插入roots时优先使用unused的这些节点，其次才是first_unused的结点。\n\n下图为移除了buf[1]的结构： ![buf[1]移除缓存去后的可用结点](https://note.youdao.com/yws/api/personal/file/B788660EE8EE43DDB952F0DC408264B7?method=download&shareKey=3896ffff3a8a0ab653a5c4fd197426da&ynotemdtimestamp=1598325595262)\n\n- 第一步，初始化 gc_init()初始化垃圾回收器：分配buf数组内存、设置first_unused/unused等\n\n```c\nZEND_API void gc_init(void)\n{\n\tif (GC_G(buf) == NULL && GC_G(gc_enabled)) {\n\t    // 分配buf缓冲区内存，大小为GC_ROOT_BUFFER_MAX_ENTERIES(10001),其中第1个保留不被使用。\n\t\tGC_G(buf) = (gc_root_buffer*) malloc(sizeof(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);\n\t\tGC_G(last_unused) = &GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];\n\t\t// 进行GC_G的初始化，其中：GC_G(first_unused) = GC_G(buf) + 1;从第二个开始，保留第一个。\n\t\tgc_reset();\n\t}\n}\n```\n\n- 第二步，垃圾回收，在Zend执行过程中如果销毁一个变量就会判断是否需要加入垃圾收集器。销毁一个zval会调用i_zval_ptr_dtor()进行处理。\n\n```c\n// file:zend_variables.h\nstatic zend_always_inline void i_zval_ptr_dtor(zval *zval_ptr ZEND_FILE_LINE_DC)\n{\n    // 不使用引用计数的类型不需要进行回收（整型、浮点型、布尔型，null）\n\tif (Z_REFCOUNTED_P(zval_ptr)) {\n\t    // refcount减一\n\t\tif (!Z_DELREF_P(zval_ptr)) {\n\t\t    // refcount减一后变为0，不是垃圾，正常回收\n\t\t\t_zval_dtor_func_for_ptr(Z_COUNTED_P(zval_ptr) ZEND_FILE_LINE_RELAY_CC);\n\t\t} else {\n\t\t    // refcount减一后仍然大于0，表示该变量可能是一个垃圾，被垃圾回收器回收。\n\t\t\tGC_ZVAL_CHECK_POSSIBLE_ROOT(zval_ptr);\n\t\t}\n\t}\n}\n// file:zend_gc.h\n#define GC_ZVAL_CHECK_POSSIBLE_ROOT(z) \\\n\tgc_check_possible_root((z))\n\nstatic zend_always_inline void gc_check_possible_root(zval *z)\n{\n\tZVAL_DEREF(z);\n\t// 判断是否是可收集（检查变量类型掩码zval.u1.type_flag是否包含IS_TYPE_COLLECTABLE,即数组、对象）以及是否已经收集过了（通过zend_refcount_h.v.u.gc_info来判断，第一次收集后会把这个值设置为GC_PURPLE来避免重复收集）\n\tif (Z_COLLECTABLE_P(z) && UNEXPECTED(!Z_GC_INFO_P(z))) {\n\t\tgc_possible_root(Z_COUNTED_P(z));\n\t}\n}\n```\n\n收集时首先会从buf中选择一个空闲节点，然后将vlaue的gc保存到这个结点中，若没有空闲节点则表明回收器已经满了，这个时候就会触发垃圾鉴定、回收程序。\n\n```c\n// file:zend_gc.c\nZEND_API void ZEND_FASTCALL gc_possible_root(zend_refcounted *ref)\n{\n\tgc_root_buffer *newRoot;\n\n\tif (UNEXPECTED(CG(unclean_shutdown)) || UNEXPECTED(GC_G(gc_active))) {\n\t\treturn;\n\t}\n\n\tZEND_ASSERT(GC_TYPE(ref) == IS_ARRAY || GC_TYPE(ref) == IS_OBJECT);\n\t// 插入的结点必须是GC_BLACK,防止重复插入\n\tZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(ref) == GC_BLACK));\n\tZEND_ASSERT(!GC_ADDRESS(GC_INFO(ref)));\n\n\tGC_BENCH_INC(zval_possible_root);\n\n    // 首先看一下unused中又没有可用的。\n\tnewRoot = GC_G(unused);\n\tif (newRoot) {\n\t    // 有的话先用unused的，然后将GC_G(unused)指向单链表的下一个\n\t\tGC_G(unused) = newRoot->prev;\n\t} else if (GC_G(first_unused) != GC_G(last_unused)) {\n\t    // unused没有可用的，且bug中还有可用\n\t\tnewRoot = GC_G(first_unused);\n\t\tGC_G(first_unused)++;\n\t} else {\n\t    // buf缓存区已满，这时需要启动垃圾鉴定、回收程序。\n\t\t...\n\t}\n    // 将插入的red标位紫色，防止重复插入\n\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);\n\t// 将该节点在buf中的位置保存到gc_info中，目的在于当后续value的refcount变为了0，需要将其从buf中删除时可以知道该value保存在那个gc_root_buffer中，如果没有这个信息，在删除vlaue时无法获取gc_root_buffer的位置。\n\tGC_INFO(ref) = (newRoot - GC_G(buf)) | GC_PURPLE;\n\tnewRoot->ref = ref;\n    // 插入roots链表头部\n\tnewRoot->next = GC_G(roots).next;\n\tnewRoot->prev = &GC_G(roots);\n\tGC_G(roots).next->prev = newRoot;\n\tGC_G(roots).next = newRoot;\n\n\tGC_BENCH_INC(zval_buffered);\n\tGC_BENCH_INC(root_buf_length);\n\tGC_BENCH_PEAK(root_buf_peak, root_buf_length);\n}\n```\n\n- 第三步，删除 删除的操作通过GC_REMOVE_FROM_BUFFER()完成。\n\n```c\n// file:zend_gc.h\n#define GC_REMOVE_FROM_BUFFER(p) do { \\\n\t\tzend_refcounted *_p = (zend_refcounted*)(p); \\\n\t\tif (GC_ADDRESS(GC_INFO(_p))) { \\\n\t\t\tgc_remove_from_buffer(_p); \\\n\t\t} \\\n\t} while (0)\n\t\n#define GC_ADDRESS(v) \\\n\t((v) & ~GC_COLOR)\n```\n\n删除时，先根据gc_info取到gc_root_buffer，然后再从buf中移除，删除后再把空的gc_root_buffer插入到unused单链表尾部。\n\n```c\n// file:zend_gc.c\nZEND_API void ZEND_FASTCALL gc_remove_from_buffer(zend_refcounted *ref)\n{\n\tgc_root_buffer *root;\n\n\tZEND_ASSERT(GC_ADDRESS(GC_INFO(ref)));\n\n\tGC_BENCH_INC(zval_remove_from_buffer);\n\n\tif (EXPECTED(GC_ADDRESS(GC_INFO(ref)) < GC_ROOT_BUFFER_MAX_ENTRIES)) {\n\t\troot = GC_G(buf) + GC_ADDRESS(GC_INFO(ref));\n\t\tgc_remove_from_roots(root);\n\t} else {\n\t\troot = gc_find_additional_buffer(ref);\n\t\tgc_remove_from_additional_roots(root);\n\t}\n\tif (GC_REF_GET_COLOR(ref) != GC_BLACK) {\n\t\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);\n\t}\n\tGC_INFO(ref) = 0;\n\n\t/* updete next root that is going to be freed */\n\tif (GC_G(next_to_free) == root) {\n\t\tGC_G(next_to_free) = root->next;\n\t}\n}\n```\n\n当buf缓存区满了执行垃圾回收的过程如下：\n\n```c\nZEND_API int zend_gc_collect_cycles(void)\n{\n\t    ...\n\t    // (1)遍历roots链表，对当前结点vlaue的所有成员（如数组元素、成员变量）进行深度优先遍历，把成员refcount减1.\n\t\tgc_mark_roots();\n\t\tGC_TRACE(\"Scanning roots\");\n\t\t// (2)再次遍历roots链表，检查各结点当前refcount是否为0，是的话标为white，表示是垃圾，不是的话需要还原（1），吧refcount再加回去\n\t\tgc_scan_roots();\n\n#if ZEND_GC_DEBUG\n\t\torig_gc_full = GC_G(gc_full);\n\t\tGC_G(gc_full) = 0;\n#endif\n\n\t\tGC_TRACE(\"Collecting roots\");\n\t\tadditional_buffer_snapshot = GC_G(additional_buffer);\n\t\t// 将roots链表中的非白色结点删除，之后roots链表中全部是真正的垃圾，将垃圾链表转到to_free等待释放\n\t  \n\t  ...\n\t  \n\t\t\n\t\t// 释放垃圾\n\t\tcurrent = to_free.next;\n\t\twhile (current != &to_free) {\n\t\t\tnext = current->next;\n\t\t\tp = current->ref;\n\t\t\tif (EXPECTED(current >= GC_G(buf) && current < GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) {\n\t\t\t\tcurrent->prev = GC_G(unused);\n\t\t\t\tGC_G(unused) = current;\n\t\t\t}\n\t\t\tefree(p);\n\t\t\tcurrent = next;\n\t\t}\n\n\t...\n}\n```","slug":"PHP7内核-内存管理-GC机制","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7ftf001g0sg3boif2j7u","content":"<h5 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h5><p>C/C++语言中，如果想在<code>堆</code>上分配变量，需要手动进行内存的分配与释放，变量的内存管理是见非常繁琐的事，稍有不慎就可能导致不可域值的错误。 PHP实现了自动GC机制，由语言自行管理。PHP中的变量是不需要手动释放的，内核帮我们实现了变量的内存管理，包括内存的分配与回收。</p>\n<a id=\"more\"></a>\n\n<p><strong>自动GC最简单的实现方式</strong>：在函数中定义变量时分配一块内存，用于保存zval及对应的value结构，在函数返回时再将内存释放，若函数执行期间改变来凝固作为参数调用了其他函数或复制给了其他变量，则把变量复制一份，变量之间相互独立，不会出现冲突。<br>（<u>问题：深拷贝可能造成内存浪费，比如定义一个变量赋值给另一个变量，后面是只读操作的情况</u>）</p>\n<p><strong>解决方式（PHP采用此种方式）:</strong> <code>引用计数</code>+<code>写时复制</code>。</p>\n<ul>\n<li>当变量赋值、传递时多个变量公用一个value，引用计数用来记录value有多少个变量在使用；</li>\n<li>当变量的value发生改变时，进行深拷贝。</li>\n</ul>\n<p>注：long、double类型是使用的硬拷贝。</p>\n<h5 id=\"2-引用计数\"><a href=\"#2-引用计数\" class=\"headerlink\" title=\"2 引用计数\"></a>2 引用计数</h5><p>引用计数用来记录当前有多少<code>zval</code>指向同一个<code>zend_value</code>.<br>引用计数：<u>指在value中增加一个字段refcount记录指向当前value的数量，变量复制、函数传参时并不直接硬拷贝一份value数据，而是将refcount++，变量销毁时将refcount–，等到refcount减为0时表示已经没有变量引用这个value，将它销毁即可。</u></p>\n<p><strong>PHP7中将变量的引用计数保存在zend_value中</strong>（与之前版本不同）</p>\n<p>之前变量中不同类型的结构体中都有一个相同的成员：gc，该结构用于保存引用计数的,其定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_type.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_refcounted_h</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span>         refcount;\t\t\t<span class=\"comment\">/* reference counter 32-bit */</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\tZEND_ENDIAN_LOHI_3(</span><br><span class=\"line\">\t\t\t    <span class=\"comment\">// 类型</span></span><br><span class=\"line\">\t\t\t\tzend_uchar    type,</span><br><span class=\"line\">\t\t\t\tzend_uchar    flags,    <span class=\"comment\">/* used for strings &amp; objects */</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 垃圾回收时用到</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">uint16_t</span>      gc_info)  <span class=\"comment\">/* keeps GC root number (or 0) and color */</span></span><br><span class=\"line\">\t\t&#125; v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> type_info;</span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">&#125; zend_refcounted_h;</span><br></pre></td></tr></table></figure>\n\n<p>例1：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"string\">&quot;time:&quot;</span> . time();   <span class=\"comment\">//$a       -&gt;  zend_string_1(refcount=1)</span></span><br><span class=\"line\">$b = $a;                 <span class=\"comment\">//$a,$b    -&gt;  zend_string_1(refcount=2)</span></span><br><span class=\"line\">$c = $b;                 <span class=\"comment\">//$a,$b,$c -&gt;  zend_string_1(refcount=3)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unset</span>($b);               <span class=\"comment\">//$b = IS_UNDEF  $a,$c -&gt;  zend_string_1(refcount=2)</span></span><br></pre></td></tr></table></figure>\n\n<p>例2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>();   <span class=\"comment\">// $a       -&gt; zend_array(refcount=1)</span></span><br><span class=\"line\">$b = $a;        <span class=\"comment\">// $a,$b    -&gt;zend_array(refcount=2)</span></span><br><span class=\"line\">$c = $b;        <span class=\"comment\">// $a,$b,$c -&gt; zend_array(refcount=3)</span></span><br><span class=\"line\"><span class=\"keyword\">unset</span>($b);      <span class=\"comment\">// $a,$c    -&gt; zend_array(refcount=2)  $b = IS_UNDEF</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>问: 是所有变量类型会用到引用计数吗?如果不是,那么那些情况不会用到呢?</strong></p>\n<p>不是, 其中不会用到引用计数的情况如下:</p>\n<ul>\n<li>①、没有具体value结构的类型是不会用到的，比如：整型、浮点型、布尔型、NULL，他们的值直接通过zval保存，赋值时采用<u>深拷贝</u>。</li>\n<li>②、interned string：内部字符串，在PHP中写的函数名、类名、变量名、静态字符串等都是这种类型，定义:$a = “hi<del>“;后面的字符串内容是唯一不变的，这些字符串等同于C语言中定义在静态变量区的字符串：char *a = “hi</del>“;，这些字符串的生命周期为request期间，request完成后会统一销毁释放，自然也就无需在运行期间通过引用计数管理内存。<br>（注：<em>内部字符串与普通字符串的类型都是IS_STRING，它们并不是通过type进行区分的，而是通过zend_refcount_h.u.v.flag区分，内部字符串的flag值将包含IS_STR_INTERNED</em>）</li>\n<li>③、immutable array：不可变数组，只有在用opcache的时候才会用到这种类型，不清楚具体实现，暂时忽略。</li>\n</ul>\n<p>除了以上几种情况, 其余类型将会用到引用计数。</p>\n<p><strong>问: PHP内核是怎样区分value是否支持引用计数的呢?</strong></p>\n<p>使用<code>zval.u1</code>中的类型掩码<code>type_flag</code>字段， 这个字段除了标识value是否支持引用计数外还有其它几个标识位，按位分割<br><em>注：type_flag与zval.value-&gt;gc.u.flag不是一个值。</em></p>\n<p>支持引用计数的value类型是<code>zval.u1.type_flag &amp; IS_TYPE_REFCOUNTED</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_REFCOUNTED = 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TYPE_REFCOUNTED          (1&lt;&lt;2)</span></span><br></pre></td></tr></table></figure>\n\n<p>下列类型会使用引用计数机制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|     type       | refcounted |</span><br><span class=\"line\">+----------------+------------+</span><br><span class=\"line\">|simple types    |            |</span><br><span class=\"line\">|string          |      Y     |</span><br><span class=\"line\">|interned string |            |</span><br><span class=\"line\">|array           |      Y     |</span><br><span class=\"line\">|immutable array |            |</span><br><span class=\"line\">|object          |      Y     |</span><br><span class=\"line\">|resource        |      Y     |</span><br><span class=\"line\">|reference       |      Y     |</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3-写时复制\"><a href=\"#3-写时复制\" class=\"headerlink\" title=\"3 写时复制\"></a>3 写时复制</h5><p>写时复制机制，它只有在必要的时候（即发生写的时候）才会进行深拷贝，可以很好地提升效率。</p>\n<p>具体过程：<u>变量使用了引用计数，当出现其中一个变量修改value的情况，这个时候就需要对value进行分离，发生改变的变量恢复至一份数据出来进行修改，同时断开原来value的指向，指向新的value。</u></p>\n<p>例1：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发生分离</span></span><br><span class=\"line\">$b[] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/F0B25584D691443AB81AB2C8EA60C941?method=download&shareKey=98bf888bb661490664329007cb8b939c&ynotemdtimestamp=1598325595262\" alt=\"zval_sep\"></p>\n<p>例2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发生分离</span></span><br><span class=\"line\">$c[] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/4CDEAFB9332D4EEE9443D527A09934BF?method=download&shareKey=26b4c24edc932c27e427583bc422d2e3&ynotemdtimestamp=1598325595262\" alt=\"a、b、c发生写时复制的过程\"></p>\n<p>注：不是所有类型都可以copy的，比如<u>对象、资源就无法进行复制，也就是无法进行分离，如果多个变量指向同一个对象，当其中一个变量修改对象时，其修改将反映到所有变量上</u>。事实上<strong>只有string、array两种支持value的分离</strong>，与引用计数相同，也是通过<code>zval.u1.type_flag</code>标识value是否可复制的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_COPYABLE = 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TYPE_COPYABLE         (1&lt;&lt;4)</span></span><br><span class=\"line\">|     type       |  copyable  |</span><br><span class=\"line\">+----------------+------------+</span><br><span class=\"line\">|simple types    |            |</span><br><span class=\"line\">|<span class=\"built_in\">string</span>          |      Y     |</span><br><span class=\"line\">|interned <span class=\"built_in\">string</span> |            |</span><br><span class=\"line\">|<span class=\"built_in\">array</span>           |      Y     |</span><br><span class=\"line\">|immutable <span class=\"built_in\">array</span> |            |</span><br><span class=\"line\">|object          |            |</span><br><span class=\"line\">|resource        |            |</span><br><span class=\"line\">|reference       |            |</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"4-变量回收\"><a href=\"#4-变量回收\" class=\"headerlink\" title=\"4 变量回收\"></a>4 变量回收</h5><p>PHP变量回收方式：</p>\n<ul>\n<li>主动销毁：指的就是 unset。</li>\n<li>自动销毁：指PHP的自动管理机制（GC机制).<ul>\n<li>在return时减掉局部变量的refcount，即使没有显式的return，PHP也会自动给加上这个操作;</li>\n<li>写时复制时也会断开原来value的指向，这时候也会检查断开后旧value的refcount。</li>\n</ul>\n</li>\n</ul>\n<p>变量回收时机： zval断开value的指向时，若发现refcount=0则会直接释放value。其中发生断开的情况包括：</p>\n<ul>\n<li>修改变量：修改变量时会断开原有value的指向</li>\n<li>函数返回：函数返回时会释放所有的局部变量，也就是把所有局部变量的引用计数减1.</li>\n</ul>\n<h5 id=\"5-垃圾回收\"><a href=\"#5-垃圾回收\" class=\"headerlink\" title=\"5 垃圾回收\"></a>5 垃圾回收</h5><p>PHP用过引用计数实现了变量的自动GC机制，还是会有一种情况GC机制无法解决，从而导致变量无法回首导致内存始终得不到释放，造成内存泄露。</p>\n<p>造成内存泄漏的情况：<u>循环引用</u></p>\n<p><strong>问: 什么是循环引用?</strong><br>循环引用就是变量的内部成员引用了变量自身，比如数组中某个元素指向了数组，这样一来数组的引用计数中就有一个来自自身成员，当所有外部引用断开时，数组的refcount仍然大于0而得不到释放，但实际上这种变量不可能再被使用了。</p>\n<p><strong>垃圾收集器收集的时机</strong>：<u>refcount减少时，即每次refcount减少都会试图收集</u></p>\n<p>示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">$a[] = &amp;$a;</span><br><span class=\"line\"><span class=\"keyword\">unset</span>($a);</span><br></pre></td></tr></table></figure>\n\n<p>unset($a)前，变量a的类型为引用，该引用的refcount=2，一个来自于$a,一个来自于$a[1];示意图如下： <img src=\"https://note.youdao.com/yws/api/personal/file/8C22AE1A04B249948E9ADECA4F6D9865?method=download&shareKey=90e64014943ead9d4294b592037d0484&ynotemdtimestamp=1598325595262\" alt=\"unset($a)前的引用关系\"></p>\n<p>unset($a)后，减少了一次该引用的refcount，此时已经没有任何外部引用了，但是数组中仍然有一个元素指向该引用，如下图所示： <img src=\"https://note.youdao.com/yws/api/personal/file/74E94E6D9F384C0A9E9F44FF5F086CC9?method=download&shareKey=1ef849b379e45a8729679844f572119d&ynotemdtimestamp=1598325595262\" alt=\"unset($a)后的引用关系\"></p>\n<p>这种因为循环引用而导致无法释放的变量称之为垃圾，PHP引入了另一种机制来对这些垃圾进行回收，即<strong>垃圾回收器</strong>。</p>\n<ul>\n<li>若一个变量value的refcount减少到0，那么此vlaue可以被释放掉，不属于垃圾。</li>\n<li>若一个变量value的refcount减少之后大于0，那么此vlaue还不能被释放，此value<u>可能</u>成为一个垃圾。</li>\n</ul>\n<p>垃圾回收器会将可能成为垃圾的value收集起来，等到达一定数量后开始启动垃圾鉴定程序，将真正的垃圾释放掉。</p>\n<p><strong>当前垃圾只会出现在array、object两种类型中</strong></p>\n<ul>\n<li>array：数组中的某个成员指向了数组</li>\n<li>object：对象的成员属性引用对象本身</li>\n</ul>\n<p><strong>问：垃圾回收器怎样判断当前类型是否可回收？</strong> </p>\n<p>垃圾回收器不是通过变量类型进行判断的，而是通过<code>zval.u1.type_flag</code>标识进行判断，只有包含<code>IS_TYPE_COLLECTABLE</code>标识的变量类型才会被收集。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_COLLECTABLE = 8</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> IS_TYPE_COLLECTABLE  (1&lt;&lt;3)</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"5-1-回收算法\"><a href=\"#5-1-回收算法\" class=\"headerlink\" title=\"5.1 回收算法\"></a>5.1 回收算法</h6><p>垃圾回收器把收集到的可能垃圾保存到一个buffer缓冲区中，当到达一定数量后就会启动垃圾鉴定、回收程序。<br>回收算法的原理：<u>既然垃圾是由于成员引用自身导致的，那么就对value的所有成员减一遍引用计数，如果发现value本身refcount变为了0，则表明引用全部来自自身成员。</u></p>\n<h6 id=\"5-2-具体实现\"><a href=\"#5-2-具体实现\" class=\"headerlink\" title=\"5.2 具体实现\"></a>5.2 具体实现</h6><p>垃圾回收器主要通过<code>zend_gc_globals</code>这个这结构对垃圾进行管理，收集到的可能成为垃圾的vlaue就保存在这个结构的buf中，即<code>垃圾缓冲区</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_gc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_gc_globals</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 是否启用gc（php.ini中zend.enable_gc设置是否开启，默认是开启的）</span></span><br><span class=\"line\">\tzend_bool         gc_enabled;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否在垃圾检查过程中</span></span><br><span class=\"line\">\tzend_bool         gc_active;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存区是否已满</span></span><br><span class=\"line\">\tzend_bool         gc_full;</span><br><span class=\"line\">    <span class=\"comment\">// 启动时分配的用于保存可能垃圾的缓存区(初始化时，一次性分配了10001个gc_root_buffer,其中第一个被保留)</span></span><br><span class=\"line\">\tgc_root_buffer   *buf;\t\t\t\t<span class=\"comment\">/* preallocated arrays of buffers   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf中最新加入的一个可能垃圾（root是一个双向链表的头部）</span></span><br><span class=\"line\">\tgc_root_buffer    roots;\t\t\t<span class=\"comment\">/* list of possible roots of cycles */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向bug中没有使用的buffer（用于管理buf中开始加入后面又删除的结点，是一个单链表）</span></span><br><span class=\"line\">\tgc_root_buffer   *unused;\t\t\t<span class=\"comment\">/* list of unused buffers           */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf中第一个没有使用的buffer</span></span><br><span class=\"line\">\tgc_root_buffer   *first_unused;\t\t<span class=\"comment\">/* pointer to first unused buffer   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf尾部</span></span><br><span class=\"line\">\tgc_root_buffer   *last_unused;\t\t<span class=\"comment\">/* pointer to last unused buffer    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 待释放的垃圾</span></span><br><span class=\"line\">\tgc_root_buffer    to_free;\t\t\t<span class=\"comment\">/* list to free                     */</span></span><br><span class=\"line\">\tgc_root_buffer   *next_to_free;</span><br><span class=\"line\">    <span class=\"comment\">// 统计gc运行次数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> gc_runs;</span><br><span class=\"line\">\t<span class=\"comment\">// 统计已回收的垃圾数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> collected;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> GC_BENCH</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> root_buf_length;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> root_buf_peak;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_possible_root;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_buffered;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_remove_from_buffer;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_marked_grey;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tgc_additional_buffer *additional_buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; zend_gc_globals;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>buf用于保存收集到的value，他是一个数组，在垃圾回收器初始化时一次性分配了10001个gc_root_buffer，其中第一个buffer被保留，插入vlaue时直接取出可用结点即可。</li>\n<li>roots指向buf中最新加入的一个结点，root是一个双向链表的头部，之所以是一个双向链表，是因为bug数组中保存的只是有可能成为垃圾的vlaue吗，其中有些value在加入之后又被删除了，这样bug数组中就会出现一些空隙。</li>\n<li>first_unused一开始指向bug的第一个位置，有些元素插入roots时如果first_unused还没有到达buf尾部，则返回first_unused给最新的元素，然后执行first_unused++,直到last_unused.</li>\n</ul>\n<p>下图为已经加入了2个gc的结构： <img src=\"https://note.youdao.com/yws/api/personal/file/0A2236A0CF6442A0BB985383709DB5B7?method=download&shareKey=6656570e92c3731c6f1ce8572522a2d0&ynotemdtimestamp=1598325595262\" alt=\"buf缓冲区的可用节点\"></p>\n<ul>\n<li>unused成员，他的含义与first_unused类似，用来管理buf中开始加入后面又删除的结点，是一个单链表结构。也就是说first_unused是一直往后偏移的，直到buf的结尾，buf中间由于value删除而重新空闲的结点则由unused串起来。下次有新的value插入roots时优先使用unused的这些节点，其次才是first_unused的结点。</li>\n</ul>\n<p>下图为移除了buf[1]的结构： <img src=\"https://note.youdao.com/yws/api/personal/file/B788660EE8EE43DDB952F0DC408264B7?method=download&shareKey=3896ffff3a8a0ab653a5c4fd197426da&ynotemdtimestamp=1598325595262\" alt=\"buf[1]移除缓存去后的可用结点\"></p>\n<ul>\n<li>第一步，初始化 gc_init()初始化垃圾回收器：分配buf数组内存、设置first_unused/unused等</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">gc_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_G(buf) == <span class=\"literal\">NULL</span> &amp;&amp; GC_G(gc_enabled)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 分配buf缓冲区内存，大小为GC_ROOT_BUFFER_MAX_ENTERIES(10001),其中第1个保留不被使用。</span></span><br><span class=\"line\">\t\tGC_G(buf) = (gc_root_buffer*) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);</span><br><span class=\"line\">\t\tGC_G(last_unused) = &amp;GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];</span><br><span class=\"line\">\t\t<span class=\"comment\">// 进行GC_G的初始化，其中：GC_G(first_unused) = GC_G(buf) + 1;从第二个开始，保留第一个。</span></span><br><span class=\"line\">\t\tgc_reset();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二步，垃圾回收，在Zend执行过程中如果销毁一个变量就会判断是否需要加入垃圾收集器。销毁一个zval会调用i_zval_ptr_dtor()进行处理。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_variables.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> <span class=\"title\">i_zval_ptr_dtor</span><span class=\"params\">(zval *zval_ptr ZEND_FILE_LINE_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不使用引用计数的类型不需要进行回收（整型、浮点型、布尔型，null）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Z_REFCOUNTED_P(zval_ptr)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// refcount减一</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!Z_DELREF_P(zval_ptr)) &#123;</span><br><span class=\"line\">\t\t    <span class=\"comment\">// refcount减一后变为0，不是垃圾，正常回收</span></span><br><span class=\"line\">\t\t\t_zval_dtor_func_for_ptr(Z_COUNTED_P(zval_ptr) ZEND_FILE_LINE_RELAY_CC);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t    <span class=\"comment\">// refcount减一后仍然大于0，表示该变量可能是一个垃圾，被垃圾回收器回收。</span></span><br><span class=\"line\">\t\t\tGC_ZVAL_CHECK_POSSIBLE_ROOT(zval_ptr);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// file:zend_gc.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_ZVAL_CHECK_POSSIBLE_ROOT(z) \\</span></span><br><span class=\"line\">\tgc_check_possible_root((z))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> <span class=\"title\">gc_check_possible_root</span><span class=\"params\">(zval *z)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tZVAL_DEREF(z);</span><br><span class=\"line\">\t<span class=\"comment\">// 判断是否是可收集（检查变量类型掩码zval.u1.type_flag是否包含IS_TYPE_COLLECTABLE,即数组、对象）以及是否已经收集过了（通过zend_refcount_h.v.u.gc_info来判断，第一次收集后会把这个值设置为GC_PURPLE来避免重复收集）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Z_COLLECTABLE_P(z) &amp;&amp; UNEXPECTED(!Z_GC_INFO_P(z))) &#123;</span><br><span class=\"line\">\t\tgc_possible_root(Z_COUNTED_P(z));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>收集时首先会从buf中选择一个空闲节点，然后将vlaue的gc保存到这个结点中，若没有空闲节点则表明回收器已经满了，这个时候就会触发垃圾鉴定、回收程序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.c</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">gc_possible_root</span><span class=\"params\">(zend_refcounted *ref)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgc_root_buffer *newRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(CG(unclean_shutdown)) || UNEXPECTED(GC_G(gc_active))) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tZEND_ASSERT(GC_TYPE(ref) == IS_ARRAY || GC_TYPE(ref) == IS_OBJECT);</span><br><span class=\"line\">\t<span class=\"comment\">// 插入的结点必须是GC_BLACK,防止重复插入</span></span><br><span class=\"line\">\tZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(ref) == GC_BLACK));</span><br><span class=\"line\">\tZEND_ASSERT(!GC_ADDRESS(GC_INFO(ref)));</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_possible_root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 首先看一下unused中又没有可用的。</span></span><br><span class=\"line\">\tnewRoot = GC_G(unused);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newRoot) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 有的话先用unused的，然后将GC_G(unused)指向单链表的下一个</span></span><br><span class=\"line\">\t\tGC_G(unused) = newRoot-&gt;prev;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (GC_G(first_unused) != GC_G(last_unused)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// unused没有可用的，且bug中还有可用</span></span><br><span class=\"line\">\t\tnewRoot = GC_G(first_unused);</span><br><span class=\"line\">\t\tGC_G(first_unused)++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// buf缓存区已满，这时需要启动垃圾鉴定、回收程序。</span></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将插入的red标位紫色，防止重复插入</span></span><br><span class=\"line\">\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);</span><br><span class=\"line\">\t<span class=\"comment\">// 将该节点在buf中的位置保存到gc_info中，目的在于当后续value的refcount变为了0，需要将其从buf中删除时可以知道该value保存在那个gc_root_buffer中，如果没有这个信息，在删除vlaue时无法获取gc_root_buffer的位置。</span></span><br><span class=\"line\">\tGC_INFO(ref) = (newRoot - GC_G(buf)) | GC_PURPLE;</span><br><span class=\"line\">\tnewRoot-&gt;ref = ref;</span><br><span class=\"line\">    <span class=\"comment\">// 插入roots链表头部</span></span><br><span class=\"line\">\tnewRoot-&gt;next = GC_G(roots).next;</span><br><span class=\"line\">\tnewRoot-&gt;prev = &amp;GC_G(roots);</span><br><span class=\"line\">\tGC_G(roots).next-&gt;prev = newRoot;</span><br><span class=\"line\">\tGC_G(roots).next = newRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_buffered);</span><br><span class=\"line\">\tGC_BENCH_INC(root_buf_length);</span><br><span class=\"line\">\tGC_BENCH_PEAK(root_buf_peak, root_buf_length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第三步，删除 删除的操作通过GC_REMOVE_FROM_BUFFER()完成。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_REMOVE_FROM_BUFFER(p) do &#123; \\</span></span><br><span class=\"line\">\t\tzend_refcounted *_p = (zend_refcounted*)(p); \\</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (GC_ADDRESS(GC_INFO(_p))) &#123; \\</span><br><span class=\"line\">\t\t\tgc_remove_from_buffer(_p); \\</span><br><span class=\"line\">\t\t&#125; \\</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_ADDRESS(v) \\</span></span><br><span class=\"line\">\t((v) &amp; ~GC_COLOR)</span><br></pre></td></tr></table></figure>\n\n<p>删除时，先根据gc_info取到gc_root_buffer，然后再从buf中移除，删除后再把空的gc_root_buffer插入到unused单链表尾部。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.c</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">gc_remove_from_buffer</span><span class=\"params\">(zend_refcounted *ref)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgc_root_buffer *root;</span><br><span class=\"line\"></span><br><span class=\"line\">\tZEND_ASSERT(GC_ADDRESS(GC_INFO(ref)));</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_remove_from_buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (EXPECTED(GC_ADDRESS(GC_INFO(ref)) &lt; GC_ROOT_BUFFER_MAX_ENTRIES)) &#123;</span><br><span class=\"line\">\t\troot = GC_G(buf) + GC_ADDRESS(GC_INFO(ref));</span><br><span class=\"line\">\t\tgc_remove_from_roots(root);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\troot = gc_find_additional_buffer(ref);</span><br><span class=\"line\">\t\tgc_remove_from_additional_roots(root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_REF_GET_COLOR(ref) != GC_BLACK) &#123;</span><br><span class=\"line\">\t\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tGC_INFO(ref) = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* updete next root that is going to be freed */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_G(next_to_free) == root) &#123;</span><br><span class=\"line\">\t\tGC_G(next_to_free) = root-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当buf缓存区满了执行垃圾回收的过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">int</span> <span class=\"title\">zend_gc_collect_cycles</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t    ...</span><br><span class=\"line\">\t    <span class=\"comment\">// (1)遍历roots链表，对当前结点vlaue的所有成员（如数组元素、成员变量）进行深度优先遍历，把成员refcount减1.</span></span><br><span class=\"line\">\t\tgc_mark_roots();</span><br><span class=\"line\">\t\tGC_TRACE(<span class=\"string\">&quot;Scanning roots&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// (2)再次遍历roots链表，检查各结点当前refcount是否为0，是的话标为white，表示是垃圾，不是的话需要还原（1），吧refcount再加回去</span></span><br><span class=\"line\">\t\tgc_scan_roots();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_GC_DEBUG</span></span><br><span class=\"line\">\t\torig_gc_full = GC_G(gc_full);</span><br><span class=\"line\">\t\tGC_G(gc_full) = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tGC_TRACE(<span class=\"string\">&quot;Collecting roots&quot;</span>);</span><br><span class=\"line\">\t\tadditional_buffer_snapshot = GC_G(additional_buffer);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将roots链表中的非白色结点删除，之后roots链表中全部是真正的垃圾，将垃圾链表转到to_free等待释放</span></span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t  ...</span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 释放垃圾</span></span><br><span class=\"line\">\t\tcurrent = to_free.next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (current != &amp;to_free) &#123;</span><br><span class=\"line\">\t\t\tnext = current-&gt;next;</span><br><span class=\"line\">\t\t\tp = current-&gt;ref;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (EXPECTED(current &gt;= GC_G(buf) &amp;&amp; current &lt; GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) &#123;</span><br><span class=\"line\">\t\t\t\tcurrent-&gt;prev = GC_G(unused);</span><br><span class=\"line\">\t\t\t\tGC_G(unused) = current;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tefree(p);</span><br><span class=\"line\">\t\t\tcurrent = next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h5 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h5><p>C/C++语言中，如果想在<code>堆</code>上分配变量，需要手动进行内存的分配与释放，变量的内存管理是见非常繁琐的事，稍有不慎就可能导致不可域值的错误。 PHP实现了自动GC机制，由语言自行管理。PHP中的变量是不需要手动释放的，内核帮我们实现了变量的内存管理，包括内存的分配与回收。</p>","more":"<p><strong>自动GC最简单的实现方式</strong>：在函数中定义变量时分配一块内存，用于保存zval及对应的value结构，在函数返回时再将内存释放，若函数执行期间改变来凝固作为参数调用了其他函数或复制给了其他变量，则把变量复制一份，变量之间相互独立，不会出现冲突。<br>（<u>问题：深拷贝可能造成内存浪费，比如定义一个变量赋值给另一个变量，后面是只读操作的情况</u>）</p>\n<p><strong>解决方式（PHP采用此种方式）:</strong> <code>引用计数</code>+<code>写时复制</code>。</p>\n<ul>\n<li>当变量赋值、传递时多个变量公用一个value，引用计数用来记录value有多少个变量在使用；</li>\n<li>当变量的value发生改变时，进行深拷贝。</li>\n</ul>\n<p>注：long、double类型是使用的硬拷贝。</p>\n<h5 id=\"2-引用计数\"><a href=\"#2-引用计数\" class=\"headerlink\" title=\"2 引用计数\"></a>2 引用计数</h5><p>引用计数用来记录当前有多少<code>zval</code>指向同一个<code>zend_value</code>.<br>引用计数：<u>指在value中增加一个字段refcount记录指向当前value的数量，变量复制、函数传参时并不直接硬拷贝一份value数据，而是将refcount++，变量销毁时将refcount–，等到refcount减为0时表示已经没有变量引用这个value，将它销毁即可。</u></p>\n<p><strong>PHP7中将变量的引用计数保存在zend_value中</strong>（与之前版本不同）</p>\n<p>之前变量中不同类型的结构体中都有一个相同的成员：gc，该结构用于保存引用计数的,其定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_type.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_refcounted_h</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span>         refcount;\t\t\t<span class=\"comment\">/* reference counter 32-bit */</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\tZEND_ENDIAN_LOHI_3(</span><br><span class=\"line\">\t\t\t    <span class=\"comment\">// 类型</span></span><br><span class=\"line\">\t\t\t\tzend_uchar    type,</span><br><span class=\"line\">\t\t\t\tzend_uchar    flags,    <span class=\"comment\">/* used for strings &amp; objects */</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 垃圾回收时用到</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">uint16_t</span>      gc_info)  <span class=\"comment\">/* keeps GC root number (or 0) and color */</span></span><br><span class=\"line\">\t\t&#125; v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> type_info;</span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">&#125; zend_refcounted_h;</span><br></pre></td></tr></table></figure>\n\n<p>例1：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"string\">&quot;time:&quot;</span> . time();   <span class=\"comment\">//$a       -&gt;  zend_string_1(refcount=1)</span></span><br><span class=\"line\">$b = $a;                 <span class=\"comment\">//$a,$b    -&gt;  zend_string_1(refcount=2)</span></span><br><span class=\"line\">$c = $b;                 <span class=\"comment\">//$a,$b,$c -&gt;  zend_string_1(refcount=3)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unset</span>($b);               <span class=\"comment\">//$b = IS_UNDEF  $a,$c -&gt;  zend_string_1(refcount=2)</span></span><br></pre></td></tr></table></figure>\n\n<p>例2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>();   <span class=\"comment\">// $a       -&gt; zend_array(refcount=1)</span></span><br><span class=\"line\">$b = $a;        <span class=\"comment\">// $a,$b    -&gt;zend_array(refcount=2)</span></span><br><span class=\"line\">$c = $b;        <span class=\"comment\">// $a,$b,$c -&gt; zend_array(refcount=3)</span></span><br><span class=\"line\"><span class=\"keyword\">unset</span>($b);      <span class=\"comment\">// $a,$c    -&gt; zend_array(refcount=2)  $b = IS_UNDEF</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>问: 是所有变量类型会用到引用计数吗?如果不是,那么那些情况不会用到呢?</strong></p>\n<p>不是, 其中不会用到引用计数的情况如下:</p>\n<ul>\n<li>①、没有具体value结构的类型是不会用到的，比如：整型、浮点型、布尔型、NULL，他们的值直接通过zval保存，赋值时采用<u>深拷贝</u>。</li>\n<li>②、interned string：内部字符串，在PHP中写的函数名、类名、变量名、静态字符串等都是这种类型，定义:$a = “hi<del>“;后面的字符串内容是唯一不变的，这些字符串等同于C语言中定义在静态变量区的字符串：char *a = “hi</del>“;，这些字符串的生命周期为request期间，request完成后会统一销毁释放，自然也就无需在运行期间通过引用计数管理内存。<br>（注：<em>内部字符串与普通字符串的类型都是IS_STRING，它们并不是通过type进行区分的，而是通过zend_refcount_h.u.v.flag区分，内部字符串的flag值将包含IS_STR_INTERNED</em>）</li>\n<li>③、immutable array：不可变数组，只有在用opcache的时候才会用到这种类型，不清楚具体实现，暂时忽略。</li>\n</ul>\n<p>除了以上几种情况, 其余类型将会用到引用计数。</p>\n<p><strong>问: PHP内核是怎样区分value是否支持引用计数的呢?</strong></p>\n<p>使用<code>zval.u1</code>中的类型掩码<code>type_flag</code>字段， 这个字段除了标识value是否支持引用计数外还有其它几个标识位，按位分割<br><em>注：type_flag与zval.value-&gt;gc.u.flag不是一个值。</em></p>\n<p>支持引用计数的value类型是<code>zval.u1.type_flag &amp; IS_TYPE_REFCOUNTED</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_REFCOUNTED = 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TYPE_REFCOUNTED          (1&lt;&lt;2)</span></span><br></pre></td></tr></table></figure>\n\n<p>下列类型会使用引用计数机制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|     type       | refcounted |</span><br><span class=\"line\">+----------------+------------+</span><br><span class=\"line\">|simple types    |            |</span><br><span class=\"line\">|string          |      Y     |</span><br><span class=\"line\">|interned string |            |</span><br><span class=\"line\">|array           |      Y     |</span><br><span class=\"line\">|immutable array |            |</span><br><span class=\"line\">|object          |      Y     |</span><br><span class=\"line\">|resource        |      Y     |</span><br><span class=\"line\">|reference       |      Y     |</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3-写时复制\"><a href=\"#3-写时复制\" class=\"headerlink\" title=\"3 写时复制\"></a>3 写时复制</h5><p>写时复制机制，它只有在必要的时候（即发生写的时候）才会进行深拷贝，可以很好地提升效率。</p>\n<p>具体过程：<u>变量使用了引用计数，当出现其中一个变量修改value的情况，这个时候就需要对value进行分离，发生改变的变量恢复至一份数据出来进行修改，同时断开原来value的指向，指向新的value。</u></p>\n<p>例1：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发生分离</span></span><br><span class=\"line\">$b[] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/F0B25584D691443AB81AB2C8EA60C941?method=download&shareKey=98bf888bb661490664329007cb8b939c&ynotemdtimestamp=1598325595262\" alt=\"zval_sep\"></p>\n<p>例2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发生分离</span></span><br><span class=\"line\">$c[] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/4CDEAFB9332D4EEE9443D527A09934BF?method=download&shareKey=26b4c24edc932c27e427583bc422d2e3&ynotemdtimestamp=1598325595262\" alt=\"a、b、c发生写时复制的过程\"></p>\n<p>注：不是所有类型都可以copy的，比如<u>对象、资源就无法进行复制，也就是无法进行分离，如果多个变量指向同一个对象，当其中一个变量修改对象时，其修改将反映到所有变量上</u>。事实上<strong>只有string、array两种支持value的分离</strong>，与引用计数相同，也是通过<code>zval.u1.type_flag</code>标识value是否可复制的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_COPYABLE = 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TYPE_COPYABLE         (1&lt;&lt;4)</span></span><br><span class=\"line\">|     type       |  copyable  |</span><br><span class=\"line\">+----------------+------------+</span><br><span class=\"line\">|simple types    |            |</span><br><span class=\"line\">|<span class=\"built_in\">string</span>          |      Y     |</span><br><span class=\"line\">|interned <span class=\"built_in\">string</span> |            |</span><br><span class=\"line\">|<span class=\"built_in\">array</span>           |      Y     |</span><br><span class=\"line\">|immutable <span class=\"built_in\">array</span> |            |</span><br><span class=\"line\">|object          |            |</span><br><span class=\"line\">|resource        |            |</span><br><span class=\"line\">|reference       |            |</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"4-变量回收\"><a href=\"#4-变量回收\" class=\"headerlink\" title=\"4 变量回收\"></a>4 变量回收</h5><p>PHP变量回收方式：</p>\n<ul>\n<li>主动销毁：指的就是 unset。</li>\n<li>自动销毁：指PHP的自动管理机制（GC机制).<ul>\n<li>在return时减掉局部变量的refcount，即使没有显式的return，PHP也会自动给加上这个操作;</li>\n<li>写时复制时也会断开原来value的指向，这时候也会检查断开后旧value的refcount。</li>\n</ul>\n</li>\n</ul>\n<p>变量回收时机： zval断开value的指向时，若发现refcount=0则会直接释放value。其中发生断开的情况包括：</p>\n<ul>\n<li>修改变量：修改变量时会断开原有value的指向</li>\n<li>函数返回：函数返回时会释放所有的局部变量，也就是把所有局部变量的引用计数减1.</li>\n</ul>\n<h5 id=\"5-垃圾回收\"><a href=\"#5-垃圾回收\" class=\"headerlink\" title=\"5 垃圾回收\"></a>5 垃圾回收</h5><p>PHP用过引用计数实现了变量的自动GC机制，还是会有一种情况GC机制无法解决，从而导致变量无法回首导致内存始终得不到释放，造成内存泄露。</p>\n<p>造成内存泄漏的情况：<u>循环引用</u></p>\n<p><strong>问: 什么是循环引用?</strong><br>循环引用就是变量的内部成员引用了变量自身，比如数组中某个元素指向了数组，这样一来数组的引用计数中就有一个来自自身成员，当所有外部引用断开时，数组的refcount仍然大于0而得不到释放，但实际上这种变量不可能再被使用了。</p>\n<p><strong>垃圾收集器收集的时机</strong>：<u>refcount减少时，即每次refcount减少都会试图收集</u></p>\n<p>示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">$a[] = &amp;$a;</span><br><span class=\"line\"><span class=\"keyword\">unset</span>($a);</span><br></pre></td></tr></table></figure>\n\n<p>unset($a)前，变量a的类型为引用，该引用的refcount=2，一个来自于$a,一个来自于$a[1];示意图如下： <img src=\"https://note.youdao.com/yws/api/personal/file/8C22AE1A04B249948E9ADECA4F6D9865?method=download&shareKey=90e64014943ead9d4294b592037d0484&ynotemdtimestamp=1598325595262\" alt=\"unset($a)前的引用关系\"></p>\n<p>unset($a)后，减少了一次该引用的refcount，此时已经没有任何外部引用了，但是数组中仍然有一个元素指向该引用，如下图所示： <img src=\"https://note.youdao.com/yws/api/personal/file/74E94E6D9F384C0A9E9F44FF5F086CC9?method=download&shareKey=1ef849b379e45a8729679844f572119d&ynotemdtimestamp=1598325595262\" alt=\"unset($a)后的引用关系\"></p>\n<p>这种因为循环引用而导致无法释放的变量称之为垃圾，PHP引入了另一种机制来对这些垃圾进行回收，即<strong>垃圾回收器</strong>。</p>\n<ul>\n<li>若一个变量value的refcount减少到0，那么此vlaue可以被释放掉，不属于垃圾。</li>\n<li>若一个变量value的refcount减少之后大于0，那么此vlaue还不能被释放，此value<u>可能</u>成为一个垃圾。</li>\n</ul>\n<p>垃圾回收器会将可能成为垃圾的value收集起来，等到达一定数量后开始启动垃圾鉴定程序，将真正的垃圾释放掉。</p>\n<p><strong>当前垃圾只会出现在array、object两种类型中</strong></p>\n<ul>\n<li>array：数组中的某个成员指向了数组</li>\n<li>object：对象的成员属性引用对象本身</li>\n</ul>\n<p><strong>问：垃圾回收器怎样判断当前类型是否可回收？</strong> </p>\n<p>垃圾回收器不是通过变量类型进行判断的，而是通过<code>zval.u1.type_flag</code>标识进行判断，只有包含<code>IS_TYPE_COLLECTABLE</code>标识的变量类型才会被收集。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_COLLECTABLE = 8</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> IS_TYPE_COLLECTABLE  (1&lt;&lt;3)</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"5-1-回收算法\"><a href=\"#5-1-回收算法\" class=\"headerlink\" title=\"5.1 回收算法\"></a>5.1 回收算法</h6><p>垃圾回收器把收集到的可能垃圾保存到一个buffer缓冲区中，当到达一定数量后就会启动垃圾鉴定、回收程序。<br>回收算法的原理：<u>既然垃圾是由于成员引用自身导致的，那么就对value的所有成员减一遍引用计数，如果发现value本身refcount变为了0，则表明引用全部来自自身成员。</u></p>\n<h6 id=\"5-2-具体实现\"><a href=\"#5-2-具体实现\" class=\"headerlink\" title=\"5.2 具体实现\"></a>5.2 具体实现</h6><p>垃圾回收器主要通过<code>zend_gc_globals</code>这个这结构对垃圾进行管理，收集到的可能成为垃圾的vlaue就保存在这个结构的buf中，即<code>垃圾缓冲区</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_gc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_gc_globals</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 是否启用gc（php.ini中zend.enable_gc设置是否开启，默认是开启的）</span></span><br><span class=\"line\">\tzend_bool         gc_enabled;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否在垃圾检查过程中</span></span><br><span class=\"line\">\tzend_bool         gc_active;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存区是否已满</span></span><br><span class=\"line\">\tzend_bool         gc_full;</span><br><span class=\"line\">    <span class=\"comment\">// 启动时分配的用于保存可能垃圾的缓存区(初始化时，一次性分配了10001个gc_root_buffer,其中第一个被保留)</span></span><br><span class=\"line\">\tgc_root_buffer   *buf;\t\t\t\t<span class=\"comment\">/* preallocated arrays of buffers   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf中最新加入的一个可能垃圾（root是一个双向链表的头部）</span></span><br><span class=\"line\">\tgc_root_buffer    roots;\t\t\t<span class=\"comment\">/* list of possible roots of cycles */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向bug中没有使用的buffer（用于管理buf中开始加入后面又删除的结点，是一个单链表）</span></span><br><span class=\"line\">\tgc_root_buffer   *unused;\t\t\t<span class=\"comment\">/* list of unused buffers           */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf中第一个没有使用的buffer</span></span><br><span class=\"line\">\tgc_root_buffer   *first_unused;\t\t<span class=\"comment\">/* pointer to first unused buffer   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf尾部</span></span><br><span class=\"line\">\tgc_root_buffer   *last_unused;\t\t<span class=\"comment\">/* pointer to last unused buffer    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 待释放的垃圾</span></span><br><span class=\"line\">\tgc_root_buffer    to_free;\t\t\t<span class=\"comment\">/* list to free                     */</span></span><br><span class=\"line\">\tgc_root_buffer   *next_to_free;</span><br><span class=\"line\">    <span class=\"comment\">// 统计gc运行次数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> gc_runs;</span><br><span class=\"line\">\t<span class=\"comment\">// 统计已回收的垃圾数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> collected;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> GC_BENCH</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> root_buf_length;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> root_buf_peak;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_possible_root;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_buffered;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_remove_from_buffer;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_marked_grey;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tgc_additional_buffer *additional_buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; zend_gc_globals;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>buf用于保存收集到的value，他是一个数组，在垃圾回收器初始化时一次性分配了10001个gc_root_buffer，其中第一个buffer被保留，插入vlaue时直接取出可用结点即可。</li>\n<li>roots指向buf中最新加入的一个结点，root是一个双向链表的头部，之所以是一个双向链表，是因为bug数组中保存的只是有可能成为垃圾的vlaue吗，其中有些value在加入之后又被删除了，这样bug数组中就会出现一些空隙。</li>\n<li>first_unused一开始指向bug的第一个位置，有些元素插入roots时如果first_unused还没有到达buf尾部，则返回first_unused给最新的元素，然后执行first_unused++,直到last_unused.</li>\n</ul>\n<p>下图为已经加入了2个gc的结构： <img src=\"https://note.youdao.com/yws/api/personal/file/0A2236A0CF6442A0BB985383709DB5B7?method=download&shareKey=6656570e92c3731c6f1ce8572522a2d0&ynotemdtimestamp=1598325595262\" alt=\"buf缓冲区的可用节点\"></p>\n<ul>\n<li>unused成员，他的含义与first_unused类似，用来管理buf中开始加入后面又删除的结点，是一个单链表结构。也就是说first_unused是一直往后偏移的，直到buf的结尾，buf中间由于value删除而重新空闲的结点则由unused串起来。下次有新的value插入roots时优先使用unused的这些节点，其次才是first_unused的结点。</li>\n</ul>\n<p>下图为移除了buf[1]的结构： <img src=\"https://note.youdao.com/yws/api/personal/file/B788660EE8EE43DDB952F0DC408264B7?method=download&shareKey=3896ffff3a8a0ab653a5c4fd197426da&ynotemdtimestamp=1598325595262\" alt=\"buf[1]移除缓存去后的可用结点\"></p>\n<ul>\n<li>第一步，初始化 gc_init()初始化垃圾回收器：分配buf数组内存、设置first_unused/unused等</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">gc_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_G(buf) == <span class=\"literal\">NULL</span> &amp;&amp; GC_G(gc_enabled)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 分配buf缓冲区内存，大小为GC_ROOT_BUFFER_MAX_ENTERIES(10001),其中第1个保留不被使用。</span></span><br><span class=\"line\">\t\tGC_G(buf) = (gc_root_buffer*) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);</span><br><span class=\"line\">\t\tGC_G(last_unused) = &amp;GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];</span><br><span class=\"line\">\t\t<span class=\"comment\">// 进行GC_G的初始化，其中：GC_G(first_unused) = GC_G(buf) + 1;从第二个开始，保留第一个。</span></span><br><span class=\"line\">\t\tgc_reset();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二步，垃圾回收，在Zend执行过程中如果销毁一个变量就会判断是否需要加入垃圾收集器。销毁一个zval会调用i_zval_ptr_dtor()进行处理。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_variables.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> <span class=\"title\">i_zval_ptr_dtor</span><span class=\"params\">(zval *zval_ptr ZEND_FILE_LINE_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不使用引用计数的类型不需要进行回收（整型、浮点型、布尔型，null）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Z_REFCOUNTED_P(zval_ptr)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// refcount减一</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!Z_DELREF_P(zval_ptr)) &#123;</span><br><span class=\"line\">\t\t    <span class=\"comment\">// refcount减一后变为0，不是垃圾，正常回收</span></span><br><span class=\"line\">\t\t\t_zval_dtor_func_for_ptr(Z_COUNTED_P(zval_ptr) ZEND_FILE_LINE_RELAY_CC);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t    <span class=\"comment\">// refcount减一后仍然大于0，表示该变量可能是一个垃圾，被垃圾回收器回收。</span></span><br><span class=\"line\">\t\t\tGC_ZVAL_CHECK_POSSIBLE_ROOT(zval_ptr);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// file:zend_gc.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_ZVAL_CHECK_POSSIBLE_ROOT(z) \\</span></span><br><span class=\"line\">\tgc_check_possible_root((z))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> <span class=\"title\">gc_check_possible_root</span><span class=\"params\">(zval *z)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tZVAL_DEREF(z);</span><br><span class=\"line\">\t<span class=\"comment\">// 判断是否是可收集（检查变量类型掩码zval.u1.type_flag是否包含IS_TYPE_COLLECTABLE,即数组、对象）以及是否已经收集过了（通过zend_refcount_h.v.u.gc_info来判断，第一次收集后会把这个值设置为GC_PURPLE来避免重复收集）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Z_COLLECTABLE_P(z) &amp;&amp; UNEXPECTED(!Z_GC_INFO_P(z))) &#123;</span><br><span class=\"line\">\t\tgc_possible_root(Z_COUNTED_P(z));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>收集时首先会从buf中选择一个空闲节点，然后将vlaue的gc保存到这个结点中，若没有空闲节点则表明回收器已经满了，这个时候就会触发垃圾鉴定、回收程序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.c</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">gc_possible_root</span><span class=\"params\">(zend_refcounted *ref)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgc_root_buffer *newRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(CG(unclean_shutdown)) || UNEXPECTED(GC_G(gc_active))) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tZEND_ASSERT(GC_TYPE(ref) == IS_ARRAY || GC_TYPE(ref) == IS_OBJECT);</span><br><span class=\"line\">\t<span class=\"comment\">// 插入的结点必须是GC_BLACK,防止重复插入</span></span><br><span class=\"line\">\tZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(ref) == GC_BLACK));</span><br><span class=\"line\">\tZEND_ASSERT(!GC_ADDRESS(GC_INFO(ref)));</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_possible_root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 首先看一下unused中又没有可用的。</span></span><br><span class=\"line\">\tnewRoot = GC_G(unused);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newRoot) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 有的话先用unused的，然后将GC_G(unused)指向单链表的下一个</span></span><br><span class=\"line\">\t\tGC_G(unused) = newRoot-&gt;prev;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (GC_G(first_unused) != GC_G(last_unused)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// unused没有可用的，且bug中还有可用</span></span><br><span class=\"line\">\t\tnewRoot = GC_G(first_unused);</span><br><span class=\"line\">\t\tGC_G(first_unused)++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// buf缓存区已满，这时需要启动垃圾鉴定、回收程序。</span></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将插入的red标位紫色，防止重复插入</span></span><br><span class=\"line\">\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);</span><br><span class=\"line\">\t<span class=\"comment\">// 将该节点在buf中的位置保存到gc_info中，目的在于当后续value的refcount变为了0，需要将其从buf中删除时可以知道该value保存在那个gc_root_buffer中，如果没有这个信息，在删除vlaue时无法获取gc_root_buffer的位置。</span></span><br><span class=\"line\">\tGC_INFO(ref) = (newRoot - GC_G(buf)) | GC_PURPLE;</span><br><span class=\"line\">\tnewRoot-&gt;ref = ref;</span><br><span class=\"line\">    <span class=\"comment\">// 插入roots链表头部</span></span><br><span class=\"line\">\tnewRoot-&gt;next = GC_G(roots).next;</span><br><span class=\"line\">\tnewRoot-&gt;prev = &amp;GC_G(roots);</span><br><span class=\"line\">\tGC_G(roots).next-&gt;prev = newRoot;</span><br><span class=\"line\">\tGC_G(roots).next = newRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_buffered);</span><br><span class=\"line\">\tGC_BENCH_INC(root_buf_length);</span><br><span class=\"line\">\tGC_BENCH_PEAK(root_buf_peak, root_buf_length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第三步，删除 删除的操作通过GC_REMOVE_FROM_BUFFER()完成。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_REMOVE_FROM_BUFFER(p) do &#123; \\</span></span><br><span class=\"line\">\t\tzend_refcounted *_p = (zend_refcounted*)(p); \\</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (GC_ADDRESS(GC_INFO(_p))) &#123; \\</span><br><span class=\"line\">\t\t\tgc_remove_from_buffer(_p); \\</span><br><span class=\"line\">\t\t&#125; \\</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_ADDRESS(v) \\</span></span><br><span class=\"line\">\t((v) &amp; ~GC_COLOR)</span><br></pre></td></tr></table></figure>\n\n<p>删除时，先根据gc_info取到gc_root_buffer，然后再从buf中移除，删除后再把空的gc_root_buffer插入到unused单链表尾部。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.c</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">gc_remove_from_buffer</span><span class=\"params\">(zend_refcounted *ref)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgc_root_buffer *root;</span><br><span class=\"line\"></span><br><span class=\"line\">\tZEND_ASSERT(GC_ADDRESS(GC_INFO(ref)));</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_remove_from_buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (EXPECTED(GC_ADDRESS(GC_INFO(ref)) &lt; GC_ROOT_BUFFER_MAX_ENTRIES)) &#123;</span><br><span class=\"line\">\t\troot = GC_G(buf) + GC_ADDRESS(GC_INFO(ref));</span><br><span class=\"line\">\t\tgc_remove_from_roots(root);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\troot = gc_find_additional_buffer(ref);</span><br><span class=\"line\">\t\tgc_remove_from_additional_roots(root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_REF_GET_COLOR(ref) != GC_BLACK) &#123;</span><br><span class=\"line\">\t\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tGC_INFO(ref) = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* updete next root that is going to be freed */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_G(next_to_free) == root) &#123;</span><br><span class=\"line\">\t\tGC_G(next_to_free) = root-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当buf缓存区满了执行垃圾回收的过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">int</span> <span class=\"title\">zend_gc_collect_cycles</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t    ...</span><br><span class=\"line\">\t    <span class=\"comment\">// (1)遍历roots链表，对当前结点vlaue的所有成员（如数组元素、成员变量）进行深度优先遍历，把成员refcount减1.</span></span><br><span class=\"line\">\t\tgc_mark_roots();</span><br><span class=\"line\">\t\tGC_TRACE(<span class=\"string\">&quot;Scanning roots&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// (2)再次遍历roots链表，检查各结点当前refcount是否为0，是的话标为white，表示是垃圾，不是的话需要还原（1），吧refcount再加回去</span></span><br><span class=\"line\">\t\tgc_scan_roots();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_GC_DEBUG</span></span><br><span class=\"line\">\t\torig_gc_full = GC_G(gc_full);</span><br><span class=\"line\">\t\tGC_G(gc_full) = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tGC_TRACE(<span class=\"string\">&quot;Collecting roots&quot;</span>);</span><br><span class=\"line\">\t\tadditional_buffer_snapshot = GC_G(additional_buffer);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将roots链表中的非白色结点删除，之后roots链表中全部是真正的垃圾，将垃圾链表转到to_free等待释放</span></span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t  ...</span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 释放垃圾</span></span><br><span class=\"line\">\t\tcurrent = to_free.next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (current != &amp;to_free) &#123;</span><br><span class=\"line\">\t\t\tnext = current-&gt;next;</span><br><span class=\"line\">\t\t\tp = current-&gt;ref;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (EXPECTED(current &gt;= GC_G(buf) &amp;&amp; current &lt; GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) &#123;</span><br><span class=\"line\">\t\t\t\tcurrent-&gt;prev = GC_G(unused);</span><br><span class=\"line\">\t\t\t\tGC_G(unused) = current;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tefree(p);</span><br><span class=\"line\">\t\t\tcurrent = next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"PHP7内核-内存管理-内存池","date":"2020-08-25T06:29:45.000Z","_content":"\n#### 1 简介\n在C语言中，通常直接使用malloc进行内存的分配，而频繁的分配、释放内存无疑会产生内存碎片，降低系统性能。PHP自己实现了一套内存池（`ZendMM`：`Zend Memery Manager`）用于替换`glibc`的`malloc`、`free`，以解决内存频繁分配、释放的问题。\n\n<!--more-->\n\n内存池技术主要作用：\n- ①、减少内存分配及释放的次数\n- ②、有效控制内存碎片的产生\n\nPHP的内存池的实现参考了`tcmalloc`的设计，`tcmalloc`是`Google`开源的一个非常优秀的内存分配器。\n\n内存池是PHP内核中最底层的内存操作，他是非常独立的一个模块，可以移植到其他C语言应用中去。  \n\n\n\n**内存池定义了三种粒度的内存块**：\n\n- **chunk**：每个chunk的大小为2M\n- **page**：page的大小为4KB，每个chunk被切割为512个page（2048/4）\n- **slot**：一个或若干个page被切割为多个slot\n\n\n\n申请内存时按照不同的申请大小决定具体的分配策略：\n\n- **Huge(chunk)**:申请内存大于2MB，<u>直接调用系统分配</u>，分配若干个chunk.(>2MB)\n- **Large(page)**：申请内~~存大于3092B~~（即page大小的3/4, 4 * 1024 * 3/4 = 3072B）,小于2044KB（即511个page的大小），分配若干个page。(3072B~2044KB)\n- **Small(slot)**:申请内存小于等于3092B(即page大小的3/4)，<u>内存池提前定义好了30种同等大小的内存（8、16、24、32...3072）,它们分配在不同的page上（不同大小的内存可能会分配在多个连续的page），申请内存时直接在对应的page上查找可用的slot</u>。(<3092B)\n\n内存池通过**zend_mm_heap**结构存储内存池的主要信息，比如`大内存链表`、`chunk链表`、`slot各大小内存链表`等。\n```C\n// file:zend_alloc.c\n# define AG(v) (alloc_globals.v)\nstatic zend_alloc_globals alloc_globals;\n\n// file:zend_alloc.h\ntypedef struct _zend_mm_heap zend_mm_heap;\nstruct _zend_mm_heap {\n#if ZEND_MM_CUSTOM\n\tint                use_custom_heap;\n#endif\n#if ZEND_MM_STORAGE\n\tzend_mm_storage   *storage;\n#endif\n#if ZEND_MM_STAT\n    // 当前已使用的内存数\n\tsize_t             size;                    /* current memory usage */\n\t// 内存单次申请的峰值\n\tsize_t             peak;                    /* peak memory usage */\n#endif\n    // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部\n\tzend_mm_free_slot *free_slot[ZEND_MM_BINS]; /* free lists for small sizes */\n\n    ...\n\n    // 大内存链表\n\tzend_mm_huge_list *huge_list;               /* list of huge allocated blocks */\n    // 指向chunk链表头部\n\tzend_mm_chunk     *main_chunk;\n\t// 缓存的chunk链表\n\tzend_mm_chunk     *cached_chunks;\t\t\t/* list of unused chunks */\n\t// 已分配的chunk数\n\tint                chunks_count;\t\t\t/* number of alocated chunks */\n\t// 当前request使用chunk峰值\n\tint                peak_chunks_count;\t\t/* peak number of allocated chunks for current request */\n\t// 缓存的chunk数\n\tint                cached_chunks_count;\t\t/* number of cached chunks */\n\t// chunk使用均值，每次请求结束后会根据peak_chunk_count重新计算：(avg_chunks_count + peak_chunks_count)/2.0\n\tdouble             avg_chunks_count;\t\t/* average number of chunks allocated per request */\n\tint                last_chunks_delete_boundary; /* numer of chunks after last deletion */\n\tint                last_chunks_delete_count;    /* number of deletion over the last boundary */\n    ...\n};\n```\n大内存分配的是若干个chunk，然后通过一个`zend_mm_huge_list结构`进行管理，**大内存之间构成一个单向链表**。\n```c\n// file:zend_alloc.h\ntypedef struct  _zend_mm_huge_list zend_mm_huge_list;\n\nstruct _zend_mm_huge_list {\n\tvoid              *ptr;\n\tsize_t             size;\n\tzend_mm_huge_list *next;\n#if ZEND_DEBUG\n\tzend_mm_debug_info dbg;\n#endif\n};\n```\n![huge_list链表](https://note.youdao.com/yws/api/personal/file/48872B5FBB994E018B73A4AF38B466CE?method=download&shareKey=b96499c0e19a3b8b9803bcfe2f50d9eb)\n\n<u>chunk是内存池向系统申请、释放内存的最小粒度。</u>`chunk`之间构成双向链表，第一个chunk的地址保存于`zend_mm_heap->main_chunk`。\n\n每个chunk的大小为2MB，被切割为512个page，所以每个page的大小为4KB，其中第一个page的内存用于chunk自己的结构体成员，主要记录chunk的一些信息，比如前后chunk的指针，当前chunk上各个page的使用情况等。\n\nchunk的定义结构如下：\n```c\n// file:zend_alloc.c\nstruct _zend_mm_chunk {\n\tzend_mm_heap      *heap;\n\t// 指向下一个chunk\n\tzend_mm_chunk     *next;\n\t// 指向上一个chunk\n\tzend_mm_chunk     *prev;\n\t// 当前chunk的剩余可用page数\n\tint                free_pages;\t\t\t\t/* number of free pages */\n\tint                free_tail;               /* number of free pages at the end of chunk */\n\tint                num;\n\tchar               reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)];\n\t// heap结构，只有主chunk会用到（即第一个chunk）\n\tzend_mm_heap       heap_slot;               /* used only in main chunk */\n\t// 标识各page是否已使用的bitmap，总大小为512bit，对应page总数，每个page占一个bit位。\n\tzend_mm_page_map   free_map;                /* 512 bits or 64 bytes */\n\t// 各page的信息：当前page使用类型（用于large分配还是small）、占用的page数等\n\tzend_mm_page_info  map[ZEND_MM_PAGES];      /* 2 KB = 512 * 4 */\n};\n```\n\n\n\nslot内存是把若干个page按照固定大小分割好的内存块。\n\n**内存池定义了30中大小的slot内存**：8、16、24、32...1792、2048、3072.这些slot的大小是有规律的。\n- ①、最小的slot大小为8byte\n- ②、前8个slot一次递增8byte（0~7递增 8byte）\n- ③、后面每隔4个递增值乘以2（8~11递增16byte、12~15递增32byte、16~19递增64byte、20~23递增128byte、24~27递增256byte、28~30递增512byte）\n\n\n\n每种大小的slot占用的page数不相同的：\n- ①、slot0~15各占1个page\n\n- ②、slot16~29分别占5、3、1、1、5、3、2、2、5、3、7、4、5、3个page；  \n    注：这个值实际也是有规律可循的，其算法为，目的是为了减少内存的碎片。\n    ```\n    page的个数 = 最小公倍数(slot对应的内存大小, page的大小即4096) / 4096\n    ```\n\n    \n    分配各个规格的slot时会按照各这个配置申请对应的数量的page，然后进行分割组成链表。<u>相同大小的slot之间构成单链表</u>。\n```\nstruct _zend_mm_free_slot {\n\tzend_mm_free_slot *next_free_slot;\n};\n```\n\nheap、huge、chunk、page、slot之间的关系如下图所示：\n![heap、huge、chunk、page、slot结构关系](https://note.youdao.com/yws/api/personal/file/A8793900579C4D84A8CCE6E131F70B04?method=download&shareKey=7c1b42213c6357aae7855f4bcc43c78c)\n\n#### 2 内存池的初始化\n初始化过程主要是`分配heap结构`，<u>如果是多线程环境，则会为每一个线程分配一个内存池，线程之间互不影响</u>。\n\n注：<u>`zend_mm_heap`这个结构不是单独分配的，它嵌在`chunk`结构体中（即`heap_slot`成员）</u>。也就是说内存池初始化时是分配了一个chunk结构，`zend_mm_chunk->heap_slot`作为内存池的heap结构，这个chunk也是第一个chunk，即main_chunk,如下图所示：\n![zend_mm_heap结构的分配](https://note.youdao.com/yws/api/personal/file/1598F914D6D043A2928403E3B65280FE?method=download&shareKey=fa722c4892712fb681baea9ac6c93cf8)\n\n**问题：为什么内存时的heap结构要嵌在chunk中而不是单独分配呢？** \n因为每个chunk的第一个page始终是给chunk结构体自己使用的，剩下的511个page才会做内存分配，但是chunk结构体并不需要一个page那么大的内存。也就是说被占用的page会有剩余的空间，因此，为了尽可能利用空间，就将heap结构嵌在了chunk中。\n\n具体的分配过成在zend_mm_init()中实现：\n```c\n// file:zend_alloc.c\nstatic zend_mm_heap *zend_mm_init(void)\n{\n    // 向系统申请2MB大小的chunk\n\tzend_mm_chunk *chunk = (zend_mm_chunk*)zend_mm_chunk_alloc_int(ZEND_MM_CHUNK_SIZE, ZEND_MM_CHUNK_SIZE);\n\tzend_mm_heap *heap;\n\n\tif (UNEXPECTED(chunk == NULL)) {\n#if ZEND_MM_ERROR\n#ifdef _WIN32\n\t\tstderr_last_error(\"Can't initialize heap\");\n#else\n\t\tfprintf(stderr, \"\\nCan't initialize heap: [%d] %s\\n\", errno, strerror(errno));\n#endif\n#endif\n\t\treturn NULL;\n\t}\n\t// heap结构实际数主chunk嵌入的一个结构，后面再分配的chunk的heap_slot不再使用\n\theap = &chunk->heap_slot;\n\tchunk->heap = heap;\n\tchunk->next = chunk;\n\tchunk->prev = chunk;\n\t// 剩余可用page数\n\tchunk->free_pages = ZEND_MM_PAGES - ZEND_MM_FIRST_PAGE;\n\tchunk->free_tail = ZEND_MM_FIRST_PAGE;\n\tchunk->num = 0\n\t// 将第一个page的bit分配标识位设置为1，表示已经被分配、占用\n\tchunk->free_map[0] = (Z_L(1) << ZEND_MM_FIRST_PAGE) - 1;\n\t// 第一个page的类型为ZEND_MM_IS_LRUN,即large内存\n\tchunk->map[0] = ZEND_MM_LRUN(ZEND_MM_FIRST_PAGE);\n\t// 指向主chunk\n\theap->main_chunk = chunk;\n\t// 初始化剩下的一些成员\n\t...\n\t// huge内存链表\n\theap->huge_list = NULL;\n\treturn heap;\n}\n\n```\n\n#### 3 内存的分配\nHuge大内存的分配过程比较简单、而Large与Small内存分配涉及到page的查找操作，过程稍显复杂。\n\n使用`emalloc`申请时，内存池会按照申请内存的大小自动选择那种格内存进行分配，如下图所示：\n![内存的分配流程](https://note.youdao.com/yws/api/personal/file/1C273A1B04A44C379427B94CBE2A42FB?method=download&shareKey=d5059f5c0dafd673a661edf8efe31120)\n\n##### 3.1 Huge分配\nHuge是指超多2MB大小内存的分配，<u>实际分配时将对齐到n个chunk</u>，分配完还会分配一个zend_mm_huge_list结构，用于管理所有的Huge内存。\n```c\nstatic void *zend_mm_alloc_huge(zend_mm_heap *heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n#ifdef ZEND_WIN32\n\t/* On Windows we don't have ability to extend huge blocks in-place.\n\t * We allocate them with 2MB size granularity, to avoid many\n\t * reallocations when they are extended by small pieces\n\t */\n\t // 按页大小重置实际要分配的内存\n\tsize_t new_size = ZEND_MM_ALIGNED_SIZE_EX(size, MAX(REAL_PAGE_SIZE, ZEND_MM_CHUNK_SIZE));\n#else\n\tsize_t new_size = ZEND_MM_ALIGNED_SIZE_EX(size, REAL_PAGE_SIZE);\n#endif\n\tvoid *ptr;\n\n#if ZEND_MM_LIMIT\n    // 如果有内存使用限制，则检查是否已达上限，达到的话进行zend_mm_gc清理后再检查\n\tif (UNEXPECTED(heap->real_size + new_size > heap->limit)) {\n\t\tif (zend_mm_gc(heap) && heap->real_size + new_size <= heap->limit) {\n\t\t\t/* pass */\n\t\t} else if (heap->overflow == 0) {\n#if ZEND_DEBUG\n\t\t\tzend_mm_safe_error(heap, \"Allowed memory size of %zu bytes exhausted at %s:%d (tried to allocate %zu bytes)\", heap->limit, __zend_filename, __zend_lineno, size);\n#else\n\t\t\tzend_mm_safe_error(heap, \"Allowed memory size of %zu bytes exhausted (tried to allocate %zu bytes)\", heap->limit, size);\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n    // 分配chunk()，系统返回的地址是随机的，并不一定是ZEND_MM_CHUNK_ZIZE的整数倍，内存池需要自己移动到对齐的位置，比如：返回地址ptr是2000，而最近的一个对齐地址是2048，内存池会把ptr移动到2048，从这个位置使用。\n\tptr = zend_mm_chunk_alloc(heap, new_size, ZEND_MM_CHUNK_SIZE);\n   \n    ... \n    \n#if ZEND_DEBUG\n    // 将申请的内存通过zend_mm_huge_list插入到链表中\n\tzend_mm_add_huge_block(heap, ptr, new_size, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#else\n\tzend_mm_add_huge_block(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#endif\n    ...\n\treturn ptr;\n}\n```\n除了Huge分配以外，分配chunk内存也是Large、Small内存分配的基础，<u>它是ZendMM向系统申请内存的唯一粒度</u>。\n\n注：*分配chunk时，会将内存地址对齐到chunk的大小2MB（`ZEND_MM_THUNK_SIZE`）。也就是说，分配的chunk地址都是`ZEND_MM_THUNK_SIZE`的整数倍。（**实际上这个对齐并不是由系统简单的完成，而是需要内存池在申请内存后自己进行调整！**）*\n\n\n\n`ZendMM`具体处理对齐的方法是：\n\n- ①、按实际要申请的内存大小申请一次\n    - 若系统分配的地址恰好是ZEND_MM_CHUNK_SIZE的整数倍，则不需要调整，直接返回。\n    - 若系统分配的地址不是ZEND_MM_CHUNK_SIZE的整数倍，则需要使用第②步进行调整。\n- ②、调整方式：\n    - 首先ZendMM会将这块内存释放掉；\n    - 按照“`实际要申请的内存大小 + ZEND_MM_CHUNK_SIZE`”的大小重新申请一块内存，多申请的ZEND_MM_CHUNK大小的内存是用来调整的`，ZendMM`会从系统分配的地址向后偏移到最近一个`ZEND_MM_CHUNK_SIZE的整数倍`位置，调整完之后再把剩余的内存释放掉。\n\n```c\nstatic void *zend_mm_chunk_alloc_int(size_t size, size_t alignment)\n{\n    // 向系统申请size大小的内存\n\tvoid *ptr = zend_mm_mmap(size);\n\n\tif (ptr == NULL) {\n\t\treturn NULL;\n\t} else if (ZEND_MM_ALIGNED_OFFSET(ptr, alignment) == 0) { // 判断申请的内存是都为alignment的整数倍，是的话直接返回\n#ifdef MADV_HUGEPAGE\n\t    madvise(ptr, size, MADV_HUGEPAGE);\n#endif\n\t\treturn ptr;\n\t} else {\n\t    // 申请的内存不是按照alignment对齐的\n\t\tsize_t offset;\n\n\t\t// 将申请的内存释放掉重新申请\n\t\tzend_mm_munmap(ptr, size);\n\t\t// 重新申请一块内存，这里会多申请一块内存，用于截取到alignment的整数倍，可以忽略REAL_PAGE_SIZE\n\t\tptr = zend_mm_mmap(size + alignment - REAL_PAGE_SIZE);\n#ifdef _WIN32\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tzend_mm_munmap(ptr, size + alignment - REAL_PAGE_SIZE);\n\t\tptr = zend_mm_mmap_fixed((void*)((char*)ptr + (alignment - offset)), size);\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tif (offset != 0) {\n\t\t\tzend_mm_munmap(ptr, size);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ptr;\n#else\n        // offset为ptr距离上一个alignment对齐内存位置的大小，注意不能往前移，因为前面的内存都是分配了的。\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tif (offset != 0) {\n\t\t\toffset = alignment - offset;\n\t\t\tzend_mm_munmap(ptr, offset);\n\t\t\t// 偏移ptr，对齐到alignment\n\t\t\tptr = (char*)ptr + offset;\n\t\t\talignment -= offset;\n\t\t}\n\t\tif (alignment > REAL_PAGE_SIZE) {\n\t\t\tzend_mm_munmap((char*)ptr + size, alignment - REAL_PAGE_SIZE);\n\t\t}\n# ifdef MADV_HUGEPAGE\n\t    madvise(ptr, size, MADV_HUGEPAGE);\n# endif\n#endif\n\t\treturn ptr;\n\t}\n}\n```\n\n其中用到了`ZEND_MM_ALIGNED_OFFSET宏`，这个宏的作用是计算按alignment对齐的内存地址距离上一个alignment整数倍内存地址的大小，也就是offset偏移量。\n\n**alignment必须是2的n次方**，比如一段`n*alignment`大小的内存，ptr为其中一个位置，那么就可以通过位运算计算得到ptr在所属alignment内存块中的offset，如下图所示：\n\n```\n#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\\n\t(((size_t)(size)) & ((alignment) - 1))\n```\n![相对对齐值的内存offset](https://note.youdao.com/yws/api/personal/file/9940B8821F1E4B19B2783B68381DFD5C?method=download&shareKey=8e13fe6980c3aa04d6cf3c97f1522b9d)\n\n这个位运算是因为`alignment`为`2^n`（用二进制表示即为第n个位上为1，其余位为0，当alignment-1相当于将除了第n位为0，其余低位全部为1），所以通过alignment取到最低的位置，也就是相对上一个整数倍的alignment的offset，非位运算算式如下，但效率没有位运算高。\n```\noffset = ptr - (ptr/alignment取整 * alignment)\n```\n\n##### 3.2 Large分配\n当申请的内存大于3072B、小于2044KB时，内存池会选择在chunk上查找对应数量的page返回。<u>Large内存申请的粒度是page，也就是分配n页连续的page</u>，所以Large分配的过程就转化为在chunk上查找n页连续可用的page的过程。\n\n```c\nstatic zend_always_inline void *zend_mm_alloc_large(zend_mm_heap *heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n    // 根据size大小计算需要分配多少个page\n\tint pages_count = (int)ZEND_MM_SIZE_TO_NUM(size, ZEND_MM_PAGE_SIZE);\n#if ZEND_DEBUG\n    // 分配page_count个page\n\tvoid *ptr = zend_mm_alloc_pages(heap, pages_count, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#else\n\tvoid *ptr = zend_mm_alloc_pages(heap, pages_count ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#endif\n#if ZEND_MM_STAT\n\tdo {\n\t\tsize_t size = heap->size + pages_count * ZEND_MM_PAGE_SIZE;\n\t\tsize_t peak = MAX(heap->peak, size);\n\t\theap->size = size;\n\t\theap->peak = peak;\n\t} while (0);\n#endif\n\treturn ptr;\n}\n```\n\nchunk结构中有两个成员用于记录page分配信息：\n- **free_map**：类型为`zend_mm_page_map`，实际就是`zend_ulong_free_map[16/8]`，这是一个bitmap，总大小为64byte，也就是512bit，用于记录用当前chunk上512个page是否分配，512个page对应512bit，1表示已分配，0表示未分配。\n![free_map](https://note.youdao.com/yws/api/personal/file/C879457EC2154FAEA678D562C217773B?method=download&shareKey=29d90ba60d479fdeccd33ac88325813a)\n- **map**：这个是一个可容纳512个类型为uint32_t元素的数组，<u>该数组用于记录各page的分配类型及分配的page页数</u>，每个page对应一个数组成员。Large内存、Small内存都会占用page，正是通过这个数组标识改page属于哪个类型（最高两位用于标识page的分配类型）：\n    \n    - Large：01（0x40000000）\n    \n- Small：10（0x80000000）\n    \n      \n    \n      示例：申请12KB的内存，即3个page，内存池分配了page1，2，3，则map[1] = 0x400000000|3,如下图所示：\n      ![page的分配类型及页数](https://note.youdao.com/yws/api/personal/file/474A05B6CB2D401785FA0FAB75FB3E97?method=download&shareKey=a1ce9cdd22022755fffe79243bd1db0e)\n\npage分配时从第一个chunk开始遍历，依次查找各chunk是否有满足要求的page，如果当前chunk没有合适的，则进入下一chunk，如果直到最后都没有找到，则新分配一个chunk。\n<u>分配准则为：申请的page页数要尽可能地填满chunk的空隙</u>，也就是说尽可能的与分配了的page连在一起，避免中间出现page空隙。减少后续分配时的茶之后按次数，提高内存利用率。\n\n最优page的检索过程如下：\n- step1：  \n  首先从第一个page分组（page0~63）开始检查，如果当前分组无空闲page（即free_map[x]=-1）则进入下一分组，知道当前分组有空闲page，然后进入step2.\n- step2：  \n  当前分组有可用page，首先检查当前page分组的bit位，找到第一个空闲page的位置，记做page_num，接着继续向下查找空闲page，知道遇到第一个已经分配的page位置，将最后一个空闲page位置记做`end_page_num`。（*注：查找end_page_num时并不局限在当前page分组内，会向下查找，直到最后一页。其查找做成主要依据free_map*），page_num至end_page_num为找到的可用page，接着判断找到的page页数是否够用：\n  \n    - 不够的情况：将page_num至end_page_num这些page的bit位标为1，也就是已分配，然后回到step1继续检索其他page分组。\n    - 刚好是要申请的页数：直接使用，中断检索。\n    - page页数比申请的页数大，则表示可用，但不一定是最优的，将page_num暂存起来，接着回到step1继续向后找别的空闲page，最后比较选择best_len最小的，即能够最大程度填满page间隔\n\t  ```c\n\t\t\t\t/* find first 0 bit */\n\t\t\t\t // tmp为当前page分组的bit位，i为当前分组第1个page的页码。\n\t\t\t\tpage_num = i + zend_mm_bitset_nts(tmp);\n\t\t\t\t/* reset bits from 0 to \"bit\" */\n\t\t\t\ttmp &= tmp + 1;\n\t\t\t\t/* skip free blocks */\n\t\t\t\t// 快速跳过剩余page全部可用的分组\n\t\t\t\twhile (tmp == 0) {\n\t\t\t\t\ti += ZEND_MM_BITSET_LEN;\n\t\t\t\t\tif (i >= free_tail || i == ZEND_MM_PAGES) {\n\t\t\t\t\t\tlen = ZEND_MM_PAGES - page_num;\n\t\t\t\t\t\tif (len >= pages_count && len < best_len) {\n\t\t\t\t\t\t\tchunk->free_tail = page_num + pages_count;\n\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* set accurate value */\n\t\t\t\t\t\t\tchunk->free_tail = page_num;\n\t\t\t\t\t\t\tif (best > 0) {\n\t\t\t\t\t\t\t\tpage_num = best;\n\t\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto not_found;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 当前分组剩下的page都是可用的，直接跳到下一分组\n\t\t\t\t\ttmp = *(bitset++);\n\t\t\t\t}\n\t\t\t\t/* find first 1 bit */\n\t\t\t\t// 找到第一个已分配page\n\t\t\t\tlen = i + zend_mm_bitset_ntz(tmp) - page_num;\n\t\t\t\tif (len >= pages_count) {\n\t\t\t\t\tif (len == pages_count) {\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t} else if (len < best_len) {\n\t\t\t\t\t\tbest_len = len;\n\t\t\t\t\t\tbest = page_num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* set bits from 0 to \"bit\" */\n\t\t\t\t// 把找到的这些page标为已分配，注：此时tmp已经经过tmp &= tmp + 1处理\n  \t\t\ttmp |= tmp - 1;\n  ```\n示例：当前某个chunk的page分配情况如下图中的A所示，page：0，1，2，6，9，10已经分配占用，接下来要申请2页的page。\n  ![page的查找过程](https://note.youdao.com/yws/api/personal/file/335A8945237E483EAD280F5A26DED219?method=download&shareKey=29b8b43bfeb58653a22ace5a4562f538)\n- step3：\n   最后没找到合适的page页后设置对应page的分配信息，即free_map、map,然后返回找到第一页page的地址\n    ```c\n    found:\n\tif (steps > 2 && pages_count < 8) {\n\t\t/* move chunk into the head of the linked-list */\n\t\tchunk->prev->next = chunk->next;\n\t\tchunk->next->prev = chunk->prev;\n\t\tchunk->next = heap->main_chunk->next;\n\t\tchunk->prev = heap->main_chunk;\n\t\tchunk->prev->next = chunk;\n\t\tchunk->next->prev = chunk;\n\t}\n\t/* mark run as allocated */\n\tchunk->free_pages -= pages_count;\n\tzend_mm_bitset_set_range(chunk->free_map, page_num, pages_count);\n\tchunk->map[page_num] = ZEND_MM_LRUN(pages_count);\n\tif (page_num == chunk->free_tail) {\n\t\tchunk->free_tail = page_num + pages_count;\n\t}\n\treturn ZEND_MM_PAGE_ADDR(chunk, page_num);\n    ```\n   \n##### 3.3 Small分配\nSmall内存在分配时，首先检查申请规格的内存是否已经分配，如果没有分配或者分配的已经用完了，则申请相应页数的page，page的分配过成与Larg分配完全一致，申请到page以后按固定大小将page切割为slot，slot之间构成单链表，链表头部保存至`AG(mm_heap)->free_slot`；如果对应的slot已经分配，则直接返回`AG(mm_heap)->free_slot`。  \n\n示例：16byte、3072byte大小的slot，将分别申请1个、3个page、然后切割为256个16byte的slot，以及4个3072byte的slot，如下图所示：\n![slot[1]与slot[29]链表](https://note.youdao.com/yws/api/personal/file/4345829756E149EEAB1C4DE3928C76AC?method=download&shareKey=c358be1e7b73c1ff04ccac1eb772c992)\n\n#### 4 系统内存分配\n<u>内存池向系统申请内存的最小粒度是chunk</u>，通过mmap()来申请。\n\n#### 5 内存释放\n内存释放主要通过`efree()`来完成，内存池会根据释放的内存地址自动判断属于哪种粒度的内存，从而执行不同的释放逻辑。\n\n\n\n**问：内存池是如何只根据一个地址就判断出改地址属于哪种内存类型的呢？**  \n因为chunk分配时是按照ZEND_MM_CHUNK_SIZE（即2MB）对齐的，也就是chunk的起始内存地址一定是ZEND_MM_CHUNK_SIZE的整数倍，所以可以根据chunk上的任意位置知道chunk的起始位置与所在page。\n\n##### 5.1 Huge内存的释放\n首先，根据释放地址ptr计算该机制相对chunk起始位置的内存偏移量，这个值通过宏ZEND_MM_ALIGNED_OFFSET()的到，通过位运算计算的到。  \n\n示例：ptr = 0x7ffff7c01000，计算的到offset = 4096\n\n```\noffet = ptr & (alignment - 1) = 0x7ffff7c01000 & 0x1fffff = 0x1000 = 4096\n```\n\n<u>Huge内存能够完全使用chunk，也就是Huge内存地址相对chunk的offset一定等于0，而Large、Small内存因为chunk的第1个page被占用了，所以这两种内存的offset不可能为0.</u>\n\n内存池根据offset值判断出释放的内存是否为`Huge类型`，如果是则将占用的chunk释放，同时从AG(mm_heap)->huge_list链表中删除。\n\n##### 5.2 Large内存的释放\n若计算得到的offset不等于0，则表示该地址是Large内存或者Small内存，然后根据offset值进一步计算出属于第几个page   \n<u>计算方法：根据offset除page的大小取整，的到`page_num`，的到`page`页码后就可以从`chunk->map`中获取该`page`的分配类型，知道是何种粒度的内存了。</u>\n\nLarge内存，<u>并不会直接释放物理内存</u>，只是将对应的page的分配信息重新设置为未分配。若释放page后，<u>当前chunk下所有的page都是未分配的，则会释放chunk</u>，释放时优先选择把chunk移到`AG(mm_heap)->cached_chunks`缓存队列中，缓存数达到一定值后就不在继续缓存新加入的chunk，将内存归还系统，便面占用过多的资源。\n（分配chunk时，如果发现cached_chunks中有缓存的chunk,就直接取出使用，不再向系统申请。）\n\n##### 5.3 Small内存的释放\n若待释放的地址为Small内存，则会将释放的slot插入到该规格slot可用链表的头部，如下图所示：\n![释放slot](https://note.youdao.com/yws/api/personal/file/9141601D64BF4D76AF0A211F55A479A2?method=download&shareKey=7df69cd6f617df511be8d5f87c7a58f4)","source":"_posts/PHP7内核-内存管理-内存池.md","raw":"---\ntitle: PHP7内核-内存管理-内存池\ndate: 2020-08-25 14:29:45\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n#### 1 简介\n在C语言中，通常直接使用malloc进行内存的分配，而频繁的分配、释放内存无疑会产生内存碎片，降低系统性能。PHP自己实现了一套内存池（`ZendMM`：`Zend Memery Manager`）用于替换`glibc`的`malloc`、`free`，以解决内存频繁分配、释放的问题。\n\n<!--more-->\n\n内存池技术主要作用：\n- ①、减少内存分配及释放的次数\n- ②、有效控制内存碎片的产生\n\nPHP的内存池的实现参考了`tcmalloc`的设计，`tcmalloc`是`Google`开源的一个非常优秀的内存分配器。\n\n内存池是PHP内核中最底层的内存操作，他是非常独立的一个模块，可以移植到其他C语言应用中去。  \n\n\n\n**内存池定义了三种粒度的内存块**：\n\n- **chunk**：每个chunk的大小为2M\n- **page**：page的大小为4KB，每个chunk被切割为512个page（2048/4）\n- **slot**：一个或若干个page被切割为多个slot\n\n\n\n申请内存时按照不同的申请大小决定具体的分配策略：\n\n- **Huge(chunk)**:申请内存大于2MB，<u>直接调用系统分配</u>，分配若干个chunk.(>2MB)\n- **Large(page)**：申请内~~存大于3092B~~（即page大小的3/4, 4 * 1024 * 3/4 = 3072B）,小于2044KB（即511个page的大小），分配若干个page。(3072B~2044KB)\n- **Small(slot)**:申请内存小于等于3092B(即page大小的3/4)，<u>内存池提前定义好了30种同等大小的内存（8、16、24、32...3072）,它们分配在不同的page上（不同大小的内存可能会分配在多个连续的page），申请内存时直接在对应的page上查找可用的slot</u>。(<3092B)\n\n内存池通过**zend_mm_heap**结构存储内存池的主要信息，比如`大内存链表`、`chunk链表`、`slot各大小内存链表`等。\n```C\n// file:zend_alloc.c\n# define AG(v) (alloc_globals.v)\nstatic zend_alloc_globals alloc_globals;\n\n// file:zend_alloc.h\ntypedef struct _zend_mm_heap zend_mm_heap;\nstruct _zend_mm_heap {\n#if ZEND_MM_CUSTOM\n\tint                use_custom_heap;\n#endif\n#if ZEND_MM_STORAGE\n\tzend_mm_storage   *storage;\n#endif\n#if ZEND_MM_STAT\n    // 当前已使用的内存数\n\tsize_t             size;                    /* current memory usage */\n\t// 内存单次申请的峰值\n\tsize_t             peak;                    /* peak memory usage */\n#endif\n    // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部\n\tzend_mm_free_slot *free_slot[ZEND_MM_BINS]; /* free lists for small sizes */\n\n    ...\n\n    // 大内存链表\n\tzend_mm_huge_list *huge_list;               /* list of huge allocated blocks */\n    // 指向chunk链表头部\n\tzend_mm_chunk     *main_chunk;\n\t// 缓存的chunk链表\n\tzend_mm_chunk     *cached_chunks;\t\t\t/* list of unused chunks */\n\t// 已分配的chunk数\n\tint                chunks_count;\t\t\t/* number of alocated chunks */\n\t// 当前request使用chunk峰值\n\tint                peak_chunks_count;\t\t/* peak number of allocated chunks for current request */\n\t// 缓存的chunk数\n\tint                cached_chunks_count;\t\t/* number of cached chunks */\n\t// chunk使用均值，每次请求结束后会根据peak_chunk_count重新计算：(avg_chunks_count + peak_chunks_count)/2.0\n\tdouble             avg_chunks_count;\t\t/* average number of chunks allocated per request */\n\tint                last_chunks_delete_boundary; /* numer of chunks after last deletion */\n\tint                last_chunks_delete_count;    /* number of deletion over the last boundary */\n    ...\n};\n```\n大内存分配的是若干个chunk，然后通过一个`zend_mm_huge_list结构`进行管理，**大内存之间构成一个单向链表**。\n```c\n// file:zend_alloc.h\ntypedef struct  _zend_mm_huge_list zend_mm_huge_list;\n\nstruct _zend_mm_huge_list {\n\tvoid              *ptr;\n\tsize_t             size;\n\tzend_mm_huge_list *next;\n#if ZEND_DEBUG\n\tzend_mm_debug_info dbg;\n#endif\n};\n```\n![huge_list链表](https://note.youdao.com/yws/api/personal/file/48872B5FBB994E018B73A4AF38B466CE?method=download&shareKey=b96499c0e19a3b8b9803bcfe2f50d9eb)\n\n<u>chunk是内存池向系统申请、释放内存的最小粒度。</u>`chunk`之间构成双向链表，第一个chunk的地址保存于`zend_mm_heap->main_chunk`。\n\n每个chunk的大小为2MB，被切割为512个page，所以每个page的大小为4KB，其中第一个page的内存用于chunk自己的结构体成员，主要记录chunk的一些信息，比如前后chunk的指针，当前chunk上各个page的使用情况等。\n\nchunk的定义结构如下：\n```c\n// file:zend_alloc.c\nstruct _zend_mm_chunk {\n\tzend_mm_heap      *heap;\n\t// 指向下一个chunk\n\tzend_mm_chunk     *next;\n\t// 指向上一个chunk\n\tzend_mm_chunk     *prev;\n\t// 当前chunk的剩余可用page数\n\tint                free_pages;\t\t\t\t/* number of free pages */\n\tint                free_tail;               /* number of free pages at the end of chunk */\n\tint                num;\n\tchar               reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)];\n\t// heap结构，只有主chunk会用到（即第一个chunk）\n\tzend_mm_heap       heap_slot;               /* used only in main chunk */\n\t// 标识各page是否已使用的bitmap，总大小为512bit，对应page总数，每个page占一个bit位。\n\tzend_mm_page_map   free_map;                /* 512 bits or 64 bytes */\n\t// 各page的信息：当前page使用类型（用于large分配还是small）、占用的page数等\n\tzend_mm_page_info  map[ZEND_MM_PAGES];      /* 2 KB = 512 * 4 */\n};\n```\n\n\n\nslot内存是把若干个page按照固定大小分割好的内存块。\n\n**内存池定义了30中大小的slot内存**：8、16、24、32...1792、2048、3072.这些slot的大小是有规律的。\n- ①、最小的slot大小为8byte\n- ②、前8个slot一次递增8byte（0~7递增 8byte）\n- ③、后面每隔4个递增值乘以2（8~11递增16byte、12~15递增32byte、16~19递增64byte、20~23递增128byte、24~27递增256byte、28~30递增512byte）\n\n\n\n每种大小的slot占用的page数不相同的：\n- ①、slot0~15各占1个page\n\n- ②、slot16~29分别占5、3、1、1、5、3、2、2、5、3、7、4、5、3个page；  \n    注：这个值实际也是有规律可循的，其算法为，目的是为了减少内存的碎片。\n    ```\n    page的个数 = 最小公倍数(slot对应的内存大小, page的大小即4096) / 4096\n    ```\n\n    \n    分配各个规格的slot时会按照各这个配置申请对应的数量的page，然后进行分割组成链表。<u>相同大小的slot之间构成单链表</u>。\n```\nstruct _zend_mm_free_slot {\n\tzend_mm_free_slot *next_free_slot;\n};\n```\n\nheap、huge、chunk、page、slot之间的关系如下图所示：\n![heap、huge、chunk、page、slot结构关系](https://note.youdao.com/yws/api/personal/file/A8793900579C4D84A8CCE6E131F70B04?method=download&shareKey=7c1b42213c6357aae7855f4bcc43c78c)\n\n#### 2 内存池的初始化\n初始化过程主要是`分配heap结构`，<u>如果是多线程环境，则会为每一个线程分配一个内存池，线程之间互不影响</u>。\n\n注：<u>`zend_mm_heap`这个结构不是单独分配的，它嵌在`chunk`结构体中（即`heap_slot`成员）</u>。也就是说内存池初始化时是分配了一个chunk结构，`zend_mm_chunk->heap_slot`作为内存池的heap结构，这个chunk也是第一个chunk，即main_chunk,如下图所示：\n![zend_mm_heap结构的分配](https://note.youdao.com/yws/api/personal/file/1598F914D6D043A2928403E3B65280FE?method=download&shareKey=fa722c4892712fb681baea9ac6c93cf8)\n\n**问题：为什么内存时的heap结构要嵌在chunk中而不是单独分配呢？** \n因为每个chunk的第一个page始终是给chunk结构体自己使用的，剩下的511个page才会做内存分配，但是chunk结构体并不需要一个page那么大的内存。也就是说被占用的page会有剩余的空间，因此，为了尽可能利用空间，就将heap结构嵌在了chunk中。\n\n具体的分配过成在zend_mm_init()中实现：\n```c\n// file:zend_alloc.c\nstatic zend_mm_heap *zend_mm_init(void)\n{\n    // 向系统申请2MB大小的chunk\n\tzend_mm_chunk *chunk = (zend_mm_chunk*)zend_mm_chunk_alloc_int(ZEND_MM_CHUNK_SIZE, ZEND_MM_CHUNK_SIZE);\n\tzend_mm_heap *heap;\n\n\tif (UNEXPECTED(chunk == NULL)) {\n#if ZEND_MM_ERROR\n#ifdef _WIN32\n\t\tstderr_last_error(\"Can't initialize heap\");\n#else\n\t\tfprintf(stderr, \"\\nCan't initialize heap: [%d] %s\\n\", errno, strerror(errno));\n#endif\n#endif\n\t\treturn NULL;\n\t}\n\t// heap结构实际数主chunk嵌入的一个结构，后面再分配的chunk的heap_slot不再使用\n\theap = &chunk->heap_slot;\n\tchunk->heap = heap;\n\tchunk->next = chunk;\n\tchunk->prev = chunk;\n\t// 剩余可用page数\n\tchunk->free_pages = ZEND_MM_PAGES - ZEND_MM_FIRST_PAGE;\n\tchunk->free_tail = ZEND_MM_FIRST_PAGE;\n\tchunk->num = 0\n\t// 将第一个page的bit分配标识位设置为1，表示已经被分配、占用\n\tchunk->free_map[0] = (Z_L(1) << ZEND_MM_FIRST_PAGE) - 1;\n\t// 第一个page的类型为ZEND_MM_IS_LRUN,即large内存\n\tchunk->map[0] = ZEND_MM_LRUN(ZEND_MM_FIRST_PAGE);\n\t// 指向主chunk\n\theap->main_chunk = chunk;\n\t// 初始化剩下的一些成员\n\t...\n\t// huge内存链表\n\theap->huge_list = NULL;\n\treturn heap;\n}\n\n```\n\n#### 3 内存的分配\nHuge大内存的分配过程比较简单、而Large与Small内存分配涉及到page的查找操作，过程稍显复杂。\n\n使用`emalloc`申请时，内存池会按照申请内存的大小自动选择那种格内存进行分配，如下图所示：\n![内存的分配流程](https://note.youdao.com/yws/api/personal/file/1C273A1B04A44C379427B94CBE2A42FB?method=download&shareKey=d5059f5c0dafd673a661edf8efe31120)\n\n##### 3.1 Huge分配\nHuge是指超多2MB大小内存的分配，<u>实际分配时将对齐到n个chunk</u>，分配完还会分配一个zend_mm_huge_list结构，用于管理所有的Huge内存。\n```c\nstatic void *zend_mm_alloc_huge(zend_mm_heap *heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n#ifdef ZEND_WIN32\n\t/* On Windows we don't have ability to extend huge blocks in-place.\n\t * We allocate them with 2MB size granularity, to avoid many\n\t * reallocations when they are extended by small pieces\n\t */\n\t // 按页大小重置实际要分配的内存\n\tsize_t new_size = ZEND_MM_ALIGNED_SIZE_EX(size, MAX(REAL_PAGE_SIZE, ZEND_MM_CHUNK_SIZE));\n#else\n\tsize_t new_size = ZEND_MM_ALIGNED_SIZE_EX(size, REAL_PAGE_SIZE);\n#endif\n\tvoid *ptr;\n\n#if ZEND_MM_LIMIT\n    // 如果有内存使用限制，则检查是否已达上限，达到的话进行zend_mm_gc清理后再检查\n\tif (UNEXPECTED(heap->real_size + new_size > heap->limit)) {\n\t\tif (zend_mm_gc(heap) && heap->real_size + new_size <= heap->limit) {\n\t\t\t/* pass */\n\t\t} else if (heap->overflow == 0) {\n#if ZEND_DEBUG\n\t\t\tzend_mm_safe_error(heap, \"Allowed memory size of %zu bytes exhausted at %s:%d (tried to allocate %zu bytes)\", heap->limit, __zend_filename, __zend_lineno, size);\n#else\n\t\t\tzend_mm_safe_error(heap, \"Allowed memory size of %zu bytes exhausted (tried to allocate %zu bytes)\", heap->limit, size);\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n    // 分配chunk()，系统返回的地址是随机的，并不一定是ZEND_MM_CHUNK_ZIZE的整数倍，内存池需要自己移动到对齐的位置，比如：返回地址ptr是2000，而最近的一个对齐地址是2048，内存池会把ptr移动到2048，从这个位置使用。\n\tptr = zend_mm_chunk_alloc(heap, new_size, ZEND_MM_CHUNK_SIZE);\n   \n    ... \n    \n#if ZEND_DEBUG\n    // 将申请的内存通过zend_mm_huge_list插入到链表中\n\tzend_mm_add_huge_block(heap, ptr, new_size, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#else\n\tzend_mm_add_huge_block(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#endif\n    ...\n\treturn ptr;\n}\n```\n除了Huge分配以外，分配chunk内存也是Large、Small内存分配的基础，<u>它是ZendMM向系统申请内存的唯一粒度</u>。\n\n注：*分配chunk时，会将内存地址对齐到chunk的大小2MB（`ZEND_MM_THUNK_SIZE`）。也就是说，分配的chunk地址都是`ZEND_MM_THUNK_SIZE`的整数倍。（**实际上这个对齐并不是由系统简单的完成，而是需要内存池在申请内存后自己进行调整！**）*\n\n\n\n`ZendMM`具体处理对齐的方法是：\n\n- ①、按实际要申请的内存大小申请一次\n    - 若系统分配的地址恰好是ZEND_MM_CHUNK_SIZE的整数倍，则不需要调整，直接返回。\n    - 若系统分配的地址不是ZEND_MM_CHUNK_SIZE的整数倍，则需要使用第②步进行调整。\n- ②、调整方式：\n    - 首先ZendMM会将这块内存释放掉；\n    - 按照“`实际要申请的内存大小 + ZEND_MM_CHUNK_SIZE`”的大小重新申请一块内存，多申请的ZEND_MM_CHUNK大小的内存是用来调整的`，ZendMM`会从系统分配的地址向后偏移到最近一个`ZEND_MM_CHUNK_SIZE的整数倍`位置，调整完之后再把剩余的内存释放掉。\n\n```c\nstatic void *zend_mm_chunk_alloc_int(size_t size, size_t alignment)\n{\n    // 向系统申请size大小的内存\n\tvoid *ptr = zend_mm_mmap(size);\n\n\tif (ptr == NULL) {\n\t\treturn NULL;\n\t} else if (ZEND_MM_ALIGNED_OFFSET(ptr, alignment) == 0) { // 判断申请的内存是都为alignment的整数倍，是的话直接返回\n#ifdef MADV_HUGEPAGE\n\t    madvise(ptr, size, MADV_HUGEPAGE);\n#endif\n\t\treturn ptr;\n\t} else {\n\t    // 申请的内存不是按照alignment对齐的\n\t\tsize_t offset;\n\n\t\t// 将申请的内存释放掉重新申请\n\t\tzend_mm_munmap(ptr, size);\n\t\t// 重新申请一块内存，这里会多申请一块内存，用于截取到alignment的整数倍，可以忽略REAL_PAGE_SIZE\n\t\tptr = zend_mm_mmap(size + alignment - REAL_PAGE_SIZE);\n#ifdef _WIN32\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tzend_mm_munmap(ptr, size + alignment - REAL_PAGE_SIZE);\n\t\tptr = zend_mm_mmap_fixed((void*)((char*)ptr + (alignment - offset)), size);\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tif (offset != 0) {\n\t\t\tzend_mm_munmap(ptr, size);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ptr;\n#else\n        // offset为ptr距离上一个alignment对齐内存位置的大小，注意不能往前移，因为前面的内存都是分配了的。\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tif (offset != 0) {\n\t\t\toffset = alignment - offset;\n\t\t\tzend_mm_munmap(ptr, offset);\n\t\t\t// 偏移ptr，对齐到alignment\n\t\t\tptr = (char*)ptr + offset;\n\t\t\talignment -= offset;\n\t\t}\n\t\tif (alignment > REAL_PAGE_SIZE) {\n\t\t\tzend_mm_munmap((char*)ptr + size, alignment - REAL_PAGE_SIZE);\n\t\t}\n# ifdef MADV_HUGEPAGE\n\t    madvise(ptr, size, MADV_HUGEPAGE);\n# endif\n#endif\n\t\treturn ptr;\n\t}\n}\n```\n\n其中用到了`ZEND_MM_ALIGNED_OFFSET宏`，这个宏的作用是计算按alignment对齐的内存地址距离上一个alignment整数倍内存地址的大小，也就是offset偏移量。\n\n**alignment必须是2的n次方**，比如一段`n*alignment`大小的内存，ptr为其中一个位置，那么就可以通过位运算计算得到ptr在所属alignment内存块中的offset，如下图所示：\n\n```\n#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\\n\t(((size_t)(size)) & ((alignment) - 1))\n```\n![相对对齐值的内存offset](https://note.youdao.com/yws/api/personal/file/9940B8821F1E4B19B2783B68381DFD5C?method=download&shareKey=8e13fe6980c3aa04d6cf3c97f1522b9d)\n\n这个位运算是因为`alignment`为`2^n`（用二进制表示即为第n个位上为1，其余位为0，当alignment-1相当于将除了第n位为0，其余低位全部为1），所以通过alignment取到最低的位置，也就是相对上一个整数倍的alignment的offset，非位运算算式如下，但效率没有位运算高。\n```\noffset = ptr - (ptr/alignment取整 * alignment)\n```\n\n##### 3.2 Large分配\n当申请的内存大于3072B、小于2044KB时，内存池会选择在chunk上查找对应数量的page返回。<u>Large内存申请的粒度是page，也就是分配n页连续的page</u>，所以Large分配的过程就转化为在chunk上查找n页连续可用的page的过程。\n\n```c\nstatic zend_always_inline void *zend_mm_alloc_large(zend_mm_heap *heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n    // 根据size大小计算需要分配多少个page\n\tint pages_count = (int)ZEND_MM_SIZE_TO_NUM(size, ZEND_MM_PAGE_SIZE);\n#if ZEND_DEBUG\n    // 分配page_count个page\n\tvoid *ptr = zend_mm_alloc_pages(heap, pages_count, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#else\n\tvoid *ptr = zend_mm_alloc_pages(heap, pages_count ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#endif\n#if ZEND_MM_STAT\n\tdo {\n\t\tsize_t size = heap->size + pages_count * ZEND_MM_PAGE_SIZE;\n\t\tsize_t peak = MAX(heap->peak, size);\n\t\theap->size = size;\n\t\theap->peak = peak;\n\t} while (0);\n#endif\n\treturn ptr;\n}\n```\n\nchunk结构中有两个成员用于记录page分配信息：\n- **free_map**：类型为`zend_mm_page_map`，实际就是`zend_ulong_free_map[16/8]`，这是一个bitmap，总大小为64byte，也就是512bit，用于记录用当前chunk上512个page是否分配，512个page对应512bit，1表示已分配，0表示未分配。\n![free_map](https://note.youdao.com/yws/api/personal/file/C879457EC2154FAEA678D562C217773B?method=download&shareKey=29d90ba60d479fdeccd33ac88325813a)\n- **map**：这个是一个可容纳512个类型为uint32_t元素的数组，<u>该数组用于记录各page的分配类型及分配的page页数</u>，每个page对应一个数组成员。Large内存、Small内存都会占用page，正是通过这个数组标识改page属于哪个类型（最高两位用于标识page的分配类型）：\n    \n    - Large：01（0x40000000）\n    \n- Small：10（0x80000000）\n    \n      \n    \n      示例：申请12KB的内存，即3个page，内存池分配了page1，2，3，则map[1] = 0x400000000|3,如下图所示：\n      ![page的分配类型及页数](https://note.youdao.com/yws/api/personal/file/474A05B6CB2D401785FA0FAB75FB3E97?method=download&shareKey=a1ce9cdd22022755fffe79243bd1db0e)\n\npage分配时从第一个chunk开始遍历，依次查找各chunk是否有满足要求的page，如果当前chunk没有合适的，则进入下一chunk，如果直到最后都没有找到，则新分配一个chunk。\n<u>分配准则为：申请的page页数要尽可能地填满chunk的空隙</u>，也就是说尽可能的与分配了的page连在一起，避免中间出现page空隙。减少后续分配时的茶之后按次数，提高内存利用率。\n\n最优page的检索过程如下：\n- step1：  \n  首先从第一个page分组（page0~63）开始检查，如果当前分组无空闲page（即free_map[x]=-1）则进入下一分组，知道当前分组有空闲page，然后进入step2.\n- step2：  \n  当前分组有可用page，首先检查当前page分组的bit位，找到第一个空闲page的位置，记做page_num，接着继续向下查找空闲page，知道遇到第一个已经分配的page位置，将最后一个空闲page位置记做`end_page_num`。（*注：查找end_page_num时并不局限在当前page分组内，会向下查找，直到最后一页。其查找做成主要依据free_map*），page_num至end_page_num为找到的可用page，接着判断找到的page页数是否够用：\n  \n    - 不够的情况：将page_num至end_page_num这些page的bit位标为1，也就是已分配，然后回到step1继续检索其他page分组。\n    - 刚好是要申请的页数：直接使用，中断检索。\n    - page页数比申请的页数大，则表示可用，但不一定是最优的，将page_num暂存起来，接着回到step1继续向后找别的空闲page，最后比较选择best_len最小的，即能够最大程度填满page间隔\n\t  ```c\n\t\t\t\t/* find first 0 bit */\n\t\t\t\t // tmp为当前page分组的bit位，i为当前分组第1个page的页码。\n\t\t\t\tpage_num = i + zend_mm_bitset_nts(tmp);\n\t\t\t\t/* reset bits from 0 to \"bit\" */\n\t\t\t\ttmp &= tmp + 1;\n\t\t\t\t/* skip free blocks */\n\t\t\t\t// 快速跳过剩余page全部可用的分组\n\t\t\t\twhile (tmp == 0) {\n\t\t\t\t\ti += ZEND_MM_BITSET_LEN;\n\t\t\t\t\tif (i >= free_tail || i == ZEND_MM_PAGES) {\n\t\t\t\t\t\tlen = ZEND_MM_PAGES - page_num;\n\t\t\t\t\t\tif (len >= pages_count && len < best_len) {\n\t\t\t\t\t\t\tchunk->free_tail = page_num + pages_count;\n\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* set accurate value */\n\t\t\t\t\t\t\tchunk->free_tail = page_num;\n\t\t\t\t\t\t\tif (best > 0) {\n\t\t\t\t\t\t\t\tpage_num = best;\n\t\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto not_found;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 当前分组剩下的page都是可用的，直接跳到下一分组\n\t\t\t\t\ttmp = *(bitset++);\n\t\t\t\t}\n\t\t\t\t/* find first 1 bit */\n\t\t\t\t// 找到第一个已分配page\n\t\t\t\tlen = i + zend_mm_bitset_ntz(tmp) - page_num;\n\t\t\t\tif (len >= pages_count) {\n\t\t\t\t\tif (len == pages_count) {\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t} else if (len < best_len) {\n\t\t\t\t\t\tbest_len = len;\n\t\t\t\t\t\tbest = page_num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* set bits from 0 to \"bit\" */\n\t\t\t\t// 把找到的这些page标为已分配，注：此时tmp已经经过tmp &= tmp + 1处理\n  \t\t\ttmp |= tmp - 1;\n  ```\n示例：当前某个chunk的page分配情况如下图中的A所示，page：0，1，2，6，9，10已经分配占用，接下来要申请2页的page。\n  ![page的查找过程](https://note.youdao.com/yws/api/personal/file/335A8945237E483EAD280F5A26DED219?method=download&shareKey=29b8b43bfeb58653a22ace5a4562f538)\n- step3：\n   最后没找到合适的page页后设置对应page的分配信息，即free_map、map,然后返回找到第一页page的地址\n    ```c\n    found:\n\tif (steps > 2 && pages_count < 8) {\n\t\t/* move chunk into the head of the linked-list */\n\t\tchunk->prev->next = chunk->next;\n\t\tchunk->next->prev = chunk->prev;\n\t\tchunk->next = heap->main_chunk->next;\n\t\tchunk->prev = heap->main_chunk;\n\t\tchunk->prev->next = chunk;\n\t\tchunk->next->prev = chunk;\n\t}\n\t/* mark run as allocated */\n\tchunk->free_pages -= pages_count;\n\tzend_mm_bitset_set_range(chunk->free_map, page_num, pages_count);\n\tchunk->map[page_num] = ZEND_MM_LRUN(pages_count);\n\tif (page_num == chunk->free_tail) {\n\t\tchunk->free_tail = page_num + pages_count;\n\t}\n\treturn ZEND_MM_PAGE_ADDR(chunk, page_num);\n    ```\n   \n##### 3.3 Small分配\nSmall内存在分配时，首先检查申请规格的内存是否已经分配，如果没有分配或者分配的已经用完了，则申请相应页数的page，page的分配过成与Larg分配完全一致，申请到page以后按固定大小将page切割为slot，slot之间构成单链表，链表头部保存至`AG(mm_heap)->free_slot`；如果对应的slot已经分配，则直接返回`AG(mm_heap)->free_slot`。  \n\n示例：16byte、3072byte大小的slot，将分别申请1个、3个page、然后切割为256个16byte的slot，以及4个3072byte的slot，如下图所示：\n![slot[1]与slot[29]链表](https://note.youdao.com/yws/api/personal/file/4345829756E149EEAB1C4DE3928C76AC?method=download&shareKey=c358be1e7b73c1ff04ccac1eb772c992)\n\n#### 4 系统内存分配\n<u>内存池向系统申请内存的最小粒度是chunk</u>，通过mmap()来申请。\n\n#### 5 内存释放\n内存释放主要通过`efree()`来完成，内存池会根据释放的内存地址自动判断属于哪种粒度的内存，从而执行不同的释放逻辑。\n\n\n\n**问：内存池是如何只根据一个地址就判断出改地址属于哪种内存类型的呢？**  \n因为chunk分配时是按照ZEND_MM_CHUNK_SIZE（即2MB）对齐的，也就是chunk的起始内存地址一定是ZEND_MM_CHUNK_SIZE的整数倍，所以可以根据chunk上的任意位置知道chunk的起始位置与所在page。\n\n##### 5.1 Huge内存的释放\n首先，根据释放地址ptr计算该机制相对chunk起始位置的内存偏移量，这个值通过宏ZEND_MM_ALIGNED_OFFSET()的到，通过位运算计算的到。  \n\n示例：ptr = 0x7ffff7c01000，计算的到offset = 4096\n\n```\noffet = ptr & (alignment - 1) = 0x7ffff7c01000 & 0x1fffff = 0x1000 = 4096\n```\n\n<u>Huge内存能够完全使用chunk，也就是Huge内存地址相对chunk的offset一定等于0，而Large、Small内存因为chunk的第1个page被占用了，所以这两种内存的offset不可能为0.</u>\n\n内存池根据offset值判断出释放的内存是否为`Huge类型`，如果是则将占用的chunk释放，同时从AG(mm_heap)->huge_list链表中删除。\n\n##### 5.2 Large内存的释放\n若计算得到的offset不等于0，则表示该地址是Large内存或者Small内存，然后根据offset值进一步计算出属于第几个page   \n<u>计算方法：根据offset除page的大小取整，的到`page_num`，的到`page`页码后就可以从`chunk->map`中获取该`page`的分配类型，知道是何种粒度的内存了。</u>\n\nLarge内存，<u>并不会直接释放物理内存</u>，只是将对应的page的分配信息重新设置为未分配。若释放page后，<u>当前chunk下所有的page都是未分配的，则会释放chunk</u>，释放时优先选择把chunk移到`AG(mm_heap)->cached_chunks`缓存队列中，缓存数达到一定值后就不在继续缓存新加入的chunk，将内存归还系统，便面占用过多的资源。\n（分配chunk时，如果发现cached_chunks中有缓存的chunk,就直接取出使用，不再向系统申请。）\n\n##### 5.3 Small内存的释放\n若待释放的地址为Small内存，则会将释放的slot插入到该规格slot可用链表的头部，如下图所示：\n![释放slot](https://note.youdao.com/yws/api/personal/file/9141601D64BF4D76AF0A211F55A479A2?method=download&shareKey=7df69cd6f617df511be8d5f87c7a58f4)","slug":"PHP7内核-内存管理-内存池","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7ftg001i0sg3civ1fzxu","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>在C语言中，通常直接使用malloc进行内存的分配，而频繁的分配、释放内存无疑会产生内存碎片，降低系统性能。PHP自己实现了一套内存池（<code>ZendMM</code>：<code>Zend Memery Manager</code>）用于替换<code>glibc</code>的<code>malloc</code>、<code>free</code>，以解决内存频繁分配、释放的问题。</p>\n<a id=\"more\"></a>\n\n<p>内存池技术主要作用：</p>\n<ul>\n<li>①、减少内存分配及释放的次数</li>\n<li>②、有效控制内存碎片的产生</li>\n</ul>\n<p>PHP的内存池的实现参考了<code>tcmalloc</code>的设计，<code>tcmalloc</code>是<code>Google</code>开源的一个非常优秀的内存分配器。</p>\n<p>内存池是PHP内核中最底层的内存操作，他是非常独立的一个模块，可以移植到其他C语言应用中去。  </p>\n<p><strong>内存池定义了三种粒度的内存块</strong>：</p>\n<ul>\n<li><strong>chunk</strong>：每个chunk的大小为2M</li>\n<li><strong>page</strong>：page的大小为4KB，每个chunk被切割为512个page（2048/4）</li>\n<li><strong>slot</strong>：一个或若干个page被切割为多个slot</li>\n</ul>\n<p>申请内存时按照不同的申请大小决定具体的分配策略：</p>\n<ul>\n<li><strong>Huge(chunk)</strong>:申请内存大于2MB，<u>直接调用系统分配</u>，分配若干个chunk.(&gt;2MB)</li>\n<li>**Large(page)**：申请内<del>存大于3092B</del>（即page大小的3/4, 4 * 1024 * 3/4 = 3072B）,小于2044KB（即511个page的大小），分配若干个page。(3072B~2044KB)</li>\n<li><strong>Small(slot)</strong>:申请内存小于等于3092B(即page大小的3/4)，<u>内存池提前定义好了30种同等大小的内存（8、16、24、32…3072）,它们分配在不同的page上（不同大小的内存可能会分配在多个连续的page），申请内存时直接在对应的page上查找可用的slot</u>。(&lt;3092B)</li>\n</ul>\n<p>内存池通过<strong>zend_mm_heap</strong>结构存储内存池的主要信息，比如<code>大内存链表</code>、<code>chunk链表</code>、<code>slot各大小内存链表</code>等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> AG(v) (alloc_globals.v)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> zend_alloc_globals alloc_globals;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// file:zend_alloc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_heap</span> <span class=\"title\">zend_mm_heap</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_heap</span> &#123;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_CUSTOM</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                use_custom_heap;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STORAGE</span></span><br><span class=\"line\">\tzend_mm_storage   *storage;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STAT</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前已使用的内存数</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             size;                    <span class=\"comment\">/* current memory usage */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 内存单次申请的峰值</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             peak;                    <span class=\"comment\">/* peak memory usage */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部</span></span><br><span class=\"line\">\tzend_mm_free_slot *free_slot[ZEND_MM_BINS]; <span class=\"comment\">/* free lists for small sizes */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 大内存链表</span></span><br><span class=\"line\">\tzend_mm_huge_list *huge_list;               <span class=\"comment\">/* list of huge allocated blocks */</span></span><br><span class=\"line\">    <span class=\"comment\">// 指向chunk链表头部</span></span><br><span class=\"line\">\tzend_mm_chunk     *main_chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存的chunk链表</span></span><br><span class=\"line\">\tzend_mm_chunk     *cached_chunks;\t\t\t<span class=\"comment\">/* list of unused chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 已分配的chunk数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                chunks_count;\t\t\t<span class=\"comment\">/* number of alocated chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当前request使用chunk峰值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                peak_chunks_count;\t\t<span class=\"comment\">/* peak number of allocated chunks for current request */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 缓存的chunk数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                cached_chunks_count;\t\t<span class=\"comment\">/* number of cached chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// chunk使用均值，每次请求结束后会根据peak_chunk_count重新计算：(avg_chunks_count + peak_chunks_count)/2.0</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span>             avg_chunks_count;\t\t<span class=\"comment\">/* average number of chunks allocated per request */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                last_chunks_delete_boundary; <span class=\"comment\">/* numer of chunks after last deletion */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                last_chunks_delete_count;    <span class=\"comment\">/* number of deletion over the last boundary */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>大内存分配的是若干个chunk，然后通过一个<code>zend_mm_huge_list结构</code>进行管理，<strong>大内存之间构成一个单向链表</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>  _<span class=\"title\">zend_mm_huge_list</span> <span class=\"title\">zend_mm_huge_list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_huge_list</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>              *ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             size;</span><br><span class=\"line\">\tzend_mm_huge_list *next;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">\tzend_mm_debug_info dbg;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/48872B5FBB994E018B73A4AF38B466CE?method=download&shareKey=b96499c0e19a3b8b9803bcfe2f50d9eb\" alt=\"huge_list链表\"></p>\n<p><u>chunk是内存池向系统申请、释放内存的最小粒度。</u><code>chunk</code>之间构成双向链表，第一个chunk的地址保存于<code>zend_mm_heap-&gt;main_chunk</code>。</p>\n<p>每个chunk的大小为2MB，被切割为512个page，所以每个page的大小为4KB，其中第一个page的内存用于chunk自己的结构体成员，主要记录chunk的一些信息，比如前后chunk的指针，当前chunk上各个page的使用情况等。</p>\n<p>chunk的定义结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_chunk</span> &#123;</span></span><br><span class=\"line\">\tzend_mm_heap      *heap;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向下一个chunk</span></span><br><span class=\"line\">\tzend_mm_chunk     *next;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向上一个chunk</span></span><br><span class=\"line\">\tzend_mm_chunk     *prev;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前chunk的剩余可用page数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                free_pages;\t\t\t\t<span class=\"comment\">/* number of free pages */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                free_tail;               <span class=\"comment\">/* number of free pages at the end of chunk */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                num;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>               reserve[<span class=\"number\">64</span> - (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*) * <span class=\"number\">3</span> + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">3</span>)];</span><br><span class=\"line\">\t<span class=\"comment\">// heap结构，只有主chunk会用到（即第一个chunk）</span></span><br><span class=\"line\">\tzend_mm_heap       heap_slot;               <span class=\"comment\">/* used only in main chunk */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 标识各page是否已使用的bitmap，总大小为512bit，对应page总数，每个page占一个bit位。</span></span><br><span class=\"line\">\tzend_mm_page_map   free_map;                <span class=\"comment\">/* 512 bits or 64 bytes */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 各page的信息：当前page使用类型（用于large分配还是small）、占用的page数等</span></span><br><span class=\"line\">\tzend_mm_page_info  <span class=\"built_in\">map</span>[ZEND_MM_PAGES];      <span class=\"comment\">/* 2 KB = 512 * 4 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>slot内存是把若干个page按照固定大小分割好的内存块。</p>\n<p><strong>内存池定义了30中大小的slot内存</strong>：8、16、24、32…1792、2048、3072.这些slot的大小是有规律的。</p>\n<ul>\n<li>①、最小的slot大小为8byte</li>\n<li>②、前8个slot一次递增8byte（0~7递增 8byte）</li>\n<li>③、后面每隔4个递增值乘以2（8<del>11递增16byte、12</del>15递增32byte、16<del>19递增64byte、20</del>23递增128byte、24<del>27递增256byte、28</del>30递增512byte）</li>\n</ul>\n<p>每种大小的slot占用的page数不相同的：</p>\n<ul>\n<li><p>①、slot0~15各占1个page</p>\n</li>\n<li><p>②、slot16~29分别占5、3、1、1、5、3、2、2、5、3、7、4、5、3个page；<br>  注：这个值实际也是有规律可循的，其算法为，目的是为了减少内存的碎片。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page的个数 &#x3D; 最小公倍数(slot对应的内存大小, page的大小即4096) &#x2F; 4096</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<pre><code>分配各个规格的slot时会按照各这个配置申请对应的数量的page，然后进行分割组成链表。&lt;u&gt;相同大小的slot之间构成单链表&lt;/u&gt;。</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_mm_free_slot &#123;</span><br><span class=\"line\">\tzend_mm_free_slot *next_free_slot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>heap、huge、chunk、page、slot之间的关系如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/A8793900579C4D84A8CCE6E131F70B04?method=download&shareKey=7c1b42213c6357aae7855f4bcc43c78c\" alt=\"heap、huge、chunk、page、slot结构关系\"></p>\n<h4 id=\"2-内存池的初始化\"><a href=\"#2-内存池的初始化\" class=\"headerlink\" title=\"2 内存池的初始化\"></a>2 内存池的初始化</h4><p>初始化过程主要是<code>分配heap结构</code>，<u>如果是多线程环境，则会为每一个线程分配一个内存池，线程之间互不影响</u>。</p>\n<p>注：<u><code>zend_mm_heap</code>这个结构不是单独分配的，它嵌在<code>chunk</code>结构体中（即<code>heap_slot</code>成员）</u>。也就是说内存池初始化时是分配了一个chunk结构，<code>zend_mm_chunk-&gt;heap_slot</code>作为内存池的heap结构，这个chunk也是第一个chunk，即main_chunk,如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/1598F914D6D043A2928403E3B65280FE?method=download&shareKey=fa722c4892712fb681baea9ac6c93cf8\" alt=\"zend_mm_heap结构的分配\"></p>\n<p><strong>问题：为什么内存时的heap结构要嵌在chunk中而不是单独分配呢？</strong><br>因为每个chunk的第一个page始终是给chunk结构体自己使用的，剩下的511个page才会做内存分配，但是chunk结构体并不需要一个page那么大的内存。也就是说被占用的page会有剩余的空间，因此，为了尽可能利用空间，就将heap结构嵌在了chunk中。</p>\n<p>具体的分配过成在zend_mm_init()中实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_mm_heap *<span class=\"title\">zend_mm_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 向系统申请2MB大小的chunk</span></span><br><span class=\"line\">\tzend_mm_chunk *chunk = (zend_mm_chunk*)zend_mm_chunk_alloc_int(ZEND_MM_CHUNK_SIZE, ZEND_MM_CHUNK_SIZE);</span><br><span class=\"line\">\tzend_mm_heap *heap;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(chunk == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_ERROR</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _WIN32</span></span><br><span class=\"line\">\t\tstderr_last_error(<span class=\"string\">&quot;Can&#x27;t initialize heap&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;\\nCan&#x27;t initialize heap: [%d] %s\\n&quot;</span>, errno, strerror(errno));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// heap结构实际数主chunk嵌入的一个结构，后面再分配的chunk的heap_slot不再使用</span></span><br><span class=\"line\">\theap = &amp;chunk-&gt;heap_slot;</span><br><span class=\"line\">\tchunk-&gt;heap = heap;</span><br><span class=\"line\">\tchunk-&gt;next = chunk;</span><br><span class=\"line\">\tchunk-&gt;prev = chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 剩余可用page数</span></span><br><span class=\"line\">\tchunk-&gt;free_pages = ZEND_MM_PAGES - ZEND_MM_FIRST_PAGE;</span><br><span class=\"line\">\tchunk-&gt;free_tail = ZEND_MM_FIRST_PAGE;</span><br><span class=\"line\">\tchunk-&gt;num = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"comment\">// 将第一个page的bit分配标识位设置为1，表示已经被分配、占用</span></span><br><span class=\"line\">\tchunk-&gt;free_map[<span class=\"number\">0</span>] = (Z_L(<span class=\"number\">1</span>) &lt;&lt; ZEND_MM_FIRST_PAGE) - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一个page的类型为ZEND_MM_IS_LRUN,即large内存</span></span><br><span class=\"line\">\tchunk-&gt;<span class=\"built_in\">map</span>[<span class=\"number\">0</span>] = ZEND_MM_LRUN(ZEND_MM_FIRST_PAGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 指向主chunk</span></span><br><span class=\"line\">\theap-&gt;main_chunk = chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化剩下的一些成员</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// huge内存链表</span></span><br><span class=\"line\">\theap-&gt;huge_list = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-内存的分配\"><a href=\"#3-内存的分配\" class=\"headerlink\" title=\"3 内存的分配\"></a>3 内存的分配</h4><p>Huge大内存的分配过程比较简单、而Large与Small内存分配涉及到page的查找操作，过程稍显复杂。</p>\n<p>使用<code>emalloc</code>申请时，内存池会按照申请内存的大小自动选择那种格内存进行分配，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/1C273A1B04A44C379427B94CBE2A42FB?method=download&shareKey=d5059f5c0dafd673a661edf8efe31120\" alt=\"内存的分配流程\"></p>\n<h5 id=\"3-1-Huge分配\"><a href=\"#3-1-Huge分配\" class=\"headerlink\" title=\"3.1 Huge分配\"></a>3.1 Huge分配</h5><p>Huge是指超多2MB大小内存的分配，<u>实际分配时将对齐到n个chunk</u>，分配完还会分配一个zend_mm_huge_list结构，用于管理所有的Huge内存。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_alloc_huge</span><span class=\"params\">(zend_mm_heap *heap, <span class=\"keyword\">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ZEND_WIN32</span></span><br><span class=\"line\">\t<span class=\"comment\">/* On Windows we don&#x27;t have ability to extend huge blocks in-place.</span></span><br><span class=\"line\"><span class=\"comment\">\t * We allocate them with 2MB size granularity, to avoid many</span></span><br><span class=\"line\"><span class=\"comment\">\t * reallocations when they are extended by small pieces</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t <span class=\"comment\">// 按页大小重置实际要分配的内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> new_size = ZEND_MM_ALIGNED_SIZE_EX(size, MAX(REAL_PAGE_SIZE, ZEND_MM_CHUNK_SIZE));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> new_size = ZEND_MM_ALIGNED_SIZE_EX(size, REAL_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_LIMIT</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果有内存使用限制，则检查是否已达上限，达到的话进行zend_mm_gc清理后再检查</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(heap-&gt;real_size + new_size &gt; heap-&gt;limit)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (zend_mm_gc(heap) &amp;&amp; heap-&gt;real_size + new_size &lt;= heap-&gt;limit) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* pass */</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (heap-&gt;overflow == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">#<span class=\"keyword\">if</span> ZEND_DEBUG</span><br><span class=\"line\">\t\t\tzend_mm_safe_error(heap, <span class=\"string\">&quot;Allowed memory size of %zu bytes exhausted at %s:%d (tried to allocate %zu bytes)&quot;</span>, heap-&gt;limit, __zend_filename, __zend_lineno, size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\tzend_mm_safe_error(heap, <span class=\"string\">&quot;Allowed memory size of %zu bytes exhausted (tried to allocate %zu bytes)&quot;</span>, heap-&gt;limit, size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 分配chunk()，系统返回的地址是随机的，并不一定是ZEND_MM_CHUNK_ZIZE的整数倍，内存池需要自己移动到对齐的位置，比如：返回地址ptr是2000，而最近的一个对齐地址是2048，内存池会把ptr移动到2048，从这个位置使用。</span></span><br><span class=\"line\">\tptr = zend_mm_chunk_alloc(heap, new_size, ZEND_MM_CHUNK_SIZE);</span><br><span class=\"line\">   </span><br><span class=\"line\">    ... </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">    <span class=\"comment\">// 将申请的内存通过zend_mm_huge_list插入到链表中</span></span><br><span class=\"line\">\tzend_mm_add_huge_block(heap, ptr, new_size, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\tzend_mm_add_huge_block(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了Huge分配以外，分配chunk内存也是Large、Small内存分配的基础，<u>它是ZendMM向系统申请内存的唯一粒度</u>。</p>\n<p>注：<em>分配chunk时，会将内存地址对齐到chunk的大小2MB（<code>ZEND_MM_THUNK_SIZE</code>）。也就是说，分配的chunk地址都是<code>ZEND_MM_THUNK_SIZE</code>的整数倍。（<strong>实际上这个对齐并不是由系统简单的完成，而是需要内存池在申请内存后自己进行调整！</strong>）</em></p>\n<p><code>ZendMM</code>具体处理对齐的方法是：</p>\n<ul>\n<li>①、按实际要申请的内存大小申请一次<ul>\n<li>若系统分配的地址恰好是ZEND_MM_CHUNK_SIZE的整数倍，则不需要调整，直接返回。</li>\n<li>若系统分配的地址不是ZEND_MM_CHUNK_SIZE的整数倍，则需要使用第②步进行调整。</li>\n</ul>\n</li>\n<li>②、调整方式：<ul>\n<li>首先ZendMM会将这块内存释放掉；</li>\n<li>按照“<code>实际要申请的内存大小 + ZEND_MM_CHUNK_SIZE</code>”的大小重新申请一块内存，多申请的ZEND_MM_CHUNK大小的内存是用来调整的<code>，ZendMM</code>会从系统分配的地址向后偏移到最近一个<code>ZEND_MM_CHUNK_SIZE的整数倍</code>位置，调整完之后再把剩余的内存释放掉。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_chunk_alloc_int</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> alignment)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 向系统申请size大小的内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_mmap(size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ptr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ZEND_MM_ALIGNED_OFFSET(ptr, alignment) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 判断申请的内存是都为alignment的整数倍，是的话直接返回</span></span><br><span class=\"line\">#ifdef MADV_HUGEPAGE</span><br><span class=\"line\">\t    madvise(ptr, size, MADV_HUGEPAGE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 申请的内存不是按照alignment对齐的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> offset;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将申请的内存释放掉重新申请</span></span><br><span class=\"line\">\t\tzend_mm_munmap(ptr, size);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 重新申请一块内存，这里会多申请一块内存，用于截取到alignment的整数倍，可以忽略REAL_PAGE_SIZE</span></span><br><span class=\"line\">\t\tptr = zend_mm_mmap(size + alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _WIN32</span></span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\tzend_mm_munmap(ptr, size + alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\">\t\tptr = zend_mm_mmap_fixed((<span class=\"keyword\">void</span>*)((<span class=\"keyword\">char</span>*)ptr + (alignment - offset)), size);</span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (offset != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tzend_mm_munmap(ptr, size);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        <span class=\"comment\">// offset为ptr距离上一个alignment对齐内存位置的大小，注意不能往前移，因为前面的内存都是分配了的。</span></span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (offset != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\toffset = alignment - offset;</span><br><span class=\"line\">\t\t\tzend_mm_munmap(ptr, offset);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 偏移ptr，对齐到alignment</span></span><br><span class=\"line\">\t\t\tptr = (<span class=\"keyword\">char</span>*)ptr + offset;</span><br><span class=\"line\">\t\t\talignment -= offset;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (alignment &gt; REAL_PAGE_SIZE) &#123;</span><br><span class=\"line\">\t\t\tzend_mm_munmap((<span class=\"keyword\">char</span>*)ptr + size, alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">ifdef</span> MADV_HUGEPAGE</span></span><br><span class=\"line\">\t    madvise(ptr, size, MADV_HUGEPAGE);</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中用到了<code>ZEND_MM_ALIGNED_OFFSET宏</code>，这个宏的作用是计算按alignment对齐的内存地址距离上一个alignment整数倍内存地址的大小，也就是offset偏移量。</p>\n<p><strong>alignment必须是2的n次方</strong>，比如一段<code>n*alignment</code>大小的内存，ptr为其中一个位置，那么就可以通过位运算计算得到ptr在所属alignment内存块中的offset，如下图所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\</span><br><span class=\"line\">\t(((size_t)(size)) &amp; ((alignment) - 1))</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/9940B8821F1E4B19B2783B68381DFD5C?method=download&shareKey=8e13fe6980c3aa04d6cf3c97f1522b9d\" alt=\"相对对齐值的内存offset\"></p>\n<p>这个位运算是因为<code>alignment</code>为<code>2^n</code>（用二进制表示即为第n个位上为1，其余位为0，当alignment-1相当于将除了第n位为0，其余低位全部为1），所以通过alignment取到最低的位置，也就是相对上一个整数倍的alignment的offset，非位运算算式如下，但效率没有位运算高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offset &#x3D; ptr - (ptr&#x2F;alignment取整 * alignment)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-Large分配\"><a href=\"#3-2-Large分配\" class=\"headerlink\" title=\"3.2 Large分配\"></a>3.2 Large分配</h5><p>当申请的内存大于3072B、小于2044KB时，内存池会选择在chunk上查找对应数量的page返回。<u>Large内存申请的粒度是page，也就是分配n页连续的page</u>，所以Large分配的过程就转化为在chunk上查找n页连续可用的page的过程。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_alloc_large</span><span class=\"params\">(zend_mm_heap *heap, <span class=\"keyword\">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据size大小计算需要分配多少个page</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pages_count = (<span class=\"keyword\">int</span>)ZEND_MM_SIZE_TO_NUM(size, ZEND_MM_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">    <span class=\"comment\">// 分配page_count个page</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_alloc_pages(heap, pages_count, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_alloc_pages(heap, pages_count ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STAT</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> size = heap-&gt;size + pages_count * ZEND_MM_PAGE_SIZE;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> peak = MAX(heap-&gt;peak, size);</span><br><span class=\"line\">\t\theap-&gt;size = size;</span><br><span class=\"line\">\t\theap-&gt;peak = peak;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>chunk结构中有两个成员用于记录page分配信息：</p>\n<ul>\n<li><p><strong>free_map</strong>：类型为<code>zend_mm_page_map</code>，实际就是<code>zend_ulong_free_map[16/8]</code>，这是一个bitmap，总大小为64byte，也就是512bit，用于记录用当前chunk上512个page是否分配，512个page对应512bit，1表示已分配，0表示未分配。<br><img src=\"https://note.youdao.com/yws/api/personal/file/C879457EC2154FAEA678D562C217773B?method=download&shareKey=29d90ba60d479fdeccd33ac88325813a\" alt=\"free_map\"></p>\n</li>\n<li><p><strong>map</strong>：这个是一个可容纳512个类型为uint32_t元素的数组，<u>该数组用于记录各page的分配类型及分配的page页数</u>，每个page对应一个数组成员。Large内存、Small内存都会占用page，正是通过这个数组标识改page属于哪个类型（最高两位用于标识page的分配类型）：</p>\n<ul>\n<li>Large：01（0x40000000）</li>\n</ul>\n</li>\n<li><p>Small：10（0x80000000）</p>\n</li>\n</ul>\n<pre><code>  示例：申请12KB的内存，即3个page，内存池分配了page1，2，3，则map[1] = 0x400000000|3,如下图所示：\n  ![page的分配类型及页数](https://note.youdao.com/yws/api/personal/file/474A05B6CB2D401785FA0FAB75FB3E97?method=download&amp;shareKey=a1ce9cdd22022755fffe79243bd1db0e)</code></pre>\n<p>page分配时从第一个chunk开始遍历，依次查找各chunk是否有满足要求的page，如果当前chunk没有合适的，则进入下一chunk，如果直到最后都没有找到，则新分配一个chunk。<br><u>分配准则为：申请的page页数要尽可能地填满chunk的空隙</u>，也就是说尽可能的与分配了的page连在一起，避免中间出现page空隙。减少后续分配时的茶之后按次数，提高内存利用率。</p>\n<p>最优page的检索过程如下：</p>\n<ul>\n<li><p>step1：<br>首先从第一个page分组（page0~63）开始检查，如果当前分组无空闲page（即free_map[x]=-1）则进入下一分组，知道当前分组有空闲page，然后进入step2.</p>\n</li>\n<li><p>step2：<br>当前分组有可用page，首先检查当前page分组的bit位，找到第一个空闲page的位置，记做page_num，接着继续向下查找空闲page，知道遇到第一个已经分配的page位置，将最后一个空闲page位置记做<code>end_page_num</code>。（<em>注：查找end_page_num时并不局限在当前page分组内，会向下查找，直到最后一页。其查找做成主要依据free_map</em>），page_num至end_page_num为找到的可用page，接着判断找到的page页数是否够用：</p>\n<ul>\n<li>不够的情况：将page_num至end_page_num这些page的bit位标为1，也就是已分配，然后回到step1继续检索其他page分组。</li>\n<li>刚好是要申请的页数：直接使用，中断检索。</li>\n<li>page页数比申请的页数大，则表示可用，但不一定是最优的，将page_num暂存起来，接着回到step1继续向后找别的空闲page，最后比较选择best_len最小的，即能够最大程度填满page间隔<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* find first 0 bit */</span></span><br><span class=\"line\"> <span class=\"comment\">// tmp为当前page分组的bit位，i为当前分组第1个page的页码。</span></span><br><span class=\"line\">page_num = i + zend_mm_bitset_nts(tmp);</span><br><span class=\"line\"><span class=\"comment\">/* reset bits from 0 to &quot;bit&quot; */</span></span><br><span class=\"line\">tmp &amp;= tmp + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">/* skip free blocks */</span></span><br><span class=\"line\"><span class=\"comment\">// 快速跳过剩余page全部可用的分组</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (tmp == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\ti += ZEND_MM_BITSET_LEN;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i &gt;= free_tail || i == ZEND_MM_PAGES) &#123;</span><br><span class=\"line\">\t\tlen = ZEND_MM_PAGES - page_num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (len &gt;= pages_count &amp;&amp; len &lt; best_len) &#123;</span><br><span class=\"line\">\t\t\tchunk-&gt;free_tail = page_num + pages_count;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* set accurate value */</span></span><br><span class=\"line\">\t\t\tchunk-&gt;free_tail = page_num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (best &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tpage_num = best;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> not_found;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前分组剩下的page都是可用的，直接跳到下一分组</span></span><br><span class=\"line\">\ttmp = *(<span class=\"built_in\">bitset</span>++);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* find first 1 bit */</span></span><br><span class=\"line\"><span class=\"comment\">// 找到第一个已分配page</span></span><br><span class=\"line\">len = i + zend_mm_bitset_ntz(tmp) - page_num;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (len &gt;= pages_count) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (len == pages_count) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &lt; best_len) &#123;</span><br><span class=\"line\">\t\tbest_len = len;</span><br><span class=\"line\">\t\tbest = page_num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* set bits from 0 to &quot;bit&quot; */</span></span><br><span class=\"line\"><span class=\"comment\">// 把找到的这些page标为已分配，注：此时tmp已经经过tmp &amp;= tmp + 1处理</span></span><br><span class=\"line\">\ttmp |= tmp - <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n示例：当前某个chunk的page分配情况如下图中的A所示，page：0，1，2，6，9，10已经分配占用，接下来要申请2页的page。<br><img src=\"https://note.youdao.com/yws/api/personal/file/335A8945237E483EAD280F5A26DED219?method=download&shareKey=29b8b43bfeb58653a22ace5a4562f538\" alt=\"page的查找过程\"></li>\n</ul>\n</li>\n<li><p>step3：<br> 最后没找到合适的page页后设置对应page的分配信息，即free_map、map,然后返回找到第一页page的地址</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   found:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (steps &gt; <span class=\"number\">2</span> &amp;&amp; pages_count &lt; <span class=\"number\">8</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* move chunk into the head of the linked-list */</span></span><br><span class=\"line\">\tchunk-&gt;prev-&gt;next = chunk-&gt;next;</span><br><span class=\"line\">\tchunk-&gt;next-&gt;prev = chunk-&gt;prev;</span><br><span class=\"line\">\tchunk-&gt;next = heap-&gt;main_chunk-&gt;next;</span><br><span class=\"line\">\tchunk-&gt;prev = heap-&gt;main_chunk;</span><br><span class=\"line\">\tchunk-&gt;prev-&gt;next = chunk;</span><br><span class=\"line\">\tchunk-&gt;next-&gt;prev = chunk;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* mark run as allocated */</span></span><br><span class=\"line\">chunk-&gt;free_pages -= pages_count;</span><br><span class=\"line\">zend_mm_bitset_set_range(chunk-&gt;free_map, page_num, pages_count);</span><br><span class=\"line\">chunk-&gt;<span class=\"built_in\">map</span>[page_num] = ZEND_MM_LRUN(pages_count);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (page_num == chunk-&gt;free_tail) &#123;</span><br><span class=\"line\">\tchunk-&gt;free_tail = page_num + pages_count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ZEND_MM_PAGE_ADDR(chunk, page_num);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h5 id=\"3-3-Small分配\"><a href=\"#3-3-Small分配\" class=\"headerlink\" title=\"3.3 Small分配\"></a>3.3 Small分配</h5><p>Small内存在分配时，首先检查申请规格的内存是否已经分配，如果没有分配或者分配的已经用完了，则申请相应页数的page，page的分配过成与Larg分配完全一致，申请到page以后按固定大小将page切割为slot，slot之间构成单链表，链表头部保存至<code>AG(mm_heap)-&gt;free_slot</code>；如果对应的slot已经分配，则直接返回<code>AG(mm_heap)-&gt;free_slot</code>。  </p>\n<p>示例：16byte、3072byte大小的slot，将分别申请1个、3个page、然后切割为256个16byte的slot，以及4个3072byte的slot，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/4345829756E149EEAB1C4DE3928C76AC?method=download&shareKey=c358be1e7b73c1ff04ccac1eb772c992\" alt=\"slot[1]与slot[29]链表\"></p>\n<h4 id=\"4-系统内存分配\"><a href=\"#4-系统内存分配\" class=\"headerlink\" title=\"4 系统内存分配\"></a>4 系统内存分配</h4><p><u>内存池向系统申请内存的最小粒度是chunk</u>，通过mmap()来申请。</p>\n<h4 id=\"5-内存释放\"><a href=\"#5-内存释放\" class=\"headerlink\" title=\"5 内存释放\"></a>5 内存释放</h4><p>内存释放主要通过<code>efree()</code>来完成，内存池会根据释放的内存地址自动判断属于哪种粒度的内存，从而执行不同的释放逻辑。</p>\n<p><strong>问：内存池是如何只根据一个地址就判断出改地址属于哪种内存类型的呢？</strong><br>因为chunk分配时是按照ZEND_MM_CHUNK_SIZE（即2MB）对齐的，也就是chunk的起始内存地址一定是ZEND_MM_CHUNK_SIZE的整数倍，所以可以根据chunk上的任意位置知道chunk的起始位置与所在page。</p>\n<h5 id=\"5-1-Huge内存的释放\"><a href=\"#5-1-Huge内存的释放\" class=\"headerlink\" title=\"5.1 Huge内存的释放\"></a>5.1 Huge内存的释放</h5><p>首先，根据释放地址ptr计算该机制相对chunk起始位置的内存偏移量，这个值通过宏ZEND_MM_ALIGNED_OFFSET()的到，通过位运算计算的到。  </p>\n<p>示例：ptr = 0x7ffff7c01000，计算的到offset = 4096</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offet &#x3D; ptr &amp; (alignment - 1) &#x3D; 0x7ffff7c01000 &amp; 0x1fffff &#x3D; 0x1000 &#x3D; 4096</span><br></pre></td></tr></table></figure>\n\n<p><u>Huge内存能够完全使用chunk，也就是Huge内存地址相对chunk的offset一定等于0，而Large、Small内存因为chunk的第1个page被占用了，所以这两种内存的offset不可能为0.</u></p>\n<p>内存池根据offset值判断出释放的内存是否为<code>Huge类型</code>，如果是则将占用的chunk释放，同时从AG(mm_heap)-&gt;huge_list链表中删除。</p>\n<h5 id=\"5-2-Large内存的释放\"><a href=\"#5-2-Large内存的释放\" class=\"headerlink\" title=\"5.2 Large内存的释放\"></a>5.2 Large内存的释放</h5><p>若计算得到的offset不等于0，则表示该地址是Large内存或者Small内存，然后根据offset值进一步计算出属于第几个page<br><u>计算方法：根据offset除page的大小取整，的到<code>page_num</code>，的到<code>page</code>页码后就可以从<code>chunk-&gt;map</code>中获取该<code>page</code>的分配类型，知道是何种粒度的内存了。</u></p>\n<p>Large内存，<u>并不会直接释放物理内存</u>，只是将对应的page的分配信息重新设置为未分配。若释放page后，<u>当前chunk下所有的page都是未分配的，则会释放chunk</u>，释放时优先选择把chunk移到<code>AG(mm_heap)-&gt;cached_chunks</code>缓存队列中，缓存数达到一定值后就不在继续缓存新加入的chunk，将内存归还系统，便面占用过多的资源。<br>（分配chunk时，如果发现cached_chunks中有缓存的chunk,就直接取出使用，不再向系统申请。）</p>\n<h5 id=\"5-3-Small内存的释放\"><a href=\"#5-3-Small内存的释放\" class=\"headerlink\" title=\"5.3 Small内存的释放\"></a>5.3 Small内存的释放</h5><p>若待释放的地址为Small内存，则会将释放的slot插入到该规格slot可用链表的头部，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/9141601D64BF4D76AF0A211F55A479A2?method=download&shareKey=7df69cd6f617df511be8d5f87c7a58f4\" alt=\"释放slot\"></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>在C语言中，通常直接使用malloc进行内存的分配，而频繁的分配、释放内存无疑会产生内存碎片，降低系统性能。PHP自己实现了一套内存池（<code>ZendMM</code>：<code>Zend Memery Manager</code>）用于替换<code>glibc</code>的<code>malloc</code>、<code>free</code>，以解决内存频繁分配、释放的问题。</p>","more":"<p>内存池技术主要作用：</p>\n<ul>\n<li>①、减少内存分配及释放的次数</li>\n<li>②、有效控制内存碎片的产生</li>\n</ul>\n<p>PHP的内存池的实现参考了<code>tcmalloc</code>的设计，<code>tcmalloc</code>是<code>Google</code>开源的一个非常优秀的内存分配器。</p>\n<p>内存池是PHP内核中最底层的内存操作，他是非常独立的一个模块，可以移植到其他C语言应用中去。  </p>\n<p><strong>内存池定义了三种粒度的内存块</strong>：</p>\n<ul>\n<li><strong>chunk</strong>：每个chunk的大小为2M</li>\n<li><strong>page</strong>：page的大小为4KB，每个chunk被切割为512个page（2048/4）</li>\n<li><strong>slot</strong>：一个或若干个page被切割为多个slot</li>\n</ul>\n<p>申请内存时按照不同的申请大小决定具体的分配策略：</p>\n<ul>\n<li><strong>Huge(chunk)</strong>:申请内存大于2MB，<u>直接调用系统分配</u>，分配若干个chunk.(&gt;2MB)</li>\n<li>**Large(page)**：申请内<del>存大于3092B</del>（即page大小的3/4, 4 * 1024 * 3/4 = 3072B）,小于2044KB（即511个page的大小），分配若干个page。(3072B~2044KB)</li>\n<li><strong>Small(slot)</strong>:申请内存小于等于3092B(即page大小的3/4)，<u>内存池提前定义好了30种同等大小的内存（8、16、24、32…3072）,它们分配在不同的page上（不同大小的内存可能会分配在多个连续的page），申请内存时直接在对应的page上查找可用的slot</u>。(&lt;3092B)</li>\n</ul>\n<p>内存池通过<strong>zend_mm_heap</strong>结构存储内存池的主要信息，比如<code>大内存链表</code>、<code>chunk链表</code>、<code>slot各大小内存链表</code>等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> AG(v) (alloc_globals.v)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> zend_alloc_globals alloc_globals;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// file:zend_alloc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_heap</span> <span class=\"title\">zend_mm_heap</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_heap</span> &#123;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_CUSTOM</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                use_custom_heap;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STORAGE</span></span><br><span class=\"line\">\tzend_mm_storage   *storage;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STAT</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前已使用的内存数</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             size;                    <span class=\"comment\">/* current memory usage */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 内存单次申请的峰值</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             peak;                    <span class=\"comment\">/* peak memory usage */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部</span></span><br><span class=\"line\">\tzend_mm_free_slot *free_slot[ZEND_MM_BINS]; <span class=\"comment\">/* free lists for small sizes */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 大内存链表</span></span><br><span class=\"line\">\tzend_mm_huge_list *huge_list;               <span class=\"comment\">/* list of huge allocated blocks */</span></span><br><span class=\"line\">    <span class=\"comment\">// 指向chunk链表头部</span></span><br><span class=\"line\">\tzend_mm_chunk     *main_chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存的chunk链表</span></span><br><span class=\"line\">\tzend_mm_chunk     *cached_chunks;\t\t\t<span class=\"comment\">/* list of unused chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 已分配的chunk数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                chunks_count;\t\t\t<span class=\"comment\">/* number of alocated chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当前request使用chunk峰值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                peak_chunks_count;\t\t<span class=\"comment\">/* peak number of allocated chunks for current request */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 缓存的chunk数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                cached_chunks_count;\t\t<span class=\"comment\">/* number of cached chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// chunk使用均值，每次请求结束后会根据peak_chunk_count重新计算：(avg_chunks_count + peak_chunks_count)/2.0</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span>             avg_chunks_count;\t\t<span class=\"comment\">/* average number of chunks allocated per request */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                last_chunks_delete_boundary; <span class=\"comment\">/* numer of chunks after last deletion */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                last_chunks_delete_count;    <span class=\"comment\">/* number of deletion over the last boundary */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>大内存分配的是若干个chunk，然后通过一个<code>zend_mm_huge_list结构</code>进行管理，<strong>大内存之间构成一个单向链表</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>  _<span class=\"title\">zend_mm_huge_list</span> <span class=\"title\">zend_mm_huge_list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_huge_list</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>              *ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             size;</span><br><span class=\"line\">\tzend_mm_huge_list *next;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">\tzend_mm_debug_info dbg;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/48872B5FBB994E018B73A4AF38B466CE?method=download&shareKey=b96499c0e19a3b8b9803bcfe2f50d9eb\" alt=\"huge_list链表\"></p>\n<p><u>chunk是内存池向系统申请、释放内存的最小粒度。</u><code>chunk</code>之间构成双向链表，第一个chunk的地址保存于<code>zend_mm_heap-&gt;main_chunk</code>。</p>\n<p>每个chunk的大小为2MB，被切割为512个page，所以每个page的大小为4KB，其中第一个page的内存用于chunk自己的结构体成员，主要记录chunk的一些信息，比如前后chunk的指针，当前chunk上各个page的使用情况等。</p>\n<p>chunk的定义结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_chunk</span> &#123;</span></span><br><span class=\"line\">\tzend_mm_heap      *heap;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向下一个chunk</span></span><br><span class=\"line\">\tzend_mm_chunk     *next;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向上一个chunk</span></span><br><span class=\"line\">\tzend_mm_chunk     *prev;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前chunk的剩余可用page数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                free_pages;\t\t\t\t<span class=\"comment\">/* number of free pages */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                free_tail;               <span class=\"comment\">/* number of free pages at the end of chunk */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                num;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>               reserve[<span class=\"number\">64</span> - (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*) * <span class=\"number\">3</span> + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">3</span>)];</span><br><span class=\"line\">\t<span class=\"comment\">// heap结构，只有主chunk会用到（即第一个chunk）</span></span><br><span class=\"line\">\tzend_mm_heap       heap_slot;               <span class=\"comment\">/* used only in main chunk */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 标识各page是否已使用的bitmap，总大小为512bit，对应page总数，每个page占一个bit位。</span></span><br><span class=\"line\">\tzend_mm_page_map   free_map;                <span class=\"comment\">/* 512 bits or 64 bytes */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 各page的信息：当前page使用类型（用于large分配还是small）、占用的page数等</span></span><br><span class=\"line\">\tzend_mm_page_info  <span class=\"built_in\">map</span>[ZEND_MM_PAGES];      <span class=\"comment\">/* 2 KB = 512 * 4 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>slot内存是把若干个page按照固定大小分割好的内存块。</p>\n<p><strong>内存池定义了30中大小的slot内存</strong>：8、16、24、32…1792、2048、3072.这些slot的大小是有规律的。</p>\n<ul>\n<li>①、最小的slot大小为8byte</li>\n<li>②、前8个slot一次递增8byte（0~7递增 8byte）</li>\n<li>③、后面每隔4个递增值乘以2（8<del>11递增16byte、12</del>15递增32byte、16<del>19递增64byte、20</del>23递增128byte、24<del>27递增256byte、28</del>30递增512byte）</li>\n</ul>\n<p>每种大小的slot占用的page数不相同的：</p>\n<ul>\n<li><p>①、slot0~15各占1个page</p>\n</li>\n<li><p>②、slot16~29分别占5、3、1、1、5、3、2、2、5、3、7、4、5、3个page；<br>  注：这个值实际也是有规律可循的，其算法为，目的是为了减少内存的碎片。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page的个数 &#x3D; 最小公倍数(slot对应的内存大小, page的大小即4096) &#x2F; 4096</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<pre><code>分配各个规格的slot时会按照各这个配置申请对应的数量的page，然后进行分割组成链表。&lt;u&gt;相同大小的slot之间构成单链表&lt;/u&gt;。</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_mm_free_slot &#123;</span><br><span class=\"line\">\tzend_mm_free_slot *next_free_slot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>heap、huge、chunk、page、slot之间的关系如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/A8793900579C4D84A8CCE6E131F70B04?method=download&shareKey=7c1b42213c6357aae7855f4bcc43c78c\" alt=\"heap、huge、chunk、page、slot结构关系\"></p>\n<h4 id=\"2-内存池的初始化\"><a href=\"#2-内存池的初始化\" class=\"headerlink\" title=\"2 内存池的初始化\"></a>2 内存池的初始化</h4><p>初始化过程主要是<code>分配heap结构</code>，<u>如果是多线程环境，则会为每一个线程分配一个内存池，线程之间互不影响</u>。</p>\n<p>注：<u><code>zend_mm_heap</code>这个结构不是单独分配的，它嵌在<code>chunk</code>结构体中（即<code>heap_slot</code>成员）</u>。也就是说内存池初始化时是分配了一个chunk结构，<code>zend_mm_chunk-&gt;heap_slot</code>作为内存池的heap结构，这个chunk也是第一个chunk，即main_chunk,如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/1598F914D6D043A2928403E3B65280FE?method=download&shareKey=fa722c4892712fb681baea9ac6c93cf8\" alt=\"zend_mm_heap结构的分配\"></p>\n<p><strong>问题：为什么内存时的heap结构要嵌在chunk中而不是单独分配呢？</strong><br>因为每个chunk的第一个page始终是给chunk结构体自己使用的，剩下的511个page才会做内存分配，但是chunk结构体并不需要一个page那么大的内存。也就是说被占用的page会有剩余的空间，因此，为了尽可能利用空间，就将heap结构嵌在了chunk中。</p>\n<p>具体的分配过成在zend_mm_init()中实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_mm_heap *<span class=\"title\">zend_mm_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 向系统申请2MB大小的chunk</span></span><br><span class=\"line\">\tzend_mm_chunk *chunk = (zend_mm_chunk*)zend_mm_chunk_alloc_int(ZEND_MM_CHUNK_SIZE, ZEND_MM_CHUNK_SIZE);</span><br><span class=\"line\">\tzend_mm_heap *heap;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(chunk == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_ERROR</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _WIN32</span></span><br><span class=\"line\">\t\tstderr_last_error(<span class=\"string\">&quot;Can&#x27;t initialize heap&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;\\nCan&#x27;t initialize heap: [%d] %s\\n&quot;</span>, errno, strerror(errno));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// heap结构实际数主chunk嵌入的一个结构，后面再分配的chunk的heap_slot不再使用</span></span><br><span class=\"line\">\theap = &amp;chunk-&gt;heap_slot;</span><br><span class=\"line\">\tchunk-&gt;heap = heap;</span><br><span class=\"line\">\tchunk-&gt;next = chunk;</span><br><span class=\"line\">\tchunk-&gt;prev = chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 剩余可用page数</span></span><br><span class=\"line\">\tchunk-&gt;free_pages = ZEND_MM_PAGES - ZEND_MM_FIRST_PAGE;</span><br><span class=\"line\">\tchunk-&gt;free_tail = ZEND_MM_FIRST_PAGE;</span><br><span class=\"line\">\tchunk-&gt;num = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"comment\">// 将第一个page的bit分配标识位设置为1，表示已经被分配、占用</span></span><br><span class=\"line\">\tchunk-&gt;free_map[<span class=\"number\">0</span>] = (Z_L(<span class=\"number\">1</span>) &lt;&lt; ZEND_MM_FIRST_PAGE) - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一个page的类型为ZEND_MM_IS_LRUN,即large内存</span></span><br><span class=\"line\">\tchunk-&gt;<span class=\"built_in\">map</span>[<span class=\"number\">0</span>] = ZEND_MM_LRUN(ZEND_MM_FIRST_PAGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 指向主chunk</span></span><br><span class=\"line\">\theap-&gt;main_chunk = chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化剩下的一些成员</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// huge内存链表</span></span><br><span class=\"line\">\theap-&gt;huge_list = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-内存的分配\"><a href=\"#3-内存的分配\" class=\"headerlink\" title=\"3 内存的分配\"></a>3 内存的分配</h4><p>Huge大内存的分配过程比较简单、而Large与Small内存分配涉及到page的查找操作，过程稍显复杂。</p>\n<p>使用<code>emalloc</code>申请时，内存池会按照申请内存的大小自动选择那种格内存进行分配，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/1C273A1B04A44C379427B94CBE2A42FB?method=download&shareKey=d5059f5c0dafd673a661edf8efe31120\" alt=\"内存的分配流程\"></p>\n<h5 id=\"3-1-Huge分配\"><a href=\"#3-1-Huge分配\" class=\"headerlink\" title=\"3.1 Huge分配\"></a>3.1 Huge分配</h5><p>Huge是指超多2MB大小内存的分配，<u>实际分配时将对齐到n个chunk</u>，分配完还会分配一个zend_mm_huge_list结构，用于管理所有的Huge内存。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_alloc_huge</span><span class=\"params\">(zend_mm_heap *heap, <span class=\"keyword\">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ZEND_WIN32</span></span><br><span class=\"line\">\t<span class=\"comment\">/* On Windows we don&#x27;t have ability to extend huge blocks in-place.</span></span><br><span class=\"line\"><span class=\"comment\">\t * We allocate them with 2MB size granularity, to avoid many</span></span><br><span class=\"line\"><span class=\"comment\">\t * reallocations when they are extended by small pieces</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t <span class=\"comment\">// 按页大小重置实际要分配的内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> new_size = ZEND_MM_ALIGNED_SIZE_EX(size, MAX(REAL_PAGE_SIZE, ZEND_MM_CHUNK_SIZE));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> new_size = ZEND_MM_ALIGNED_SIZE_EX(size, REAL_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_LIMIT</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果有内存使用限制，则检查是否已达上限，达到的话进行zend_mm_gc清理后再检查</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(heap-&gt;real_size + new_size &gt; heap-&gt;limit)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (zend_mm_gc(heap) &amp;&amp; heap-&gt;real_size + new_size &lt;= heap-&gt;limit) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* pass */</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (heap-&gt;overflow == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">#<span class=\"keyword\">if</span> ZEND_DEBUG</span><br><span class=\"line\">\t\t\tzend_mm_safe_error(heap, <span class=\"string\">&quot;Allowed memory size of %zu bytes exhausted at %s:%d (tried to allocate %zu bytes)&quot;</span>, heap-&gt;limit, __zend_filename, __zend_lineno, size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\tzend_mm_safe_error(heap, <span class=\"string\">&quot;Allowed memory size of %zu bytes exhausted (tried to allocate %zu bytes)&quot;</span>, heap-&gt;limit, size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 分配chunk()，系统返回的地址是随机的，并不一定是ZEND_MM_CHUNK_ZIZE的整数倍，内存池需要自己移动到对齐的位置，比如：返回地址ptr是2000，而最近的一个对齐地址是2048，内存池会把ptr移动到2048，从这个位置使用。</span></span><br><span class=\"line\">\tptr = zend_mm_chunk_alloc(heap, new_size, ZEND_MM_CHUNK_SIZE);</span><br><span class=\"line\">   </span><br><span class=\"line\">    ... </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">    <span class=\"comment\">// 将申请的内存通过zend_mm_huge_list插入到链表中</span></span><br><span class=\"line\">\tzend_mm_add_huge_block(heap, ptr, new_size, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\tzend_mm_add_huge_block(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了Huge分配以外，分配chunk内存也是Large、Small内存分配的基础，<u>它是ZendMM向系统申请内存的唯一粒度</u>。</p>\n<p>注：<em>分配chunk时，会将内存地址对齐到chunk的大小2MB（<code>ZEND_MM_THUNK_SIZE</code>）。也就是说，分配的chunk地址都是<code>ZEND_MM_THUNK_SIZE</code>的整数倍。（<strong>实际上这个对齐并不是由系统简单的完成，而是需要内存池在申请内存后自己进行调整！</strong>）</em></p>\n<p><code>ZendMM</code>具体处理对齐的方法是：</p>\n<ul>\n<li>①、按实际要申请的内存大小申请一次<ul>\n<li>若系统分配的地址恰好是ZEND_MM_CHUNK_SIZE的整数倍，则不需要调整，直接返回。</li>\n<li>若系统分配的地址不是ZEND_MM_CHUNK_SIZE的整数倍，则需要使用第②步进行调整。</li>\n</ul>\n</li>\n<li>②、调整方式：<ul>\n<li>首先ZendMM会将这块内存释放掉；</li>\n<li>按照“<code>实际要申请的内存大小 + ZEND_MM_CHUNK_SIZE</code>”的大小重新申请一块内存，多申请的ZEND_MM_CHUNK大小的内存是用来调整的<code>，ZendMM</code>会从系统分配的地址向后偏移到最近一个<code>ZEND_MM_CHUNK_SIZE的整数倍</code>位置，调整完之后再把剩余的内存释放掉。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_chunk_alloc_int</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> alignment)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 向系统申请size大小的内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_mmap(size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ptr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ZEND_MM_ALIGNED_OFFSET(ptr, alignment) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 判断申请的内存是都为alignment的整数倍，是的话直接返回</span></span><br><span class=\"line\">#ifdef MADV_HUGEPAGE</span><br><span class=\"line\">\t    madvise(ptr, size, MADV_HUGEPAGE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 申请的内存不是按照alignment对齐的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> offset;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将申请的内存释放掉重新申请</span></span><br><span class=\"line\">\t\tzend_mm_munmap(ptr, size);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 重新申请一块内存，这里会多申请一块内存，用于截取到alignment的整数倍，可以忽略REAL_PAGE_SIZE</span></span><br><span class=\"line\">\t\tptr = zend_mm_mmap(size + alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _WIN32</span></span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\tzend_mm_munmap(ptr, size + alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\">\t\tptr = zend_mm_mmap_fixed((<span class=\"keyword\">void</span>*)((<span class=\"keyword\">char</span>*)ptr + (alignment - offset)), size);</span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (offset != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tzend_mm_munmap(ptr, size);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        <span class=\"comment\">// offset为ptr距离上一个alignment对齐内存位置的大小，注意不能往前移，因为前面的内存都是分配了的。</span></span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (offset != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\toffset = alignment - offset;</span><br><span class=\"line\">\t\t\tzend_mm_munmap(ptr, offset);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 偏移ptr，对齐到alignment</span></span><br><span class=\"line\">\t\t\tptr = (<span class=\"keyword\">char</span>*)ptr + offset;</span><br><span class=\"line\">\t\t\talignment -= offset;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (alignment &gt; REAL_PAGE_SIZE) &#123;</span><br><span class=\"line\">\t\t\tzend_mm_munmap((<span class=\"keyword\">char</span>*)ptr + size, alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">ifdef</span> MADV_HUGEPAGE</span></span><br><span class=\"line\">\t    madvise(ptr, size, MADV_HUGEPAGE);</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中用到了<code>ZEND_MM_ALIGNED_OFFSET宏</code>，这个宏的作用是计算按alignment对齐的内存地址距离上一个alignment整数倍内存地址的大小，也就是offset偏移量。</p>\n<p><strong>alignment必须是2的n次方</strong>，比如一段<code>n*alignment</code>大小的内存，ptr为其中一个位置，那么就可以通过位运算计算得到ptr在所属alignment内存块中的offset，如下图所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\</span><br><span class=\"line\">\t(((size_t)(size)) &amp; ((alignment) - 1))</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/9940B8821F1E4B19B2783B68381DFD5C?method=download&shareKey=8e13fe6980c3aa04d6cf3c97f1522b9d\" alt=\"相对对齐值的内存offset\"></p>\n<p>这个位运算是因为<code>alignment</code>为<code>2^n</code>（用二进制表示即为第n个位上为1，其余位为0，当alignment-1相当于将除了第n位为0，其余低位全部为1），所以通过alignment取到最低的位置，也就是相对上一个整数倍的alignment的offset，非位运算算式如下，但效率没有位运算高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offset &#x3D; ptr - (ptr&#x2F;alignment取整 * alignment)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-Large分配\"><a href=\"#3-2-Large分配\" class=\"headerlink\" title=\"3.2 Large分配\"></a>3.2 Large分配</h5><p>当申请的内存大于3072B、小于2044KB时，内存池会选择在chunk上查找对应数量的page返回。<u>Large内存申请的粒度是page，也就是分配n页连续的page</u>，所以Large分配的过程就转化为在chunk上查找n页连续可用的page的过程。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_alloc_large</span><span class=\"params\">(zend_mm_heap *heap, <span class=\"keyword\">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据size大小计算需要分配多少个page</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pages_count = (<span class=\"keyword\">int</span>)ZEND_MM_SIZE_TO_NUM(size, ZEND_MM_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">    <span class=\"comment\">// 分配page_count个page</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_alloc_pages(heap, pages_count, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_alloc_pages(heap, pages_count ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STAT</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> size = heap-&gt;size + pages_count * ZEND_MM_PAGE_SIZE;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> peak = MAX(heap-&gt;peak, size);</span><br><span class=\"line\">\t\theap-&gt;size = size;</span><br><span class=\"line\">\t\theap-&gt;peak = peak;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>chunk结构中有两个成员用于记录page分配信息：</p>\n<ul>\n<li><p><strong>free_map</strong>：类型为<code>zend_mm_page_map</code>，实际就是<code>zend_ulong_free_map[16/8]</code>，这是一个bitmap，总大小为64byte，也就是512bit，用于记录用当前chunk上512个page是否分配，512个page对应512bit，1表示已分配，0表示未分配。<br><img src=\"https://note.youdao.com/yws/api/personal/file/C879457EC2154FAEA678D562C217773B?method=download&shareKey=29d90ba60d479fdeccd33ac88325813a\" alt=\"free_map\"></p>\n</li>\n<li><p><strong>map</strong>：这个是一个可容纳512个类型为uint32_t元素的数组，<u>该数组用于记录各page的分配类型及分配的page页数</u>，每个page对应一个数组成员。Large内存、Small内存都会占用page，正是通过这个数组标识改page属于哪个类型（最高两位用于标识page的分配类型）：</p>\n<ul>\n<li>Large：01（0x40000000）</li>\n</ul>\n</li>\n<li><p>Small：10（0x80000000）</p>\n</li>\n</ul>\n<pre><code>  示例：申请12KB的内存，即3个page，内存池分配了page1，2，3，则map[1] = 0x400000000|3,如下图所示：\n  ![page的分配类型及页数](https://note.youdao.com/yws/api/personal/file/474A05B6CB2D401785FA0FAB75FB3E97?method=download&amp;shareKey=a1ce9cdd22022755fffe79243bd1db0e)</code></pre>\n<p>page分配时从第一个chunk开始遍历，依次查找各chunk是否有满足要求的page，如果当前chunk没有合适的，则进入下一chunk，如果直到最后都没有找到，则新分配一个chunk。<br><u>分配准则为：申请的page页数要尽可能地填满chunk的空隙</u>，也就是说尽可能的与分配了的page连在一起，避免中间出现page空隙。减少后续分配时的茶之后按次数，提高内存利用率。</p>\n<p>最优page的检索过程如下：</p>\n<ul>\n<li><p>step1：<br>首先从第一个page分组（page0~63）开始检查，如果当前分组无空闲page（即free_map[x]=-1）则进入下一分组，知道当前分组有空闲page，然后进入step2.</p>\n</li>\n<li><p>step2：<br>当前分组有可用page，首先检查当前page分组的bit位，找到第一个空闲page的位置，记做page_num，接着继续向下查找空闲page，知道遇到第一个已经分配的page位置，将最后一个空闲page位置记做<code>end_page_num</code>。（<em>注：查找end_page_num时并不局限在当前page分组内，会向下查找，直到最后一页。其查找做成主要依据free_map</em>），page_num至end_page_num为找到的可用page，接着判断找到的page页数是否够用：</p>\n<ul>\n<li>不够的情况：将page_num至end_page_num这些page的bit位标为1，也就是已分配，然后回到step1继续检索其他page分组。</li>\n<li>刚好是要申请的页数：直接使用，中断检索。</li>\n<li>page页数比申请的页数大，则表示可用，但不一定是最优的，将page_num暂存起来，接着回到step1继续向后找别的空闲page，最后比较选择best_len最小的，即能够最大程度填满page间隔<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* find first 0 bit */</span></span><br><span class=\"line\"> <span class=\"comment\">// tmp为当前page分组的bit位，i为当前分组第1个page的页码。</span></span><br><span class=\"line\">page_num = i + zend_mm_bitset_nts(tmp);</span><br><span class=\"line\"><span class=\"comment\">/* reset bits from 0 to &quot;bit&quot; */</span></span><br><span class=\"line\">tmp &amp;= tmp + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">/* skip free blocks */</span></span><br><span class=\"line\"><span class=\"comment\">// 快速跳过剩余page全部可用的分组</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (tmp == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\ti += ZEND_MM_BITSET_LEN;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i &gt;= free_tail || i == ZEND_MM_PAGES) &#123;</span><br><span class=\"line\">\t\tlen = ZEND_MM_PAGES - page_num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (len &gt;= pages_count &amp;&amp; len &lt; best_len) &#123;</span><br><span class=\"line\">\t\t\tchunk-&gt;free_tail = page_num + pages_count;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* set accurate value */</span></span><br><span class=\"line\">\t\t\tchunk-&gt;free_tail = page_num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (best &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tpage_num = best;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> not_found;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前分组剩下的page都是可用的，直接跳到下一分组</span></span><br><span class=\"line\">\ttmp = *(<span class=\"built_in\">bitset</span>++);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* find first 1 bit */</span></span><br><span class=\"line\"><span class=\"comment\">// 找到第一个已分配page</span></span><br><span class=\"line\">len = i + zend_mm_bitset_ntz(tmp) - page_num;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (len &gt;= pages_count) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (len == pages_count) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &lt; best_len) &#123;</span><br><span class=\"line\">\t\tbest_len = len;</span><br><span class=\"line\">\t\tbest = page_num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* set bits from 0 to &quot;bit&quot; */</span></span><br><span class=\"line\"><span class=\"comment\">// 把找到的这些page标为已分配，注：此时tmp已经经过tmp &amp;= tmp + 1处理</span></span><br><span class=\"line\">\ttmp |= tmp - <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n示例：当前某个chunk的page分配情况如下图中的A所示，page：0，1，2，6，9，10已经分配占用，接下来要申请2页的page。<br><img src=\"https://note.youdao.com/yws/api/personal/file/335A8945237E483EAD280F5A26DED219?method=download&shareKey=29b8b43bfeb58653a22ace5a4562f538\" alt=\"page的查找过程\"></li>\n</ul>\n</li>\n<li><p>step3：<br> 最后没找到合适的page页后设置对应page的分配信息，即free_map、map,然后返回找到第一页page的地址</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   found:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (steps &gt; <span class=\"number\">2</span> &amp;&amp; pages_count &lt; <span class=\"number\">8</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* move chunk into the head of the linked-list */</span></span><br><span class=\"line\">\tchunk-&gt;prev-&gt;next = chunk-&gt;next;</span><br><span class=\"line\">\tchunk-&gt;next-&gt;prev = chunk-&gt;prev;</span><br><span class=\"line\">\tchunk-&gt;next = heap-&gt;main_chunk-&gt;next;</span><br><span class=\"line\">\tchunk-&gt;prev = heap-&gt;main_chunk;</span><br><span class=\"line\">\tchunk-&gt;prev-&gt;next = chunk;</span><br><span class=\"line\">\tchunk-&gt;next-&gt;prev = chunk;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* mark run as allocated */</span></span><br><span class=\"line\">chunk-&gt;free_pages -= pages_count;</span><br><span class=\"line\">zend_mm_bitset_set_range(chunk-&gt;free_map, page_num, pages_count);</span><br><span class=\"line\">chunk-&gt;<span class=\"built_in\">map</span>[page_num] = ZEND_MM_LRUN(pages_count);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (page_num == chunk-&gt;free_tail) &#123;</span><br><span class=\"line\">\tchunk-&gt;free_tail = page_num + pages_count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ZEND_MM_PAGE_ADDR(chunk, page_num);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h5 id=\"3-3-Small分配\"><a href=\"#3-3-Small分配\" class=\"headerlink\" title=\"3.3 Small分配\"></a>3.3 Small分配</h5><p>Small内存在分配时，首先检查申请规格的内存是否已经分配，如果没有分配或者分配的已经用完了，则申请相应页数的page，page的分配过成与Larg分配完全一致，申请到page以后按固定大小将page切割为slot，slot之间构成单链表，链表头部保存至<code>AG(mm_heap)-&gt;free_slot</code>；如果对应的slot已经分配，则直接返回<code>AG(mm_heap)-&gt;free_slot</code>。  </p>\n<p>示例：16byte、3072byte大小的slot，将分别申请1个、3个page、然后切割为256个16byte的slot，以及4个3072byte的slot，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/4345829756E149EEAB1C4DE3928C76AC?method=download&shareKey=c358be1e7b73c1ff04ccac1eb772c992\" alt=\"slot[1]与slot[29]链表\"></p>\n<h4 id=\"4-系统内存分配\"><a href=\"#4-系统内存分配\" class=\"headerlink\" title=\"4 系统内存分配\"></a>4 系统内存分配</h4><p><u>内存池向系统申请内存的最小粒度是chunk</u>，通过mmap()来申请。</p>\n<h4 id=\"5-内存释放\"><a href=\"#5-内存释放\" class=\"headerlink\" title=\"5 内存释放\"></a>5 内存释放</h4><p>内存释放主要通过<code>efree()</code>来完成，内存池会根据释放的内存地址自动判断属于哪种粒度的内存，从而执行不同的释放逻辑。</p>\n<p><strong>问：内存池是如何只根据一个地址就判断出改地址属于哪种内存类型的呢？</strong><br>因为chunk分配时是按照ZEND_MM_CHUNK_SIZE（即2MB）对齐的，也就是chunk的起始内存地址一定是ZEND_MM_CHUNK_SIZE的整数倍，所以可以根据chunk上的任意位置知道chunk的起始位置与所在page。</p>\n<h5 id=\"5-1-Huge内存的释放\"><a href=\"#5-1-Huge内存的释放\" class=\"headerlink\" title=\"5.1 Huge内存的释放\"></a>5.1 Huge内存的释放</h5><p>首先，根据释放地址ptr计算该机制相对chunk起始位置的内存偏移量，这个值通过宏ZEND_MM_ALIGNED_OFFSET()的到，通过位运算计算的到。  </p>\n<p>示例：ptr = 0x7ffff7c01000，计算的到offset = 4096</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offet &#x3D; ptr &amp; (alignment - 1) &#x3D; 0x7ffff7c01000 &amp; 0x1fffff &#x3D; 0x1000 &#x3D; 4096</span><br></pre></td></tr></table></figure>\n\n<p><u>Huge内存能够完全使用chunk，也就是Huge内存地址相对chunk的offset一定等于0，而Large、Small内存因为chunk的第1个page被占用了，所以这两种内存的offset不可能为0.</u></p>\n<p>内存池根据offset值判断出释放的内存是否为<code>Huge类型</code>，如果是则将占用的chunk释放，同时从AG(mm_heap)-&gt;huge_list链表中删除。</p>\n<h5 id=\"5-2-Large内存的释放\"><a href=\"#5-2-Large内存的释放\" class=\"headerlink\" title=\"5.2 Large内存的释放\"></a>5.2 Large内存的释放</h5><p>若计算得到的offset不等于0，则表示该地址是Large内存或者Small内存，然后根据offset值进一步计算出属于第几个page<br><u>计算方法：根据offset除page的大小取整，的到<code>page_num</code>，的到<code>page</code>页码后就可以从<code>chunk-&gt;map</code>中获取该<code>page</code>的分配类型，知道是何种粒度的内存了。</u></p>\n<p>Large内存，<u>并不会直接释放物理内存</u>，只是将对应的page的分配信息重新设置为未分配。若释放page后，<u>当前chunk下所有的page都是未分配的，则会释放chunk</u>，释放时优先选择把chunk移到<code>AG(mm_heap)-&gt;cached_chunks</code>缓存队列中，缓存数达到一定值后就不在继续缓存新加入的chunk，将内存归还系统，便面占用过多的资源。<br>（分配chunk时，如果发现cached_chunks中有缓存的chunk,就直接取出使用，不再向系统申请。）</p>\n<h5 id=\"5-3-Small内存的释放\"><a href=\"#5-3-Small内存的释放\" class=\"headerlink\" title=\"5.3 Small内存的释放\"></a>5.3 Small内存的释放</h5><p>若待释放的地址为Small内存，则会将释放的slot插入到该规格slot可用链表的头部，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/9141601D64BF4D76AF0A211F55A479A2?method=download&shareKey=7df69cd6f617df511be8d5f87c7a58f4\" alt=\"释放slot\"></p>"},{"title":"PHP7内核-变量","date":"2020-08-21T08:28:40.000Z","_content":"\n\n\n#### 变量的内部实现\n​\t\t变量是一个语言实现的基础，变量有两个组成部分：变量名、变量值，PHP中可以将其对应为：`zval`、`zend_value`，这两个概念一定要区分开，PHP中变量的内存是通过`引用计数`进行管理的，而且**PHP7中引用计数是在`zend_value`而不是zval上，变量之间的传递、赋值通常也是针对zend_value**。\n\n<!--more-->\n\nPHP中可以通过`$关键词`定义一个变量：`$a;`，在定义的同时可以进行初始化：`$a = \"hi~\";`<u>注意这实际是两步：定义、初始化</u>，只定义一个变量也是可以的，可以不给它赋值，比如：\n\n```php\n$a;\n$b = 1;\n```\n这段代码在执行时会分配两个zval。\n\n#### 变量的基础结构\n```c\n//zend_types.h\ntypedef struct _zval_struct     zval;\nstruct _zval_struct {\n    zend_value        value; //变量实际的value\n    union {\n        struct {\n            ZEND_ENDIAN_LOHI_4(  //这个是为了兼容大小字节序，小字节序就是下面的顺序，大字节序则下面4个顺序翻转\n                zend_uchar    type,         //变量类型\n                zend_uchar    type_flags,  //类型掩码，不同的类型会有不同的几种属性，内存管理会用到\n                zend_uchar    const_flags,\n                zend_uchar    reserved)     //call info，zend执行流程会用到\n        } v;\n        uint32_t type_info; //上面4个值的组合值，可以直接根据type_info取到4个对应位置的值\n    } u1;\n    union {\n        uint32_t     var_flags;\n        uint32_t     next;                 //哈希表中解决哈希冲突时用到\n        uint32_t     cache_slot;           /* literal cache slot 运行时缓存会用到*/ \n        uint32_t     lineno;               /* line number (for ast nodes) */\n        uint32_t     num_args;             /* arguments number for EX(This) */\n        uint32_t     fe_pos;               /* foreach position foreach遍历时会用到*/\n        uint32_t     fe_iter_idx;          /* foreach iterator index */\n    } u2; //一些辅助值\n};\n```\n`\t\tzval`结构比较简单，内嵌一个union类型的`zend_value`保存具体变量类型的值或指针，zval中还有两个union：`u1`、`u2`:\n\n- **u1**: 它是联合了一个结构体`v`和一个32位无符号整型`type_info`；ZEND_ENDIAN_LOHI_4是一个宏，用于解决字节序问题的，他会根据系统字节序决定struct v中4个成员的顺序。v定义了4个成员变量，**变量的类型就通过u1.v.type区分**；另外一个值`type_flags`为类型掩码，在变量的内存管理、gc机制中会用到；至于后面两个const_flags、reserved暂且不管。\n- **u2**: 这个值纯粹是个辅助值，zval结构中value、u1分别占了8byte、4byte，一共12byte，假如zval只有:value、u1两个值，整个zval的大小也会对齐到16byte，既然不管有没有u2大小都是16byte，把多余的4byte拿出来用于一些特殊用途还是很划算的，比如next在哈希表解决哈希冲突时会用到，还有fe_pos在foreach会用到......  \n\n```c\ntypedef union _zend_value {\n    zend_long         lval;    //int整形\n    double            dval;    //浮点型\n    zend_refcounted  *counted;\n    zend_string      *str;     //string字符串\n    zend_array       *arr;     //array数组\n    zend_object      *obj;     //object对象\n    zend_resource    *res;     //resource资源类型\n    zend_reference   *ref;     //引用类型，通过&$var_name定义的\n    zend_ast_ref     *ast;     //下面几个都是内核使用的value\n    zval             *zv;\n    void             *ptr;\n    zend_class_entry *ce;\n    zend_function    *func;\n    struct {\n        uint32_t w1;\n        uint32_t w2;\n    } ww;\n} zend_value;\n\n```\n​\t\t`zend_value`是一个联合体，各个类型根据自己的类型选择使用不同的成员，**从zend_value可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构**。zend_value中没有布尔型，这是因为PHP7中将布尔型具体拆分为了true、false两种类型，通过zval.u1.v.type进行区分（注：老版本中，布尔型是通过整型进行区分的）\n\n#### 类型\n`zval.u1.type`类型：\n\n```c\n/* regular data types */\n#define IS_UNDEF                    0\n#define IS_NULL                     1\n#define IS_FALSE                    2\n#define IS_TRUE                     3\n#define IS_LONG                     4\n#define IS_DOUBLE                   5\n#define IS_STRING                   6\n#define IS_ARRAY                    7\n#define IS_OBJECT                   8\n#define IS_RESOURCE                 9\n#define IS_REFERENCE                10\n\n/* constant expressions */\n#define IS_CONSTANT                 11\n#define IS_CONSTANT_AST             12\n\n/* fake types */\n#define _IS_BOOL                    13\n#define IS_CALLABLE                 14\n\n/* internal types */\n#define IS_INDIRECT                 15\n#define IS_PTR                      17\n```\n\n##### 标量类型\n- 没有value，直接根据type区分的类型：`true`、`false`、`null`\n- 值存于value中，无需额外的value指针：`zend_long`、 `double`\n\n##### 字符串（zend_string）\n​\t\tPHP中没有使用`char`来表示字符串，而是为字符串单独定义了一个结构`zend_string`，其中除了存储字符串内容，还存储了其他信息。\n```c\nstruct _zend_string {\n    zend_refcounted_h gc; // 变量引用计数信息，用于内存管理。比如当前value的引用数，所有用到引用计数的变量类型都会有这个结构\n    zend_ulong        h;  /* hash value 哈希值，数组中计算索引时会用到*/\n    size_t            len; // 字符串长度，通过这个值保证二进制安全\n    char              val[1]; // 字符串内容，变长struct，分配时按len长度申请内存\n};\n```\n​\t\t字符串内容`val`是一个可变数组，在字符串分配时的操作为`malloc(sizeof(zend_string) + 字符串长度)`。\n*注：val中多出一个字节（val[1]而不是val[0]）用于存储字符串的最后一个字符\"\\0\".*\n\n例如：$a=\"abc\"，对应zend_string内存结构如下：\n![zend_string内存结构](https://note.youdao.com/yws/api/personal/file/39A4055CBC584591A643CF8855653427?method=download&shareKey=100018cf52486ade9a25e3f4d8227678)\n\n\n字符串具体分类：\n- `IS_STR_PERSISTENT`: 通过malloc分配。\n- `IS_STR_INTERNED`: php代码中写的一些字面量，如函数名、变量名。\n- `IS_STR_PERMERNENT`:永久值，生命周期大于request。\n- `IS_STR_CONSTANT`:常量。\n- `IS_STR_CONSTANT_UNQUALIFIED`:这个信息通过flag保存：zval.value->gc.u.flags\n\n##### 数组（array）\n​\t\t`Array`是PHP中非常强大的一个数据结构，它的**底层实现为散列表（HashTable 哈希表）**。\n​\t\t散列表是根据`key`直接进行访问的数据结构，它的`key-value`之间有一个映射函数，可以根据key通过映射函数直接索引到对应的value值，直接根据`“内存起始地址+偏移值”`进行寻址，加快查找速度。理想情况下，查找的期望时间复杂度为O(1).\n\n\n\nHashTable的数据结构如下:\n\n```c\ntypedef struct _zend_array HashTable;\n\nstruct _zend_array {\n    zend_refcounted_h gc; //引用计数信息，与字符串相同\n    // 提供一些辅助的功能，比如，flag用来设置散列表的一些属性，是否持久化、是否已经初始化。\n    union {\n        struct {\n            ZEND_ENDIAN_LOHI_4(\n                zend_uchar    flags,\n                zend_uchar    nApplyCount,\n                zend_uchar    nIteratorsCount,\n                zend_uchar    reserve)\n        } v;\n        uint32_t flags;\n    } u;\n    // 用于散列函数映射存储元素在arData数组中的下标。其值实际是nTableSize的负数，即nTableMask=-nTableSize（nTableMask=~nTableSize+1）\n    uint32_t          nTableMask; //计算bucket索引时的掩码\n    // 存储元素数组，每个元素的结构统一为Bucket，其内存是连续的，arData指向第一个Bucket（即指向数组的起始位置）\n    Bucket           *arData; //bucket数组\n    // 当前已使用的Bucket数，但这些Bucket并不都是有效的，因此再删除一个数组元素时，并不会马上将其从数组中移除，而是将这个元素的类型表位IS_UNDEF，只有在数组容量超过限制，需要扩容时才会删除。\n    uint32_t          nNumUsed; \n    // 数组实际存储的元素数（有效元素数）。\n    uint32_t          nNumOfElements; //已有元素数，nNumOfElements <= nNumUsed，因为删除的并不是直接从arData中移除\n    // 数组的总容量，其大小为2的幂次方，最小为8（即2^3）。\n    uint32_t          nTableSize; //数组的大小，为2^n\n    uint32_t          nInternalPointer; //数值索引\n    // 下一个可用的数值索引，如arr[]=1;arr['a']=2;arr[]=3;则nNextFreeElement=2；该成员是给自动确定数值索引使用的。\n    zend_long         nNextFreeElement;\n    // 当删除或覆盖数组中的某个元素时，若提供了这个函数句柄，则会回调此函数。\n    dtor_func_t       pDestructor;\n};\n```\n\n\nBucket的结构如下,主要用来保存元素的key及value。\n\n```c\ntypedef struct _Bucket {\n    // 存储的具体的value，这里嵌入了一个zval而不是一个指针。\n\tzval              val;\n\t// hash code，用来映射元素的存储位置。若元素是数值索引，那么他的值就是数值索引的值；若是字符串，那么这个只就是根据字符串key通过Time33算法计算得到的散列值。\n\tzend_ulong        h;                /* hash value (or numeric index)   */\n\t// 存储元素的key。\n\tzend_string      *key;              /* string key or NULL for numerics */\n} Bucket;\n```\n###### 基本实现\n散列表主要由两部分组成：\n- 存储元素数组\n- 散列函数\n一个简单的散列函数可以采用取模的方式，比如散列表的大小为8，那么在散列表初始化数组时就会分配8个元素大小的空间，根据key的hash code与8取模的到的值作为该元素在数组中的下标。其示意图如下：\n\n![散列表的基本实现](https://note.youdao.com/yws/api/personal/file/F2CB6F384907410BB02F7F7411F4E341?method=download&shareKey=fc47b2317eb268543f1440ed7296beb0)\n\n**以散列函数的输出值作为该元素在存储元素数组中的下标的方式有一个问题: **元素在数组中的位置是随机的，它是无序的。\n\n\n\n- **问：那么PHP是如何保证元素的顺序与其插入顺序一致？** \n  \t\t为了实现散列表的有序性，PHP在散列函数与元素数组之间加了一层映射表，该映射表也是一个数组，大小与存储元素的数组相同，它存储的元素类型为整型，用于保存实际存储的有序数组中的下标：**元素按照先后顺序依次插入实际存储的数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中**，如下图所示。\n\n![散列表映射关系](https://note.youdao.com/yws/api/personal/file/A8DBDBE3688A48739E06BF38ACDA300F?method=download&shareKey=6e4969019969485debc917c11a87da4d)\n\n原理如上，但实际上PHP是将这个映射表与arData放在一起，在数组初始化时会分配存储Bucket的内存，同时还会分配相同数量的uint32_t大小的空间，将arData偏移到存储元素数组的位置，这个中间映射表可以通过arData向前访问到。如下图所示：\n![HashTable中间映射表](https://note.youdao.com/yws/api/personal/file/358B60D6F6AA407E9B034BACE5E8ACB6?method=download&shareKey=e515e9d30e617ea6c6fa8b9475a9efeb)\n\n###### 散列函数\n​\t\t通常散列会数会以取模的方式给出，比如：`key->h%nTableSize`.但是PHP采用了另一种方式，因为散列表的大小为2的幂次方，所以通过**或运算**可以得到`[-1,nTableMask]`之间的散列值。\n```\nnIndex = h | ht->nTableMask\n```\n\n\neg：\n\n```\nh=18003212\nnTableSize=8\n\nnTableMask=-8\nnIndex=-4\n```\n\n\n\n###### 数组的初始化\n\n​\t\t数组初始化的过程主要是对`HashTable`中的成员进行设置，初始化时并不会立即分配`arData`的内存，`arData`的内存在**插入第一个元素时才会分配**。\n```c\nZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n    // 初始化gc信息\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\t// 设置flags\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\t// nTableMask的值是临时的\n\tht->nTableMask = HT_MIN_MASK;\n\t// 临时设置ht->arData\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n\t// 把数组的大小重置为2的幂次方\n\tht->nTableSize = zend_hash_check_size(nSize);\n}\n```\n###### 插入\n​\t\t插入时，会检查数组是否已经分配存储空间。PHP会在第一次插入时根据`nTableSize`的大小分配，分配完成后把`HashTable->u.flags`打上`HASH_FLAG_INITIALIZAED`掩码。\n\n- 分配内存  \n分配的内存包括映射表及元素数组：\n```\nnTableSize * (sizeof(Bucket) + sizeof(uint32_t))\n```\n分配完成后，将`HashTable->arData`指向第一个`Bucket`的位置。\n\n- 插入数据  \n将元素按照顺序插入`arData`，然后将其在`arData`数组中的位置存储到根据`key`的`hash code`（即`key->h`）与`nTableMask`计算得到的中间映射表中的对应位置。\n```c\nzend_hash.c\n// _zend_hash_add_or_update_i:\nadd_to_hash:\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\t// idx为Bucket在arData中存储位置\n\tidx = ht->nNumUsed++;\n\tht->nNumOfElements++;\n\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\tht->nInternalPointer = idx;\n\t}\n\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);\n\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t}\n\t// 找到存储Bucket，设置key、value\n\tp = ht->arData + idx;\n\tp->h = h;\n\tp->key = NULL;\n\t// 计算中间映射表的散列值，idx将保存在映射数组的nIndex位置\n\tnIndex = h | ht->nTableMask;\n\t// 将映射表中原来的值保存到新Bucket中，哈希冲突时会用到\n\tZVAL_COPY_VALUE(&p->val, pData);\n\t// 先把旧的值保存到新插入的元素中\n\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t// 再把新元素数组存储位置更新到映射表中\n\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn &p->val;\n```\n###### 哈希冲突\n​\t\t散列表中不同元素的`key`可能计算得到相同的哈希值，这些具有相同哈希值的元素在插入散列表时就会发生冲突，因为映射表只能存储一个元素。  \n**常见的解决方式（PHP采用这种方式）：将冲突的Bucket串成链表，查找时需要遍历这个链表，逐个比较`key`，从而找到目标元素。**\n\n- 具体操作：\n  \t\t`HashTable`中的`Bucket`会记录与它冲突的元素在`arData`数组中的存储位置。在设置映射值时，如果发现映射表中要设置的位置已经被之前插入的元素占用了（值不等于初始化的-1），那么会把已经存在的值保存到新插入的`Bucket`中，然后将映射表中的值更新为新`Bucket`的存储位置（即每次都会把冲突的元素插到开头）。  \n  **冲突元素的保存位置为：**`Bucket.val.u2.next`\n\n\n\n**示例**：一个数组有三个元素，按照a、b、c的顺序插入，加入a、c两个key冲突了，则HashTable的结构如下：\n$arr = [];\n$arr['a'] = 11;\n$arr['b'] = 22;\n$arr['c'] = 33;\n![哈希冲突链表](https://note.youdao.com/yws/api/personal/file/C469391F27FF454698CCD908B98FB2B2?method=download&shareKey=9501d4a7b3029c279f3d545c7f9c18e2)\n\n###### 查找\n查找过程如下：\n- ①、根据`key`计算出`hash code`（即`zend_string->h`）与`nTableMask`计算得到散列值`nIndex`。\n- ②、根据散列值从中间映射表中得到存储元素在有序存储数组中的位置`idx`。\n- ③、根据`idx`从有序存储数组（`HashTable->arData`）中取出`Bucket`\n- ④、从取出的`Bucket`进行遍历，判断Bucket的key是否是要查找的key，若是则停止遍历，否则继续根据`zval.u2.next`遍历比较。\n\n```c\n// zend_hash_find_bucket:\n// 根据zend_string *key进行查找\nstatic zend_always_inline Bucket *zend_hash_find_bucket(const HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\th = zend_string_hash_val(key);\n\tarData = ht->arData;\n\t// 计算散列值\n\tnIndex = h | ht->nTableMask;\n\t// 获取Bucket存储位置\n\tidx = HT_HASH_EX(arData, nIndex);\n    // 遍历\n\twhile (EXPECTED(idx != HT_INVALID_IDX)) {\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif (EXPECTED(p->key == key)) { /* check for the same interned string */\n\t\t\treturn p;\n\t\t} else if (EXPECTED(p->h == h) && // 先比较hash code\n\t\t     EXPECTED(p->key) && \n\t\t     // 在比较key长度，最后按字符比较是否相同\n\t\t     EXPECTED(ZSTR_LEN(p->key) == ZSTR_LEN(key)) &&\n\t\t     EXPECTED(memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {// 比较查找的key与Bucket的key是否匹配\n\t\t\treturn p;\n\t\t}\n\t\t// 不匹配则继续遍历\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n```\n\n\n###### 扩容\n\n​\t\t数组的容量是有限的，最多可以存储`nTableSize`个元素，那么当数组空间已满还要继续插入时如何处理？  \n\n\n\n**问: PHP是怎样实现的自动扩容？**\n\n​\t\t**扩容的过程为**：检查数组中已经删除的元素所占的比例（已经删除但未从存储数组中移除的元素）.若比例达到域值，则触发**重建索引**的操作，这个过程会把删除的Bucket移除，然后把后面的Bucket往前移补上空缺的Bucket；若还没有达到域值，则分配一个原数组大小2倍的新数组，然后把原数组的元素复制到新数组上，重建索引。 \n\n\n<u>域值判断公式</u>如下，即域值为`nNumOfElement + (nNumElement / 32)`\n\n```\nht->nNumUsed > ht->nNumOfElement + (ht->nNumOfElement >> 5)\n```\n\n具体的处理过程：\n```c\nstatic void ZEND_FASTCALL zend_hash_do_resize(HashTable *ht)\n{\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed > ht->nNumOfElements + (ht->nNumOfElements >> 5)) { // 无序扩容，将删除的Bucket移除，然后把后面的bucket往前补上空缺\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t// 只有到达一定域值才进行rehash操作\n\t\tzend_hash_rehash(ht); // 重建索引数组\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else if (ht->nTableSize < HT_MAX_SIZE) { // 扩容，分配原数组大小2倍的新数组。\n\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\t// 扩大为2倍，加法比乘法快\n\t\tuint32_t nSize = ht->nTableSize + ht->nTableSize;\n\t\tBucket *old_buckets = ht->arData;\n\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t// 新分配arData空间，大小为(sizeof(Bucket) + sizeof(uint32_t)) * nSize;\n\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\tht->nTableSize = nSize;\n\t\tht->nTableMask = -ht->nTableSize;\n\t    // 将arData指针偏移到Bucket数组起始位置\n\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\t// 将旧的Bucket数组复制到新空间（此步只复制存储的元素，即HashTable->arData，不会复制中间映射表，因为扩容后旧的映射表已无法使用，key-value的映射关系需要重新计算，即重建索引）\n\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\t// 释放旧空间\n\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\t// 重建索引数组：映射表\n\t\tzend_hash_rehash(ht);\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", ht->nTableSize * 2, sizeof(Bucket) + sizeof(uint32_t), sizeof(Bucket));\n\t}\n}\n```\n重建索引的过程实际上就是将所有元素重新插入一遍，其处理过程如下：\n```\n// 遍历数组，重新设置中间映射表（索引表）\n    do {\n\t\t\tnIndex = p->h | ht->nTableMask;\n\t\t\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);\n\t\t\tp++;\n\t\t} while (++i < ht->nNumUsed);\n```\n重建索引会将已删除的bucket移除，移除后会把这个Bucket之后的元素全部向前移动一个位置，所以**重建索引后存储数组中元素全部紧密排列在一起**。\n\n\n\n##### 引用\n\n​\t\t引用类型是PHP中比较特殊的一种类型，它实际是指向另外一个PHP变量（*在PHP中通过`&操作符`产生一个引用变量*），对它的修改会直接改动实际指向的zval，<u>可以简单的理解为C中的指针</u>。  \n\n操作步骤：\n\n- 首先为`&`操作的变量分配一个`zend_reference结构`，其内嵌一个`zval`，这个`zval`的`value`指向原来`zval`的`value`(**注: 如果是布尔、整形、浮点则直接复制原来的值**)。\n- 然后将原`zval`的类型修改为`IS_REFERENCE`，原`zval`的`value`指向新创建的`zend_reference`结构。\n```\nstruct _zend_reference {\n    zend_refcounted_h gc;\n    zval              val; // 指向原来的value\n};\n```\n示例1：\n```\n$a = date('Y-m-d');\n$b = &$a;\n```\n![a与b内存引用关系](https://note.youdao.com/yws/api/personal/file/A5F4C7219117457A88A7D7CC3AFB53A9?method=download&shareKey=3d6950341fd9f21fea74f78f022500fd)\n\n**注：若此时将`$b`复制给其他变量，那么传递给新变量的value将实时及引用的值，而不是引用本身**。PHP中的引用只有一级，不会出现一个引用指向另外一个引用的情况，即没有C语言中多级指针的概念。\n\n```\n$a = date('Y-m-d');\n$b = &$a;\n$c = $b; // 若想让$c也指向$a/$b引用的值，则：$c = &$b或$c = &$a;\n```\n![a,b与c内存引用关系](https://note.youdao.com/yws/api/personal/file/1E8C8DDDE51D479296CA8F63EA5353B7?method=download&shareKey=43183c8018d3140f9b924508528c2af2)\n\n\n示例2：\n```\n$a = \"time:\" . time();      //$a    -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n```\n![zend_ref](https://note.youdao.com/yws/api/personal/file/697F728B851442D4AF142554DDF78333?method=download&shareKey=59d725805b5b7c8bc59c391e87607101)\n\n注意：**引用只能通过`&`产生，无法通过赋值传递**  \n\n例：\n\n```\nerror:\n$a = \"time:\" . time();      //$a    -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n$c = $b;                    //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=2)\n                            //$c    -> \nright:\n$a = \"time:\" . time();      //$a       -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b    -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n$c = &$b;/*或$c = &$a*/     //$a,$b,$c -> zend_reference_1(refcount=3) -> zend_string_1(refcount=1)                             \n```\n这个也表示PHP中的 **引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况** ，也就是没有C语言中指针的指针的概念。\n\n\n\n##### 对象/资源\n对象比较常见，资源指的是tcp连接、文件句柄等等类型。\n```\nstruct _zend_object {\n    zend_refcounted_h gc;\n    uint32_t          handle;\n    zend_class_entry *ce; //对象对应的class类\n    const zend_object_handlers *handlers;\n    HashTable        *properties; //对象属性哈希表\n    zval              properties_table[1];\n};\n\nstruct _zend_resource {\n    zend_refcounted_h gc;\n    int               handle;\n    int               type;\n    void             *ptr;\n};\n```\n\n##### 类型转换\n​\t\tPHP是弱类型语言，使用时不需要明确定义变量的类型，Zend虚拟机在执行PHP代码时，会根据具体的应用场景进行转换，也就是变量会按照类型转换规则将不合格变量转换给合格的变量，然后进行操作。\n\n例:\n```\n$a = \"100\" + 200\n```\n执行时Zend发现相加的一个值为字符串，就会试图将`字符串100`转为数值类型（整型或浮点型），然后与200相加。  \n**注：转换的时候并不会改变原来的值，而是会生成一个新的变量进行处理。**\n\n\n\n###### 强制转换\n\nPHP提供了一种强制转换方式：\n- (int)/(integer): 转换为整型integer\n- (bool)/(boolean):转换为布尔类型boolean\n- (flaot)/(double)/(real):转换为浮点型flaot\n- (string):转换为字符串string\n- (array):转换为数组array\n- (object):转换为对象object\n- (unset):转换为null\n\n*注：有些类型之间是无法转换的，如：资源类型，无法将任何类型转换为资源类型。*\n\n###### 转换为null\n​\t\t任意类型都可以转为null，转换时直接将新的`zval类型`设置为`IS_NULL`。\n\n\n\n###### 转换为布尔型\n\n​\t\t当转换为布尔型时，根据原值的`true`、`false`决定转换后的结果，一些值被认为是`false`，除此之外的其他值通常被认为是`true`。\n\n被认为是false的值:\n\n- 布尔值false本身\n- 整型0\n- 浮点型值0.0\n- ==空字符串（‘’），以及字符串‘0’==\n- 空数组\n- null\n\n\n\n###### 转换为整型\n\n从`其他值`转换为`整型`的规则如下：\n- null：转换为0\n- 布尔型：false转为0，true转为1\n- 浮点型：向下取整，比如，(int)2.8 = 2\n- 字符串：与C语言strtoll()的规则一致\n    - 字符串以合法数值(包含正负数)开始，就使用该数值\n    - **否则，其值为0**\n- 数组：很多操作不支持将一个数组自动转为整型处理，比如array()+2将报error错误，但可以强制把数组转为整型：\n    - 非空数组：1\n    - 空数组：0\n```php\nphp > $a = array()+2;\nPHP Fatal error:  Unsupported operand types in php shell code on line 1\nPHP Stack trace:\nPHP   1. {main}() php shell code:0\nPHP   2. {main}() php shell code:0\nphp > \nphp > $a = array();\nphp > $b = (int)$a;\nphp > echo $b;\n0\n```\n- 对象：与数组类似，很多操作也不支持将兑现个自动转为整型，但有些操作只会抛一个warning警告，还是会把对象转换为1.\n- 资源：转为分配给这个资源的唯一编号\n\n\n\n###### 转为浮点型\n\n​\t\t除了字符串类型外，其他类型转换规则与整型基本一致，只是在整型转换结果上加了小数位，字符串转为浮点数有`zend_strtod`完成。\n\n\n\n###### 转换为字符串\n\n- 强制转换：\n    - (string)\n    - strval()函数\n- 自动转换：\n    - 需要字符串的表达式中，比如：函数echo或print时\n    - 非string类型变量与一个string变量进行比较时\n        - null/fasle:转为空字符串\n        - true：转为“1”\n        - 整型：原样转为字符串，**转换时将各位一次除10取余**\n        - 浮点型：原样转为字符串\n        - 资源：转为“Resource id#xxx”\n        - 数组：转为“Array”，同时报Notice\n        - 对象：不能转换，将报错,如下：\n        ```php\n        php > class A \n        php > {public $b;}\n        php > \n        php > $a = new A();\n        php > \n        php > echo 'a= ' . $a;\n        PHP Catchable fatal error:  Object of class A could not be converted to string in php shell code on line 1\n        PHP Stack trace:\n        PHP   1. {main}() php shell code:0\n        ```\n###### 转换为数组\n- 若变量类型为`null`、`integer`、`float`、`string`、`boolean`和`resource`中的一个：将得到一个仅有一个元素的数组，其`下标为0`，即(array)$scalarValue与`array($scalarValue)`完全一样。\n- 若变量类型为object：其结果为一个数组，数组的元素为该对象的全部属性（包含public、private、protected），但他们也是有区别的，如下：\n    - public的属性：key\n    - private的属性：key加类型作为前缀\n    - protected的属性：'*'加key作为前缀\n    ```\n    class test\n    {\n        public $a = 123;\n        private $b = 'bbb';\n        protected $c = 'ccc';\n    }\n\n    $test = new test();\n    print_r((array)$test);\n    ```\n    以上例子将输出：\n    ```\n    $php stat.php \n    Array\n    (\n        [a] => 123\n        [testb] => bbb\n        [*c] => ccc\n    )\n    ```\n\n###### 转换为对象\n其他任何类型的值被转换为对象，将会创建一个内置类stdClass的实例：\n- 若该值为null：新的实例为空\n- array：转换成的object将以键名成为属性名，并具有相对应的值\n    - 数值索引的元素也将转为属性，但无法通过“->”访问，只能遍历获取\n    - 非数值索引：会以‘scalar’作为属性名","source":"_posts/PHP7内核-变量.md","raw":"---\ntitle: PHP7内核-变量\ndate: 2020-08-21 16:28:40\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n\n\n#### 变量的内部实现\n​\t\t变量是一个语言实现的基础，变量有两个组成部分：变量名、变量值，PHP中可以将其对应为：`zval`、`zend_value`，这两个概念一定要区分开，PHP中变量的内存是通过`引用计数`进行管理的，而且**PHP7中引用计数是在`zend_value`而不是zval上，变量之间的传递、赋值通常也是针对zend_value**。\n\n<!--more-->\n\nPHP中可以通过`$关键词`定义一个变量：`$a;`，在定义的同时可以进行初始化：`$a = \"hi~\";`<u>注意这实际是两步：定义、初始化</u>，只定义一个变量也是可以的，可以不给它赋值，比如：\n\n```php\n$a;\n$b = 1;\n```\n这段代码在执行时会分配两个zval。\n\n#### 变量的基础结构\n```c\n//zend_types.h\ntypedef struct _zval_struct     zval;\nstruct _zval_struct {\n    zend_value        value; //变量实际的value\n    union {\n        struct {\n            ZEND_ENDIAN_LOHI_4(  //这个是为了兼容大小字节序，小字节序就是下面的顺序，大字节序则下面4个顺序翻转\n                zend_uchar    type,         //变量类型\n                zend_uchar    type_flags,  //类型掩码，不同的类型会有不同的几种属性，内存管理会用到\n                zend_uchar    const_flags,\n                zend_uchar    reserved)     //call info，zend执行流程会用到\n        } v;\n        uint32_t type_info; //上面4个值的组合值，可以直接根据type_info取到4个对应位置的值\n    } u1;\n    union {\n        uint32_t     var_flags;\n        uint32_t     next;                 //哈希表中解决哈希冲突时用到\n        uint32_t     cache_slot;           /* literal cache slot 运行时缓存会用到*/ \n        uint32_t     lineno;               /* line number (for ast nodes) */\n        uint32_t     num_args;             /* arguments number for EX(This) */\n        uint32_t     fe_pos;               /* foreach position foreach遍历时会用到*/\n        uint32_t     fe_iter_idx;          /* foreach iterator index */\n    } u2; //一些辅助值\n};\n```\n`\t\tzval`结构比较简单，内嵌一个union类型的`zend_value`保存具体变量类型的值或指针，zval中还有两个union：`u1`、`u2`:\n\n- **u1**: 它是联合了一个结构体`v`和一个32位无符号整型`type_info`；ZEND_ENDIAN_LOHI_4是一个宏，用于解决字节序问题的，他会根据系统字节序决定struct v中4个成员的顺序。v定义了4个成员变量，**变量的类型就通过u1.v.type区分**；另外一个值`type_flags`为类型掩码，在变量的内存管理、gc机制中会用到；至于后面两个const_flags、reserved暂且不管。\n- **u2**: 这个值纯粹是个辅助值，zval结构中value、u1分别占了8byte、4byte，一共12byte，假如zval只有:value、u1两个值，整个zval的大小也会对齐到16byte，既然不管有没有u2大小都是16byte，把多余的4byte拿出来用于一些特殊用途还是很划算的，比如next在哈希表解决哈希冲突时会用到，还有fe_pos在foreach会用到......  \n\n```c\ntypedef union _zend_value {\n    zend_long         lval;    //int整形\n    double            dval;    //浮点型\n    zend_refcounted  *counted;\n    zend_string      *str;     //string字符串\n    zend_array       *arr;     //array数组\n    zend_object      *obj;     //object对象\n    zend_resource    *res;     //resource资源类型\n    zend_reference   *ref;     //引用类型，通过&$var_name定义的\n    zend_ast_ref     *ast;     //下面几个都是内核使用的value\n    zval             *zv;\n    void             *ptr;\n    zend_class_entry *ce;\n    zend_function    *func;\n    struct {\n        uint32_t w1;\n        uint32_t w2;\n    } ww;\n} zend_value;\n\n```\n​\t\t`zend_value`是一个联合体，各个类型根据自己的类型选择使用不同的成员，**从zend_value可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构**。zend_value中没有布尔型，这是因为PHP7中将布尔型具体拆分为了true、false两种类型，通过zval.u1.v.type进行区分（注：老版本中，布尔型是通过整型进行区分的）\n\n#### 类型\n`zval.u1.type`类型：\n\n```c\n/* regular data types */\n#define IS_UNDEF                    0\n#define IS_NULL                     1\n#define IS_FALSE                    2\n#define IS_TRUE                     3\n#define IS_LONG                     4\n#define IS_DOUBLE                   5\n#define IS_STRING                   6\n#define IS_ARRAY                    7\n#define IS_OBJECT                   8\n#define IS_RESOURCE                 9\n#define IS_REFERENCE                10\n\n/* constant expressions */\n#define IS_CONSTANT                 11\n#define IS_CONSTANT_AST             12\n\n/* fake types */\n#define _IS_BOOL                    13\n#define IS_CALLABLE                 14\n\n/* internal types */\n#define IS_INDIRECT                 15\n#define IS_PTR                      17\n```\n\n##### 标量类型\n- 没有value，直接根据type区分的类型：`true`、`false`、`null`\n- 值存于value中，无需额外的value指针：`zend_long`、 `double`\n\n##### 字符串（zend_string）\n​\t\tPHP中没有使用`char`来表示字符串，而是为字符串单独定义了一个结构`zend_string`，其中除了存储字符串内容，还存储了其他信息。\n```c\nstruct _zend_string {\n    zend_refcounted_h gc; // 变量引用计数信息，用于内存管理。比如当前value的引用数，所有用到引用计数的变量类型都会有这个结构\n    zend_ulong        h;  /* hash value 哈希值，数组中计算索引时会用到*/\n    size_t            len; // 字符串长度，通过这个值保证二进制安全\n    char              val[1]; // 字符串内容，变长struct，分配时按len长度申请内存\n};\n```\n​\t\t字符串内容`val`是一个可变数组，在字符串分配时的操作为`malloc(sizeof(zend_string) + 字符串长度)`。\n*注：val中多出一个字节（val[1]而不是val[0]）用于存储字符串的最后一个字符\"\\0\".*\n\n例如：$a=\"abc\"，对应zend_string内存结构如下：\n![zend_string内存结构](https://note.youdao.com/yws/api/personal/file/39A4055CBC584591A643CF8855653427?method=download&shareKey=100018cf52486ade9a25e3f4d8227678)\n\n\n字符串具体分类：\n- `IS_STR_PERSISTENT`: 通过malloc分配。\n- `IS_STR_INTERNED`: php代码中写的一些字面量，如函数名、变量名。\n- `IS_STR_PERMERNENT`:永久值，生命周期大于request。\n- `IS_STR_CONSTANT`:常量。\n- `IS_STR_CONSTANT_UNQUALIFIED`:这个信息通过flag保存：zval.value->gc.u.flags\n\n##### 数组（array）\n​\t\t`Array`是PHP中非常强大的一个数据结构，它的**底层实现为散列表（HashTable 哈希表）**。\n​\t\t散列表是根据`key`直接进行访问的数据结构，它的`key-value`之间有一个映射函数，可以根据key通过映射函数直接索引到对应的value值，直接根据`“内存起始地址+偏移值”`进行寻址，加快查找速度。理想情况下，查找的期望时间复杂度为O(1).\n\n\n\nHashTable的数据结构如下:\n\n```c\ntypedef struct _zend_array HashTable;\n\nstruct _zend_array {\n    zend_refcounted_h gc; //引用计数信息，与字符串相同\n    // 提供一些辅助的功能，比如，flag用来设置散列表的一些属性，是否持久化、是否已经初始化。\n    union {\n        struct {\n            ZEND_ENDIAN_LOHI_4(\n                zend_uchar    flags,\n                zend_uchar    nApplyCount,\n                zend_uchar    nIteratorsCount,\n                zend_uchar    reserve)\n        } v;\n        uint32_t flags;\n    } u;\n    // 用于散列函数映射存储元素在arData数组中的下标。其值实际是nTableSize的负数，即nTableMask=-nTableSize（nTableMask=~nTableSize+1）\n    uint32_t          nTableMask; //计算bucket索引时的掩码\n    // 存储元素数组，每个元素的结构统一为Bucket，其内存是连续的，arData指向第一个Bucket（即指向数组的起始位置）\n    Bucket           *arData; //bucket数组\n    // 当前已使用的Bucket数，但这些Bucket并不都是有效的，因此再删除一个数组元素时，并不会马上将其从数组中移除，而是将这个元素的类型表位IS_UNDEF，只有在数组容量超过限制，需要扩容时才会删除。\n    uint32_t          nNumUsed; \n    // 数组实际存储的元素数（有效元素数）。\n    uint32_t          nNumOfElements; //已有元素数，nNumOfElements <= nNumUsed，因为删除的并不是直接从arData中移除\n    // 数组的总容量，其大小为2的幂次方，最小为8（即2^3）。\n    uint32_t          nTableSize; //数组的大小，为2^n\n    uint32_t          nInternalPointer; //数值索引\n    // 下一个可用的数值索引，如arr[]=1;arr['a']=2;arr[]=3;则nNextFreeElement=2；该成员是给自动确定数值索引使用的。\n    zend_long         nNextFreeElement;\n    // 当删除或覆盖数组中的某个元素时，若提供了这个函数句柄，则会回调此函数。\n    dtor_func_t       pDestructor;\n};\n```\n\n\nBucket的结构如下,主要用来保存元素的key及value。\n\n```c\ntypedef struct _Bucket {\n    // 存储的具体的value，这里嵌入了一个zval而不是一个指针。\n\tzval              val;\n\t// hash code，用来映射元素的存储位置。若元素是数值索引，那么他的值就是数值索引的值；若是字符串，那么这个只就是根据字符串key通过Time33算法计算得到的散列值。\n\tzend_ulong        h;                /* hash value (or numeric index)   */\n\t// 存储元素的key。\n\tzend_string      *key;              /* string key or NULL for numerics */\n} Bucket;\n```\n###### 基本实现\n散列表主要由两部分组成：\n- 存储元素数组\n- 散列函数\n一个简单的散列函数可以采用取模的方式，比如散列表的大小为8，那么在散列表初始化数组时就会分配8个元素大小的空间，根据key的hash code与8取模的到的值作为该元素在数组中的下标。其示意图如下：\n\n![散列表的基本实现](https://note.youdao.com/yws/api/personal/file/F2CB6F384907410BB02F7F7411F4E341?method=download&shareKey=fc47b2317eb268543f1440ed7296beb0)\n\n**以散列函数的输出值作为该元素在存储元素数组中的下标的方式有一个问题: **元素在数组中的位置是随机的，它是无序的。\n\n\n\n- **问：那么PHP是如何保证元素的顺序与其插入顺序一致？** \n  \t\t为了实现散列表的有序性，PHP在散列函数与元素数组之间加了一层映射表，该映射表也是一个数组，大小与存储元素的数组相同，它存储的元素类型为整型，用于保存实际存储的有序数组中的下标：**元素按照先后顺序依次插入实际存储的数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中**，如下图所示。\n\n![散列表映射关系](https://note.youdao.com/yws/api/personal/file/A8DBDBE3688A48739E06BF38ACDA300F?method=download&shareKey=6e4969019969485debc917c11a87da4d)\n\n原理如上，但实际上PHP是将这个映射表与arData放在一起，在数组初始化时会分配存储Bucket的内存，同时还会分配相同数量的uint32_t大小的空间，将arData偏移到存储元素数组的位置，这个中间映射表可以通过arData向前访问到。如下图所示：\n![HashTable中间映射表](https://note.youdao.com/yws/api/personal/file/358B60D6F6AA407E9B034BACE5E8ACB6?method=download&shareKey=e515e9d30e617ea6c6fa8b9475a9efeb)\n\n###### 散列函数\n​\t\t通常散列会数会以取模的方式给出，比如：`key->h%nTableSize`.但是PHP采用了另一种方式，因为散列表的大小为2的幂次方，所以通过**或运算**可以得到`[-1,nTableMask]`之间的散列值。\n```\nnIndex = h | ht->nTableMask\n```\n\n\neg：\n\n```\nh=18003212\nnTableSize=8\n\nnTableMask=-8\nnIndex=-4\n```\n\n\n\n###### 数组的初始化\n\n​\t\t数组初始化的过程主要是对`HashTable`中的成员进行设置，初始化时并不会立即分配`arData`的内存，`arData`的内存在**插入第一个元素时才会分配**。\n```c\nZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n    // 初始化gc信息\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\t// 设置flags\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\t// nTableMask的值是临时的\n\tht->nTableMask = HT_MIN_MASK;\n\t// 临时设置ht->arData\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n\t// 把数组的大小重置为2的幂次方\n\tht->nTableSize = zend_hash_check_size(nSize);\n}\n```\n###### 插入\n​\t\t插入时，会检查数组是否已经分配存储空间。PHP会在第一次插入时根据`nTableSize`的大小分配，分配完成后把`HashTable->u.flags`打上`HASH_FLAG_INITIALIZAED`掩码。\n\n- 分配内存  \n分配的内存包括映射表及元素数组：\n```\nnTableSize * (sizeof(Bucket) + sizeof(uint32_t))\n```\n分配完成后，将`HashTable->arData`指向第一个`Bucket`的位置。\n\n- 插入数据  \n将元素按照顺序插入`arData`，然后将其在`arData`数组中的位置存储到根据`key`的`hash code`（即`key->h`）与`nTableMask`计算得到的中间映射表中的对应位置。\n```c\nzend_hash.c\n// _zend_hash_add_or_update_i:\nadd_to_hash:\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\t// idx为Bucket在arData中存储位置\n\tidx = ht->nNumUsed++;\n\tht->nNumOfElements++;\n\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\tht->nInternalPointer = idx;\n\t}\n\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);\n\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t}\n\t// 找到存储Bucket，设置key、value\n\tp = ht->arData + idx;\n\tp->h = h;\n\tp->key = NULL;\n\t// 计算中间映射表的散列值，idx将保存在映射数组的nIndex位置\n\tnIndex = h | ht->nTableMask;\n\t// 将映射表中原来的值保存到新Bucket中，哈希冲突时会用到\n\tZVAL_COPY_VALUE(&p->val, pData);\n\t// 先把旧的值保存到新插入的元素中\n\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t// 再把新元素数组存储位置更新到映射表中\n\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn &p->val;\n```\n###### 哈希冲突\n​\t\t散列表中不同元素的`key`可能计算得到相同的哈希值，这些具有相同哈希值的元素在插入散列表时就会发生冲突，因为映射表只能存储一个元素。  \n**常见的解决方式（PHP采用这种方式）：将冲突的Bucket串成链表，查找时需要遍历这个链表，逐个比较`key`，从而找到目标元素。**\n\n- 具体操作：\n  \t\t`HashTable`中的`Bucket`会记录与它冲突的元素在`arData`数组中的存储位置。在设置映射值时，如果发现映射表中要设置的位置已经被之前插入的元素占用了（值不等于初始化的-1），那么会把已经存在的值保存到新插入的`Bucket`中，然后将映射表中的值更新为新`Bucket`的存储位置（即每次都会把冲突的元素插到开头）。  \n  **冲突元素的保存位置为：**`Bucket.val.u2.next`\n\n\n\n**示例**：一个数组有三个元素，按照a、b、c的顺序插入，加入a、c两个key冲突了，则HashTable的结构如下：\n$arr = [];\n$arr['a'] = 11;\n$arr['b'] = 22;\n$arr['c'] = 33;\n![哈希冲突链表](https://note.youdao.com/yws/api/personal/file/C469391F27FF454698CCD908B98FB2B2?method=download&shareKey=9501d4a7b3029c279f3d545c7f9c18e2)\n\n###### 查找\n查找过程如下：\n- ①、根据`key`计算出`hash code`（即`zend_string->h`）与`nTableMask`计算得到散列值`nIndex`。\n- ②、根据散列值从中间映射表中得到存储元素在有序存储数组中的位置`idx`。\n- ③、根据`idx`从有序存储数组（`HashTable->arData`）中取出`Bucket`\n- ④、从取出的`Bucket`进行遍历，判断Bucket的key是否是要查找的key，若是则停止遍历，否则继续根据`zval.u2.next`遍历比较。\n\n```c\n// zend_hash_find_bucket:\n// 根据zend_string *key进行查找\nstatic zend_always_inline Bucket *zend_hash_find_bucket(const HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\th = zend_string_hash_val(key);\n\tarData = ht->arData;\n\t// 计算散列值\n\tnIndex = h | ht->nTableMask;\n\t// 获取Bucket存储位置\n\tidx = HT_HASH_EX(arData, nIndex);\n    // 遍历\n\twhile (EXPECTED(idx != HT_INVALID_IDX)) {\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif (EXPECTED(p->key == key)) { /* check for the same interned string */\n\t\t\treturn p;\n\t\t} else if (EXPECTED(p->h == h) && // 先比较hash code\n\t\t     EXPECTED(p->key) && \n\t\t     // 在比较key长度，最后按字符比较是否相同\n\t\t     EXPECTED(ZSTR_LEN(p->key) == ZSTR_LEN(key)) &&\n\t\t     EXPECTED(memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {// 比较查找的key与Bucket的key是否匹配\n\t\t\treturn p;\n\t\t}\n\t\t// 不匹配则继续遍历\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n```\n\n\n###### 扩容\n\n​\t\t数组的容量是有限的，最多可以存储`nTableSize`个元素，那么当数组空间已满还要继续插入时如何处理？  \n\n\n\n**问: PHP是怎样实现的自动扩容？**\n\n​\t\t**扩容的过程为**：检查数组中已经删除的元素所占的比例（已经删除但未从存储数组中移除的元素）.若比例达到域值，则触发**重建索引**的操作，这个过程会把删除的Bucket移除，然后把后面的Bucket往前移补上空缺的Bucket；若还没有达到域值，则分配一个原数组大小2倍的新数组，然后把原数组的元素复制到新数组上，重建索引。 \n\n\n<u>域值判断公式</u>如下，即域值为`nNumOfElement + (nNumElement / 32)`\n\n```\nht->nNumUsed > ht->nNumOfElement + (ht->nNumOfElement >> 5)\n```\n\n具体的处理过程：\n```c\nstatic void ZEND_FASTCALL zend_hash_do_resize(HashTable *ht)\n{\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed > ht->nNumOfElements + (ht->nNumOfElements >> 5)) { // 无序扩容，将删除的Bucket移除，然后把后面的bucket往前补上空缺\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t// 只有到达一定域值才进行rehash操作\n\t\tzend_hash_rehash(ht); // 重建索引数组\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else if (ht->nTableSize < HT_MAX_SIZE) { // 扩容，分配原数组大小2倍的新数组。\n\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\t// 扩大为2倍，加法比乘法快\n\t\tuint32_t nSize = ht->nTableSize + ht->nTableSize;\n\t\tBucket *old_buckets = ht->arData;\n\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t// 新分配arData空间，大小为(sizeof(Bucket) + sizeof(uint32_t)) * nSize;\n\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\tht->nTableSize = nSize;\n\t\tht->nTableMask = -ht->nTableSize;\n\t    // 将arData指针偏移到Bucket数组起始位置\n\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\t// 将旧的Bucket数组复制到新空间（此步只复制存储的元素，即HashTable->arData，不会复制中间映射表，因为扩容后旧的映射表已无法使用，key-value的映射关系需要重新计算，即重建索引）\n\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\t// 释放旧空间\n\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\t// 重建索引数组：映射表\n\t\tzend_hash_rehash(ht);\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", ht->nTableSize * 2, sizeof(Bucket) + sizeof(uint32_t), sizeof(Bucket));\n\t}\n}\n```\n重建索引的过程实际上就是将所有元素重新插入一遍，其处理过程如下：\n```\n// 遍历数组，重新设置中间映射表（索引表）\n    do {\n\t\t\tnIndex = p->h | ht->nTableMask;\n\t\t\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);\n\t\t\tp++;\n\t\t} while (++i < ht->nNumUsed);\n```\n重建索引会将已删除的bucket移除，移除后会把这个Bucket之后的元素全部向前移动一个位置，所以**重建索引后存储数组中元素全部紧密排列在一起**。\n\n\n\n##### 引用\n\n​\t\t引用类型是PHP中比较特殊的一种类型，它实际是指向另外一个PHP变量（*在PHP中通过`&操作符`产生一个引用变量*），对它的修改会直接改动实际指向的zval，<u>可以简单的理解为C中的指针</u>。  \n\n操作步骤：\n\n- 首先为`&`操作的变量分配一个`zend_reference结构`，其内嵌一个`zval`，这个`zval`的`value`指向原来`zval`的`value`(**注: 如果是布尔、整形、浮点则直接复制原来的值**)。\n- 然后将原`zval`的类型修改为`IS_REFERENCE`，原`zval`的`value`指向新创建的`zend_reference`结构。\n```\nstruct _zend_reference {\n    zend_refcounted_h gc;\n    zval              val; // 指向原来的value\n};\n```\n示例1：\n```\n$a = date('Y-m-d');\n$b = &$a;\n```\n![a与b内存引用关系](https://note.youdao.com/yws/api/personal/file/A5F4C7219117457A88A7D7CC3AFB53A9?method=download&shareKey=3d6950341fd9f21fea74f78f022500fd)\n\n**注：若此时将`$b`复制给其他变量，那么传递给新变量的value将实时及引用的值，而不是引用本身**。PHP中的引用只有一级，不会出现一个引用指向另外一个引用的情况，即没有C语言中多级指针的概念。\n\n```\n$a = date('Y-m-d');\n$b = &$a;\n$c = $b; // 若想让$c也指向$a/$b引用的值，则：$c = &$b或$c = &$a;\n```\n![a,b与c内存引用关系](https://note.youdao.com/yws/api/personal/file/1E8C8DDDE51D479296CA8F63EA5353B7?method=download&shareKey=43183c8018d3140f9b924508528c2af2)\n\n\n示例2：\n```\n$a = \"time:\" . time();      //$a    -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n```\n![zend_ref](https://note.youdao.com/yws/api/personal/file/697F728B851442D4AF142554DDF78333?method=download&shareKey=59d725805b5b7c8bc59c391e87607101)\n\n注意：**引用只能通过`&`产生，无法通过赋值传递**  \n\n例：\n\n```\nerror:\n$a = \"time:\" . time();      //$a    -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n$c = $b;                    //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=2)\n                            //$c    -> \nright:\n$a = \"time:\" . time();      //$a       -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b    -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n$c = &$b;/*或$c = &$a*/     //$a,$b,$c -> zend_reference_1(refcount=3) -> zend_string_1(refcount=1)                             \n```\n这个也表示PHP中的 **引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况** ，也就是没有C语言中指针的指针的概念。\n\n\n\n##### 对象/资源\n对象比较常见，资源指的是tcp连接、文件句柄等等类型。\n```\nstruct _zend_object {\n    zend_refcounted_h gc;\n    uint32_t          handle;\n    zend_class_entry *ce; //对象对应的class类\n    const zend_object_handlers *handlers;\n    HashTable        *properties; //对象属性哈希表\n    zval              properties_table[1];\n};\n\nstruct _zend_resource {\n    zend_refcounted_h gc;\n    int               handle;\n    int               type;\n    void             *ptr;\n};\n```\n\n##### 类型转换\n​\t\tPHP是弱类型语言，使用时不需要明确定义变量的类型，Zend虚拟机在执行PHP代码时，会根据具体的应用场景进行转换，也就是变量会按照类型转换规则将不合格变量转换给合格的变量，然后进行操作。\n\n例:\n```\n$a = \"100\" + 200\n```\n执行时Zend发现相加的一个值为字符串，就会试图将`字符串100`转为数值类型（整型或浮点型），然后与200相加。  \n**注：转换的时候并不会改变原来的值，而是会生成一个新的变量进行处理。**\n\n\n\n###### 强制转换\n\nPHP提供了一种强制转换方式：\n- (int)/(integer): 转换为整型integer\n- (bool)/(boolean):转换为布尔类型boolean\n- (flaot)/(double)/(real):转换为浮点型flaot\n- (string):转换为字符串string\n- (array):转换为数组array\n- (object):转换为对象object\n- (unset):转换为null\n\n*注：有些类型之间是无法转换的，如：资源类型，无法将任何类型转换为资源类型。*\n\n###### 转换为null\n​\t\t任意类型都可以转为null，转换时直接将新的`zval类型`设置为`IS_NULL`。\n\n\n\n###### 转换为布尔型\n\n​\t\t当转换为布尔型时，根据原值的`true`、`false`决定转换后的结果，一些值被认为是`false`，除此之外的其他值通常被认为是`true`。\n\n被认为是false的值:\n\n- 布尔值false本身\n- 整型0\n- 浮点型值0.0\n- ==空字符串（‘’），以及字符串‘0’==\n- 空数组\n- null\n\n\n\n###### 转换为整型\n\n从`其他值`转换为`整型`的规则如下：\n- null：转换为0\n- 布尔型：false转为0，true转为1\n- 浮点型：向下取整，比如，(int)2.8 = 2\n- 字符串：与C语言strtoll()的规则一致\n    - 字符串以合法数值(包含正负数)开始，就使用该数值\n    - **否则，其值为0**\n- 数组：很多操作不支持将一个数组自动转为整型处理，比如array()+2将报error错误，但可以强制把数组转为整型：\n    - 非空数组：1\n    - 空数组：0\n```php\nphp > $a = array()+2;\nPHP Fatal error:  Unsupported operand types in php shell code on line 1\nPHP Stack trace:\nPHP   1. {main}() php shell code:0\nPHP   2. {main}() php shell code:0\nphp > \nphp > $a = array();\nphp > $b = (int)$a;\nphp > echo $b;\n0\n```\n- 对象：与数组类似，很多操作也不支持将兑现个自动转为整型，但有些操作只会抛一个warning警告，还是会把对象转换为1.\n- 资源：转为分配给这个资源的唯一编号\n\n\n\n###### 转为浮点型\n\n​\t\t除了字符串类型外，其他类型转换规则与整型基本一致，只是在整型转换结果上加了小数位，字符串转为浮点数有`zend_strtod`完成。\n\n\n\n###### 转换为字符串\n\n- 强制转换：\n    - (string)\n    - strval()函数\n- 自动转换：\n    - 需要字符串的表达式中，比如：函数echo或print时\n    - 非string类型变量与一个string变量进行比较时\n        - null/fasle:转为空字符串\n        - true：转为“1”\n        - 整型：原样转为字符串，**转换时将各位一次除10取余**\n        - 浮点型：原样转为字符串\n        - 资源：转为“Resource id#xxx”\n        - 数组：转为“Array”，同时报Notice\n        - 对象：不能转换，将报错,如下：\n        ```php\n        php > class A \n        php > {public $b;}\n        php > \n        php > $a = new A();\n        php > \n        php > echo 'a= ' . $a;\n        PHP Catchable fatal error:  Object of class A could not be converted to string in php shell code on line 1\n        PHP Stack trace:\n        PHP   1. {main}() php shell code:0\n        ```\n###### 转换为数组\n- 若变量类型为`null`、`integer`、`float`、`string`、`boolean`和`resource`中的一个：将得到一个仅有一个元素的数组，其`下标为0`，即(array)$scalarValue与`array($scalarValue)`完全一样。\n- 若变量类型为object：其结果为一个数组，数组的元素为该对象的全部属性（包含public、private、protected），但他们也是有区别的，如下：\n    - public的属性：key\n    - private的属性：key加类型作为前缀\n    - protected的属性：'*'加key作为前缀\n    ```\n    class test\n    {\n        public $a = 123;\n        private $b = 'bbb';\n        protected $c = 'ccc';\n    }\n\n    $test = new test();\n    print_r((array)$test);\n    ```\n    以上例子将输出：\n    ```\n    $php stat.php \n    Array\n    (\n        [a] => 123\n        [testb] => bbb\n        [*c] => ccc\n    )\n    ```\n\n###### 转换为对象\n其他任何类型的值被转换为对象，将会创建一个内置类stdClass的实例：\n- 若该值为null：新的实例为空\n- array：转换成的object将以键名成为属性名，并具有相对应的值\n    - 数值索引的元素也将转为属性，但无法通过“->”访问，只能遍历获取\n    - 非数值索引：会以‘scalar’作为属性名","slug":"PHP7内核-变量","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7fth001k0sg32kil4ne6","content":"<h4 id=\"变量的内部实现\"><a href=\"#变量的内部实现\" class=\"headerlink\" title=\"变量的内部实现\"></a>变量的内部实现</h4><p>​        变量是一个语言实现的基础，变量有两个组成部分：变量名、变量值，PHP中可以将其对应为：<code>zval</code>、<code>zend_value</code>，这两个概念一定要区分开，PHP中变量的内存是通过<code>引用计数</code>进行管理的，而且<strong>PHP7中引用计数是在<code>zend_value</code>而不是zval上，变量之间的传递、赋值通常也是针对zend_value</strong>。</p>\n<a id=\"more\"></a>\n\n<p>PHP中可以通过<code>$关键词</code>定义一个变量：<code>$a;</code>，在定义的同时可以进行初始化：<code>$a = &quot;hi~&quot;;</code><u>注意这实际是两步：定义、初始化</u>，只定义一个变量也是可以的，可以不给它赋值，比如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a;</span><br><span class=\"line\">$b = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>这段代码在执行时会分配两个zval。</p>\n<h4 id=\"变量的基础结构\"><a href=\"#变量的基础结构\" class=\"headerlink\" title=\"变量的基础结构\"></a>变量的基础结构</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//zend_types.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span>     <span class=\"title\">zval</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span> &#123;</span></span><br><span class=\"line\">    zend_value        value; <span class=\"comment\">//变量实际的value</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_4(  <span class=\"comment\">//这个是为了兼容大小字节序，小字节序就是下面的顺序，大字节序则下面4个顺序翻转</span></span><br><span class=\"line\">                zend_uchar    type,         <span class=\"comment\">//变量类型</span></span><br><span class=\"line\">                zend_uchar    type_flags,  <span class=\"comment\">//类型掩码，不同的类型会有不同的几种属性，内存管理会用到</span></span><br><span class=\"line\">                zend_uchar    const_flags,</span><br><span class=\"line\">                zend_uchar    reserved)     <span class=\"comment\">//call info，zend执行流程会用到</span></span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> type_info; <span class=\"comment\">//上面4个值的组合值，可以直接根据type_info取到4个对应位置的值</span></span><br><span class=\"line\">    &#125; u1;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     var_flags;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     next;                 <span class=\"comment\">//哈希表中解决哈希冲突时用到</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     cache_slot;           <span class=\"comment\">/* literal cache slot 运行时缓存会用到*/</span> </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     lineno;               <span class=\"comment\">/* line number (for ast nodes) */</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     num_args;             <span class=\"comment\">/* arguments number for EX(This) */</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     fe_pos;               <span class=\"comment\">/* foreach position foreach遍历时会用到*/</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     fe_iter_idx;          <span class=\"comment\">/* foreach iterator index */</span></span><br><span class=\"line\">    &#125; u2; <span class=\"comment\">//一些辅助值</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>        zval</code>结构比较简单，内嵌一个union类型的<code>zend_value</code>保存具体变量类型的值或指针，zval中还有两个union：<code>u1</code>、<code>u2</code>:</p>\n<ul>\n<li><strong>u1</strong>: 它是联合了一个结构体<code>v</code>和一个32位无符号整型<code>type_info</code>；ZEND_ENDIAN_LOHI_4是一个宏，用于解决字节序问题的，他会根据系统字节序决定struct v中4个成员的顺序。v定义了4个成员变量，<strong>变量的类型就通过u1.v.type区分</strong>；另外一个值<code>type_flags</code>为类型掩码，在变量的内存管理、gc机制中会用到；至于后面两个const_flags、reserved暂且不管。</li>\n<li><strong>u2</strong>: 这个值纯粹是个辅助值，zval结构中value、u1分别占了8byte、4byte，一共12byte，假如zval只有:value、u1两个值，整个zval的大小也会对齐到16byte，既然不管有没有u2大小都是16byte，把多余的4byte拿出来用于一些特殊用途还是很划算的，比如next在哈希表解决哈希冲突时会用到，还有fe_pos在foreach会用到……  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> _zend_value &#123;</span><br><span class=\"line\">    zend_long         lval;    <span class=\"comment\">//int整形</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span>            dval;    <span class=\"comment\">//浮点型</span></span><br><span class=\"line\">    zend_refcounted  *counted;</span><br><span class=\"line\">    zend_string      *str;     <span class=\"comment\">//string字符串</span></span><br><span class=\"line\">    zend_array       *arr;     <span class=\"comment\">//array数组</span></span><br><span class=\"line\">    zend_object      *obj;     <span class=\"comment\">//object对象</span></span><br><span class=\"line\">    zend_resource    *res;     <span class=\"comment\">//resource资源类型</span></span><br><span class=\"line\">    zend_reference   *ref;     <span class=\"comment\">//引用类型，通过&amp;$var_name定义的</span></span><br><span class=\"line\">    zend_ast_ref     *ast;     <span class=\"comment\">//下面几个都是内核使用的value</span></span><br><span class=\"line\">    zval             *zv;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>             *ptr;</span><br><span class=\"line\">    zend_class_entry *ce;</span><br><span class=\"line\">    zend_function    *func;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> w1;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> w2;</span><br><span class=\"line\">    &#125; ww;</span><br><span class=\"line\">&#125; zend_value;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>​        <code>zend_value</code>是一个联合体，各个类型根据自己的类型选择使用不同的成员，<strong>从zend_value可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构</strong>。zend_value中没有布尔型，这是因为PHP7中将布尔型具体拆分为了true、false两种类型，通过zval.u1.v.type进行区分（注：老版本中，布尔型是通过整型进行区分的）</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><code>zval.u1.type</code>类型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* regular data types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_UNDEF                    0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_NULL                     1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_FALSE                    2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TRUE                     3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_LONG                     4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_DOUBLE                   5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_STRING                   6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_ARRAY                    7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_OBJECT                   8</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_RESOURCE                 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_REFERENCE                10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* constant expressions */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CONSTANT                 11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CONSTANT_AST             12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* fake types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _IS_BOOL                    13</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CALLABLE                 14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* internal types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_INDIRECT                 15</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_PTR                      17</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"标量类型\"><a href=\"#标量类型\" class=\"headerlink\" title=\"标量类型\"></a>标量类型</h5><ul>\n<li>没有value，直接根据type区分的类型：<code>true</code>、<code>false</code>、<code>null</code></li>\n<li>值存于value中，无需额外的value指针：<code>zend_long</code>、 <code>double</code></li>\n</ul>\n<h5 id=\"字符串（zend-string）\"><a href=\"#字符串（zend-string）\" class=\"headerlink\" title=\"字符串（zend_string）\"></a>字符串（zend_string）</h5><p>​        PHP中没有使用<code>char</code>来表示字符串，而是为字符串单独定义了一个结构<code>zend_string</code>，其中除了存储字符串内容，还存储了其他信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_string</span> &#123;</span></span><br><span class=\"line\">    zend_refcounted_h gc; <span class=\"comment\">// 变量引用计数信息，用于内存管理。比如当前value的引用数，所有用到引用计数的变量类型都会有这个结构</span></span><br><span class=\"line\">    zend_ulong        h;  <span class=\"comment\">/* hash value 哈希值，数组中计算索引时会用到*/</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span>            len; <span class=\"comment\">// 字符串长度，通过这个值保证二进制安全</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>              val[<span class=\"number\">1</span>]; <span class=\"comment\">// 字符串内容，变长struct，分配时按len长度申请内存</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>​        字符串内容<code>val</code>是一个可变数组，在字符串分配时的操作为<code>malloc(sizeof(zend_string) + 字符串长度)</code>。<br><em>注：val中多出一个字节（val[1]而不是val[0]）用于存储字符串的最后一个字符”\\0”.</em></p>\n<p>例如：$a=”abc”，对应zend_string内存结构如下：<br><img src=\"https://note.youdao.com/yws/api/personal/file/39A4055CBC584591A643CF8855653427?method=download&shareKey=100018cf52486ade9a25e3f4d8227678\" alt=\"zend_string内存结构\"></p>\n<p>字符串具体分类：</p>\n<ul>\n<li><code>IS_STR_PERSISTENT</code>: 通过malloc分配。</li>\n<li><code>IS_STR_INTERNED</code>: php代码中写的一些字面量，如函数名、变量名。</li>\n<li><code>IS_STR_PERMERNENT</code>:永久值，生命周期大于request。</li>\n<li><code>IS_STR_CONSTANT</code>:常量。</li>\n<li><code>IS_STR_CONSTANT_UNQUALIFIED</code>:这个信息通过flag保存：zval.value-&gt;gc.u.flags</li>\n</ul>\n<h5 id=\"数组（array）\"><a href=\"#数组（array）\" class=\"headerlink\" title=\"数组（array）\"></a>数组（array）</h5><p>​        <code>Array</code>是PHP中非常强大的一个数据结构，它的<strong>底层实现为散列表（HashTable 哈希表）</strong>。<br>​        散列表是根据<code>key</code>直接进行访问的数据结构，它的<code>key-value</code>之间有一个映射函数，可以根据key通过映射函数直接索引到对应的value值，直接根据<code>“内存起始地址+偏移值”</code>进行寻址，加快查找速度。理想情况下，查找的期望时间复杂度为O(1).</p>\n<p>HashTable的数据结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_array</span> <span class=\"title\">HashTable</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_array</span> &#123;</span></span><br><span class=\"line\">    zend_refcounted_h gc; <span class=\"comment\">//引用计数信息，与字符串相同</span></span><br><span class=\"line\">    <span class=\"comment\">// 提供一些辅助的功能，比如，flag用来设置散列表的一些属性，是否持久化、是否已经初始化。</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_4(</span><br><span class=\"line\">                zend_uchar    flags,</span><br><span class=\"line\">                zend_uchar    nApplyCount,</span><br><span class=\"line\">                zend_uchar    nIteratorsCount,</span><br><span class=\"line\">                zend_uchar    reserve)</span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    &#125; u;</span><br><span class=\"line\">    <span class=\"comment\">// 用于散列函数映射存储元素在arData数组中的下标。其值实际是nTableSize的负数，即nTableMask=-nTableSize（nTableMask=~nTableSize+1）</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nTableMask; <span class=\"comment\">//计算bucket索引时的掩码</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储元素数组，每个元素的结构统一为Bucket，其内存是连续的，arData指向第一个Bucket（即指向数组的起始位置）</span></span><br><span class=\"line\">    Bucket           *arData; <span class=\"comment\">//bucket数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前已使用的Bucket数，但这些Bucket并不都是有效的，因此再删除一个数组元素时，并不会马上将其从数组中移除，而是将这个元素的类型表位IS_UNDEF，只有在数组容量超过限制，需要扩容时才会删除。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nNumUsed; </span><br><span class=\"line\">    <span class=\"comment\">// 数组实际存储的元素数（有效元素数）。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nNumOfElements; <span class=\"comment\">//已有元素数，nNumOfElements &lt;= nNumUsed，因为删除的并不是直接从arData中移除</span></span><br><span class=\"line\">    <span class=\"comment\">// 数组的总容量，其大小为2的幂次方，最小为8（即2^3）。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nTableSize; <span class=\"comment\">//数组的大小，为2^n</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nInternalPointer; <span class=\"comment\">//数值索引</span></span><br><span class=\"line\">    <span class=\"comment\">// 下一个可用的数值索引，如arr[]=1;arr[&#x27;a&#x27;]=2;arr[]=3;则nNextFreeElement=2；该成员是给自动确定数值索引使用的。</span></span><br><span class=\"line\">    zend_long         nNextFreeElement;</span><br><span class=\"line\">    <span class=\"comment\">// 当删除或覆盖数组中的某个元素时，若提供了这个函数句柄，则会回调此函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">dtor_func_t</span>       pDestructor;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>Bucket的结构如下,主要用来保存元素的key及value。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Bucket</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储的具体的value，这里嵌入了一个zval而不是一个指针。</span></span><br><span class=\"line\">\tzval              val;</span><br><span class=\"line\">\t<span class=\"comment\">// hash code，用来映射元素的存储位置。若元素是数值索引，那么他的值就是数值索引的值；若是字符串，那么这个只就是根据字符串key通过Time33算法计算得到的散列值。</span></span><br><span class=\"line\">\tzend_ulong        h;                <span class=\"comment\">/* hash value (or numeric index)   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 存储元素的key。</span></span><br><span class=\"line\">\tzend_string      *key;              <span class=\"comment\">/* string key or NULL for numerics */</span></span><br><span class=\"line\">&#125; Bucket;</span><br></pre></td></tr></table></figure>\n<h6 id=\"基本实现\"><a href=\"#基本实现\" class=\"headerlink\" title=\"基本实现\"></a>基本实现</h6><p>散列表主要由两部分组成：</p>\n<ul>\n<li>存储元素数组</li>\n<li>散列函数<br>一个简单的散列函数可以采用取模的方式，比如散列表的大小为8，那么在散列表初始化数组时就会分配8个元素大小的空间，根据key的hash code与8取模的到的值作为该元素在数组中的下标。其示意图如下：</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/F2CB6F384907410BB02F7F7411F4E341?method=download&shareKey=fc47b2317eb268543f1440ed7296beb0\" alt=\"散列表的基本实现\"></p>\n<p>**以散列函数的输出值作为该元素在存储元素数组中的下标的方式有一个问题: **元素在数组中的位置是随机的，它是无序的。</p>\n<ul>\n<li><strong>问：那么PHP是如何保证元素的顺序与其插入顺序一致？</strong> <pre><code>    为了实现散列表的有序性，PHP在散列函数与元素数组之间加了一层映射表，该映射表也是一个数组，大小与存储元素的数组相同，它存储的元素类型为整型，用于保存实际存储的有序数组中的下标：**元素按照先后顺序依次插入实际存储的数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中**，如下图所示。</code></pre>\n</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/A8DBDBE3688A48739E06BF38ACDA300F?method=download&shareKey=6e4969019969485debc917c11a87da4d\" alt=\"散列表映射关系\"></p>\n<p>原理如上，但实际上PHP是将这个映射表与arData放在一起，在数组初始化时会分配存储Bucket的内存，同时还会分配相同数量的uint32_t大小的空间，将arData偏移到存储元素数组的位置，这个中间映射表可以通过arData向前访问到。如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/358B60D6F6AA407E9B034BACE5E8ACB6?method=download&shareKey=e515e9d30e617ea6c6fa8b9475a9efeb\" alt=\"HashTable中间映射表\"></p>\n<h6 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h6><p>​        通常散列会数会以取模的方式给出，比如：<code>key-&gt;h%nTableSize</code>.但是PHP采用了另一种方式，因为散列表的大小为2的幂次方，所以通过<strong>或运算</strong>可以得到<code>[-1,nTableMask]</code>之间的散列值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nIndex &#x3D; h | ht-&gt;nTableMask</span><br></pre></td></tr></table></figure>\n\n\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h&#x3D;18003212</span><br><span class=\"line\">nTableSize&#x3D;8</span><br><span class=\"line\"></span><br><span class=\"line\">nTableMask&#x3D;-8</span><br><span class=\"line\">nIndex&#x3D;-4</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"数组的初始化\"><a href=\"#数组的初始化\" class=\"headerlink\" title=\"数组的初始化\"></a>数组的初始化</h6><p>​        数组初始化的过程主要是对<code>HashTable</code>中的成员进行设置，初始化时并不会立即分配<code>arData</code>的内存，<code>arData</code>的内存在<strong>插入第一个元素时才会分配</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL _zend_hash_init(HashTable *ht, <span class=\"keyword\">uint32_t</span> nSize, <span class=\"keyword\">dtor_func_t</span> pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化gc信息</span></span><br><span class=\"line\">\tGC_REFCOUNT(ht) = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tGC_TYPE_INFO(ht) = IS_ARRAY;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置flags</span></span><br><span class=\"line\">\tht-&gt;u.flags = (persistent ? HASH_FLAG_PERSISTENT : <span class=\"number\">0</span>) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;</span><br><span class=\"line\">\t<span class=\"comment\">// nTableMask的值是临时的</span></span><br><span class=\"line\">\tht-&gt;nTableMask = HT_MIN_MASK;</span><br><span class=\"line\">\t<span class=\"comment\">// 临时设置ht-&gt;arData</span></span><br><span class=\"line\">\tHT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket);</span><br><span class=\"line\">\tht-&gt;nNumUsed = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;nNumOfElements = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;nInternalPointer = HT_INVALID_IDX;</span><br><span class=\"line\">\tht-&gt;nNextFreeElement = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;pDestructor = pDestructor;</span><br><span class=\"line\">\t<span class=\"comment\">// 把数组的大小重置为2的幂次方</span></span><br><span class=\"line\">\tht-&gt;nTableSize = zend_hash_check_size(nSize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h6><p>​        插入时，会检查数组是否已经分配存储空间。PHP会在第一次插入时根据<code>nTableSize</code>的大小分配，分配完成后把<code>HashTable-&gt;u.flags</code>打上<code>HASH_FLAG_INITIALIZAED</code>掩码。</p>\n<ul>\n<li><p>分配内存<br>分配的内存包括映射表及元素数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nTableSize * (sizeof(Bucket) + sizeof(uint32_t))</span><br></pre></td></tr></table></figure>\n<p>分配完成后，将<code>HashTable-&gt;arData</code>指向第一个<code>Bucket</code>的位置。</p>\n</li>\n<li><p>插入数据<br>将元素按照顺序插入<code>arData</code>，然后将其在<code>arData</code>数组中的位置存储到根据<code>key</code>的<code>hash code</code>（即<code>key-&gt;h</code>）与<code>nTableMask</code>计算得到的中间映射表中的对应位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zend_hash.c</span><br><span class=\"line\"><span class=\"comment\">// _zend_hash_add_or_update_i:</span></span><br><span class=\"line\">add_to_hash:</span><br><span class=\"line\">\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t<span class=\"comment\">// idx为Bucket在arData中存储位置</span></span><br><span class=\"line\">\tidx = ht-&gt;nNumUsed++;</span><br><span class=\"line\">\tht-&gt;nNumOfElements++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ht-&gt;nInternalPointer == HT_INVALID_IDX) &#123;</span><br><span class=\"line\">\t\tht-&gt;nInternalPointer = idx;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((zend_long)h &gt;= (zend_long)ht-&gt;nNextFreeElement) &#123;</span><br><span class=\"line\">\t\tht-&gt;nNextFreeElement = h &lt; ZEND_LONG_MAX ? h + <span class=\"number\">1</span> : ZEND_LONG_MAX;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找到存储Bucket，设置key、value</span></span><br><span class=\"line\">\tp = ht-&gt;arData + idx;</span><br><span class=\"line\">\tp-&gt;h = h;</span><br><span class=\"line\">\tp-&gt;key = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算中间映射表的散列值，idx将保存在映射数组的nIndex位置</span></span><br><span class=\"line\">\tnIndex = h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t<span class=\"comment\">// 将映射表中原来的值保存到新Bucket中，哈希冲突时会用到</span></span><br><span class=\"line\">\tZVAL_COPY_VALUE(&amp;p-&gt;val, pData);</span><br><span class=\"line\">\t<span class=\"comment\">// 先把旧的值保存到新插入的元素中</span></span><br><span class=\"line\">\tZ_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class=\"line\">\t<span class=\"comment\">// 再把新元素数组存储位置更新到映射表中</span></span><br><span class=\"line\">\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);</span><br><span class=\"line\">\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;p-&gt;val;</span><br></pre></td></tr></table></figure>\n<h6 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h6><p>​        散列表中不同元素的<code>key</code>可能计算得到相同的哈希值，这些具有相同哈希值的元素在插入散列表时就会发生冲突，因为映射表只能存储一个元素。  </p>\n</li>\n</ul>\n<p><strong>常见的解决方式（PHP采用这种方式）：将冲突的Bucket串成链表，查找时需要遍历这个链表，逐个比较<code>key</code>，从而找到目标元素。</strong></p>\n<ul>\n<li>具体操作：<pre><code>    `HashTable`中的`Bucket`会记录与它冲突的元素在`arData`数组中的存储位置。在设置映射值时，如果发现映射表中要设置的位置已经被之前插入的元素占用了（值不等于初始化的-1），那么会把已经存在的值保存到新插入的`Bucket`中，然后将映射表中的值更新为新`Bucket`的存储位置（即每次都会把冲突的元素插到开头）。  </code></pre>\n<strong>冲突元素的保存位置为：</strong><code>Bucket.val.u2.next</code></li>\n</ul>\n<p><strong>示例</strong>：一个数组有三个元素，按照a、b、c的顺序插入，加入a、c两个key冲突了，则HashTable的结构如下：<br>$arr = [];<br>$arr[‘a’] = 11;<br>$arr[‘b’] = 22;<br>$arr[‘c’] = 33;<br><img src=\"https://note.youdao.com/yws/api/personal/file/C469391F27FF454698CCD908B98FB2B2?method=download&shareKey=9501d4a7b3029c279f3d545c7f9c18e2\" alt=\"哈希冲突链表\"></p>\n<h6 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h6><p>查找过程如下：</p>\n<ul>\n<li>①、根据<code>key</code>计算出<code>hash code</code>（即<code>zend_string-&gt;h</code>）与<code>nTableMask</code>计算得到散列值<code>nIndex</code>。</li>\n<li>②、根据散列值从中间映射表中得到存储元素在有序存储数组中的位置<code>idx</code>。</li>\n<li>③、根据<code>idx</code>从有序存储数组（<code>HashTable-&gt;arData</code>）中取出<code>Bucket</code></li>\n<li>④、从取出的<code>Bucket</code>进行遍历，判断Bucket的key是否是要查找的key，若是则停止遍历，否则继续根据<code>zval.u2.next</code>遍历比较。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_hash_find_bucket:</span></span><br><span class=\"line\"><span class=\"comment\">// 根据zend_string *key进行查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline Bucket *<span class=\"title\">zend_hash_find_bucket</span><span class=\"params\">(<span class=\"keyword\">const</span> HashTable *ht, zend_string *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tzend_ulong h;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> nIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> idx;</span><br><span class=\"line\">\tBucket *p, *arData;</span><br><span class=\"line\"></span><br><span class=\"line\">\th = zend_string_hash_val(key);</span><br><span class=\"line\">\tarData = ht-&gt;arData;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算散列值</span></span><br><span class=\"line\">\tnIndex = h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取Bucket存储位置</span></span><br><span class=\"line\">\tidx = HT_HASH_EX(arData, nIndex);</span><br><span class=\"line\">    <span class=\"comment\">// 遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (EXPECTED(idx != HT_INVALID_IDX)) &#123;</span><br><span class=\"line\">\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (EXPECTED(p-&gt;key == key)) &#123; <span class=\"comment\">/* check for the same interned string */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (EXPECTED(p-&gt;h == h) &amp;&amp; <span class=\"comment\">// 先比较hash code</span></span><br><span class=\"line\">\t\t     EXPECTED(p-&gt;key) &amp;&amp; </span><br><span class=\"line\">\t\t     <span class=\"comment\">// 在比较key长度，最后按字符比较是否相同</span></span><br><span class=\"line\">\t\t     EXPECTED(ZSTR_LEN(p-&gt;key) == ZSTR_LEN(key)) &amp;&amp;</span><br><span class=\"line\">\t\t     EXPECTED(<span class=\"built_in\">memcmp</span>(ZSTR_VAL(p-&gt;key), ZSTR_VAL(key), ZSTR_LEN(key)) == <span class=\"number\">0</span>)) &#123;<span class=\"comment\">// 比较查找的key与Bucket的key是否匹配</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 不匹配则继续遍历</span></span><br><span class=\"line\">\t\tidx = Z_NEXT(p-&gt;val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h6 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h6><p>​        数组的容量是有限的，最多可以存储<code>nTableSize</code>个元素，那么当数组空间已满还要继续插入时如何处理？  </p>\n<p><strong>问: PHP是怎样实现的自动扩容？</strong></p>\n<p>​        <strong>扩容的过程为</strong>：检查数组中已经删除的元素所占的比例（已经删除但未从存储数组中移除的元素）.若比例达到域值，则触发<strong>重建索引</strong>的操作，这个过程会把删除的Bucket移除，然后把后面的Bucket往前移补上空缺的Bucket；若还没有达到域值，则分配一个原数组大小2倍的新数组，然后把原数组的元素复制到新数组上，重建索引。 </p>\n<p><u>域值判断公式</u>如下，即域值为<code>nNumOfElement + (nNumElement / 32)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElement + (ht-&gt;nNumOfElement &gt;&gt; 5)</span><br></pre></td></tr></table></figure>\n\n<p>具体的处理过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">zend_hash_do_resize</span><span class=\"params\">(HashTable *ht)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tIS_CONSISTENT(ht);</span><br><span class=\"line\">\tHT_ASSERT(GC_REFCOUNT(ht) == <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; <span class=\"number\">5</span>)) &#123; <span class=\"comment\">// 无序扩容，将删除的Bucket移除，然后把后面的bucket往前补上空缺</span></span><br><span class=\"line\">\t\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 只有到达一定域值才进行rehash操作</span></span><br><span class=\"line\">\t\tzend_hash_rehash(ht); <span class=\"comment\">// 重建索引数组</span></span><br><span class=\"line\">\t\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ht-&gt;nTableSize &lt; HT_MAX_SIZE) &#123; <span class=\"comment\">// 扩容，分配原数组大小2倍的新数组。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span> *new_data, *old_data = HT_GET_DATA_ADDR(ht);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 扩大为2倍，加法比乘法快</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> nSize = ht-&gt;nTableSize + ht-&gt;nTableSize;</span><br><span class=\"line\">\t\tBucket *old_buckets = ht-&gt;arData;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 新分配arData空间，大小为(sizeof(Bucket) + sizeof(uint32_t)) * nSize;</span></span><br><span class=\"line\">\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class=\"line\">\t\tht-&gt;nTableSize = nSize;</span><br><span class=\"line\">\t\tht-&gt;nTableMask = -ht-&gt;nTableSize;</span><br><span class=\"line\">\t    <span class=\"comment\">// 将arData指针偏移到Bucket数组起始位置</span></span><br><span class=\"line\">\t\tHT_SET_DATA_ADDR(ht, new_data);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将旧的Bucket数组复制到新空间（此步只复制存储的元素，即HashTable-&gt;arData，不会复制中间映射表，因为扩容后旧的映射表已无法使用，key-value的映射关系需要重新计算，即重建索引）</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memcpy</span>(ht-&gt;arData, old_buckets, <span class=\"keyword\">sizeof</span>(Bucket) * ht-&gt;nNumUsed);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 释放旧空间</span></span><br><span class=\"line\">\t\tpefree(old_data, ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 重建索引数组：映射表</span></span><br><span class=\"line\">\t\tzend_hash_rehash(ht);</span><br><span class=\"line\">\t\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tzend_error_noreturn(E_ERROR, <span class=\"string\">&quot;Possible integer overflow in memory allocation (%zu * %zu + %zu)&quot;</span>, ht-&gt;nTableSize * <span class=\"number\">2</span>, <span class=\"keyword\">sizeof</span>(Bucket) + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">uint32_t</span>), <span class=\"keyword\">sizeof</span>(Bucket));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重建索引的过程实际上就是将所有元素重新插入一遍，其处理过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 遍历数组，重新设置中间映射表（索引表）</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">\t\t\tnIndex &#x3D; p-&gt;h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t\t\tZ_NEXT(p-&gt;val) &#x3D; HT_HASH(ht, nIndex);</span><br><span class=\"line\">\t\t\tHT_HASH(ht, nIndex) &#x3D; HT_IDX_TO_HASH(i);</span><br><span class=\"line\">\t\t\tp++;</span><br><span class=\"line\">\t\t&#125; while (++i &lt; ht-&gt;nNumUsed);</span><br></pre></td></tr></table></figure>\n<p>重建索引会将已删除的bucket移除，移除后会把这个Bucket之后的元素全部向前移动一个位置，所以<strong>重建索引后存储数组中元素全部紧密排列在一起</strong>。</p>\n<h5 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h5><p>​        引用类型是PHP中比较特殊的一种类型，它实际是指向另外一个PHP变量（<em>在PHP中通过<code>&amp;操作符</code>产生一个引用变量</em>），对它的修改会直接改动实际指向的zval，<u>可以简单的理解为C中的指针</u>。  </p>\n<p>操作步骤：</p>\n<ul>\n<li>首先为<code>&amp;</code>操作的变量分配一个<code>zend_reference结构</code>，其内嵌一个<code>zval</code>，这个<code>zval</code>的<code>value</code>指向原来<code>zval</code>的<code>value</code>(<strong>注: 如果是布尔、整形、浮点则直接复制原来的值</strong>)。</li>\n<li>然后将原<code>zval</code>的类型修改为<code>IS_REFERENCE</code>，原<code>zval</code>的<code>value</code>指向新创建的<code>zend_reference</code>结构。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_reference &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    zval              val; &#x2F;&#x2F; 指向原来的value</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n示例1：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; date(&#39;Y-m-d&#39;);</span><br><span class=\"line\">$b &#x3D; &amp;$a;</span><br></pre></td></tr></table></figure>\n<img src=\"https://note.youdao.com/yws/api/personal/file/A5F4C7219117457A88A7D7CC3AFB53A9?method=download&shareKey=3d6950341fd9f21fea74f78f022500fd\" alt=\"a与b内存引用关系\"></li>\n</ul>\n<p><strong>注：若此时将<code>$b</code>复制给其他变量，那么传递给新变量的value将实时及引用的值，而不是引用本身</strong>。PHP中的引用只有一级，不会出现一个引用指向另外一个引用的情况，即没有C语言中多级指针的概念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; date(&#39;Y-m-d&#39;);</span><br><span class=\"line\">$b &#x3D; &amp;$a;</span><br><span class=\"line\">$c &#x3D; $b; &#x2F;&#x2F; 若想让$c也指向$a&#x2F;$b引用的值，则：$c &#x3D; &amp;$b或$c &#x3D; &amp;$a;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/1E8C8DDDE51D479296CA8F63EA5353B7?method=download&shareKey=43183c8018d3140f9b924508528c2af2\" alt=\"a,b与c内存引用关系\"></p>\n<p>示例2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a    -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/697F728B851442D4AF142554DDF78333?method=download&shareKey=59d725805b5b7c8bc59c391e87607101\" alt=\"zend_ref\"></p>\n<p>注意：<strong>引用只能通过<code>&amp;</code>产生，无法通过赋值传递</strong>  </p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:</span><br><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a    -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$c &#x3D; $b;                    &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;2)</span><br><span class=\"line\">                            &#x2F;&#x2F;$c    -&gt; </span><br><span class=\"line\">right:</span><br><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a       -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b    -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$c &#x3D; &amp;$b;&#x2F;*或$c &#x3D; &amp;$a*&#x2F;     &#x2F;&#x2F;$a,$b,$c -&gt; zend_reference_1(refcount&#x3D;3) -&gt; zend_string_1(refcount&#x3D;1)                             </span><br></pre></td></tr></table></figure>\n<p>这个也表示PHP中的 <strong>引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况</strong> ，也就是没有C语言中指针的指针的概念。</p>\n<h5 id=\"对象-资源\"><a href=\"#对象-资源\" class=\"headerlink\" title=\"对象/资源\"></a>对象/资源</h5><p>对象比较常见，资源指的是tcp连接、文件句柄等等类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_object &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    uint32_t          handle;</span><br><span class=\"line\">    zend_class_entry *ce; &#x2F;&#x2F;对象对应的class类</span><br><span class=\"line\">    const zend_object_handlers *handlers;</span><br><span class=\"line\">    HashTable        *properties; &#x2F;&#x2F;对象属性哈希表</span><br><span class=\"line\">    zval              properties_table[1];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct _zend_resource &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    int               handle;</span><br><span class=\"line\">    int               type;</span><br><span class=\"line\">    void             *ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h5><p>​        PHP是弱类型语言，使用时不需要明确定义变量的类型，Zend虚拟机在执行PHP代码时，会根据具体的应用场景进行转换，也就是变量会按照类型转换规则将不合格变量转换给合格的变量，然后进行操作。</p>\n<p>例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; &quot;100&quot; + 200</span><br></pre></td></tr></table></figure>\n<p>执行时Zend发现相加的一个值为字符串，就会试图将<code>字符串100</code>转为数值类型（整型或浮点型），然后与200相加。<br><strong>注：转换的时候并不会改变原来的值，而是会生成一个新的变量进行处理。</strong></p>\n<h6 id=\"强制转换\"><a href=\"#强制转换\" class=\"headerlink\" title=\"强制转换\"></a>强制转换</h6><p>PHP提供了一种强制转换方式：</p>\n<ul>\n<li>(int)/(integer): 转换为整型integer</li>\n<li>(bool)/(boolean):转换为布尔类型boolean</li>\n<li>(flaot)/(double)/(real):转换为浮点型flaot</li>\n<li>(string):转换为字符串string</li>\n<li>(array):转换为数组array</li>\n<li>(object):转换为对象object</li>\n<li>(unset):转换为null</li>\n</ul>\n<p><em>注：有些类型之间是无法转换的，如：资源类型，无法将任何类型转换为资源类型。</em></p>\n<h6 id=\"转换为null\"><a href=\"#转换为null\" class=\"headerlink\" title=\"转换为null\"></a>转换为null</h6><p>​        任意类型都可以转为null，转换时直接将新的<code>zval类型</code>设置为<code>IS_NULL</code>。</p>\n<h6 id=\"转换为布尔型\"><a href=\"#转换为布尔型\" class=\"headerlink\" title=\"转换为布尔型\"></a>转换为布尔型</h6><p>​        当转换为布尔型时，根据原值的<code>true</code>、<code>false</code>决定转换后的结果，一些值被认为是<code>false</code>，除此之外的其他值通常被认为是<code>true</code>。</p>\n<p>被认为是false的值:</p>\n<ul>\n<li>布尔值false本身</li>\n<li>整型0</li>\n<li>浮点型值0.0</li>\n<li>==空字符串（‘’），以及字符串‘0’==</li>\n<li>空数组</li>\n<li>null</li>\n</ul>\n<h6 id=\"转换为整型\"><a href=\"#转换为整型\" class=\"headerlink\" title=\"转换为整型\"></a>转换为整型</h6><p>从<code>其他值</code>转换为<code>整型</code>的规则如下：</p>\n<ul>\n<li>null：转换为0</li>\n<li>布尔型：false转为0，true转为1</li>\n<li>浮点型：向下取整，比如，(int)2.8 = 2</li>\n<li>字符串：与C语言strtoll()的规则一致<ul>\n<li>字符串以合法数值(包含正负数)开始，就使用该数值</li>\n<li><strong>否则，其值为0</strong></li>\n</ul>\n</li>\n<li>数组：很多操作不支持将一个数组自动转为整型处理，比如array()+2将报error错误，但可以强制把数组转为整型：<ul>\n<li>非空数组：1</li>\n<li>空数组：0<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php &gt; $a = <span class=\"keyword\">array</span>()+<span class=\"number\">2</span>;</span><br><span class=\"line\">PHP Fatal <span class=\"built_in\">error</span>:  Unsupported operand types in php shell code on line <span class=\"number\">1</span></span><br><span class=\"line\">PHP Stack trace:</span><br><span class=\"line\">PHP   <span class=\"number\">1.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br><span class=\"line\">PHP   <span class=\"number\">2.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; $a = <span class=\"keyword\">array</span>();</span><br><span class=\"line\">php &gt; $b = (<span class=\"keyword\">int</span>)$a;</span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> $b;</span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>对象：与数组类似，很多操作也不支持将兑现个自动转为整型，但有些操作只会抛一个warning警告，还是会把对象转换为1.</li>\n<li>资源：转为分配给这个资源的唯一编号</li>\n</ul>\n<h6 id=\"转为浮点型\"><a href=\"#转为浮点型\" class=\"headerlink\" title=\"转为浮点型\"></a>转为浮点型</h6><p>​        除了字符串类型外，其他类型转换规则与整型基本一致，只是在整型转换结果上加了小数位，字符串转为浮点数有<code>zend_strtod</code>完成。</p>\n<h6 id=\"转换为字符串\"><a href=\"#转换为字符串\" class=\"headerlink\" title=\"转换为字符串\"></a>转换为字符串</h6><ul>\n<li>强制转换：<ul>\n<li>(string)</li>\n<li>strval()函数</li>\n</ul>\n</li>\n<li>自动转换：<ul>\n<li>需要字符串的表达式中，比如：函数echo或print时</li>\n<li>非string类型变量与一个string变量进行比较时<ul>\n<li>null/fasle:转为空字符串</li>\n<li>true：转为“1”</li>\n<li>整型：原样转为字符串，<strong>转换时将各位一次除10取余</strong></li>\n<li>浮点型：原样转为字符串</li>\n<li>资源：转为“Resource id#xxx”</li>\n<li>数组：转为“Array”，同时报Notice</li>\n<li>对象：不能转换，将报错,如下：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php &gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">php</span> &gt; </span>&#123;<span class=\"keyword\">public</span> $b;&#125;</span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; $a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;a= &#x27;</span> . $a;</span><br><span class=\"line\">PHP Catchable fatal <span class=\"built_in\">error</span>:  <span class=\"keyword\">Object</span> of <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">could</span> <span class=\"title\">not</span> <span class=\"title\">be</span> <span class=\"title\">converted</span> <span class=\"title\">to</span> <span class=\"title\">string</span> <span class=\"title\">in</span> <span class=\"title\">php</span> <span class=\"title\">shell</span> <span class=\"title\">code</span> <span class=\"title\">on</span> <span class=\"title\">line</span> 1</span></span><br><span class=\"line\">PHP Stack trace:</span><br><span class=\"line\">PHP   <span class=\"number\">1.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"转换为数组\"><a href=\"#转换为数组\" class=\"headerlink\" title=\"转换为数组\"></a>转换为数组</h6></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>若变量类型为<code>null</code>、<code>integer</code>、<code>float</code>、<code>string</code>、<code>boolean</code>和<code>resource</code>中的一个：将得到一个仅有一个元素的数组，其<code>下标为0</code>，即(array)$scalarValue与<code>array($scalarValue)</code>完全一样。</li>\n<li>若变量类型为object：其结果为一个数组，数组的元素为该对象的全部属性（包含public、private、protected），但他们也是有区别的，如下：<ul>\n<li>public的属性：key</li>\n<li>private的属性：key加类型作为前缀</li>\n<li>protected的属性：’*’加key作为前缀<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public $a &#x3D; 123;</span><br><span class=\"line\">    private $b &#x3D; &#39;bbb&#39;;</span><br><span class=\"line\">    protected $c &#x3D; &#39;ccc&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$test &#x3D; new test();</span><br><span class=\"line\">print_r((array)$test);</span><br></pre></td></tr></table></figure>\n以上例子将输出：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$php stat.php </span><br><span class=\"line\">Array</span><br><span class=\"line\">(</span><br><span class=\"line\">    [a] &#x3D;&gt; 123</span><br><span class=\"line\">    [testb] &#x3D;&gt; bbb</span><br><span class=\"line\">    [*c] &#x3D;&gt; ccc</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"转换为对象\"><a href=\"#转换为对象\" class=\"headerlink\" title=\"转换为对象\"></a>转换为对象</h6><p>其他任何类型的值被转换为对象，将会创建一个内置类stdClass的实例：</p>\n<ul>\n<li>若该值为null：新的实例为空</li>\n<li>array：转换成的object将以键名成为属性名，并具有相对应的值<ul>\n<li>数值索引的元素也将转为属性，但无法通过“-&gt;”访问，只能遍历获取</li>\n<li>非数值索引：会以‘scalar’作为属性名</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"变量的内部实现\"><a href=\"#变量的内部实现\" class=\"headerlink\" title=\"变量的内部实现\"></a>变量的内部实现</h4><p>​        变量是一个语言实现的基础，变量有两个组成部分：变量名、变量值，PHP中可以将其对应为：<code>zval</code>、<code>zend_value</code>，这两个概念一定要区分开，PHP中变量的内存是通过<code>引用计数</code>进行管理的，而且<strong>PHP7中引用计数是在<code>zend_value</code>而不是zval上，变量之间的传递、赋值通常也是针对zend_value</strong>。</p>","more":"<p>PHP中可以通过<code>$关键词</code>定义一个变量：<code>$a;</code>，在定义的同时可以进行初始化：<code>$a = &quot;hi~&quot;;</code><u>注意这实际是两步：定义、初始化</u>，只定义一个变量也是可以的，可以不给它赋值，比如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a;</span><br><span class=\"line\">$b = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>这段代码在执行时会分配两个zval。</p>\n<h4 id=\"变量的基础结构\"><a href=\"#变量的基础结构\" class=\"headerlink\" title=\"变量的基础结构\"></a>变量的基础结构</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//zend_types.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span>     <span class=\"title\">zval</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span> &#123;</span></span><br><span class=\"line\">    zend_value        value; <span class=\"comment\">//变量实际的value</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_4(  <span class=\"comment\">//这个是为了兼容大小字节序，小字节序就是下面的顺序，大字节序则下面4个顺序翻转</span></span><br><span class=\"line\">                zend_uchar    type,         <span class=\"comment\">//变量类型</span></span><br><span class=\"line\">                zend_uchar    type_flags,  <span class=\"comment\">//类型掩码，不同的类型会有不同的几种属性，内存管理会用到</span></span><br><span class=\"line\">                zend_uchar    const_flags,</span><br><span class=\"line\">                zend_uchar    reserved)     <span class=\"comment\">//call info，zend执行流程会用到</span></span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> type_info; <span class=\"comment\">//上面4个值的组合值，可以直接根据type_info取到4个对应位置的值</span></span><br><span class=\"line\">    &#125; u1;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     var_flags;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     next;                 <span class=\"comment\">//哈希表中解决哈希冲突时用到</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     cache_slot;           <span class=\"comment\">/* literal cache slot 运行时缓存会用到*/</span> </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     lineno;               <span class=\"comment\">/* line number (for ast nodes) */</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     num_args;             <span class=\"comment\">/* arguments number for EX(This) */</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     fe_pos;               <span class=\"comment\">/* foreach position foreach遍历时会用到*/</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     fe_iter_idx;          <span class=\"comment\">/* foreach iterator index */</span></span><br><span class=\"line\">    &#125; u2; <span class=\"comment\">//一些辅助值</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>        zval</code>结构比较简单，内嵌一个union类型的<code>zend_value</code>保存具体变量类型的值或指针，zval中还有两个union：<code>u1</code>、<code>u2</code>:</p>\n<ul>\n<li><strong>u1</strong>: 它是联合了一个结构体<code>v</code>和一个32位无符号整型<code>type_info</code>；ZEND_ENDIAN_LOHI_4是一个宏，用于解决字节序问题的，他会根据系统字节序决定struct v中4个成员的顺序。v定义了4个成员变量，<strong>变量的类型就通过u1.v.type区分</strong>；另外一个值<code>type_flags</code>为类型掩码，在变量的内存管理、gc机制中会用到；至于后面两个const_flags、reserved暂且不管。</li>\n<li><strong>u2</strong>: 这个值纯粹是个辅助值，zval结构中value、u1分别占了8byte、4byte，一共12byte，假如zval只有:value、u1两个值，整个zval的大小也会对齐到16byte，既然不管有没有u2大小都是16byte，把多余的4byte拿出来用于一些特殊用途还是很划算的，比如next在哈希表解决哈希冲突时会用到，还有fe_pos在foreach会用到……  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> _zend_value &#123;</span><br><span class=\"line\">    zend_long         lval;    <span class=\"comment\">//int整形</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span>            dval;    <span class=\"comment\">//浮点型</span></span><br><span class=\"line\">    zend_refcounted  *counted;</span><br><span class=\"line\">    zend_string      *str;     <span class=\"comment\">//string字符串</span></span><br><span class=\"line\">    zend_array       *arr;     <span class=\"comment\">//array数组</span></span><br><span class=\"line\">    zend_object      *obj;     <span class=\"comment\">//object对象</span></span><br><span class=\"line\">    zend_resource    *res;     <span class=\"comment\">//resource资源类型</span></span><br><span class=\"line\">    zend_reference   *ref;     <span class=\"comment\">//引用类型，通过&amp;$var_name定义的</span></span><br><span class=\"line\">    zend_ast_ref     *ast;     <span class=\"comment\">//下面几个都是内核使用的value</span></span><br><span class=\"line\">    zval             *zv;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>             *ptr;</span><br><span class=\"line\">    zend_class_entry *ce;</span><br><span class=\"line\">    zend_function    *func;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> w1;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> w2;</span><br><span class=\"line\">    &#125; ww;</span><br><span class=\"line\">&#125; zend_value;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>​        <code>zend_value</code>是一个联合体，各个类型根据自己的类型选择使用不同的成员，<strong>从zend_value可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构</strong>。zend_value中没有布尔型，这是因为PHP7中将布尔型具体拆分为了true、false两种类型，通过zval.u1.v.type进行区分（注：老版本中，布尔型是通过整型进行区分的）</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><code>zval.u1.type</code>类型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* regular data types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_UNDEF                    0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_NULL                     1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_FALSE                    2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TRUE                     3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_LONG                     4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_DOUBLE                   5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_STRING                   6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_ARRAY                    7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_OBJECT                   8</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_RESOURCE                 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_REFERENCE                10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* constant expressions */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CONSTANT                 11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CONSTANT_AST             12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* fake types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _IS_BOOL                    13</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CALLABLE                 14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* internal types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_INDIRECT                 15</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_PTR                      17</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"标量类型\"><a href=\"#标量类型\" class=\"headerlink\" title=\"标量类型\"></a>标量类型</h5><ul>\n<li>没有value，直接根据type区分的类型：<code>true</code>、<code>false</code>、<code>null</code></li>\n<li>值存于value中，无需额外的value指针：<code>zend_long</code>、 <code>double</code></li>\n</ul>\n<h5 id=\"字符串（zend-string）\"><a href=\"#字符串（zend-string）\" class=\"headerlink\" title=\"字符串（zend_string）\"></a>字符串（zend_string）</h5><p>​        PHP中没有使用<code>char</code>来表示字符串，而是为字符串单独定义了一个结构<code>zend_string</code>，其中除了存储字符串内容，还存储了其他信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_string</span> &#123;</span></span><br><span class=\"line\">    zend_refcounted_h gc; <span class=\"comment\">// 变量引用计数信息，用于内存管理。比如当前value的引用数，所有用到引用计数的变量类型都会有这个结构</span></span><br><span class=\"line\">    zend_ulong        h;  <span class=\"comment\">/* hash value 哈希值，数组中计算索引时会用到*/</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span>            len; <span class=\"comment\">// 字符串长度，通过这个值保证二进制安全</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>              val[<span class=\"number\">1</span>]; <span class=\"comment\">// 字符串内容，变长struct，分配时按len长度申请内存</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>​        字符串内容<code>val</code>是一个可变数组，在字符串分配时的操作为<code>malloc(sizeof(zend_string) + 字符串长度)</code>。<br><em>注：val中多出一个字节（val[1]而不是val[0]）用于存储字符串的最后一个字符”\\0”.</em></p>\n<p>例如：$a=”abc”，对应zend_string内存结构如下：<br><img src=\"https://note.youdao.com/yws/api/personal/file/39A4055CBC584591A643CF8855653427?method=download&shareKey=100018cf52486ade9a25e3f4d8227678\" alt=\"zend_string内存结构\"></p>\n<p>字符串具体分类：</p>\n<ul>\n<li><code>IS_STR_PERSISTENT</code>: 通过malloc分配。</li>\n<li><code>IS_STR_INTERNED</code>: php代码中写的一些字面量，如函数名、变量名。</li>\n<li><code>IS_STR_PERMERNENT</code>:永久值，生命周期大于request。</li>\n<li><code>IS_STR_CONSTANT</code>:常量。</li>\n<li><code>IS_STR_CONSTANT_UNQUALIFIED</code>:这个信息通过flag保存：zval.value-&gt;gc.u.flags</li>\n</ul>\n<h5 id=\"数组（array）\"><a href=\"#数组（array）\" class=\"headerlink\" title=\"数组（array）\"></a>数组（array）</h5><p>​        <code>Array</code>是PHP中非常强大的一个数据结构，它的<strong>底层实现为散列表（HashTable 哈希表）</strong>。<br>​        散列表是根据<code>key</code>直接进行访问的数据结构，它的<code>key-value</code>之间有一个映射函数，可以根据key通过映射函数直接索引到对应的value值，直接根据<code>“内存起始地址+偏移值”</code>进行寻址，加快查找速度。理想情况下，查找的期望时间复杂度为O(1).</p>\n<p>HashTable的数据结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_array</span> <span class=\"title\">HashTable</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_array</span> &#123;</span></span><br><span class=\"line\">    zend_refcounted_h gc; <span class=\"comment\">//引用计数信息，与字符串相同</span></span><br><span class=\"line\">    <span class=\"comment\">// 提供一些辅助的功能，比如，flag用来设置散列表的一些属性，是否持久化、是否已经初始化。</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_4(</span><br><span class=\"line\">                zend_uchar    flags,</span><br><span class=\"line\">                zend_uchar    nApplyCount,</span><br><span class=\"line\">                zend_uchar    nIteratorsCount,</span><br><span class=\"line\">                zend_uchar    reserve)</span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    &#125; u;</span><br><span class=\"line\">    <span class=\"comment\">// 用于散列函数映射存储元素在arData数组中的下标。其值实际是nTableSize的负数，即nTableMask=-nTableSize（nTableMask=~nTableSize+1）</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nTableMask; <span class=\"comment\">//计算bucket索引时的掩码</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储元素数组，每个元素的结构统一为Bucket，其内存是连续的，arData指向第一个Bucket（即指向数组的起始位置）</span></span><br><span class=\"line\">    Bucket           *arData; <span class=\"comment\">//bucket数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前已使用的Bucket数，但这些Bucket并不都是有效的，因此再删除一个数组元素时，并不会马上将其从数组中移除，而是将这个元素的类型表位IS_UNDEF，只有在数组容量超过限制，需要扩容时才会删除。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nNumUsed; </span><br><span class=\"line\">    <span class=\"comment\">// 数组实际存储的元素数（有效元素数）。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nNumOfElements; <span class=\"comment\">//已有元素数，nNumOfElements &lt;= nNumUsed，因为删除的并不是直接从arData中移除</span></span><br><span class=\"line\">    <span class=\"comment\">// 数组的总容量，其大小为2的幂次方，最小为8（即2^3）。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nTableSize; <span class=\"comment\">//数组的大小，为2^n</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nInternalPointer; <span class=\"comment\">//数值索引</span></span><br><span class=\"line\">    <span class=\"comment\">// 下一个可用的数值索引，如arr[]=1;arr[&#x27;a&#x27;]=2;arr[]=3;则nNextFreeElement=2；该成员是给自动确定数值索引使用的。</span></span><br><span class=\"line\">    zend_long         nNextFreeElement;</span><br><span class=\"line\">    <span class=\"comment\">// 当删除或覆盖数组中的某个元素时，若提供了这个函数句柄，则会回调此函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">dtor_func_t</span>       pDestructor;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>Bucket的结构如下,主要用来保存元素的key及value。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Bucket</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储的具体的value，这里嵌入了一个zval而不是一个指针。</span></span><br><span class=\"line\">\tzval              val;</span><br><span class=\"line\">\t<span class=\"comment\">// hash code，用来映射元素的存储位置。若元素是数值索引，那么他的值就是数值索引的值；若是字符串，那么这个只就是根据字符串key通过Time33算法计算得到的散列值。</span></span><br><span class=\"line\">\tzend_ulong        h;                <span class=\"comment\">/* hash value (or numeric index)   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 存储元素的key。</span></span><br><span class=\"line\">\tzend_string      *key;              <span class=\"comment\">/* string key or NULL for numerics */</span></span><br><span class=\"line\">&#125; Bucket;</span><br></pre></td></tr></table></figure>\n<h6 id=\"基本实现\"><a href=\"#基本实现\" class=\"headerlink\" title=\"基本实现\"></a>基本实现</h6><p>散列表主要由两部分组成：</p>\n<ul>\n<li>存储元素数组</li>\n<li>散列函数<br>一个简单的散列函数可以采用取模的方式，比如散列表的大小为8，那么在散列表初始化数组时就会分配8个元素大小的空间，根据key的hash code与8取模的到的值作为该元素在数组中的下标。其示意图如下：</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/F2CB6F384907410BB02F7F7411F4E341?method=download&shareKey=fc47b2317eb268543f1440ed7296beb0\" alt=\"散列表的基本实现\"></p>\n<p>**以散列函数的输出值作为该元素在存储元素数组中的下标的方式有一个问题: **元素在数组中的位置是随机的，它是无序的。</p>\n<ul>\n<li><strong>问：那么PHP是如何保证元素的顺序与其插入顺序一致？</strong> <pre><code>    为了实现散列表的有序性，PHP在散列函数与元素数组之间加了一层映射表，该映射表也是一个数组，大小与存储元素的数组相同，它存储的元素类型为整型，用于保存实际存储的有序数组中的下标：**元素按照先后顺序依次插入实际存储的数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中**，如下图所示。</code></pre>\n</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/A8DBDBE3688A48739E06BF38ACDA300F?method=download&shareKey=6e4969019969485debc917c11a87da4d\" alt=\"散列表映射关系\"></p>\n<p>原理如上，但实际上PHP是将这个映射表与arData放在一起，在数组初始化时会分配存储Bucket的内存，同时还会分配相同数量的uint32_t大小的空间，将arData偏移到存储元素数组的位置，这个中间映射表可以通过arData向前访问到。如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/358B60D6F6AA407E9B034BACE5E8ACB6?method=download&shareKey=e515e9d30e617ea6c6fa8b9475a9efeb\" alt=\"HashTable中间映射表\"></p>\n<h6 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h6><p>​        通常散列会数会以取模的方式给出，比如：<code>key-&gt;h%nTableSize</code>.但是PHP采用了另一种方式，因为散列表的大小为2的幂次方，所以通过<strong>或运算</strong>可以得到<code>[-1,nTableMask]</code>之间的散列值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nIndex &#x3D; h | ht-&gt;nTableMask</span><br></pre></td></tr></table></figure>\n\n\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h&#x3D;18003212</span><br><span class=\"line\">nTableSize&#x3D;8</span><br><span class=\"line\"></span><br><span class=\"line\">nTableMask&#x3D;-8</span><br><span class=\"line\">nIndex&#x3D;-4</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"数组的初始化\"><a href=\"#数组的初始化\" class=\"headerlink\" title=\"数组的初始化\"></a>数组的初始化</h6><p>​        数组初始化的过程主要是对<code>HashTable</code>中的成员进行设置，初始化时并不会立即分配<code>arData</code>的内存，<code>arData</code>的内存在<strong>插入第一个元素时才会分配</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL _zend_hash_init(HashTable *ht, <span class=\"keyword\">uint32_t</span> nSize, <span class=\"keyword\">dtor_func_t</span> pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化gc信息</span></span><br><span class=\"line\">\tGC_REFCOUNT(ht) = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tGC_TYPE_INFO(ht) = IS_ARRAY;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置flags</span></span><br><span class=\"line\">\tht-&gt;u.flags = (persistent ? HASH_FLAG_PERSISTENT : <span class=\"number\">0</span>) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;</span><br><span class=\"line\">\t<span class=\"comment\">// nTableMask的值是临时的</span></span><br><span class=\"line\">\tht-&gt;nTableMask = HT_MIN_MASK;</span><br><span class=\"line\">\t<span class=\"comment\">// 临时设置ht-&gt;arData</span></span><br><span class=\"line\">\tHT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket);</span><br><span class=\"line\">\tht-&gt;nNumUsed = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;nNumOfElements = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;nInternalPointer = HT_INVALID_IDX;</span><br><span class=\"line\">\tht-&gt;nNextFreeElement = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;pDestructor = pDestructor;</span><br><span class=\"line\">\t<span class=\"comment\">// 把数组的大小重置为2的幂次方</span></span><br><span class=\"line\">\tht-&gt;nTableSize = zend_hash_check_size(nSize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h6><p>​        插入时，会检查数组是否已经分配存储空间。PHP会在第一次插入时根据<code>nTableSize</code>的大小分配，分配完成后把<code>HashTable-&gt;u.flags</code>打上<code>HASH_FLAG_INITIALIZAED</code>掩码。</p>\n<ul>\n<li><p>分配内存<br>分配的内存包括映射表及元素数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nTableSize * (sizeof(Bucket) + sizeof(uint32_t))</span><br></pre></td></tr></table></figure>\n<p>分配完成后，将<code>HashTable-&gt;arData</code>指向第一个<code>Bucket</code>的位置。</p>\n</li>\n<li><p>插入数据<br>将元素按照顺序插入<code>arData</code>，然后将其在<code>arData</code>数组中的位置存储到根据<code>key</code>的<code>hash code</code>（即<code>key-&gt;h</code>）与<code>nTableMask</code>计算得到的中间映射表中的对应位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zend_hash.c</span><br><span class=\"line\"><span class=\"comment\">// _zend_hash_add_or_update_i:</span></span><br><span class=\"line\">add_to_hash:</span><br><span class=\"line\">\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t<span class=\"comment\">// idx为Bucket在arData中存储位置</span></span><br><span class=\"line\">\tidx = ht-&gt;nNumUsed++;</span><br><span class=\"line\">\tht-&gt;nNumOfElements++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ht-&gt;nInternalPointer == HT_INVALID_IDX) &#123;</span><br><span class=\"line\">\t\tht-&gt;nInternalPointer = idx;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((zend_long)h &gt;= (zend_long)ht-&gt;nNextFreeElement) &#123;</span><br><span class=\"line\">\t\tht-&gt;nNextFreeElement = h &lt; ZEND_LONG_MAX ? h + <span class=\"number\">1</span> : ZEND_LONG_MAX;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找到存储Bucket，设置key、value</span></span><br><span class=\"line\">\tp = ht-&gt;arData + idx;</span><br><span class=\"line\">\tp-&gt;h = h;</span><br><span class=\"line\">\tp-&gt;key = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算中间映射表的散列值，idx将保存在映射数组的nIndex位置</span></span><br><span class=\"line\">\tnIndex = h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t<span class=\"comment\">// 将映射表中原来的值保存到新Bucket中，哈希冲突时会用到</span></span><br><span class=\"line\">\tZVAL_COPY_VALUE(&amp;p-&gt;val, pData);</span><br><span class=\"line\">\t<span class=\"comment\">// 先把旧的值保存到新插入的元素中</span></span><br><span class=\"line\">\tZ_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class=\"line\">\t<span class=\"comment\">// 再把新元素数组存储位置更新到映射表中</span></span><br><span class=\"line\">\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);</span><br><span class=\"line\">\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;p-&gt;val;</span><br></pre></td></tr></table></figure>\n<h6 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h6><p>​        散列表中不同元素的<code>key</code>可能计算得到相同的哈希值，这些具有相同哈希值的元素在插入散列表时就会发生冲突，因为映射表只能存储一个元素。  </p>\n</li>\n</ul>\n<p><strong>常见的解决方式（PHP采用这种方式）：将冲突的Bucket串成链表，查找时需要遍历这个链表，逐个比较<code>key</code>，从而找到目标元素。</strong></p>\n<ul>\n<li>具体操作：<pre><code>    `HashTable`中的`Bucket`会记录与它冲突的元素在`arData`数组中的存储位置。在设置映射值时，如果发现映射表中要设置的位置已经被之前插入的元素占用了（值不等于初始化的-1），那么会把已经存在的值保存到新插入的`Bucket`中，然后将映射表中的值更新为新`Bucket`的存储位置（即每次都会把冲突的元素插到开头）。  </code></pre>\n<strong>冲突元素的保存位置为：</strong><code>Bucket.val.u2.next</code></li>\n</ul>\n<p><strong>示例</strong>：一个数组有三个元素，按照a、b、c的顺序插入，加入a、c两个key冲突了，则HashTable的结构如下：<br>$arr = [];<br>$arr[‘a’] = 11;<br>$arr[‘b’] = 22;<br>$arr[‘c’] = 33;<br><img src=\"https://note.youdao.com/yws/api/personal/file/C469391F27FF454698CCD908B98FB2B2?method=download&shareKey=9501d4a7b3029c279f3d545c7f9c18e2\" alt=\"哈希冲突链表\"></p>\n<h6 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h6><p>查找过程如下：</p>\n<ul>\n<li>①、根据<code>key</code>计算出<code>hash code</code>（即<code>zend_string-&gt;h</code>）与<code>nTableMask</code>计算得到散列值<code>nIndex</code>。</li>\n<li>②、根据散列值从中间映射表中得到存储元素在有序存储数组中的位置<code>idx</code>。</li>\n<li>③、根据<code>idx</code>从有序存储数组（<code>HashTable-&gt;arData</code>）中取出<code>Bucket</code></li>\n<li>④、从取出的<code>Bucket</code>进行遍历，判断Bucket的key是否是要查找的key，若是则停止遍历，否则继续根据<code>zval.u2.next</code>遍历比较。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_hash_find_bucket:</span></span><br><span class=\"line\"><span class=\"comment\">// 根据zend_string *key进行查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline Bucket *<span class=\"title\">zend_hash_find_bucket</span><span class=\"params\">(<span class=\"keyword\">const</span> HashTable *ht, zend_string *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tzend_ulong h;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> nIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> idx;</span><br><span class=\"line\">\tBucket *p, *arData;</span><br><span class=\"line\"></span><br><span class=\"line\">\th = zend_string_hash_val(key);</span><br><span class=\"line\">\tarData = ht-&gt;arData;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算散列值</span></span><br><span class=\"line\">\tnIndex = h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取Bucket存储位置</span></span><br><span class=\"line\">\tidx = HT_HASH_EX(arData, nIndex);</span><br><span class=\"line\">    <span class=\"comment\">// 遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (EXPECTED(idx != HT_INVALID_IDX)) &#123;</span><br><span class=\"line\">\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (EXPECTED(p-&gt;key == key)) &#123; <span class=\"comment\">/* check for the same interned string */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (EXPECTED(p-&gt;h == h) &amp;&amp; <span class=\"comment\">// 先比较hash code</span></span><br><span class=\"line\">\t\t     EXPECTED(p-&gt;key) &amp;&amp; </span><br><span class=\"line\">\t\t     <span class=\"comment\">// 在比较key长度，最后按字符比较是否相同</span></span><br><span class=\"line\">\t\t     EXPECTED(ZSTR_LEN(p-&gt;key) == ZSTR_LEN(key)) &amp;&amp;</span><br><span class=\"line\">\t\t     EXPECTED(<span class=\"built_in\">memcmp</span>(ZSTR_VAL(p-&gt;key), ZSTR_VAL(key), ZSTR_LEN(key)) == <span class=\"number\">0</span>)) &#123;<span class=\"comment\">// 比较查找的key与Bucket的key是否匹配</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 不匹配则继续遍历</span></span><br><span class=\"line\">\t\tidx = Z_NEXT(p-&gt;val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h6 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h6><p>​        数组的容量是有限的，最多可以存储<code>nTableSize</code>个元素，那么当数组空间已满还要继续插入时如何处理？  </p>\n<p><strong>问: PHP是怎样实现的自动扩容？</strong></p>\n<p>​        <strong>扩容的过程为</strong>：检查数组中已经删除的元素所占的比例（已经删除但未从存储数组中移除的元素）.若比例达到域值，则触发<strong>重建索引</strong>的操作，这个过程会把删除的Bucket移除，然后把后面的Bucket往前移补上空缺的Bucket；若还没有达到域值，则分配一个原数组大小2倍的新数组，然后把原数组的元素复制到新数组上，重建索引。 </p>\n<p><u>域值判断公式</u>如下，即域值为<code>nNumOfElement + (nNumElement / 32)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElement + (ht-&gt;nNumOfElement &gt;&gt; 5)</span><br></pre></td></tr></table></figure>\n\n<p>具体的处理过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">zend_hash_do_resize</span><span class=\"params\">(HashTable *ht)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tIS_CONSISTENT(ht);</span><br><span class=\"line\">\tHT_ASSERT(GC_REFCOUNT(ht) == <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; <span class=\"number\">5</span>)) &#123; <span class=\"comment\">// 无序扩容，将删除的Bucket移除，然后把后面的bucket往前补上空缺</span></span><br><span class=\"line\">\t\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 只有到达一定域值才进行rehash操作</span></span><br><span class=\"line\">\t\tzend_hash_rehash(ht); <span class=\"comment\">// 重建索引数组</span></span><br><span class=\"line\">\t\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ht-&gt;nTableSize &lt; HT_MAX_SIZE) &#123; <span class=\"comment\">// 扩容，分配原数组大小2倍的新数组。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span> *new_data, *old_data = HT_GET_DATA_ADDR(ht);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 扩大为2倍，加法比乘法快</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> nSize = ht-&gt;nTableSize + ht-&gt;nTableSize;</span><br><span class=\"line\">\t\tBucket *old_buckets = ht-&gt;arData;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 新分配arData空间，大小为(sizeof(Bucket) + sizeof(uint32_t)) * nSize;</span></span><br><span class=\"line\">\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class=\"line\">\t\tht-&gt;nTableSize = nSize;</span><br><span class=\"line\">\t\tht-&gt;nTableMask = -ht-&gt;nTableSize;</span><br><span class=\"line\">\t    <span class=\"comment\">// 将arData指针偏移到Bucket数组起始位置</span></span><br><span class=\"line\">\t\tHT_SET_DATA_ADDR(ht, new_data);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将旧的Bucket数组复制到新空间（此步只复制存储的元素，即HashTable-&gt;arData，不会复制中间映射表，因为扩容后旧的映射表已无法使用，key-value的映射关系需要重新计算，即重建索引）</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memcpy</span>(ht-&gt;arData, old_buckets, <span class=\"keyword\">sizeof</span>(Bucket) * ht-&gt;nNumUsed);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 释放旧空间</span></span><br><span class=\"line\">\t\tpefree(old_data, ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 重建索引数组：映射表</span></span><br><span class=\"line\">\t\tzend_hash_rehash(ht);</span><br><span class=\"line\">\t\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tzend_error_noreturn(E_ERROR, <span class=\"string\">&quot;Possible integer overflow in memory allocation (%zu * %zu + %zu)&quot;</span>, ht-&gt;nTableSize * <span class=\"number\">2</span>, <span class=\"keyword\">sizeof</span>(Bucket) + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">uint32_t</span>), <span class=\"keyword\">sizeof</span>(Bucket));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重建索引的过程实际上就是将所有元素重新插入一遍，其处理过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 遍历数组，重新设置中间映射表（索引表）</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">\t\t\tnIndex &#x3D; p-&gt;h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t\t\tZ_NEXT(p-&gt;val) &#x3D; HT_HASH(ht, nIndex);</span><br><span class=\"line\">\t\t\tHT_HASH(ht, nIndex) &#x3D; HT_IDX_TO_HASH(i);</span><br><span class=\"line\">\t\t\tp++;</span><br><span class=\"line\">\t\t&#125; while (++i &lt; ht-&gt;nNumUsed);</span><br></pre></td></tr></table></figure>\n<p>重建索引会将已删除的bucket移除，移除后会把这个Bucket之后的元素全部向前移动一个位置，所以<strong>重建索引后存储数组中元素全部紧密排列在一起</strong>。</p>\n<h5 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h5><p>​        引用类型是PHP中比较特殊的一种类型，它实际是指向另外一个PHP变量（<em>在PHP中通过<code>&amp;操作符</code>产生一个引用变量</em>），对它的修改会直接改动实际指向的zval，<u>可以简单的理解为C中的指针</u>。  </p>\n<p>操作步骤：</p>\n<ul>\n<li>首先为<code>&amp;</code>操作的变量分配一个<code>zend_reference结构</code>，其内嵌一个<code>zval</code>，这个<code>zval</code>的<code>value</code>指向原来<code>zval</code>的<code>value</code>(<strong>注: 如果是布尔、整形、浮点则直接复制原来的值</strong>)。</li>\n<li>然后将原<code>zval</code>的类型修改为<code>IS_REFERENCE</code>，原<code>zval</code>的<code>value</code>指向新创建的<code>zend_reference</code>结构。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_reference &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    zval              val; &#x2F;&#x2F; 指向原来的value</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n示例1：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; date(&#39;Y-m-d&#39;);</span><br><span class=\"line\">$b &#x3D; &amp;$a;</span><br></pre></td></tr></table></figure>\n<img src=\"https://note.youdao.com/yws/api/personal/file/A5F4C7219117457A88A7D7CC3AFB53A9?method=download&shareKey=3d6950341fd9f21fea74f78f022500fd\" alt=\"a与b内存引用关系\"></li>\n</ul>\n<p><strong>注：若此时将<code>$b</code>复制给其他变量，那么传递给新变量的value将实时及引用的值，而不是引用本身</strong>。PHP中的引用只有一级，不会出现一个引用指向另外一个引用的情况，即没有C语言中多级指针的概念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; date(&#39;Y-m-d&#39;);</span><br><span class=\"line\">$b &#x3D; &amp;$a;</span><br><span class=\"line\">$c &#x3D; $b; &#x2F;&#x2F; 若想让$c也指向$a&#x2F;$b引用的值，则：$c &#x3D; &amp;$b或$c &#x3D; &amp;$a;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/1E8C8DDDE51D479296CA8F63EA5353B7?method=download&shareKey=43183c8018d3140f9b924508528c2af2\" alt=\"a,b与c内存引用关系\"></p>\n<p>示例2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a    -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/697F728B851442D4AF142554DDF78333?method=download&shareKey=59d725805b5b7c8bc59c391e87607101\" alt=\"zend_ref\"></p>\n<p>注意：<strong>引用只能通过<code>&amp;</code>产生，无法通过赋值传递</strong>  </p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:</span><br><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a    -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$c &#x3D; $b;                    &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;2)</span><br><span class=\"line\">                            &#x2F;&#x2F;$c    -&gt; </span><br><span class=\"line\">right:</span><br><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a       -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b    -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$c &#x3D; &amp;$b;&#x2F;*或$c &#x3D; &amp;$a*&#x2F;     &#x2F;&#x2F;$a,$b,$c -&gt; zend_reference_1(refcount&#x3D;3) -&gt; zend_string_1(refcount&#x3D;1)                             </span><br></pre></td></tr></table></figure>\n<p>这个也表示PHP中的 <strong>引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况</strong> ，也就是没有C语言中指针的指针的概念。</p>\n<h5 id=\"对象-资源\"><a href=\"#对象-资源\" class=\"headerlink\" title=\"对象/资源\"></a>对象/资源</h5><p>对象比较常见，资源指的是tcp连接、文件句柄等等类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_object &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    uint32_t          handle;</span><br><span class=\"line\">    zend_class_entry *ce; &#x2F;&#x2F;对象对应的class类</span><br><span class=\"line\">    const zend_object_handlers *handlers;</span><br><span class=\"line\">    HashTable        *properties; &#x2F;&#x2F;对象属性哈希表</span><br><span class=\"line\">    zval              properties_table[1];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct _zend_resource &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    int               handle;</span><br><span class=\"line\">    int               type;</span><br><span class=\"line\">    void             *ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h5><p>​        PHP是弱类型语言，使用时不需要明确定义变量的类型，Zend虚拟机在执行PHP代码时，会根据具体的应用场景进行转换，也就是变量会按照类型转换规则将不合格变量转换给合格的变量，然后进行操作。</p>\n<p>例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; &quot;100&quot; + 200</span><br></pre></td></tr></table></figure>\n<p>执行时Zend发现相加的一个值为字符串，就会试图将<code>字符串100</code>转为数值类型（整型或浮点型），然后与200相加。<br><strong>注：转换的时候并不会改变原来的值，而是会生成一个新的变量进行处理。</strong></p>\n<h6 id=\"强制转换\"><a href=\"#强制转换\" class=\"headerlink\" title=\"强制转换\"></a>强制转换</h6><p>PHP提供了一种强制转换方式：</p>\n<ul>\n<li>(int)/(integer): 转换为整型integer</li>\n<li>(bool)/(boolean):转换为布尔类型boolean</li>\n<li>(flaot)/(double)/(real):转换为浮点型flaot</li>\n<li>(string):转换为字符串string</li>\n<li>(array):转换为数组array</li>\n<li>(object):转换为对象object</li>\n<li>(unset):转换为null</li>\n</ul>\n<p><em>注：有些类型之间是无法转换的，如：资源类型，无法将任何类型转换为资源类型。</em></p>\n<h6 id=\"转换为null\"><a href=\"#转换为null\" class=\"headerlink\" title=\"转换为null\"></a>转换为null</h6><p>​        任意类型都可以转为null，转换时直接将新的<code>zval类型</code>设置为<code>IS_NULL</code>。</p>\n<h6 id=\"转换为布尔型\"><a href=\"#转换为布尔型\" class=\"headerlink\" title=\"转换为布尔型\"></a>转换为布尔型</h6><p>​        当转换为布尔型时，根据原值的<code>true</code>、<code>false</code>决定转换后的结果，一些值被认为是<code>false</code>，除此之外的其他值通常被认为是<code>true</code>。</p>\n<p>被认为是false的值:</p>\n<ul>\n<li>布尔值false本身</li>\n<li>整型0</li>\n<li>浮点型值0.0</li>\n<li>==空字符串（‘’），以及字符串‘0’==</li>\n<li>空数组</li>\n<li>null</li>\n</ul>\n<h6 id=\"转换为整型\"><a href=\"#转换为整型\" class=\"headerlink\" title=\"转换为整型\"></a>转换为整型</h6><p>从<code>其他值</code>转换为<code>整型</code>的规则如下：</p>\n<ul>\n<li>null：转换为0</li>\n<li>布尔型：false转为0，true转为1</li>\n<li>浮点型：向下取整，比如，(int)2.8 = 2</li>\n<li>字符串：与C语言strtoll()的规则一致<ul>\n<li>字符串以合法数值(包含正负数)开始，就使用该数值</li>\n<li><strong>否则，其值为0</strong></li>\n</ul>\n</li>\n<li>数组：很多操作不支持将一个数组自动转为整型处理，比如array()+2将报error错误，但可以强制把数组转为整型：<ul>\n<li>非空数组：1</li>\n<li>空数组：0<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php &gt; $a = <span class=\"keyword\">array</span>()+<span class=\"number\">2</span>;</span><br><span class=\"line\">PHP Fatal <span class=\"built_in\">error</span>:  Unsupported operand types in php shell code on line <span class=\"number\">1</span></span><br><span class=\"line\">PHP Stack trace:</span><br><span class=\"line\">PHP   <span class=\"number\">1.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br><span class=\"line\">PHP   <span class=\"number\">2.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; $a = <span class=\"keyword\">array</span>();</span><br><span class=\"line\">php &gt; $b = (<span class=\"keyword\">int</span>)$a;</span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> $b;</span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>对象：与数组类似，很多操作也不支持将兑现个自动转为整型，但有些操作只会抛一个warning警告，还是会把对象转换为1.</li>\n<li>资源：转为分配给这个资源的唯一编号</li>\n</ul>\n<h6 id=\"转为浮点型\"><a href=\"#转为浮点型\" class=\"headerlink\" title=\"转为浮点型\"></a>转为浮点型</h6><p>​        除了字符串类型外，其他类型转换规则与整型基本一致，只是在整型转换结果上加了小数位，字符串转为浮点数有<code>zend_strtod</code>完成。</p>\n<h6 id=\"转换为字符串\"><a href=\"#转换为字符串\" class=\"headerlink\" title=\"转换为字符串\"></a>转换为字符串</h6><ul>\n<li>强制转换：<ul>\n<li>(string)</li>\n<li>strval()函数</li>\n</ul>\n</li>\n<li>自动转换：<ul>\n<li>需要字符串的表达式中，比如：函数echo或print时</li>\n<li>非string类型变量与一个string变量进行比较时<ul>\n<li>null/fasle:转为空字符串</li>\n<li>true：转为“1”</li>\n<li>整型：原样转为字符串，<strong>转换时将各位一次除10取余</strong></li>\n<li>浮点型：原样转为字符串</li>\n<li>资源：转为“Resource id#xxx”</li>\n<li>数组：转为“Array”，同时报Notice</li>\n<li>对象：不能转换，将报错,如下：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php &gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">php</span> &gt; </span>&#123;<span class=\"keyword\">public</span> $b;&#125;</span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; $a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;a= &#x27;</span> . $a;</span><br><span class=\"line\">PHP Catchable fatal <span class=\"built_in\">error</span>:  <span class=\"keyword\">Object</span> of <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">could</span> <span class=\"title\">not</span> <span class=\"title\">be</span> <span class=\"title\">converted</span> <span class=\"title\">to</span> <span class=\"title\">string</span> <span class=\"title\">in</span> <span class=\"title\">php</span> <span class=\"title\">shell</span> <span class=\"title\">code</span> <span class=\"title\">on</span> <span class=\"title\">line</span> 1</span></span><br><span class=\"line\">PHP Stack trace:</span><br><span class=\"line\">PHP   <span class=\"number\">1.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"转换为数组\"><a href=\"#转换为数组\" class=\"headerlink\" title=\"转换为数组\"></a>转换为数组</h6></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>若变量类型为<code>null</code>、<code>integer</code>、<code>float</code>、<code>string</code>、<code>boolean</code>和<code>resource</code>中的一个：将得到一个仅有一个元素的数组，其<code>下标为0</code>，即(array)$scalarValue与<code>array($scalarValue)</code>完全一样。</li>\n<li>若变量类型为object：其结果为一个数组，数组的元素为该对象的全部属性（包含public、private、protected），但他们也是有区别的，如下：<ul>\n<li>public的属性：key</li>\n<li>private的属性：key加类型作为前缀</li>\n<li>protected的属性：’*’加key作为前缀<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public $a &#x3D; 123;</span><br><span class=\"line\">    private $b &#x3D; &#39;bbb&#39;;</span><br><span class=\"line\">    protected $c &#x3D; &#39;ccc&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$test &#x3D; new test();</span><br><span class=\"line\">print_r((array)$test);</span><br></pre></td></tr></table></figure>\n以上例子将输出：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$php stat.php </span><br><span class=\"line\">Array</span><br><span class=\"line\">(</span><br><span class=\"line\">    [a] &#x3D;&gt; 123</span><br><span class=\"line\">    [testb] &#x3D;&gt; bbb</span><br><span class=\"line\">    [*c] &#x3D;&gt; ccc</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"转换为对象\"><a href=\"#转换为对象\" class=\"headerlink\" title=\"转换为对象\"></a>转换为对象</h6><p>其他任何类型的值被转换为对象，将会创建一个内置类stdClass的实例：</p>\n<ul>\n<li>若该值为null：新的实例为空</li>\n<li>array：转换成的object将以键名成为属性名，并具有相对应的值<ul>\n<li>数值索引的元素也将转为属性，但无法通过“-&gt;”访问，只能遍历获取</li>\n<li>非数值索引：会以‘scalar’作为属性名</li>\n</ul>\n</li>\n</ul>"},{"title":"Redis设计与实现-数据结构","date":"2020-08-25T08:30:57.000Z","_content":"\n### 1 简单动态字符串(SDS)\n\nRedis中有两种字符串表示：\n\n- **①、C字符串**：C字符串只会作为字符串字面量（string literal），用在一些无须对字符串值进行修改的地方，如打印日志。\n\n- **②、简单动态字符串**：简单动态字符串（simple dynamic string, SDS）是redis构建一种字符串的抽象类型，是redis的默认字符串表示。如字符串键值对、缓冲区等都有SDS实现。\n\n<!--more-->\n\n#### 1.1 SDS的定义\n\nsds.h/sdshdr结构表示一个SDS的值，如：\n\n```c\nstruct sdshdr {\n    // 记录bug数组汇总已使用字节的数量.\n    // 等于SDS所保存字符串的长度\n    unsigned int len;\n    // 记录buf数组中未使用字节的数量.\n    unsigned int free;\n    // 字节数组，用于保存字符串.\n    char buf[];\n};\n\n```\n\n*注：SDS遵循C字符串以`空字符（'\\0'）`结尾，但这个字节的空间不计算在SDS的`len属性`中。*\n\n#### 1.2、SDS字符串相对于C字符串的优点\n\n- 常数复杂度获取字符串长度\n  - C字符串，没有记录自身的长度信息，获取C字符串长度时需进行遍历，其复杂度为O(N)。\n  - SDS字符串，有len属性，获取长度的复杂度为O(1)。\n\n- 杜绝缓冲区溢出: SDS相对于C字符串，根据其空间分配策略，杜绝了发生缓冲区溢出的可能性。\n\n- 减少修改字符串时带来的内存重新分配次数: SDS通过未使用空间`free记录`，实现`空间预分配`和`惰性空间释放`两种优化策略。\n- 二进制安全\n- 兼容部分C字符串函数\n\n\n\n##### 1.2.1 空间预分配\n\n空间预分配用于优化SDS的字符串`增长操作`，当SDS的API对SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。\n\n分配策略：\n\n- 若对SDS修改过后，len属性的值小于1MB，则分配与len属性同样大小的未使用空间，即此时len和free属性大小一致。\n- 若对SDS修改过后，len属性的值大于1MB，则分配1MB的未使用空间。\n\n##### 1.2.2 惰性空间释放\n\n惰性空间释放用于优化SDS的字符串`缩短操作`，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等待将来使用。\n\n\n\n### 2 链表\n\n链表作为一种常用的数据结构，在Redis中应用广泛，如列表键的底层实现之一就是链表。的那个一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。此外，还有打不与订阅、慢查询、监视器等功能也用到了链表。\n\n*注：Redis的链表为双向链表。*\n\n#### 2.1 链表和链表节点的实现\n\n链表节点，使用一个`adlist.h/listNode结构`来表示：\n\n```c\ntypedef struct listNode {\n    struct listNode *prev;\n    struct listNode *next;\n    void *value;\n} listNode;\n```\n\n多个listNode可以通过prev和next指针组成**双向链表**，如下图所示：\n\n![双向链表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/双向链表.png)\n\n链表，使用`adlist.h/list结构`表示：\n\n```c\ntypedef struct list {\n    // 表头节点\n    listNode *head;\n    // 表尾结点\n    listNode *tail;\n    // 节点值赋值函数\n    void *(*dup)(void *ptr);\n    // 节点值释放函数\n    void (*free)(void *ptr);\n    // 节点值比对函数，比对链表节点梭堡村的值和另一个输入值是否相等\n    int (*match)(void *ptr, void *key);\n    // 链表所包含的节点数量\n    unsigned long len;\n} list;\n```\n\n示例：下图为一个list结构和三个listNode结构组成的链表。\n\n![list结构和三个listNode结构组成的链表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/list结构和三个listNode结构组成的链表.png)\n\n\n\n### 3 字典\n\n字典，又称为符号表（symbol table）、关联数组（assiciative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典中每个键都是独一无二的。\n\n字典的应用：字典在Redis的应用广泛，如Redis的数据库就是使用字典来作为底层实现的。此外字典还是哈希键的底层实现之一。\n\n#### 3.1 字典的实现\n\n<u>Redis的字典使用`哈希表`作为底层实现</u>，<u>一个哈希表里面可以有多个哈希表结点</u>，<u>而每个哈希表结点就保存了一个字段中的键值对</u>。\n\n##### 3.1.1 哈希表\n\nRedis字典所使用的哈希表由`dict.h/dictht结构`定义：\n\n```c\ntypedef struct dictht {\n    // 哈希表数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个结构保存着一个键值对。\n    dictEntry **table;\n    // 哈希表大小.\n    unsigned long size;\n    // 哈希表大小掩码，用于计算索引值.\n    // 总是等于size-1.\n    unsigned long sizemask;\n    // 该哈希表已有结点的数量.\n    unsigned long used;\n} dictht;\n```\n\n示例：下图为一个大小为4的空哈希表。（没有任何键值对）\n\n![大小为4的空哈希表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/大小为4的空哈希表.png)\n\n##### 3.1.2 哈希表结点\n\n哈希表结点使用`dictEntry结构`表示，每个dictEntry结构都保存着一个键值对：\n\n```c\ntypedef struct dictEntry {\n    // 键\n    void *key;\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    // 指向下一个哈希表结点,形成链表,用以解决哈希冲突的问题.\n    struct dictEntry *next;\n} dictEntry;\n```\n\n示例：下图是通过`next指针`,将两个指引着相同的键`k1`和`k0`连接的数据结构.\n\n![通过next指针,将两个索引值相同的键k1和k0连接的数据结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/通过next指针,将两个索引值相同的键k1和k0连接的数据结构.png)\n\n##### 3.1.3 字典\n\nRedis中的字典由`dict.h/dict结构`表示：\n\n```c\ntypedef struct dict {\n    // 类型特定函数.Redis会为用途不同的字典设置不同的类型特定函数。\n    dictType *type;\n    // 私有数据.保存了需要传给那些类型特定函数的可选参数。\n    void *privdata;\n    // 哈希表.包含了两个项的数组，每个项都是dictht哈希表，通常，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用。\n    dictht ht[2];\n    // rehash索引.记录rehash的进度，若当前没有进行rehash，那么它的值为-1.\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n```\n\n其中`type`和`privdata`属性是<u>针对不同类型的键值对,为创建多态字典而设置</u>。\n\n\n\ntype特定函数结构：\n\n```c\ntypedef struct dictType {\n    // 计算哈希值的函数。\n    unsigned int (*hashFunction)(const void *key);\n    // 复制键的函数。\n    void *(*keyDup)(void *privdata, const void *key);\n    // 复制值的函数。\n    void *(*valDup)(void *privdata, const void *obj);\n    // 对比键的函数.\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);\n    // 销毁键的函数。\n    void (*keyDestructor)(void *privdata, void *key);\n    // 销毁值的函数。\n    void (*valDestructor)(void *privdata, void *obj);\n} dictType;\n```\n\n示例：下图为普通状态的下的字典示例。\n\n![普通状态下的字典示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/普通状态下的字典示例.png)\n\n#### 3.2 哈希算法\n\n要将一个新的键值对添加到字典中时，程序需先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表结点放到哈希表数组的指定索引上面。\n\n\n\n**Redis计算哈希值方式？**\n\n使用字典设置的哈希函数，计算键key的哈希值：\n\n```\nhash = dict->type->hashFunction(key);\n```\n\n\n\n**Redis计算索引值的方式？**\n\n根据哈希表的`sizemask属性`和哈希值计算出索引值，其中根据情况不同，ht[x]可以使ht[0]或ht[1]。\n\n```\nindex = hash & dict->ht[x].sizemask;\n```\n\n注：当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。\n\n\n\n#### 3.3 解决键冲突\n\n当有两个或者以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了`冲突（collision）`。\n\n\n\n**Redis怎样解决键冲突？**\n\nRedis的哈希表使用`链地址法`来解决键冲突。\n\n每个哈希表结点都有一个`next指针`，多个哈希表结点可以用next指针构成一个<u>单向链表</u>，被分配到同一个索引上的多个结点可以用这个单向链表连接起来，解决键冲突的问题。\n\n*注：由于dictEntry结点组成的链表没有指向链表表尾的指针，所以程序总是将新节点添加到链表的表头位置（复杂度为O(1)）*\n\n\n\n示例：k2与k1发生了键冲突，k2后添加，如下图所示。\n\n![k2与k1发生了键冲突,k2后添加](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/k2与k1发生了键冲突,k2后添加.png)\n\n#### 3.4 rehash\n\n随着操作的不断执行，哈希表保存的键值对会逐渐增减，为了让哈希表的负载因子维持在一个合理的范围内，需对哈希表的大小进行相应的扩展或收缩。这个过程就是rehash。\n\n**Redis是怎样对字典的哈希表执行rehash的（rehash的步骤）？**\n\n- ①、为字典的`h[1]`哈希表分配空间。\n  - 扩展操作：`ht[1]`的大小为第一个大于等于`ht[0].used*2的2^n`(2的n次方幂)；\n  - 收缩操作：`ht[1]`的大小为第一个大于等于`ht[0].used的2^n`。\n- ②、将保存在`ht[0]`中的所有键值对rehash到`ht[1]`上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。\n- ③、当`ht[0]`包含的所有键值对都前移到了`ht[1]`后，释放`ht[0]`，将`ht[1]`设置为`ht[0]`，并在`ht[1]`新创建一个空白哈希表，为下一次rehash做准备。\n\n\n\n示例：假设ht[0].used当前的值为4，要对进行扩展操作，则ht[1]的大小为4*2=8，刚好为2^3，所以ht[1]哈希表的大小设置为8.\n\n\n\n**哈希表的扩展与收缩都与负载因子有关，那么什么是负载因子呢？怎样计算负载因子？**\n\nRedis的负载因子为哈希表以保存结点的数量与哈希表的大小的比值，计算方法如下：\n\n```\nload_factor = ht[0].used / ht[0].size\n```\n\n示例：对于一个大小为512，包含256个键值对的哈希表说，这个哈希表的负载因子为：\n\nload_factor = 256 / 512 = 0.5\n\n\n\n**什么情况下程序会自动对哈希表执行扩展操作？**\n\n- ①、服务器没有在执行`BGSAVE`或者`BGREWRITEAOF`命令，并且哈希表的负载因子<u>大于等于1</u>.\n- ②、服务器正在执行`BGSAVE`或者`BGREWRITEAOF`命令，并且哈希表的负载因子<u>大于等于5</u>.\n\n*注：在执行BGSAVE或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入，最大限度地节约内存。*\n\n\n\n**什么情况下程序会对哈希表执行收缩操作？**\n\n当哈希表的负载因子<u>小于0.1</u>时，程序自动开始对哈希表执行收缩操作。\n\n\n\n#### 3.5 渐进式rehash\n\n扩展或收缩哈希表需要将`ht[0]`里面的键值对rehash到`ht[1]`里面，但是这个rehash动作并不是一次性、集中式完成的，而是分多次、<u>渐进式</u>地完成的。\n\n\n\n**为什么要渐进式完成rehash？**\n\n为了<u>避免大量键值对rehash对服务器性能造成影响</u>。采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。\n\n\n\n**哈希表是怎样渐进式rehash的（rehash的详细步骤）？**\n\n- ①、为`ht[1]`分配空间，让字典同时持有ht[0]和ht[1]两个哈希表、\n- ②、在字典中维持一个`rehashidx`，并将它的值设置为0，表示rehash工作正式开始。\n- ③、在rehash进行期间，每次对字段执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增加一。\n- ④、随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]上，这是程序将rehashidx属性设为-1，表示rehash操作已完成。\n\n\n\n**渐进式rehash执行期间会涉及到ht[0]和ht[1]两个哈希表，是怎样操作的呢？**\n\n- 针对删除、查找、更新操作，会在两个哈希表上进行，例如，查找一个键时，程序会在ht[0]上查找，若没有找到，会继续到ht[1]里面进行查找。\n- 对于新增操作，新增加到字典的键值对一律被保存到ht[1]里面，而ht[0]则不再进行任何操作。\n\n\n\n### 4 跳跃表\n\n跳跃表是一种`有序数据结构`，它<u>通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</u>。\n\nRedis使用跳跃表作为`有序集合键`的底层实现之一，若一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，跳跃表还在集群节点中用作内部数据结构。\n\n#### 4.1 跳跃表结点的实现\n\nRedis跳跃表由`redis.h/zskiplistNode和redis.h/zskiplist`两个结构定义。\n\n跳跃表示例如下：\n\n![跳跃表示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/跳跃表示例.png)\n\n\n\n`zskiplistNode结构`用于表示跳跃表的结点。\n\n```c\ntypedef struct zskiplistNode {\n    // 成员对象.示例图中o1，o2，o3是结点所保存的成员对象。\n    robj *obj;\n    // 分值. 跳跃表中，结点按照各自所保存的分值从小到大排列。\n    double score;\n    // 后退指针.指向当前的结点的前一个结点，后退指针在程序从表尾想表头遍历时使用。示例图上用BW标识结点的后退指针。\n    struct zskiplistNode *backward;\n    // 层.每个层都有两个属性：前进指针和跨度。\n    struct zskiplistLevel {\n        // 前进指针.前进指针用于访问表尾方向的其他节点。示例图上的带有数字的剪头就表示前进指针。\n        struct zskiplostNode *forward;\n        // 跨度.跨度记录了前进指针所指向结点和当前结点的距离。示例图上箭头上的数字就表示跨度。\n        unsigned int span;\n    } level[];\n} zskiplistNode;\n```\n\n##### 4.1.1 层\n\n跳跃表节点的`level数组`可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。一般来说，层的数量越多，访问其他节点的速度就越快。\n\n每次创建一个新跳跃表节点的时候，程序都根据<u>幂次定律</u>(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。\n\n示例：下图为三个高度分别为1层、3层、5层的节点。\n\n![高度分别为1层,3层,5层的节点](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/高度分别为1层,3层,5层的节点.png)\n\n##### 4.1.2 前进指针\n\n每个层都有一个指向表尾党项的`前进指针`（`level[i].forward`属性），用于从表头向表尾方向访问节点。\n\n\n\n**跳跃表是怎样遍历所有节点的呢？**\n\n示例图如下：\n\n![跳跃表遍历](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/跳跃表遍历.png)\n\n- ①、迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中第二个节点。\n- ②、在第二个结点时，程序沿着第二层的前进指针移动到表中第三个节点。\n- ③、在第三个节点时，程序沿着第二层的前进指针移动到表中的第四个结点。\n- ④、当程序在此沿着第四个节点的前进指针移动时，它碰到了一个NULL，程序知道这时已经到达了跳跃表的表尾，结束遍历。\n\n*注：遍历操作只使用前进指针就能完成。*\n\n\n\n##### 4.1.3 跨度\n\n层的跨度（`level[i].span`属性）用于记录两个结点之间的距离，两个结点之间跨度越大，他们相距得就越远；指向`null`的所有前进指针的跨度都为0，因为他们没有指向任何节点。\n\n<u>跨度实际上是用来计算排位的</u>：在查找某个结点的过程中，将访问过的所有层的跨度累计起来，得到的结果就是目标结点在跳跃表中的排位。\n\n\n\n##### 4.1.4 后退指针\n\n节点的后退指针(`backward`属性)用于从<u>表尾向表头</u>方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。\n\n\n\n##### 4.1.5 分值和成员\n\n节点的分值(`score`属性)是一个`double类型的浮点数`，跳跃表中的所有结点都按分值<u>从小到大来排序</u>。\n\n节点的成员对象(obj属性)是一个指针，他指向一个字符串对象，而字符串对象则保存着一个SDS值。\n\n注：**同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但多个结点保存的分值却可以是相同的**。分值相同的结点将按照成员对象在字典序中的大小来进行排序，成员对象较小的结点会排在前面（靠近表头的方向）。\n\n\n\n#### 4.2 跳跃表的实现\n\n仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个`zskiplist结构`来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或快速地获取跳跃表节点的数量等信息。\n\n`zskiplist结构`如下：\n\n```c\ntypedef struct zskiplist {\n    // header 指向跳跃表的表头节点。\n    // tail 指向跳跃表的表位节点.\n    struct zskiplistNode *header, *tail;\n    // 记录跳跃表的长度，即跳跃表目前包含结点的数量（表头节点不计算在内）\n    unsigned long length;\n    // level 记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。\n    int level;\n} zskiplist;\n```\n\n*注：level表头节点的层高并不计算在内。*\n\n\n\n### 五、整数集合\n\n整数集合是`集合键`的底层实现之一，当一个**集合只包含整数值元素，并且这个集合的元素数量不多时**，Redis就会使用整数集合作为集合键得底层实现。\n\n（<u>注：整数集合是只包含整数值元素的集合。</u>）\n\n\n\n#### 5.1 整数集合的实现\n\n整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为`int16_t`、`int32_t`或者`int64_t`的整数值，并保证集合中不会出现重复元素。\n\n每个`intset.h/intset结构`表示一个整数集合：\n\n```c\ntypedef struct intset {\n    // 编码方式.\n    uint_32_t encoding;\n    // 集合包含的元素数量.即contents数组的长度。\n    uint32_t length;\n    // 保存元素的数组.\n    int8_t contents[];\n}\n```\n\n\n\n**整数集合的底层实现是什么？**\n\n整数集合的底层是通过数组（`contents`属性）实现的，整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小<u>从小到大</u>有序地排列，并且数组中不包含任何重复项。\n\n\n\n注：\n\n①、数组元素在底层是有进行从小到大的排序的。\n\n②、虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存int8_t类型的值，contents数组的真正类型取决于encoding属性的值。\n\nencoding属性的取值包括以下内容：\n\n- **INTSET_ENC_INT16**:表示`int16_t`类型的数组，数组里面每个项都是一个int16_t类型的整数值（2^15 ~2^(15)-1）。\n- **INTSET_ENC_INT32**:表示`int32_t`类型的数组，数组里面每个项都是一个int32_t类型的整数值(2^31 ~2^(31)-1)。\n- **INTSET_ENC_INT64**:表示`int64_t`类型的数组，数组里面每个项都是一个int64_t类型的整数值(2^63 ~2^(63)-1)。\n\n\n\n#### 5.2 升级\n\n当添加新元素到整数集合中时，<u>新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先升级，然后才能将新元素添加到整数集合里面</u>。\n\n\n\n**Redis是怎样升级整数集合并添加新元素的呢（升级及添加新元素的步骤）？**\n\n升级整数集合并添加新元素共分为三步进行：\n\n- ①、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。\n- ②、将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在防止元素的过程中，需要继续维持底层数组的有序性质不变。\n- ③、将新元素添加到底层数组里面。\n\n*注：每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中又有的元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。*\n\n\n\n升级时新元素的摆放位置，要引发升级，那么要么新元素大于所有现有元素，要么小于现有所有元素，因此摆放位置应该在数组的两端。\n\n为什么要进行升级，而不是直接采用int64_t类型？\n\n- ①、提高灵活性。\n- ②、节约内存。\n\n\n\n#### 5.3 降级\n\n整数集合**不支持降级操作**，一旦对数组进行了升级，编码就会一直保持升级后的状态。\n\n\n\n### 六、压缩列表\n\n压缩列表（ziplist）是`列表键`和`哈希键`的底层实现之一。\n\n\n\n压缩列表(ziplist)在Redis的应用场景有哪些？\n\n- ①、当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。\n\n\n- ②、当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。\n\n\n\n\n#### 6.1 压缩列表的构成\n\n压缩列表是Redis为了<u>节约内存</u>而开发的，是由一系列特殊编码的<u>连续内存块组成</u>的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。\n\n压缩列表的各个组成部分如下图：\n\n![压缩表各部分组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩表各部分组成.png)\n\n下表中记录了各个组成部分的类型、长度以及用途。\n\n![压缩表各组成部分的类型,长度以及用途](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩表各组成部分的类型,长度以及用途.png)\n\n示例：包含三个节点的压缩列表\n\n![包含三个节点的压缩列表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/包含三个节点的压缩列表.png)\n\n其中：\n\n- `zlbytes`的属性值为0x50,表示压缩列表的总长为80.\n- `zltail`属性的值为0x3c，表示有一个指向压缩列表起始地址的指针p，在指针p加上偏移量60，就可以计算出表尾节点entry3的地址。\n- `zllen`属性值为0x3，表示压缩列表包含三个节点。\n- `zlend`属性值为特殊值，用于标记压缩列表的末端。\n\n\n\n#### 6.2 压缩列表节点的构成\n\n每个压缩列表节点可以保存<u>一个字节数组</u>或者<u>一个整数值</u>。\n\n- **字节数组**可以是以下三中长度的其中一种：\n  - 长度小于等于63（2^6-1）字节的字节数组。\n  - 长度小于等于16383（2^14-1）字节的字节数组。\n  - 长度小于等于4294967295（2^32-1）字节的字节数组。\n- **整数值**可以是以下六种长度的其中一种：\n  - 4位长，介于0~12之间的无符号整数；\n  - 1字节长的有符号整数；\n  - 3字节长的有符号整数；\n  - int16_t类型整数；\n  - int32_t类型整数；\n  - int64_t类型整数。\n\n\n\n`压缩列表结点的组成部分`如下：\n\n![压缩列表结点的组成部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩列表结点的组成部分.png)\n\n##### 6.2.1 previous_entry_length\n\n`previous_entry_length属性`以`字节`为单位，记录了压缩列表中前一个节点的长度，`previous_entry_length`属性的长度可以是1字节或者5字节。\n\n- 若前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。\n- 若前一节点的长度大于等于254字节，那么previoud_entry_length属性的长度为5字节，其中第一字节会被设置为0xFE，而后的四个字节则用于保存前一节点的长度。\n\n根据previous_entry_length属性可以计算得到前一个节点的起始地址。通过这一原理，即可实现从表尾向表头遍历。\n\n\n\n##### 6.2.2 encoding\n\n节点的`encoding`属性记录了节点的content属性所保存数据的类型及长度：\n\n**字节数组编码**：一字节、两字节或者五字节，encoding最高位为**00、01、10表示字节数组编码**，除去最高两位后表示数组的长度。\n\n![encoding属性数组编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/encoding属性数组编码.png)\n\n\n\n**整数编码**：一字节，**encoding最高位为11**，除去最高两位后的其他位记录整数值的类型和长度。\n\n![encoding属性整数编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/encoding属性整数编码.png)\n\n##### 6.2.3 content\n\n节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由encoding属性决定。\n\n示例1：以下示例展示了一个保存字节数组的节点示例。\n\n![保存字节数组的节点示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/保存字节数组的节点示例.png)\n\n其中：\n\n- encoding的最高两位为00，表示一个字节数组。\n- encoding的后六位001011记录了字节数组的长度为11.\n- content属性保存着节点的值“hello world”\n\n示例2：以下示例展示了一个保存整数值的节点示例。\n\n![保存整数值的节点示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/保存整数值的节点示例.png)\n\n其中：\n\n- encoding表示节点保存的是int16_t类型的整数值。\n- content属性保存着节点的值10086.\n\n\n\n#### 6.3 连锁更新\n\n**什么情况下会发生连锁更新？**\n\n比如当前所有结点长度均小于254字节情况下，新添加一个长度大于254字节的节点到压缩列表的表头，此时需对压缩列表执行空间重分配操作，扩展后面的previous_entry_length属性空间。\n\n定义：Redis将这种特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。\n\n连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。\n\n\n\n### 参考资料\n\n1. redis设计与实现（第二版） 黄健宏","source":"_posts/Redis设计与实现-数据结构.md","raw":"---\ntitle: Redis设计与实现-数据结构\ndate: 2020-08-25 16:30:57\ntags: [\"Redis\",\"Note\"]\ncategories: [\"Redis\", \"Note\", \"Redis设计与实现\"]\n---\n\n### 1 简单动态字符串(SDS)\n\nRedis中有两种字符串表示：\n\n- **①、C字符串**：C字符串只会作为字符串字面量（string literal），用在一些无须对字符串值进行修改的地方，如打印日志。\n\n- **②、简单动态字符串**：简单动态字符串（simple dynamic string, SDS）是redis构建一种字符串的抽象类型，是redis的默认字符串表示。如字符串键值对、缓冲区等都有SDS实现。\n\n<!--more-->\n\n#### 1.1 SDS的定义\n\nsds.h/sdshdr结构表示一个SDS的值，如：\n\n```c\nstruct sdshdr {\n    // 记录bug数组汇总已使用字节的数量.\n    // 等于SDS所保存字符串的长度\n    unsigned int len;\n    // 记录buf数组中未使用字节的数量.\n    unsigned int free;\n    // 字节数组，用于保存字符串.\n    char buf[];\n};\n\n```\n\n*注：SDS遵循C字符串以`空字符（'\\0'）`结尾，但这个字节的空间不计算在SDS的`len属性`中。*\n\n#### 1.2、SDS字符串相对于C字符串的优点\n\n- 常数复杂度获取字符串长度\n  - C字符串，没有记录自身的长度信息，获取C字符串长度时需进行遍历，其复杂度为O(N)。\n  - SDS字符串，有len属性，获取长度的复杂度为O(1)。\n\n- 杜绝缓冲区溢出: SDS相对于C字符串，根据其空间分配策略，杜绝了发生缓冲区溢出的可能性。\n\n- 减少修改字符串时带来的内存重新分配次数: SDS通过未使用空间`free记录`，实现`空间预分配`和`惰性空间释放`两种优化策略。\n- 二进制安全\n- 兼容部分C字符串函数\n\n\n\n##### 1.2.1 空间预分配\n\n空间预分配用于优化SDS的字符串`增长操作`，当SDS的API对SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。\n\n分配策略：\n\n- 若对SDS修改过后，len属性的值小于1MB，则分配与len属性同样大小的未使用空间，即此时len和free属性大小一致。\n- 若对SDS修改过后，len属性的值大于1MB，则分配1MB的未使用空间。\n\n##### 1.2.2 惰性空间释放\n\n惰性空间释放用于优化SDS的字符串`缩短操作`，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等待将来使用。\n\n\n\n### 2 链表\n\n链表作为一种常用的数据结构，在Redis中应用广泛，如列表键的底层实现之一就是链表。的那个一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。此外，还有打不与订阅、慢查询、监视器等功能也用到了链表。\n\n*注：Redis的链表为双向链表。*\n\n#### 2.1 链表和链表节点的实现\n\n链表节点，使用一个`adlist.h/listNode结构`来表示：\n\n```c\ntypedef struct listNode {\n    struct listNode *prev;\n    struct listNode *next;\n    void *value;\n} listNode;\n```\n\n多个listNode可以通过prev和next指针组成**双向链表**，如下图所示：\n\n![双向链表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/双向链表.png)\n\n链表，使用`adlist.h/list结构`表示：\n\n```c\ntypedef struct list {\n    // 表头节点\n    listNode *head;\n    // 表尾结点\n    listNode *tail;\n    // 节点值赋值函数\n    void *(*dup)(void *ptr);\n    // 节点值释放函数\n    void (*free)(void *ptr);\n    // 节点值比对函数，比对链表节点梭堡村的值和另一个输入值是否相等\n    int (*match)(void *ptr, void *key);\n    // 链表所包含的节点数量\n    unsigned long len;\n} list;\n```\n\n示例：下图为一个list结构和三个listNode结构组成的链表。\n\n![list结构和三个listNode结构组成的链表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/list结构和三个listNode结构组成的链表.png)\n\n\n\n### 3 字典\n\n字典，又称为符号表（symbol table）、关联数组（assiciative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典中每个键都是独一无二的。\n\n字典的应用：字典在Redis的应用广泛，如Redis的数据库就是使用字典来作为底层实现的。此外字典还是哈希键的底层实现之一。\n\n#### 3.1 字典的实现\n\n<u>Redis的字典使用`哈希表`作为底层实现</u>，<u>一个哈希表里面可以有多个哈希表结点</u>，<u>而每个哈希表结点就保存了一个字段中的键值对</u>。\n\n##### 3.1.1 哈希表\n\nRedis字典所使用的哈希表由`dict.h/dictht结构`定义：\n\n```c\ntypedef struct dictht {\n    // 哈希表数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个结构保存着一个键值对。\n    dictEntry **table;\n    // 哈希表大小.\n    unsigned long size;\n    // 哈希表大小掩码，用于计算索引值.\n    // 总是等于size-1.\n    unsigned long sizemask;\n    // 该哈希表已有结点的数量.\n    unsigned long used;\n} dictht;\n```\n\n示例：下图为一个大小为4的空哈希表。（没有任何键值对）\n\n![大小为4的空哈希表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/大小为4的空哈希表.png)\n\n##### 3.1.2 哈希表结点\n\n哈希表结点使用`dictEntry结构`表示，每个dictEntry结构都保存着一个键值对：\n\n```c\ntypedef struct dictEntry {\n    // 键\n    void *key;\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    // 指向下一个哈希表结点,形成链表,用以解决哈希冲突的问题.\n    struct dictEntry *next;\n} dictEntry;\n```\n\n示例：下图是通过`next指针`,将两个指引着相同的键`k1`和`k0`连接的数据结构.\n\n![通过next指针,将两个索引值相同的键k1和k0连接的数据结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/通过next指针,将两个索引值相同的键k1和k0连接的数据结构.png)\n\n##### 3.1.3 字典\n\nRedis中的字典由`dict.h/dict结构`表示：\n\n```c\ntypedef struct dict {\n    // 类型特定函数.Redis会为用途不同的字典设置不同的类型特定函数。\n    dictType *type;\n    // 私有数据.保存了需要传给那些类型特定函数的可选参数。\n    void *privdata;\n    // 哈希表.包含了两个项的数组，每个项都是dictht哈希表，通常，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用。\n    dictht ht[2];\n    // rehash索引.记录rehash的进度，若当前没有进行rehash，那么它的值为-1.\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n```\n\n其中`type`和`privdata`属性是<u>针对不同类型的键值对,为创建多态字典而设置</u>。\n\n\n\ntype特定函数结构：\n\n```c\ntypedef struct dictType {\n    // 计算哈希值的函数。\n    unsigned int (*hashFunction)(const void *key);\n    // 复制键的函数。\n    void *(*keyDup)(void *privdata, const void *key);\n    // 复制值的函数。\n    void *(*valDup)(void *privdata, const void *obj);\n    // 对比键的函数.\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);\n    // 销毁键的函数。\n    void (*keyDestructor)(void *privdata, void *key);\n    // 销毁值的函数。\n    void (*valDestructor)(void *privdata, void *obj);\n} dictType;\n```\n\n示例：下图为普通状态的下的字典示例。\n\n![普通状态下的字典示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/普通状态下的字典示例.png)\n\n#### 3.2 哈希算法\n\n要将一个新的键值对添加到字典中时，程序需先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表结点放到哈希表数组的指定索引上面。\n\n\n\n**Redis计算哈希值方式？**\n\n使用字典设置的哈希函数，计算键key的哈希值：\n\n```\nhash = dict->type->hashFunction(key);\n```\n\n\n\n**Redis计算索引值的方式？**\n\n根据哈希表的`sizemask属性`和哈希值计算出索引值，其中根据情况不同，ht[x]可以使ht[0]或ht[1]。\n\n```\nindex = hash & dict->ht[x].sizemask;\n```\n\n注：当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。\n\n\n\n#### 3.3 解决键冲突\n\n当有两个或者以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了`冲突（collision）`。\n\n\n\n**Redis怎样解决键冲突？**\n\nRedis的哈希表使用`链地址法`来解决键冲突。\n\n每个哈希表结点都有一个`next指针`，多个哈希表结点可以用next指针构成一个<u>单向链表</u>，被分配到同一个索引上的多个结点可以用这个单向链表连接起来，解决键冲突的问题。\n\n*注：由于dictEntry结点组成的链表没有指向链表表尾的指针，所以程序总是将新节点添加到链表的表头位置（复杂度为O(1)）*\n\n\n\n示例：k2与k1发生了键冲突，k2后添加，如下图所示。\n\n![k2与k1发生了键冲突,k2后添加](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/k2与k1发生了键冲突,k2后添加.png)\n\n#### 3.4 rehash\n\n随着操作的不断执行，哈希表保存的键值对会逐渐增减，为了让哈希表的负载因子维持在一个合理的范围内，需对哈希表的大小进行相应的扩展或收缩。这个过程就是rehash。\n\n**Redis是怎样对字典的哈希表执行rehash的（rehash的步骤）？**\n\n- ①、为字典的`h[1]`哈希表分配空间。\n  - 扩展操作：`ht[1]`的大小为第一个大于等于`ht[0].used*2的2^n`(2的n次方幂)；\n  - 收缩操作：`ht[1]`的大小为第一个大于等于`ht[0].used的2^n`。\n- ②、将保存在`ht[0]`中的所有键值对rehash到`ht[1]`上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。\n- ③、当`ht[0]`包含的所有键值对都前移到了`ht[1]`后，释放`ht[0]`，将`ht[1]`设置为`ht[0]`，并在`ht[1]`新创建一个空白哈希表，为下一次rehash做准备。\n\n\n\n示例：假设ht[0].used当前的值为4，要对进行扩展操作，则ht[1]的大小为4*2=8，刚好为2^3，所以ht[1]哈希表的大小设置为8.\n\n\n\n**哈希表的扩展与收缩都与负载因子有关，那么什么是负载因子呢？怎样计算负载因子？**\n\nRedis的负载因子为哈希表以保存结点的数量与哈希表的大小的比值，计算方法如下：\n\n```\nload_factor = ht[0].used / ht[0].size\n```\n\n示例：对于一个大小为512，包含256个键值对的哈希表说，这个哈希表的负载因子为：\n\nload_factor = 256 / 512 = 0.5\n\n\n\n**什么情况下程序会自动对哈希表执行扩展操作？**\n\n- ①、服务器没有在执行`BGSAVE`或者`BGREWRITEAOF`命令，并且哈希表的负载因子<u>大于等于1</u>.\n- ②、服务器正在执行`BGSAVE`或者`BGREWRITEAOF`命令，并且哈希表的负载因子<u>大于等于5</u>.\n\n*注：在执行BGSAVE或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入，最大限度地节约内存。*\n\n\n\n**什么情况下程序会对哈希表执行收缩操作？**\n\n当哈希表的负载因子<u>小于0.1</u>时，程序自动开始对哈希表执行收缩操作。\n\n\n\n#### 3.5 渐进式rehash\n\n扩展或收缩哈希表需要将`ht[0]`里面的键值对rehash到`ht[1]`里面，但是这个rehash动作并不是一次性、集中式完成的，而是分多次、<u>渐进式</u>地完成的。\n\n\n\n**为什么要渐进式完成rehash？**\n\n为了<u>避免大量键值对rehash对服务器性能造成影响</u>。采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。\n\n\n\n**哈希表是怎样渐进式rehash的（rehash的详细步骤）？**\n\n- ①、为`ht[1]`分配空间，让字典同时持有ht[0]和ht[1]两个哈希表、\n- ②、在字典中维持一个`rehashidx`，并将它的值设置为0，表示rehash工作正式开始。\n- ③、在rehash进行期间，每次对字段执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增加一。\n- ④、随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]上，这是程序将rehashidx属性设为-1，表示rehash操作已完成。\n\n\n\n**渐进式rehash执行期间会涉及到ht[0]和ht[1]两个哈希表，是怎样操作的呢？**\n\n- 针对删除、查找、更新操作，会在两个哈希表上进行，例如，查找一个键时，程序会在ht[0]上查找，若没有找到，会继续到ht[1]里面进行查找。\n- 对于新增操作，新增加到字典的键值对一律被保存到ht[1]里面，而ht[0]则不再进行任何操作。\n\n\n\n### 4 跳跃表\n\n跳跃表是一种`有序数据结构`，它<u>通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</u>。\n\nRedis使用跳跃表作为`有序集合键`的底层实现之一，若一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，跳跃表还在集群节点中用作内部数据结构。\n\n#### 4.1 跳跃表结点的实现\n\nRedis跳跃表由`redis.h/zskiplistNode和redis.h/zskiplist`两个结构定义。\n\n跳跃表示例如下：\n\n![跳跃表示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/跳跃表示例.png)\n\n\n\n`zskiplistNode结构`用于表示跳跃表的结点。\n\n```c\ntypedef struct zskiplistNode {\n    // 成员对象.示例图中o1，o2，o3是结点所保存的成员对象。\n    robj *obj;\n    // 分值. 跳跃表中，结点按照各自所保存的分值从小到大排列。\n    double score;\n    // 后退指针.指向当前的结点的前一个结点，后退指针在程序从表尾想表头遍历时使用。示例图上用BW标识结点的后退指针。\n    struct zskiplistNode *backward;\n    // 层.每个层都有两个属性：前进指针和跨度。\n    struct zskiplistLevel {\n        // 前进指针.前进指针用于访问表尾方向的其他节点。示例图上的带有数字的剪头就表示前进指针。\n        struct zskiplostNode *forward;\n        // 跨度.跨度记录了前进指针所指向结点和当前结点的距离。示例图上箭头上的数字就表示跨度。\n        unsigned int span;\n    } level[];\n} zskiplistNode;\n```\n\n##### 4.1.1 层\n\n跳跃表节点的`level数组`可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。一般来说，层的数量越多，访问其他节点的速度就越快。\n\n每次创建一个新跳跃表节点的时候，程序都根据<u>幂次定律</u>(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。\n\n示例：下图为三个高度分别为1层、3层、5层的节点。\n\n![高度分别为1层,3层,5层的节点](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/高度分别为1层,3层,5层的节点.png)\n\n##### 4.1.2 前进指针\n\n每个层都有一个指向表尾党项的`前进指针`（`level[i].forward`属性），用于从表头向表尾方向访问节点。\n\n\n\n**跳跃表是怎样遍历所有节点的呢？**\n\n示例图如下：\n\n![跳跃表遍历](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/跳跃表遍历.png)\n\n- ①、迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中第二个节点。\n- ②、在第二个结点时，程序沿着第二层的前进指针移动到表中第三个节点。\n- ③、在第三个节点时，程序沿着第二层的前进指针移动到表中的第四个结点。\n- ④、当程序在此沿着第四个节点的前进指针移动时，它碰到了一个NULL，程序知道这时已经到达了跳跃表的表尾，结束遍历。\n\n*注：遍历操作只使用前进指针就能完成。*\n\n\n\n##### 4.1.3 跨度\n\n层的跨度（`level[i].span`属性）用于记录两个结点之间的距离，两个结点之间跨度越大，他们相距得就越远；指向`null`的所有前进指针的跨度都为0，因为他们没有指向任何节点。\n\n<u>跨度实际上是用来计算排位的</u>：在查找某个结点的过程中，将访问过的所有层的跨度累计起来，得到的结果就是目标结点在跳跃表中的排位。\n\n\n\n##### 4.1.4 后退指针\n\n节点的后退指针(`backward`属性)用于从<u>表尾向表头</u>方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。\n\n\n\n##### 4.1.5 分值和成员\n\n节点的分值(`score`属性)是一个`double类型的浮点数`，跳跃表中的所有结点都按分值<u>从小到大来排序</u>。\n\n节点的成员对象(obj属性)是一个指针，他指向一个字符串对象，而字符串对象则保存着一个SDS值。\n\n注：**同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但多个结点保存的分值却可以是相同的**。分值相同的结点将按照成员对象在字典序中的大小来进行排序，成员对象较小的结点会排在前面（靠近表头的方向）。\n\n\n\n#### 4.2 跳跃表的实现\n\n仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个`zskiplist结构`来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或快速地获取跳跃表节点的数量等信息。\n\n`zskiplist结构`如下：\n\n```c\ntypedef struct zskiplist {\n    // header 指向跳跃表的表头节点。\n    // tail 指向跳跃表的表位节点.\n    struct zskiplistNode *header, *tail;\n    // 记录跳跃表的长度，即跳跃表目前包含结点的数量（表头节点不计算在内）\n    unsigned long length;\n    // level 记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。\n    int level;\n} zskiplist;\n```\n\n*注：level表头节点的层高并不计算在内。*\n\n\n\n### 五、整数集合\n\n整数集合是`集合键`的底层实现之一，当一个**集合只包含整数值元素，并且这个集合的元素数量不多时**，Redis就会使用整数集合作为集合键得底层实现。\n\n（<u>注：整数集合是只包含整数值元素的集合。</u>）\n\n\n\n#### 5.1 整数集合的实现\n\n整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为`int16_t`、`int32_t`或者`int64_t`的整数值，并保证集合中不会出现重复元素。\n\n每个`intset.h/intset结构`表示一个整数集合：\n\n```c\ntypedef struct intset {\n    // 编码方式.\n    uint_32_t encoding;\n    // 集合包含的元素数量.即contents数组的长度。\n    uint32_t length;\n    // 保存元素的数组.\n    int8_t contents[];\n}\n```\n\n\n\n**整数集合的底层实现是什么？**\n\n整数集合的底层是通过数组（`contents`属性）实现的，整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小<u>从小到大</u>有序地排列，并且数组中不包含任何重复项。\n\n\n\n注：\n\n①、数组元素在底层是有进行从小到大的排序的。\n\n②、虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存int8_t类型的值，contents数组的真正类型取决于encoding属性的值。\n\nencoding属性的取值包括以下内容：\n\n- **INTSET_ENC_INT16**:表示`int16_t`类型的数组，数组里面每个项都是一个int16_t类型的整数值（2^15 ~2^(15)-1）。\n- **INTSET_ENC_INT32**:表示`int32_t`类型的数组，数组里面每个项都是一个int32_t类型的整数值(2^31 ~2^(31)-1)。\n- **INTSET_ENC_INT64**:表示`int64_t`类型的数组，数组里面每个项都是一个int64_t类型的整数值(2^63 ~2^(63)-1)。\n\n\n\n#### 5.2 升级\n\n当添加新元素到整数集合中时，<u>新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先升级，然后才能将新元素添加到整数集合里面</u>。\n\n\n\n**Redis是怎样升级整数集合并添加新元素的呢（升级及添加新元素的步骤）？**\n\n升级整数集合并添加新元素共分为三步进行：\n\n- ①、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。\n- ②、将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在防止元素的过程中，需要继续维持底层数组的有序性质不变。\n- ③、将新元素添加到底层数组里面。\n\n*注：每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中又有的元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。*\n\n\n\n升级时新元素的摆放位置，要引发升级，那么要么新元素大于所有现有元素，要么小于现有所有元素，因此摆放位置应该在数组的两端。\n\n为什么要进行升级，而不是直接采用int64_t类型？\n\n- ①、提高灵活性。\n- ②、节约内存。\n\n\n\n#### 5.3 降级\n\n整数集合**不支持降级操作**，一旦对数组进行了升级，编码就会一直保持升级后的状态。\n\n\n\n### 六、压缩列表\n\n压缩列表（ziplist）是`列表键`和`哈希键`的底层实现之一。\n\n\n\n压缩列表(ziplist)在Redis的应用场景有哪些？\n\n- ①、当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。\n\n\n- ②、当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。\n\n\n\n\n#### 6.1 压缩列表的构成\n\n压缩列表是Redis为了<u>节约内存</u>而开发的，是由一系列特殊编码的<u>连续内存块组成</u>的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。\n\n压缩列表的各个组成部分如下图：\n\n![压缩表各部分组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩表各部分组成.png)\n\n下表中记录了各个组成部分的类型、长度以及用途。\n\n![压缩表各组成部分的类型,长度以及用途](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩表各组成部分的类型,长度以及用途.png)\n\n示例：包含三个节点的压缩列表\n\n![包含三个节点的压缩列表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/包含三个节点的压缩列表.png)\n\n其中：\n\n- `zlbytes`的属性值为0x50,表示压缩列表的总长为80.\n- `zltail`属性的值为0x3c，表示有一个指向压缩列表起始地址的指针p，在指针p加上偏移量60，就可以计算出表尾节点entry3的地址。\n- `zllen`属性值为0x3，表示压缩列表包含三个节点。\n- `zlend`属性值为特殊值，用于标记压缩列表的末端。\n\n\n\n#### 6.2 压缩列表节点的构成\n\n每个压缩列表节点可以保存<u>一个字节数组</u>或者<u>一个整数值</u>。\n\n- **字节数组**可以是以下三中长度的其中一种：\n  - 长度小于等于63（2^6-1）字节的字节数组。\n  - 长度小于等于16383（2^14-1）字节的字节数组。\n  - 长度小于等于4294967295（2^32-1）字节的字节数组。\n- **整数值**可以是以下六种长度的其中一种：\n  - 4位长，介于0~12之间的无符号整数；\n  - 1字节长的有符号整数；\n  - 3字节长的有符号整数；\n  - int16_t类型整数；\n  - int32_t类型整数；\n  - int64_t类型整数。\n\n\n\n`压缩列表结点的组成部分`如下：\n\n![压缩列表结点的组成部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩列表结点的组成部分.png)\n\n##### 6.2.1 previous_entry_length\n\n`previous_entry_length属性`以`字节`为单位，记录了压缩列表中前一个节点的长度，`previous_entry_length`属性的长度可以是1字节或者5字节。\n\n- 若前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。\n- 若前一节点的长度大于等于254字节，那么previoud_entry_length属性的长度为5字节，其中第一字节会被设置为0xFE，而后的四个字节则用于保存前一节点的长度。\n\n根据previous_entry_length属性可以计算得到前一个节点的起始地址。通过这一原理，即可实现从表尾向表头遍历。\n\n\n\n##### 6.2.2 encoding\n\n节点的`encoding`属性记录了节点的content属性所保存数据的类型及长度：\n\n**字节数组编码**：一字节、两字节或者五字节，encoding最高位为**00、01、10表示字节数组编码**，除去最高两位后表示数组的长度。\n\n![encoding属性数组编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/encoding属性数组编码.png)\n\n\n\n**整数编码**：一字节，**encoding最高位为11**，除去最高两位后的其他位记录整数值的类型和长度。\n\n![encoding属性整数编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/encoding属性整数编码.png)\n\n##### 6.2.3 content\n\n节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由encoding属性决定。\n\n示例1：以下示例展示了一个保存字节数组的节点示例。\n\n![保存字节数组的节点示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/保存字节数组的节点示例.png)\n\n其中：\n\n- encoding的最高两位为00，表示一个字节数组。\n- encoding的后六位001011记录了字节数组的长度为11.\n- content属性保存着节点的值“hello world”\n\n示例2：以下示例展示了一个保存整数值的节点示例。\n\n![保存整数值的节点示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/保存整数值的节点示例.png)\n\n其中：\n\n- encoding表示节点保存的是int16_t类型的整数值。\n- content属性保存着节点的值10086.\n\n\n\n#### 6.3 连锁更新\n\n**什么情况下会发生连锁更新？**\n\n比如当前所有结点长度均小于254字节情况下，新添加一个长度大于254字节的节点到压缩列表的表头，此时需对压缩列表执行空间重分配操作，扩展后面的previous_entry_length属性空间。\n\n定义：Redis将这种特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。\n\n连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。\n\n\n\n### 参考资料\n\n1. redis设计与实现（第二版） 黄健宏","slug":"Redis设计与实现-数据结构","published":1,"updated":"2020-08-31T09:14:51.187Z","_id":"ckeia7fti001n0sg3gnxj0c1q","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-简单动态字符串-SDS\"><a href=\"#1-简单动态字符串-SDS\" class=\"headerlink\" title=\"1 简单动态字符串(SDS)\"></a>1 简单动态字符串(SDS)</h3><p>Redis中有两种字符串表示：</p>\n<ul>\n<li><p><strong>①、C字符串</strong>：C字符串只会作为字符串字面量（string literal），用在一些无须对字符串值进行修改的地方，如打印日志。</p>\n</li>\n<li><p><strong>②、简单动态字符串</strong>：简单动态字符串（simple dynamic string, SDS）是redis构建一种字符串的抽象类型，是redis的默认字符串表示。如字符串键值对、缓冲区等都有SDS实现。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<h4 id=\"1-1-SDS的定义\"><a href=\"#1-1-SDS的定义\" class=\"headerlink\" title=\"1.1 SDS的定义\"></a>1.1 SDS的定义</h4><p>sds.h/sdshdr结构表示一个SDS的值，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录bug数组汇总已使用字节的数量.</span></span><br><span class=\"line\">    <span class=\"comment\">// 等于SDS所保存字符串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">// 记录buf数组中未使用字节的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 字节数组，用于保存字符串.</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><em>注：SDS遵循C字符串以<code>空字符（&#39;\\0&#39;）</code>结尾，但这个字节的空间不计算在SDS的<code>len属性</code>中。</em></p>\n<h4 id=\"1-2、SDS字符串相对于C字符串的优点\"><a href=\"#1-2、SDS字符串相对于C字符串的优点\" class=\"headerlink\" title=\"1.2、SDS字符串相对于C字符串的优点\"></a>1.2、SDS字符串相对于C字符串的优点</h4><ul>\n<li><p>常数复杂度获取字符串长度</p>\n<ul>\n<li>C字符串，没有记录自身的长度信息，获取C字符串长度时需进行遍历，其复杂度为O(N)。</li>\n<li>SDS字符串，有len属性，获取长度的复杂度为O(1)。</li>\n</ul>\n</li>\n<li><p>杜绝缓冲区溢出: SDS相对于C字符串，根据其空间分配策略，杜绝了发生缓冲区溢出的可能性。</p>\n</li>\n<li><p>减少修改字符串时带来的内存重新分配次数: SDS通过未使用空间<code>free记录</code>，实现<code>空间预分配</code>和<code>惰性空间释放</code>两种优化策略。</p>\n</li>\n<li><p>二进制安全</p>\n</li>\n<li><p>兼容部分C字符串函数</p>\n</li>\n</ul>\n<h5 id=\"1-2-1-空间预分配\"><a href=\"#1-2-1-空间预分配\" class=\"headerlink\" title=\"1.2.1 空间预分配\"></a>1.2.1 空间预分配</h5><p>空间预分配用于优化SDS的字符串<code>增长操作</code>，当SDS的API对SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。</p>\n<p>分配策略：</p>\n<ul>\n<li>若对SDS修改过后，len属性的值小于1MB，则分配与len属性同样大小的未使用空间，即此时len和free属性大小一致。</li>\n<li>若对SDS修改过后，len属性的值大于1MB，则分配1MB的未使用空间。</li>\n</ul>\n<h5 id=\"1-2-2-惰性空间释放\"><a href=\"#1-2-2-惰性空间释放\" class=\"headerlink\" title=\"1.2.2 惰性空间释放\"></a>1.2.2 惰性空间释放</h5><p>惰性空间释放用于优化SDS的字符串<code>缩短操作</code>，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等待将来使用。</p>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2 链表\"></a>2 链表</h3><p>链表作为一种常用的数据结构，在Redis中应用广泛，如列表键的底层实现之一就是链表。的那个一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。此外，还有打不与订阅、慢查询、监视器等功能也用到了链表。</p>\n<p><em>注：Redis的链表为双向链表。</em></p>\n<h4 id=\"2-1-链表和链表节点的实现\"><a href=\"#2-1-链表和链表节点的实现\" class=\"headerlink\" title=\"2.1 链表和链表节点的实现\"></a>2.1 链表和链表节点的实现</h4><p>链表节点，使用一个<code>adlist.h/listNode结构</code>来表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n\n<p>多个listNode可以通过prev和next指针组成<strong>双向链表</strong>，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\" alt=\"双向链表\"></p>\n<p>链表，使用<code>adlist.h/list结构</code>表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\">    <span class=\"comment\">// 表尾结点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\">    <span class=\"comment\">// 节点值赋值函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 节点值比对函数，比对链表节点梭堡村的值和另一个输入值是否相等</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为一个list结构和三个listNode结构组成的链表。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/list%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%89%E4%B8%AAlistNode%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90%E7%9A%84%E9%93%BE%E8%A1%A8.png\" alt=\"list结构和三个listNode结构组成的链表\"></p>\n<h3 id=\"3-字典\"><a href=\"#3-字典\" class=\"headerlink\" title=\"3 字典\"></a>3 字典</h3><p>字典，又称为符号表（symbol table）、关联数组（assiciative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典中每个键都是独一无二的。</p>\n<p>字典的应用：字典在Redis的应用广泛，如Redis的数据库就是使用字典来作为底层实现的。此外字典还是哈希键的底层实现之一。</p>\n<h4 id=\"3-1-字典的实现\"><a href=\"#3-1-字典的实现\" class=\"headerlink\" title=\"3.1 字典的实现\"></a>3.1 字典的实现</h4><p><u>Redis的字典使用<code>哈希表</code>作为底层实现</u>，<u>一个哈希表里面可以有多个哈希表结点</u>，<u>而每个哈希表结点就保存了一个字段中的键值对</u>。</p>\n<h5 id=\"3-1-1-哈希表\"><a href=\"#3-1-1-哈希表\" class=\"headerlink\" title=\"3.1.1 哈希表\"></a>3.1.1 哈希表</h5><p>Redis字典所使用的哈希表由<code>dict.h/dictht结构</code>定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个结构保存着一个键值对。</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小掩码，用于计算索引值.</span></span><br><span class=\"line\">    <span class=\"comment\">// 总是等于size-1.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"comment\">// 该哈希表已有结点的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为一个大小为4的空哈希表。（没有任何键值对）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E5%B0%8F%E4%B8%BA4%E7%9A%84%E7%A9%BA%E5%93%88%E5%B8%8C%E8%A1%A8.png\" alt=\"大小为4的空哈希表\"></p>\n<h5 id=\"3-1-2-哈希表结点\"><a href=\"#3-1-2-哈希表结点\" class=\"headerlink\" title=\"3.1.2 哈希表结点\"></a>3.1.2 哈希表结点</h5><p>哈希表结点使用<code>dictEntry结构</code>表示，每个dictEntry结构都保存着一个键值对：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"comment\">// 指向下一个哈希表结点,形成链表,用以解决哈希冲突的问题.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图是通过<code>next指针</code>,将两个指引着相同的键<code>k1</code>和<code>k0</code>连接的数据结构.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%9A%E8%BF%87next%E6%8C%87%E9%92%88,%E5%B0%86%E4%B8%A4%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%80%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E9%94%AEk1%E5%92%8Ck0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png\" alt=\"通过next指针,将两个索引值相同的键k1和k0连接的数据结构\"></p>\n<h5 id=\"3-1-3-字典\"><a href=\"#3-1-3-字典\" class=\"headerlink\" title=\"3.1.3 字典\"></a>3.1.3 字典</h5><p>Redis中的字典由<code>dict.h/dict结构</code>表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型特定函数.Redis会为用途不同的字典设置不同的类型特定函数。</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"comment\">// 私有数据.保存了需要传给那些类型特定函数的可选参数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表.包含了两个项的数组，每个项都是dictht哈希表，通常，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用。</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">// rehash索引.记录rehash的进度，若当前没有进行rehash，那么它的值为-1.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>type</code>和<code>privdata</code>属性是<u>针对不同类型的键值对,为创建多态字典而设置</u>。</p>\n<p>type特定函数结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictType</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 计算哈希值的函数。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">int</span> <span class=\"params\">(*hashFunction)</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 复制键的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*keyDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制值的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*valDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">    <span class=\"comment\">// 对比键的函数.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keyCompare)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁键的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*keyDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁值的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*valDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为普通状态的下的字典示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%99%AE%E9%80%9A%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AD%97%E5%85%B8%E7%A4%BA%E4%BE%8B.png\" alt=\"普通状态下的字典示例\"></p>\n<h4 id=\"3-2-哈希算法\"><a href=\"#3-2-哈希算法\" class=\"headerlink\" title=\"3.2 哈希算法\"></a>3.2 哈希算法</h4><p>要将一个新的键值对添加到字典中时，程序需先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表结点放到哈希表数组的指定索引上面。</p>\n<p><strong>Redis计算哈希值方式？</strong></p>\n<p>使用字典设置的哈希函数，计算键key的哈希值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Redis计算索引值的方式？</strong></p>\n<p>根据哈希表的<code>sizemask属性</code>和哈希值计算出索引值，其中根据情况不同，ht[x]可以使ht[0]或ht[1]。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index &#x3D; hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n\n<p>注：当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</p>\n<h4 id=\"3-3-解决键冲突\"><a href=\"#3-3-解决键冲突\" class=\"headerlink\" title=\"3.3 解决键冲突\"></a>3.3 解决键冲突</h4><p>当有两个或者以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了<code>冲突（collision）</code>。</p>\n<p><strong>Redis怎样解决键冲突？</strong></p>\n<p>Redis的哈希表使用<code>链地址法</code>来解决键冲突。</p>\n<p>每个哈希表结点都有一个<code>next指针</code>，多个哈希表结点可以用next指针构成一个<u>单向链表</u>，被分配到同一个索引上的多个结点可以用这个单向链表连接起来，解决键冲突的问题。</p>\n<p><em>注：由于dictEntry结点组成的链表没有指向链表表尾的指针，所以程序总是将新节点添加到链表的表头位置（复杂度为O(1)）</em></p>\n<p>示例：k2与k1发生了键冲突，k2后添加，如下图所示。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/k2%E4%B8%8Ek1%E5%8F%91%E7%94%9F%E4%BA%86%E9%94%AE%E5%86%B2%E7%AA%81,k2%E5%90%8E%E6%B7%BB%E5%8A%A0.png\" alt=\"k2与k1发生了键冲突,k2后添加\"></p>\n<h4 id=\"3-4-rehash\"><a href=\"#3-4-rehash\" class=\"headerlink\" title=\"3.4 rehash\"></a>3.4 rehash</h4><p>随着操作的不断执行，哈希表保存的键值对会逐渐增减，为了让哈希表的负载因子维持在一个合理的范围内，需对哈希表的大小进行相应的扩展或收缩。这个过程就是rehash。</p>\n<p><strong>Redis是怎样对字典的哈希表执行rehash的（rehash的步骤）？</strong></p>\n<ul>\n<li>①、为字典的<code>h[1]</code>哈希表分配空间。<ul>\n<li>扩展操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used*2的2^n</code>(2的n次方幂)；</li>\n<li>收缩操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used的2^n</code>。</li>\n</ul>\n</li>\n<li>②、将保存在<code>ht[0]</code>中的所有键值对rehash到<code>ht[1]</code>上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li>\n<li>③、当<code>ht[0]</code>包含的所有键值对都前移到了<code>ht[1]</code>后，释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新创建一个空白哈希表，为下一次rehash做准备。</li>\n</ul>\n<p>示例：假设ht[0].used当前的值为4，要对进行扩展操作，则ht[1]的大小为4*2=8，刚好为2^3，所以ht[1]哈希表的大小设置为8.</p>\n<p><strong>哈希表的扩展与收缩都与负载因子有关，那么什么是负载因子呢？怎样计算负载因子？</strong></p>\n<p>Redis的负载因子为哈希表以保存结点的数量与哈希表的大小的比值，计算方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">load_factor &#x3D; ht[0].used &#x2F; ht[0].size</span><br></pre></td></tr></table></figure>\n\n<p>示例：对于一个大小为512，包含256个键值对的哈希表说，这个哈希表的负载因子为：</p>\n<p>load_factor = 256 / 512 = 0.5</p>\n<p><strong>什么情况下程序会自动对哈希表执行扩展操作？</strong></p>\n<ul>\n<li>①、服务器没有在执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子<u>大于等于1</u>.</li>\n<li>②、服务器正在执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子<u>大于等于5</u>.</li>\n</ul>\n<p><em>注：在执行BGSAVE或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入，最大限度地节约内存。</em></p>\n<p><strong>什么情况下程序会对哈希表执行收缩操作？</strong></p>\n<p>当哈希表的负载因子<u>小于0.1</u>时，程序自动开始对哈希表执行收缩操作。</p>\n<h4 id=\"3-5-渐进式rehash\"><a href=\"#3-5-渐进式rehash\" class=\"headerlink\" title=\"3.5 渐进式rehash\"></a>3.5 渐进式rehash</h4><p>扩展或收缩哈希表需要将<code>ht[0]</code>里面的键值对rehash到<code>ht[1]</code>里面，但是这个rehash动作并不是一次性、集中式完成的，而是分多次、<u>渐进式</u>地完成的。</p>\n<p><strong>为什么要渐进式完成rehash？</strong></p>\n<p>为了<u>避免大量键值对rehash对服务器性能造成影响</u>。采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</p>\n<p><strong>哈希表是怎样渐进式rehash的（rehash的详细步骤）？</strong></p>\n<ul>\n<li>①、为<code>ht[1]</code>分配空间，让字典同时持有ht[0]和ht[1]两个哈希表、</li>\n<li>②、在字典中维持一个<code>rehashidx</code>，并将它的值设置为0，表示rehash工作正式开始。</li>\n<li>③、在rehash进行期间，每次对字段执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增加一。</li>\n<li>④、随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]上，这是程序将rehashidx属性设为-1，表示rehash操作已完成。</li>\n</ul>\n<p><strong>渐进式rehash执行期间会涉及到ht[0]和ht[1]两个哈希表，是怎样操作的呢？</strong></p>\n<ul>\n<li>针对删除、查找、更新操作，会在两个哈希表上进行，例如，查找一个键时，程序会在ht[0]上查找，若没有找到，会继续到ht[1]里面进行查找。</li>\n<li>对于新增操作，新增加到字典的键值对一律被保存到ht[1]里面，而ht[0]则不再进行任何操作。</li>\n</ul>\n<h3 id=\"4-跳跃表\"><a href=\"#4-跳跃表\" class=\"headerlink\" title=\"4 跳跃表\"></a>4 跳跃表</h3><p>跳跃表是一种<code>有序数据结构</code>，它<u>通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</u>。</p>\n<p>Redis使用跳跃表作为<code>有序集合键</code>的底层实现之一，若一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，跳跃表还在集群节点中用作内部数据结构。</p>\n<h4 id=\"4-1-跳跃表结点的实现\"><a href=\"#4-1-跳跃表结点的实现\" class=\"headerlink\" title=\"4.1 跳跃表结点的实现\"></a>4.1 跳跃表结点的实现</h4><p>Redis跳跃表由<code>redis.h/zskiplistNode和redis.h/zskiplist</code>两个结构定义。</p>\n<p>跳跃表示例如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%A4%BA%E4%BE%8B.png\" alt=\"跳跃表示例\"></p>\n<p><code>zskiplistNode结构</code>用于表示跳跃表的结点。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员对象.示例图中o1，o2，o3是结点所保存的成员对象。</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\">    <span class=\"comment\">// 分值. 跳跃表中，结点按照各自所保存的分值从小到大排列。</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">    <span class=\"comment\">// 后退指针.指向当前的结点的前一个结点，后退指针在程序从表尾想表头遍历时使用。示例图上用BW标识结点的后退指针。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 层.每个层都有两个属性：前进指针和跨度。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// 前进指针.前进指针用于访问表尾方向的其他节点。示例图上的带有数字的剪头就表示前进指针。</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplostNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\">        <span class=\"comment\">// 跨度.跨度记录了前进指针所指向结点和当前结点的距离。示例图上箭头上的数字就表示跨度。</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-1-1-层\"><a href=\"#4-1-1-层\" class=\"headerlink\" title=\"4.1.1 层\"></a>4.1.1 层</h5><p>跳跃表节点的<code>level数组</code>可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。一般来说，层的数量越多，访问其他节点的速度就越快。</p>\n<p>每次创建一个新跳跃表节点的时候，程序都根据<u>幂次定律</u>(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。</p>\n<p>示例：下图为三个高度分别为1层、3层、5层的节点。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E5%BA%A6%E5%88%86%E5%88%AB%E4%B8%BA1%E5%B1%82,3%E5%B1%82,5%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9.png\" alt=\"高度分别为1层,3层,5层的节点\"></p>\n<h5 id=\"4-1-2-前进指针\"><a href=\"#4-1-2-前进指针\" class=\"headerlink\" title=\"4.1.2 前进指针\"></a>4.1.2 前进指针</h5><p>每个层都有一个指向表尾党项的<code>前进指针</code>（<code>level[i].forward</code>属性），用于从表头向表尾方向访问节点。</p>\n<p><strong>跳跃表是怎样遍历所有节点的呢？</strong></p>\n<p>示例图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86.png\" alt=\"跳跃表遍历\"></p>\n<ul>\n<li>①、迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中第二个节点。</li>\n<li>②、在第二个结点时，程序沿着第二层的前进指针移动到表中第三个节点。</li>\n<li>③、在第三个节点时，程序沿着第二层的前进指针移动到表中的第四个结点。</li>\n<li>④、当程序在此沿着第四个节点的前进指针移动时，它碰到了一个NULL，程序知道这时已经到达了跳跃表的表尾，结束遍历。</li>\n</ul>\n<p><em>注：遍历操作只使用前进指针就能完成。</em></p>\n<h5 id=\"4-1-3-跨度\"><a href=\"#4-1-3-跨度\" class=\"headerlink\" title=\"4.1.3 跨度\"></a>4.1.3 跨度</h5><p>层的跨度（<code>level[i].span</code>属性）用于记录两个结点之间的距离，两个结点之间跨度越大，他们相距得就越远；指向<code>null</code>的所有前进指针的跨度都为0，因为他们没有指向任何节点。</p>\n<p><u>跨度实际上是用来计算排位的</u>：在查找某个结点的过程中，将访问过的所有层的跨度累计起来，得到的结果就是目标结点在跳跃表中的排位。</p>\n<h5 id=\"4-1-4-后退指针\"><a href=\"#4-1-4-后退指针\" class=\"headerlink\" title=\"4.1.4 后退指针\"></a>4.1.4 后退指针</h5><p>节点的后退指针(<code>backward</code>属性)用于从<u>表尾向表头</u>方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>\n<h5 id=\"4-1-5-分值和成员\"><a href=\"#4-1-5-分值和成员\" class=\"headerlink\" title=\"4.1.5 分值和成员\"></a>4.1.5 分值和成员</h5><p>节点的分值(<code>score</code>属性)是一个<code>double类型的浮点数</code>，跳跃表中的所有结点都按分值<u>从小到大来排序</u>。</p>\n<p>节点的成员对象(obj属性)是一个指针，他指向一个字符串对象，而字符串对象则保存着一个SDS值。</p>\n<p>注：<strong>同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但多个结点保存的分值却可以是相同的</strong>。分值相同的结点将按照成员对象在字典序中的大小来进行排序，成员对象较小的结点会排在前面（靠近表头的方向）。</p>\n<h4 id=\"4-2-跳跃表的实现\"><a href=\"#4-2-跳跃表的实现\" class=\"headerlink\" title=\"4.2 跳跃表的实现\"></a>4.2 跳跃表的实现</h4><p>仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个<code>zskiplist结构</code>来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或快速地获取跳跃表节点的数量等信息。</p>\n<p><code>zskiplist结构</code>如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// header 指向跳跃表的表头节点。</span></span><br><span class=\"line\">    <span class=\"comment\">// tail 指向跳跃表的表位节点.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录跳跃表的长度，即跳跃表目前包含结点的数量（表头节点不计算在内）</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\">    <span class=\"comment\">// level 记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n\n<p><em>注：level表头节点的层高并不计算在内。</em></p>\n<h3 id=\"五、整数集合\"><a href=\"#五、整数集合\" class=\"headerlink\" title=\"五、整数集合\"></a>五、整数集合</h3><p>整数集合是<code>集合键</code>的底层实现之一，当一个<strong>集合只包含整数值元素，并且这个集合的元素数量不多时</strong>，Redis就会使用整数集合作为集合键得底层实现。</p>\n<p>（<u>注：整数集合是只包含整数值元素的集合。</u>）</p>\n<h4 id=\"5-1-整数集合的实现\"><a href=\"#5-1-整数集合的实现\" class=\"headerlink\" title=\"5.1 整数集合的实现\"></a>5.1 整数集合的实现</h4><p>整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为<code>int16_t</code>、<code>int32_t</code>或者<code>int64_t</code>的整数值，并保证集合中不会出现重复元素。</p>\n<p>每个<code>intset.h/intset结构</code>表示一个整数集合：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 编码方式.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint_32_t</span> encoding;</span><br><span class=\"line\">    <span class=\"comment\">// 集合包含的元素数量.即contents数组的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;</span><br><span class=\"line\">    <span class=\"comment\">// 保存元素的数组.</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>整数集合的底层实现是什么？</strong></p>\n<p>整数集合的底层是通过数组（<code>contents</code>属性）实现的，整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小<u>从小到大</u>有序地排列，并且数组中不包含任何重复项。</p>\n<p>注：</p>\n<p>①、数组元素在底层是有进行从小到大的排序的。</p>\n<p>②、虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存int8_t类型的值，contents数组的真正类型取决于encoding属性的值。</p>\n<p>encoding属性的取值包括以下内容：</p>\n<ul>\n<li><strong>INTSET_ENC_INT16</strong>:表示<code>int16_t</code>类型的数组，数组里面每个项都是一个int16_t类型的整数值（2^15 ~2^(15)-1）。</li>\n<li><strong>INTSET_ENC_INT32</strong>:表示<code>int32_t</code>类型的数组，数组里面每个项都是一个int32_t类型的整数值(2^31 ~2^(31)-1)。</li>\n<li><strong>INTSET_ENC_INT64</strong>:表示<code>int64_t</code>类型的数组，数组里面每个项都是一个int64_t类型的整数值(2^63 ~2^(63)-1)。</li>\n</ul>\n<h4 id=\"5-2-升级\"><a href=\"#5-2-升级\" class=\"headerlink\" title=\"5.2 升级\"></a>5.2 升级</h4><p>当添加新元素到整数集合中时，<u>新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先升级，然后才能将新元素添加到整数集合里面</u>。</p>\n<p><strong>Redis是怎样升级整数集合并添加新元素的呢（升级及添加新元素的步骤）？</strong></p>\n<p>升级整数集合并添加新元素共分为三步进行：</p>\n<ul>\n<li>①、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>\n<li>②、将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在防止元素的过程中，需要继续维持底层数组的有序性质不变。</li>\n<li>③、将新元素添加到底层数组里面。</li>\n</ul>\n<p><em>注：每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中又有的元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。</em></p>\n<p>升级时新元素的摆放位置，要引发升级，那么要么新元素大于所有现有元素，要么小于现有所有元素，因此摆放位置应该在数组的两端。</p>\n<p>为什么要进行升级，而不是直接采用int64_t类型？</p>\n<ul>\n<li>①、提高灵活性。</li>\n<li>②、节约内存。</li>\n</ul>\n<h4 id=\"5-3-降级\"><a href=\"#5-3-降级\" class=\"headerlink\" title=\"5.3 降级\"></a>5.3 降级</h4><p>整数集合<strong>不支持降级操作</strong>，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>\n<h3 id=\"六、压缩列表\"><a href=\"#六、压缩列表\" class=\"headerlink\" title=\"六、压缩列表\"></a>六、压缩列表</h3><p>压缩列表（ziplist）是<code>列表键</code>和<code>哈希键</code>的底层实现之一。</p>\n<p>压缩列表(ziplist)在Redis的应用场景有哪些？</p>\n<ul>\n<li>①、当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</li>\n</ul>\n<ul>\n<li>②、当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</li>\n</ul>\n<h4 id=\"6-1-压缩列表的构成\"><a href=\"#6-1-压缩列表的构成\" class=\"headerlink\" title=\"6.1 压缩列表的构成\"></a>6.1 压缩列表的构成</h4><p>压缩列表是Redis为了<u>节约内存</u>而开发的，是由一系列特殊编码的<u>连续内存块组成</u>的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。</p>\n<p>压缩列表的各个组成部分如下图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E8%A1%A8%E5%90%84%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png\" alt=\"压缩表各部分组成\"></p>\n<p>下表中记录了各个组成部分的类型、长度以及用途。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E8%A1%A8%E5%90%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E7%9A%84%E7%B1%BB%E5%9E%8B,%E9%95%BF%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%94%A8%E9%80%94.png\" alt=\"压缩表各组成部分的类型,长度以及用途\"></p>\n<p>示例：包含三个节点的压缩列表</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8C%85%E5%90%AB%E4%B8%89%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png\" alt=\"包含三个节点的压缩列表\"></p>\n<p>其中：</p>\n<ul>\n<li><code>zlbytes</code>的属性值为0x50,表示压缩列表的总长为80.</li>\n<li><code>zltail</code>属性的值为0x3c，表示有一个指向压缩列表起始地址的指针p，在指针p加上偏移量60，就可以计算出表尾节点entry3的地址。</li>\n<li><code>zllen</code>属性值为0x3，表示压缩列表包含三个节点。</li>\n<li><code>zlend</code>属性值为特殊值，用于标记压缩列表的末端。</li>\n</ul>\n<h4 id=\"6-2-压缩列表节点的构成\"><a href=\"#6-2-压缩列表节点的构成\" class=\"headerlink\" title=\"6.2 压缩列表节点的构成\"></a>6.2 压缩列表节点的构成</h4><p>每个压缩列表节点可以保存<u>一个字节数组</u>或者<u>一个整数值</u>。</p>\n<ul>\n<li><strong>字节数组</strong>可以是以下三中长度的其中一种：<ul>\n<li>长度小于等于63（2^6-1）字节的字节数组。</li>\n<li>长度小于等于16383（2^14-1）字节的字节数组。</li>\n<li>长度小于等于4294967295（2^32-1）字节的字节数组。</li>\n</ul>\n</li>\n<li><strong>整数值</strong>可以是以下六种长度的其中一种：<ul>\n<li>4位长，介于0~12之间的无符号整数；</li>\n<li>1字节长的有符号整数；</li>\n<li>3字节长的有符号整数；</li>\n<li>int16_t类型整数；</li>\n<li>int32_t类型整数；</li>\n<li>int64_t类型整数。</li>\n</ul>\n</li>\n</ul>\n<p><code>压缩列表结点的组成部分</code>如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E7%82%B9%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png\" alt=\"压缩列表结点的组成部分\"></p>\n<h5 id=\"6-2-1-previous-entry-length\"><a href=\"#6-2-1-previous-entry-length\" class=\"headerlink\" title=\"6.2.1 previous_entry_length\"></a>6.2.1 previous_entry_length</h5><p><code>previous_entry_length属性</code>以<code>字节</code>为单位，记录了压缩列表中前一个节点的长度，<code>previous_entry_length</code>属性的长度可以是1字节或者5字节。</p>\n<ul>\n<li>若前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。</li>\n<li>若前一节点的长度大于等于254字节，那么previoud_entry_length属性的长度为5字节，其中第一字节会被设置为0xFE，而后的四个字节则用于保存前一节点的长度。</li>\n</ul>\n<p>根据previous_entry_length属性可以计算得到前一个节点的起始地址。通过这一原理，即可实现从表尾向表头遍历。</p>\n<h5 id=\"6-2-2-encoding\"><a href=\"#6-2-2-encoding\" class=\"headerlink\" title=\"6.2.2 encoding\"></a>6.2.2 encoding</h5><p>节点的<code>encoding</code>属性记录了节点的content属性所保存数据的类型及长度：</p>\n<p><strong>字节数组编码</strong>：一字节、两字节或者五字节，encoding最高位为<strong>00、01、10表示字节数组编码</strong>，除去最高两位后表示数组的长度。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/encoding%E5%B1%9E%E6%80%A7%E6%95%B0%E7%BB%84%E7%BC%96%E7%A0%81.png\" alt=\"encoding属性数组编码\"></p>\n<p><strong>整数编码</strong>：一字节，<strong>encoding最高位为11</strong>，除去最高两位后的其他位记录整数值的类型和长度。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/encoding%E5%B1%9E%E6%80%A7%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81.png\" alt=\"encoding属性整数编码\"></p>\n<h5 id=\"6-2-3-content\"><a href=\"#6-2-3-content\" class=\"headerlink\" title=\"6.2.3 content\"></a>6.2.3 content</h5><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由encoding属性决定。</p>\n<p>示例1：以下示例展示了一个保存字节数组的节点示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BF%9D%E5%AD%98%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%9A%84%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png\" alt=\"保存字节数组的节点示例\"></p>\n<p>其中：</p>\n<ul>\n<li>encoding的最高两位为00，表示一个字节数组。</li>\n<li>encoding的后六位001011记录了字节数组的长度为11.</li>\n<li>content属性保存着节点的值“hello world”</li>\n</ul>\n<p>示例2：以下示例展示了一个保存整数值的节点示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BF%9D%E5%AD%98%E6%95%B4%E6%95%B0%E5%80%BC%E7%9A%84%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png\" alt=\"保存整数值的节点示例\"></p>\n<p>其中：</p>\n<ul>\n<li>encoding表示节点保存的是int16_t类型的整数值。</li>\n<li>content属性保存着节点的值10086.</li>\n</ul>\n<h4 id=\"6-3-连锁更新\"><a href=\"#6-3-连锁更新\" class=\"headerlink\" title=\"6.3 连锁更新\"></a>6.3 连锁更新</h4><p><strong>什么情况下会发生连锁更新？</strong></p>\n<p>比如当前所有结点长度均小于254字节情况下，新添加一个长度大于254字节的节点到压缩列表的表头，此时需对压缩列表执行空间重分配操作，扩展后面的previous_entry_length属性空间。</p>\n<p>定义：Redis将这种特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。</p>\n<p>连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li>redis设计与实现（第二版） 黄健宏</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-简单动态字符串-SDS\"><a href=\"#1-简单动态字符串-SDS\" class=\"headerlink\" title=\"1 简单动态字符串(SDS)\"></a>1 简单动态字符串(SDS)</h3><p>Redis中有两种字符串表示：</p>\n<ul>\n<li><p><strong>①、C字符串</strong>：C字符串只会作为字符串字面量（string literal），用在一些无须对字符串值进行修改的地方，如打印日志。</p>\n</li>\n<li><p><strong>②、简单动态字符串</strong>：简单动态字符串（simple dynamic string, SDS）是redis构建一种字符串的抽象类型，是redis的默认字符串表示。如字符串键值对、缓冲区等都有SDS实现。</p>\n</li>\n</ul>","more":"<h4 id=\"1-1-SDS的定义\"><a href=\"#1-1-SDS的定义\" class=\"headerlink\" title=\"1.1 SDS的定义\"></a>1.1 SDS的定义</h4><p>sds.h/sdshdr结构表示一个SDS的值，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录bug数组汇总已使用字节的数量.</span></span><br><span class=\"line\">    <span class=\"comment\">// 等于SDS所保存字符串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">// 记录buf数组中未使用字节的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 字节数组，用于保存字符串.</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><em>注：SDS遵循C字符串以<code>空字符（&#39;\\0&#39;）</code>结尾，但这个字节的空间不计算在SDS的<code>len属性</code>中。</em></p>\n<h4 id=\"1-2、SDS字符串相对于C字符串的优点\"><a href=\"#1-2、SDS字符串相对于C字符串的优点\" class=\"headerlink\" title=\"1.2、SDS字符串相对于C字符串的优点\"></a>1.2、SDS字符串相对于C字符串的优点</h4><ul>\n<li><p>常数复杂度获取字符串长度</p>\n<ul>\n<li>C字符串，没有记录自身的长度信息，获取C字符串长度时需进行遍历，其复杂度为O(N)。</li>\n<li>SDS字符串，有len属性，获取长度的复杂度为O(1)。</li>\n</ul>\n</li>\n<li><p>杜绝缓冲区溢出: SDS相对于C字符串，根据其空间分配策略，杜绝了发生缓冲区溢出的可能性。</p>\n</li>\n<li><p>减少修改字符串时带来的内存重新分配次数: SDS通过未使用空间<code>free记录</code>，实现<code>空间预分配</code>和<code>惰性空间释放</code>两种优化策略。</p>\n</li>\n<li><p>二进制安全</p>\n</li>\n<li><p>兼容部分C字符串函数</p>\n</li>\n</ul>\n<h5 id=\"1-2-1-空间预分配\"><a href=\"#1-2-1-空间预分配\" class=\"headerlink\" title=\"1.2.1 空间预分配\"></a>1.2.1 空间预分配</h5><p>空间预分配用于优化SDS的字符串<code>增长操作</code>，当SDS的API对SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。</p>\n<p>分配策略：</p>\n<ul>\n<li>若对SDS修改过后，len属性的值小于1MB，则分配与len属性同样大小的未使用空间，即此时len和free属性大小一致。</li>\n<li>若对SDS修改过后，len属性的值大于1MB，则分配1MB的未使用空间。</li>\n</ul>\n<h5 id=\"1-2-2-惰性空间释放\"><a href=\"#1-2-2-惰性空间释放\" class=\"headerlink\" title=\"1.2.2 惰性空间释放\"></a>1.2.2 惰性空间释放</h5><p>惰性空间释放用于优化SDS的字符串<code>缩短操作</code>，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等待将来使用。</p>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2 链表\"></a>2 链表</h3><p>链表作为一种常用的数据结构，在Redis中应用广泛，如列表键的底层实现之一就是链表。的那个一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。此外，还有打不与订阅、慢查询、监视器等功能也用到了链表。</p>\n<p><em>注：Redis的链表为双向链表。</em></p>\n<h4 id=\"2-1-链表和链表节点的实现\"><a href=\"#2-1-链表和链表节点的实现\" class=\"headerlink\" title=\"2.1 链表和链表节点的实现\"></a>2.1 链表和链表节点的实现</h4><p>链表节点，使用一个<code>adlist.h/listNode结构</code>来表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n\n<p>多个listNode可以通过prev和next指针组成<strong>双向链表</strong>，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\" alt=\"双向链表\"></p>\n<p>链表，使用<code>adlist.h/list结构</code>表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\">    <span class=\"comment\">// 表尾结点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\">    <span class=\"comment\">// 节点值赋值函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 节点值比对函数，比对链表节点梭堡村的值和另一个输入值是否相等</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为一个list结构和三个listNode结构组成的链表。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/list%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%89%E4%B8%AAlistNode%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90%E7%9A%84%E9%93%BE%E8%A1%A8.png\" alt=\"list结构和三个listNode结构组成的链表\"></p>\n<h3 id=\"3-字典\"><a href=\"#3-字典\" class=\"headerlink\" title=\"3 字典\"></a>3 字典</h3><p>字典，又称为符号表（symbol table）、关联数组（assiciative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典中每个键都是独一无二的。</p>\n<p>字典的应用：字典在Redis的应用广泛，如Redis的数据库就是使用字典来作为底层实现的。此外字典还是哈希键的底层实现之一。</p>\n<h4 id=\"3-1-字典的实现\"><a href=\"#3-1-字典的实现\" class=\"headerlink\" title=\"3.1 字典的实现\"></a>3.1 字典的实现</h4><p><u>Redis的字典使用<code>哈希表</code>作为底层实现</u>，<u>一个哈希表里面可以有多个哈希表结点</u>，<u>而每个哈希表结点就保存了一个字段中的键值对</u>。</p>\n<h5 id=\"3-1-1-哈希表\"><a href=\"#3-1-1-哈希表\" class=\"headerlink\" title=\"3.1.1 哈希表\"></a>3.1.1 哈希表</h5><p>Redis字典所使用的哈希表由<code>dict.h/dictht结构</code>定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个结构保存着一个键值对。</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小掩码，用于计算索引值.</span></span><br><span class=\"line\">    <span class=\"comment\">// 总是等于size-1.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"comment\">// 该哈希表已有结点的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为一个大小为4的空哈希表。（没有任何键值对）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E5%B0%8F%E4%B8%BA4%E7%9A%84%E7%A9%BA%E5%93%88%E5%B8%8C%E8%A1%A8.png\" alt=\"大小为4的空哈希表\"></p>\n<h5 id=\"3-1-2-哈希表结点\"><a href=\"#3-1-2-哈希表结点\" class=\"headerlink\" title=\"3.1.2 哈希表结点\"></a>3.1.2 哈希表结点</h5><p>哈希表结点使用<code>dictEntry结构</code>表示，每个dictEntry结构都保存着一个键值对：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"comment\">// 指向下一个哈希表结点,形成链表,用以解决哈希冲突的问题.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图是通过<code>next指针</code>,将两个指引着相同的键<code>k1</code>和<code>k0</code>连接的数据结构.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%9A%E8%BF%87next%E6%8C%87%E9%92%88,%E5%B0%86%E4%B8%A4%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%80%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E9%94%AEk1%E5%92%8Ck0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png\" alt=\"通过next指针,将两个索引值相同的键k1和k0连接的数据结构\"></p>\n<h5 id=\"3-1-3-字典\"><a href=\"#3-1-3-字典\" class=\"headerlink\" title=\"3.1.3 字典\"></a>3.1.3 字典</h5><p>Redis中的字典由<code>dict.h/dict结构</code>表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型特定函数.Redis会为用途不同的字典设置不同的类型特定函数。</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"comment\">// 私有数据.保存了需要传给那些类型特定函数的可选参数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表.包含了两个项的数组，每个项都是dictht哈希表，通常，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用。</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">// rehash索引.记录rehash的进度，若当前没有进行rehash，那么它的值为-1.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>type</code>和<code>privdata</code>属性是<u>针对不同类型的键值对,为创建多态字典而设置</u>。</p>\n<p>type特定函数结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictType</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 计算哈希值的函数。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">int</span> <span class=\"params\">(*hashFunction)</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 复制键的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*keyDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制值的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*valDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">    <span class=\"comment\">// 对比键的函数.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keyCompare)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁键的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*keyDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁值的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*valDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为普通状态的下的字典示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%99%AE%E9%80%9A%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AD%97%E5%85%B8%E7%A4%BA%E4%BE%8B.png\" alt=\"普通状态下的字典示例\"></p>\n<h4 id=\"3-2-哈希算法\"><a href=\"#3-2-哈希算法\" class=\"headerlink\" title=\"3.2 哈希算法\"></a>3.2 哈希算法</h4><p>要将一个新的键值对添加到字典中时，程序需先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表结点放到哈希表数组的指定索引上面。</p>\n<p><strong>Redis计算哈希值方式？</strong></p>\n<p>使用字典设置的哈希函数，计算键key的哈希值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Redis计算索引值的方式？</strong></p>\n<p>根据哈希表的<code>sizemask属性</code>和哈希值计算出索引值，其中根据情况不同，ht[x]可以使ht[0]或ht[1]。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index &#x3D; hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n\n<p>注：当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</p>\n<h4 id=\"3-3-解决键冲突\"><a href=\"#3-3-解决键冲突\" class=\"headerlink\" title=\"3.3 解决键冲突\"></a>3.3 解决键冲突</h4><p>当有两个或者以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了<code>冲突（collision）</code>。</p>\n<p><strong>Redis怎样解决键冲突？</strong></p>\n<p>Redis的哈希表使用<code>链地址法</code>来解决键冲突。</p>\n<p>每个哈希表结点都有一个<code>next指针</code>，多个哈希表结点可以用next指针构成一个<u>单向链表</u>，被分配到同一个索引上的多个结点可以用这个单向链表连接起来，解决键冲突的问题。</p>\n<p><em>注：由于dictEntry结点组成的链表没有指向链表表尾的指针，所以程序总是将新节点添加到链表的表头位置（复杂度为O(1)）</em></p>\n<p>示例：k2与k1发生了键冲突，k2后添加，如下图所示。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/k2%E4%B8%8Ek1%E5%8F%91%E7%94%9F%E4%BA%86%E9%94%AE%E5%86%B2%E7%AA%81,k2%E5%90%8E%E6%B7%BB%E5%8A%A0.png\" alt=\"k2与k1发生了键冲突,k2后添加\"></p>\n<h4 id=\"3-4-rehash\"><a href=\"#3-4-rehash\" class=\"headerlink\" title=\"3.4 rehash\"></a>3.4 rehash</h4><p>随着操作的不断执行，哈希表保存的键值对会逐渐增减，为了让哈希表的负载因子维持在一个合理的范围内，需对哈希表的大小进行相应的扩展或收缩。这个过程就是rehash。</p>\n<p><strong>Redis是怎样对字典的哈希表执行rehash的（rehash的步骤）？</strong></p>\n<ul>\n<li>①、为字典的<code>h[1]</code>哈希表分配空间。<ul>\n<li>扩展操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used*2的2^n</code>(2的n次方幂)；</li>\n<li>收缩操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used的2^n</code>。</li>\n</ul>\n</li>\n<li>②、将保存在<code>ht[0]</code>中的所有键值对rehash到<code>ht[1]</code>上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li>\n<li>③、当<code>ht[0]</code>包含的所有键值对都前移到了<code>ht[1]</code>后，释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新创建一个空白哈希表，为下一次rehash做准备。</li>\n</ul>\n<p>示例：假设ht[0].used当前的值为4，要对进行扩展操作，则ht[1]的大小为4*2=8，刚好为2^3，所以ht[1]哈希表的大小设置为8.</p>\n<p><strong>哈希表的扩展与收缩都与负载因子有关，那么什么是负载因子呢？怎样计算负载因子？</strong></p>\n<p>Redis的负载因子为哈希表以保存结点的数量与哈希表的大小的比值，计算方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">load_factor &#x3D; ht[0].used &#x2F; ht[0].size</span><br></pre></td></tr></table></figure>\n\n<p>示例：对于一个大小为512，包含256个键值对的哈希表说，这个哈希表的负载因子为：</p>\n<p>load_factor = 256 / 512 = 0.5</p>\n<p><strong>什么情况下程序会自动对哈希表执行扩展操作？</strong></p>\n<ul>\n<li>①、服务器没有在执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子<u>大于等于1</u>.</li>\n<li>②、服务器正在执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子<u>大于等于5</u>.</li>\n</ul>\n<p><em>注：在执行BGSAVE或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入，最大限度地节约内存。</em></p>\n<p><strong>什么情况下程序会对哈希表执行收缩操作？</strong></p>\n<p>当哈希表的负载因子<u>小于0.1</u>时，程序自动开始对哈希表执行收缩操作。</p>\n<h4 id=\"3-5-渐进式rehash\"><a href=\"#3-5-渐进式rehash\" class=\"headerlink\" title=\"3.5 渐进式rehash\"></a>3.5 渐进式rehash</h4><p>扩展或收缩哈希表需要将<code>ht[0]</code>里面的键值对rehash到<code>ht[1]</code>里面，但是这个rehash动作并不是一次性、集中式完成的，而是分多次、<u>渐进式</u>地完成的。</p>\n<p><strong>为什么要渐进式完成rehash？</strong></p>\n<p>为了<u>避免大量键值对rehash对服务器性能造成影响</u>。采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</p>\n<p><strong>哈希表是怎样渐进式rehash的（rehash的详细步骤）？</strong></p>\n<ul>\n<li>①、为<code>ht[1]</code>分配空间，让字典同时持有ht[0]和ht[1]两个哈希表、</li>\n<li>②、在字典中维持一个<code>rehashidx</code>，并将它的值设置为0，表示rehash工作正式开始。</li>\n<li>③、在rehash进行期间，每次对字段执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增加一。</li>\n<li>④、随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]上，这是程序将rehashidx属性设为-1，表示rehash操作已完成。</li>\n</ul>\n<p><strong>渐进式rehash执行期间会涉及到ht[0]和ht[1]两个哈希表，是怎样操作的呢？</strong></p>\n<ul>\n<li>针对删除、查找、更新操作，会在两个哈希表上进行，例如，查找一个键时，程序会在ht[0]上查找，若没有找到，会继续到ht[1]里面进行查找。</li>\n<li>对于新增操作，新增加到字典的键值对一律被保存到ht[1]里面，而ht[0]则不再进行任何操作。</li>\n</ul>\n<h3 id=\"4-跳跃表\"><a href=\"#4-跳跃表\" class=\"headerlink\" title=\"4 跳跃表\"></a>4 跳跃表</h3><p>跳跃表是一种<code>有序数据结构</code>，它<u>通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</u>。</p>\n<p>Redis使用跳跃表作为<code>有序集合键</code>的底层实现之一，若一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，跳跃表还在集群节点中用作内部数据结构。</p>\n<h4 id=\"4-1-跳跃表结点的实现\"><a href=\"#4-1-跳跃表结点的实现\" class=\"headerlink\" title=\"4.1 跳跃表结点的实现\"></a>4.1 跳跃表结点的实现</h4><p>Redis跳跃表由<code>redis.h/zskiplistNode和redis.h/zskiplist</code>两个结构定义。</p>\n<p>跳跃表示例如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%A4%BA%E4%BE%8B.png\" alt=\"跳跃表示例\"></p>\n<p><code>zskiplistNode结构</code>用于表示跳跃表的结点。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员对象.示例图中o1，o2，o3是结点所保存的成员对象。</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\">    <span class=\"comment\">// 分值. 跳跃表中，结点按照各自所保存的分值从小到大排列。</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">    <span class=\"comment\">// 后退指针.指向当前的结点的前一个结点，后退指针在程序从表尾想表头遍历时使用。示例图上用BW标识结点的后退指针。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 层.每个层都有两个属性：前进指针和跨度。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// 前进指针.前进指针用于访问表尾方向的其他节点。示例图上的带有数字的剪头就表示前进指针。</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplostNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\">        <span class=\"comment\">// 跨度.跨度记录了前进指针所指向结点和当前结点的距离。示例图上箭头上的数字就表示跨度。</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-1-1-层\"><a href=\"#4-1-1-层\" class=\"headerlink\" title=\"4.1.1 层\"></a>4.1.1 层</h5><p>跳跃表节点的<code>level数组</code>可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。一般来说，层的数量越多，访问其他节点的速度就越快。</p>\n<p>每次创建一个新跳跃表节点的时候，程序都根据<u>幂次定律</u>(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。</p>\n<p>示例：下图为三个高度分别为1层、3层、5层的节点。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E5%BA%A6%E5%88%86%E5%88%AB%E4%B8%BA1%E5%B1%82,3%E5%B1%82,5%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9.png\" alt=\"高度分别为1层,3层,5层的节点\"></p>\n<h5 id=\"4-1-2-前进指针\"><a href=\"#4-1-2-前进指针\" class=\"headerlink\" title=\"4.1.2 前进指针\"></a>4.1.2 前进指针</h5><p>每个层都有一个指向表尾党项的<code>前进指针</code>（<code>level[i].forward</code>属性），用于从表头向表尾方向访问节点。</p>\n<p><strong>跳跃表是怎样遍历所有节点的呢？</strong></p>\n<p>示例图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86.png\" alt=\"跳跃表遍历\"></p>\n<ul>\n<li>①、迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中第二个节点。</li>\n<li>②、在第二个结点时，程序沿着第二层的前进指针移动到表中第三个节点。</li>\n<li>③、在第三个节点时，程序沿着第二层的前进指针移动到表中的第四个结点。</li>\n<li>④、当程序在此沿着第四个节点的前进指针移动时，它碰到了一个NULL，程序知道这时已经到达了跳跃表的表尾，结束遍历。</li>\n</ul>\n<p><em>注：遍历操作只使用前进指针就能完成。</em></p>\n<h5 id=\"4-1-3-跨度\"><a href=\"#4-1-3-跨度\" class=\"headerlink\" title=\"4.1.3 跨度\"></a>4.1.3 跨度</h5><p>层的跨度（<code>level[i].span</code>属性）用于记录两个结点之间的距离，两个结点之间跨度越大，他们相距得就越远；指向<code>null</code>的所有前进指针的跨度都为0，因为他们没有指向任何节点。</p>\n<p><u>跨度实际上是用来计算排位的</u>：在查找某个结点的过程中，将访问过的所有层的跨度累计起来，得到的结果就是目标结点在跳跃表中的排位。</p>\n<h5 id=\"4-1-4-后退指针\"><a href=\"#4-1-4-后退指针\" class=\"headerlink\" title=\"4.1.4 后退指针\"></a>4.1.4 后退指针</h5><p>节点的后退指针(<code>backward</code>属性)用于从<u>表尾向表头</u>方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>\n<h5 id=\"4-1-5-分值和成员\"><a href=\"#4-1-5-分值和成员\" class=\"headerlink\" title=\"4.1.5 分值和成员\"></a>4.1.5 分值和成员</h5><p>节点的分值(<code>score</code>属性)是一个<code>double类型的浮点数</code>，跳跃表中的所有结点都按分值<u>从小到大来排序</u>。</p>\n<p>节点的成员对象(obj属性)是一个指针，他指向一个字符串对象，而字符串对象则保存着一个SDS值。</p>\n<p>注：<strong>同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但多个结点保存的分值却可以是相同的</strong>。分值相同的结点将按照成员对象在字典序中的大小来进行排序，成员对象较小的结点会排在前面（靠近表头的方向）。</p>\n<h4 id=\"4-2-跳跃表的实现\"><a href=\"#4-2-跳跃表的实现\" class=\"headerlink\" title=\"4.2 跳跃表的实现\"></a>4.2 跳跃表的实现</h4><p>仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个<code>zskiplist结构</code>来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或快速地获取跳跃表节点的数量等信息。</p>\n<p><code>zskiplist结构</code>如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// header 指向跳跃表的表头节点。</span></span><br><span class=\"line\">    <span class=\"comment\">// tail 指向跳跃表的表位节点.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录跳跃表的长度，即跳跃表目前包含结点的数量（表头节点不计算在内）</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\">    <span class=\"comment\">// level 记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n\n<p><em>注：level表头节点的层高并不计算在内。</em></p>\n<h3 id=\"五、整数集合\"><a href=\"#五、整数集合\" class=\"headerlink\" title=\"五、整数集合\"></a>五、整数集合</h3><p>整数集合是<code>集合键</code>的底层实现之一，当一个<strong>集合只包含整数值元素，并且这个集合的元素数量不多时</strong>，Redis就会使用整数集合作为集合键得底层实现。</p>\n<p>（<u>注：整数集合是只包含整数值元素的集合。</u>）</p>\n<h4 id=\"5-1-整数集合的实现\"><a href=\"#5-1-整数集合的实现\" class=\"headerlink\" title=\"5.1 整数集合的实现\"></a>5.1 整数集合的实现</h4><p>整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为<code>int16_t</code>、<code>int32_t</code>或者<code>int64_t</code>的整数值，并保证集合中不会出现重复元素。</p>\n<p>每个<code>intset.h/intset结构</code>表示一个整数集合：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 编码方式.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint_32_t</span> encoding;</span><br><span class=\"line\">    <span class=\"comment\">// 集合包含的元素数量.即contents数组的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;</span><br><span class=\"line\">    <span class=\"comment\">// 保存元素的数组.</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>整数集合的底层实现是什么？</strong></p>\n<p>整数集合的底层是通过数组（<code>contents</code>属性）实现的，整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小<u>从小到大</u>有序地排列，并且数组中不包含任何重复项。</p>\n<p>注：</p>\n<p>①、数组元素在底层是有进行从小到大的排序的。</p>\n<p>②、虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存int8_t类型的值，contents数组的真正类型取决于encoding属性的值。</p>\n<p>encoding属性的取值包括以下内容：</p>\n<ul>\n<li><strong>INTSET_ENC_INT16</strong>:表示<code>int16_t</code>类型的数组，数组里面每个项都是一个int16_t类型的整数值（2^15 ~2^(15)-1）。</li>\n<li><strong>INTSET_ENC_INT32</strong>:表示<code>int32_t</code>类型的数组，数组里面每个项都是一个int32_t类型的整数值(2^31 ~2^(31)-1)。</li>\n<li><strong>INTSET_ENC_INT64</strong>:表示<code>int64_t</code>类型的数组，数组里面每个项都是一个int64_t类型的整数值(2^63 ~2^(63)-1)。</li>\n</ul>\n<h4 id=\"5-2-升级\"><a href=\"#5-2-升级\" class=\"headerlink\" title=\"5.2 升级\"></a>5.2 升级</h4><p>当添加新元素到整数集合中时，<u>新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先升级，然后才能将新元素添加到整数集合里面</u>。</p>\n<p><strong>Redis是怎样升级整数集合并添加新元素的呢（升级及添加新元素的步骤）？</strong></p>\n<p>升级整数集合并添加新元素共分为三步进行：</p>\n<ul>\n<li>①、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>\n<li>②、将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在防止元素的过程中，需要继续维持底层数组的有序性质不变。</li>\n<li>③、将新元素添加到底层数组里面。</li>\n</ul>\n<p><em>注：每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中又有的元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。</em></p>\n<p>升级时新元素的摆放位置，要引发升级，那么要么新元素大于所有现有元素，要么小于现有所有元素，因此摆放位置应该在数组的两端。</p>\n<p>为什么要进行升级，而不是直接采用int64_t类型？</p>\n<ul>\n<li>①、提高灵活性。</li>\n<li>②、节约内存。</li>\n</ul>\n<h4 id=\"5-3-降级\"><a href=\"#5-3-降级\" class=\"headerlink\" title=\"5.3 降级\"></a>5.3 降级</h4><p>整数集合<strong>不支持降级操作</strong>，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>\n<h3 id=\"六、压缩列表\"><a href=\"#六、压缩列表\" class=\"headerlink\" title=\"六、压缩列表\"></a>六、压缩列表</h3><p>压缩列表（ziplist）是<code>列表键</code>和<code>哈希键</code>的底层实现之一。</p>\n<p>压缩列表(ziplist)在Redis的应用场景有哪些？</p>\n<ul>\n<li>①、当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</li>\n</ul>\n<ul>\n<li>②、当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</li>\n</ul>\n<h4 id=\"6-1-压缩列表的构成\"><a href=\"#6-1-压缩列表的构成\" class=\"headerlink\" title=\"6.1 压缩列表的构成\"></a>6.1 压缩列表的构成</h4><p>压缩列表是Redis为了<u>节约内存</u>而开发的，是由一系列特殊编码的<u>连续内存块组成</u>的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。</p>\n<p>压缩列表的各个组成部分如下图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E8%A1%A8%E5%90%84%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png\" alt=\"压缩表各部分组成\"></p>\n<p>下表中记录了各个组成部分的类型、长度以及用途。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E8%A1%A8%E5%90%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E7%9A%84%E7%B1%BB%E5%9E%8B,%E9%95%BF%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%94%A8%E9%80%94.png\" alt=\"压缩表各组成部分的类型,长度以及用途\"></p>\n<p>示例：包含三个节点的压缩列表</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8C%85%E5%90%AB%E4%B8%89%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png\" alt=\"包含三个节点的压缩列表\"></p>\n<p>其中：</p>\n<ul>\n<li><code>zlbytes</code>的属性值为0x50,表示压缩列表的总长为80.</li>\n<li><code>zltail</code>属性的值为0x3c，表示有一个指向压缩列表起始地址的指针p，在指针p加上偏移量60，就可以计算出表尾节点entry3的地址。</li>\n<li><code>zllen</code>属性值为0x3，表示压缩列表包含三个节点。</li>\n<li><code>zlend</code>属性值为特殊值，用于标记压缩列表的末端。</li>\n</ul>\n<h4 id=\"6-2-压缩列表节点的构成\"><a href=\"#6-2-压缩列表节点的构成\" class=\"headerlink\" title=\"6.2 压缩列表节点的构成\"></a>6.2 压缩列表节点的构成</h4><p>每个压缩列表节点可以保存<u>一个字节数组</u>或者<u>一个整数值</u>。</p>\n<ul>\n<li><strong>字节数组</strong>可以是以下三中长度的其中一种：<ul>\n<li>长度小于等于63（2^6-1）字节的字节数组。</li>\n<li>长度小于等于16383（2^14-1）字节的字节数组。</li>\n<li>长度小于等于4294967295（2^32-1）字节的字节数组。</li>\n</ul>\n</li>\n<li><strong>整数值</strong>可以是以下六种长度的其中一种：<ul>\n<li>4位长，介于0~12之间的无符号整数；</li>\n<li>1字节长的有符号整数；</li>\n<li>3字节长的有符号整数；</li>\n<li>int16_t类型整数；</li>\n<li>int32_t类型整数；</li>\n<li>int64_t类型整数。</li>\n</ul>\n</li>\n</ul>\n<p><code>压缩列表结点的组成部分</code>如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E7%82%B9%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png\" alt=\"压缩列表结点的组成部分\"></p>\n<h5 id=\"6-2-1-previous-entry-length\"><a href=\"#6-2-1-previous-entry-length\" class=\"headerlink\" title=\"6.2.1 previous_entry_length\"></a>6.2.1 previous_entry_length</h5><p><code>previous_entry_length属性</code>以<code>字节</code>为单位，记录了压缩列表中前一个节点的长度，<code>previous_entry_length</code>属性的长度可以是1字节或者5字节。</p>\n<ul>\n<li>若前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。</li>\n<li>若前一节点的长度大于等于254字节，那么previoud_entry_length属性的长度为5字节，其中第一字节会被设置为0xFE，而后的四个字节则用于保存前一节点的长度。</li>\n</ul>\n<p>根据previous_entry_length属性可以计算得到前一个节点的起始地址。通过这一原理，即可实现从表尾向表头遍历。</p>\n<h5 id=\"6-2-2-encoding\"><a href=\"#6-2-2-encoding\" class=\"headerlink\" title=\"6.2.2 encoding\"></a>6.2.2 encoding</h5><p>节点的<code>encoding</code>属性记录了节点的content属性所保存数据的类型及长度：</p>\n<p><strong>字节数组编码</strong>：一字节、两字节或者五字节，encoding最高位为<strong>00、01、10表示字节数组编码</strong>，除去最高两位后表示数组的长度。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/encoding%E5%B1%9E%E6%80%A7%E6%95%B0%E7%BB%84%E7%BC%96%E7%A0%81.png\" alt=\"encoding属性数组编码\"></p>\n<p><strong>整数编码</strong>：一字节，<strong>encoding最高位为11</strong>，除去最高两位后的其他位记录整数值的类型和长度。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/encoding%E5%B1%9E%E6%80%A7%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81.png\" alt=\"encoding属性整数编码\"></p>\n<h5 id=\"6-2-3-content\"><a href=\"#6-2-3-content\" class=\"headerlink\" title=\"6.2.3 content\"></a>6.2.3 content</h5><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由encoding属性决定。</p>\n<p>示例1：以下示例展示了一个保存字节数组的节点示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BF%9D%E5%AD%98%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%9A%84%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png\" alt=\"保存字节数组的节点示例\"></p>\n<p>其中：</p>\n<ul>\n<li>encoding的最高两位为00，表示一个字节数组。</li>\n<li>encoding的后六位001011记录了字节数组的长度为11.</li>\n<li>content属性保存着节点的值“hello world”</li>\n</ul>\n<p>示例2：以下示例展示了一个保存整数值的节点示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BF%9D%E5%AD%98%E6%95%B4%E6%95%B0%E5%80%BC%E7%9A%84%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png\" alt=\"保存整数值的节点示例\"></p>\n<p>其中：</p>\n<ul>\n<li>encoding表示节点保存的是int16_t类型的整数值。</li>\n<li>content属性保存着节点的值10086.</li>\n</ul>\n<h4 id=\"6-3-连锁更新\"><a href=\"#6-3-连锁更新\" class=\"headerlink\" title=\"6.3 连锁更新\"></a>6.3 连锁更新</h4><p><strong>什么情况下会发生连锁更新？</strong></p>\n<p>比如当前所有结点长度均小于254字节情况下，新添加一个长度大于254字节的节点到压缩列表的表头，此时需对压缩列表执行空间重分配操作，扩展后面的previous_entry_length属性空间。</p>\n<p>定义：Redis将这种特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。</p>\n<p>连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li>redis设计与实现（第二版） 黄健宏</li>\n</ol>"},{"title":"Ubuntu16.04-搭建Hexo-Blog","date":"2020-08-20T09:19:56.000Z","_content":"\n#### 简介\n\n​\tGitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，通过构建过程运行文件，然后发布网站。 Hexo是高效的静态站点生成框架，它基于Node.js. 通过Hexo，可以直接使用Markdown语法来撰写博客。\n\n<!--more-->\n\n#### 配置Git\n\n​\t配置方式参考：[Ubuntu16.04 Github配置及使用](https://jovry-lee.github.io/2020/08/18/Ubuntu16-04-Github%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/#more)\n\n#### 安装node.js\n\n​\t安装方式参考：[Ubuntu16.04 Node.js安装.note](https://jovry-lee.github.io/2020/08/21/Ubuntu16-04-Nodejs%E5%AE%89%E8%A3%85/)\n\n#### 安装Hexo\n\n​\t安装命令：\n\n```bash\n$ npm install -g hexo-cli\n```\n\n​\t检查hexo是否安装成功：\n\n```bash\n$ hexo -v\n```\n\n​\t*得到hexo-cli：4.2.0等一串数据，安装成功。*\n\n#### Hexo创建本地博客\n\n- 初始化本地站点\n\n  本地博客路径在`~/ProjectWork/githubBlog`下,本地博客搭建操作在此路径下进行操作.\n\n  ```bash\n  $ cd ~/ProjectWork\n  $ mkdir githubBlog # 创建本地博客路径\n  $ hexo init # 初始化本地站点\n  ```\n\n*注：hexo init 命令要求该当前文件夹为空文件夹。*\n\n- 安装依赖包\n\n```bash\n$ npm install\n```\n\n- 生成网页\n\n```bash\n$ hexo g\n```\n\n*注：由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。*\n\n- 将网页放在本地服务器\n\n```bash\n$ hexo s\n```\n\n- 测试本地博客\n\n  在浏览器里输入http://localhost:4000/ \n\n- 发布一篇博客\n\n  在本地博客路径下执行以下命令, 此时source/\\_posts下会生成一个“日志名.md”的文件，该文件即是日志文件。\n\n```bash\n$ hexo new \"<日志名>\"\n```\n\n- 生成网页并放到本地服务器\n\n```bash\n$ hexo g \n$ hexo s\n```\n\n#### 将本地Hexo博客部署到Github上\n\n##### 创建代码仓库\n\n- 在Github中创建一个以.github.io结尾的Repository。\n\n- - ①、Repository name:  `Jovry-Lee.github.io`\n  - ②、勾选 Initialize this repository with a README\n  - ③、Create repository\n\n- 简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog.. 保存(Commit changes)。\n\n- 打开网页：`jovry-Lee.github.io` 这里就可以看到 README.md 里的内容了。\n\n\n##### 配置本地代码仓库\n\n- 获取Github对应的Repository的链接。（git@github.com:Jovry-Lee/Jovry-Lee.github.io.git）\n\n\n- 修改本地站点配置文件。\n\n\n```bash\n$ sudo vim _config.yml # 打开配置文件\n```\n\n- 找到#Deployment，填入以下内容：\n\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/Jovry-Lee/Jovry-Lee.github.io.git\n  branch: master\n```\n\n- 部署\n\n```bash\n$ npm install hexo-deployer-git --save # 安装hexo-deployer-git，该步骤只需要做一次\n$ hexo d\n```\n\n*得到 INFO Deploy done: git 即为部署成功*\n\n此时访问`Jovry-Lee.github.io`即可看到博客页面。\n\n#### 使用Next主题\n\n##### 配置NexT主题\n\n- 获取主题代码\n\n​\t克隆主题代码到本地博客`themes/next`路径下.\t\n\n```bash\n$ git clone https://github.com/next-theme/hexo-theme-next.git themes/next\n```\n\n- 修改博客配置文件\n  - 打开 `~/ProjectWork/githubBlog/_config.yml`\n\n  - 找到 theme:\n\n  - 把 Hexo 默认的 lanscape 修改成 next。 即 theme: next\n\n  - 找到 # Site，添加博客名称，作者名字等。\n\n  - 在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。\n\n  - 找到 # URL, 填入 url。比如 url:https://jovry-lee.github.io/\n\n    \n\n    当前本地配置如下:\n\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n\n...\n\n# Site\ntitle: Jovry's blog\nsubtitle: ''\ndescription: Keeping learning and improving!\nkeywords:\nauthor: Jovry Lee\nlanguage: en\ntimezone: 'Asia/Shanghai'\n\n...\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: https://jovry-Lee.github.io\n```\n\n- 清除旧配置\n\n​\t*注意：修改配置后最好都进行一下清理操作，不然可能不生效。*\n\n```bash\n$ hexo clean\n```\n\n- 重新生成部署\n\n\n```bash\n$ hexo g -d\n```\n\n##### NexT主题优化\n\n###### 修改NexT主题Scheme\n\n​\tNexT当前支持4种风格,默认为Muse,在NexT主题配置文件(`themes/next/_config.yml`)中可以修改Scheme,配置如下:\n\n```\n# Schemes\n#scheme: Muse\n#scheme: Mist\n#scheme: Pisces\nscheme: Gemini\n```\n\n###### 添加访问统计\n\n​\t通过配置NexT主题配置文件,修改busuanzi_count.配置如下:\n\n```\n# Show Views / Visitors of the website / page with busuanzi.\n# Get more information on http://ibruce.info/2015/04/04/busuanzi\nbusuanzi_count:\n  enable: true\n  total_visitors: true\n  total_visitors_icon: fa fa-user\n  total_views: true\n  total_views_icon: fa fa-eye\n  post_views: true\n  post_views_icon: far fa-eye\n```\n\n###### 添加头像\n\n​\t添加的头像可以保存到主站目录下,或者主题目录下.\n\n- Site路径: 保存到`~/ProjectWork/Jovry-Lee.github.io/public/uploads`路径下.\n- theme路径下:`~/ProjectWork/Jovry-Lee.github.io/themes/next/source/images`路径下\n\n配置NexT主题配置文件,修改avatar项:\n\n```\n# Sidebar Avatar\navatar:\n  # in theme directory(source/images): /images/avatar.gif\n  # in site  directory(source/uploads): /uploads/avatar.gif\n  # Replace the default image and set the url here.\n  url: /uploads/princess.jpeg\n  # 配置为true时,头像会在一个圈圈中.\n  rounded: true\n  # 配置为true时,鼠标放在头像上,头像有旋转效果.\n  rotated: true\n```\n\n###### 添加About/Tags/Categories等页面\n\n​\t默认情况下,About页面是不存在的,即使将主页展示了About的图标,若不进行页面配置,点击跳转会报404. 配置方式如下:\n\n- 进入博客Bash路径,生成about等页面.\n\n```bash\n$ cd ~/ProjectWork/Jovry-Lee.github.io\n$ hexo new page \"about\" # 生成about页面\n$ hexo new page \"tags\" # 生成tags页面\n$ hexo new page \"categories\" # 生成分类页面\n```\n\n- 配置NexT主题配置文件,修改`munu`项,启用图标, 修改如下:\n\n```\nmenu:\n  home: / || fa fa-home\n  about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  categories: /categories/ || fa fa-th\n  archives: /archives/ || fa fa-archive\n  #schedule: /schedule/ || fa fa-calendar\n  #sitemap: /sitemap.xml || fa fa-sitemap\n  #commonweal: /404/ || fa fa-heartbeat\n```\n\n- ​\t添加about个人介绍,直接在`~/ProjectWork/Jovry-Lee.github.io/source/about/index.md`文件上进行编辑即可.\n\n###### 分类和标签页自动生成categories&tags\n\n- 分类页面配置\n\n​\t在生成的分类页面`~/ProjectWork/Jovry-Lee.github.io/source/categories/index.md`上进行如下修改:\n\n```\n---\ntitle: categories\ndate: 2020-08-21 15:08:25\ntype: \"categories\"\n---\n```\n\n- 标签页面配置\n\n​\t在生成的分类页面`~/ProjectWork/Jovry-Lee.github.io/source/tags/index.md`上进行如下修改:\t\n\n```\n---\ntitle: tags\ndate: 2020-08-19 15:30:01\ntype: tags\n---\n```\n\n###### 去掉目录栏序号\n\n配置NexT主题配置文件,修改`toc`项,将`number`项设置为`false`, 修改如下:\n\n```\n# Table of Contents in the Sidebar\n# Front-matter variable (unsupport wrap expand_all).\ntoc:\n  enable: true\n  # Automatically add list number to toc.\n  number: false\n```\n\n###### 设置侧边栏社交链接\n\n​\t社交连接也是在NexT配置文件中进行修改, 关键字`social`,进行修改,去掉`#`,添加个人链接即可.\n\n##### 基于NexT主题开启评论功能——Gitalk\n\n​\t该评论功能使用Gitalk服务实现。\n\n###### 注册OAuth Application\n\n- 登录GitHub\n- 前往 `https://github.com/settings/profile`\n- 点击左侧下方的 `Developer settings`\n- 点击绿色 `Register a new application`\n- 填写以下内容：\n\n```\nApplication name：gitalk-comment\nHomepage URL：https://jovry-lee.github.io/\nApplication description：Blog comment system\nAuthorization callback URL：https://jovry-lee.github.io/\n```\n\n- 点击 Register application\n\n- 得到：\n\n```\nClient ID：xxx \n\nClient Secret： xxxx\n```\n\n###### 创建存放Gitalk-comments的repository\n\n- 创建 repository。 Repository name 为：`gitalk-comments`\n- 地址：`https://github.com/Jovry-Lee/gitalk-comments`\n- 注意稍后配置中填的是 `gitalk-comments`，<u>不是地址</u>。\n\n###### 添加Gitalk到博客\n\n- 打开本地博客路径下next主题的配置文件\n\n```bash\n$ vim ~/ProjectWork/Jovry-Lee.github.io/themes/next/_config.yml\n```\n\n- 找到gitalk，进行如下修改：\n\n```\n# Gitalk\n# For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk\ngitalk:\n  enable: true\n  github_id: Jovry-Lee # GitHub repo owner\n  repo: gitalk-comments # Repository name to store issues\n  client_id: xxx # GitHub Application Client ID\n  client_secret: xxxx # GitHub Application Client Secret\n  admin_user: Jovry-Lee # GitHub repo owner and collaborators, only these guys can initialize gitHub issues\n  distraction_free_mode: true # Facebook-like distraction free mode\n  # Gitalk's display language depends on user's browser or system environment\n  # If you want everyone visiting your site to see a uniform language, you can set a force language value\n  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW\n  language: en\n```\n\n- 重新部署\n\n```bash\n$ hexo clean \n\n$ hexo g -d\n```\n\n\n\n#### 多端使用Hexo博客\n\n​\t首先应该确保某一台电脑搭建好了Hexo博客，然后进行后续操作。\n\n##### 主端配置\n\n- ①、登录Github，在`username.github.io`仓库上新建hexo分支。\n\n  在博客仓库上新建一个分支，例如“hexo”，切换到该分支，并设置该分支为默认分支（Setting->Branches->Default branch）\n\n- ②、克隆博客仓库到本地\n\n\n*注：不是本地Hexo目录。*\n\n```shell\n$ git clone git@github.com:Jovry-Lee/Jovry-Lee.github.io.git\n```\n\n查看当前分支，确保为新建的hexo分支\n\n```shell\n$ cd Jovry-Lee.github.io/ $ git branch * hexo\n```\n\n`后续操作均是在Jovry-Lee.github.io目录(Jovry-Lee.github.io与githubBlog目录同级)下完成。`\n\n- ③、拷贝本地博客的部署文件（Hexo目录下的全部文件到`username.github.io`文件目录中），然后删除`themes`目录中主题下的`.git`目录（如果存在的话），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后提交。\n\n\n```bash\n# 拷贝Hexo目录内容\n$ sudo cp -r ~/ProjectWork/githubBlog/* ./\n# 删除themes目录下主题的.git目录，我本地用的next主题\n$ sudo rm -r themes/next/.git\n# 提交修改\n$ git add .\n$ git commit -m \"back up hexo files\"\n$ git push\n```\n\n- ④、后续写博客，即在`username.github.io`文件目录中进行了，由于仓库有个`gitignore`文件，里面忽略掉了`node_modules`文件夹，也就是说仓库的`hexo分支`并没有存储该目录，所以需要重新install一下。\n\n\n```bash\n$ npm install\n```\n\n##### 其他电脑端配置\n\n​\t安装Hexo环境，然后克隆`username.github.io`仓库的hexo分支到本地，此时本地git仓库处于hexo分支；切换到username.github.io目录，安装依赖包。\n\n```bash\n $ git clone git@github.com:Jovry-Lee/Jovry-Lee.github.io.git\n $ cd Jovry-Lee.github.io\n $ npm install\n```\n\n这里，如果npm install出错，如”npm ERR! Unexpected end of JSON input while parsing near”,可尝试：\n\n- 删除package-lock.json文件\n- 清除cache: npm cache clean --force\n- 不要用淘宝镜像：npm set registry https://registry.npmjs.org/\n\n##### 发布更新博客\n\n​\t更新博客内容后提交到github,执行以下操作进行提交及其部署.\n\n```bash\n$ git add .\n$ git commint -m \"注释\"\n$ git push\n$ hexo d -g\n```\n\n*注：每次操作时，最好先git pull 一下。*\n\n\n\n#### 设置图床\n\n​\t为了解决图片的存储问题，使用第三方静态资源库，即图床，获取图片Url，目前可供选择的图床很多，小众一些的容易挂，大厂存储服务又需要花钱，因此，这里使用Github + jsDelivr + PicGo + Imagine打造自己的图床。\n\n##### 配置Github\n\n- 创建仓库\n\n- - 输入项目名称\n  - 选择权限为公开\n  - 初始化一个READMEmd文件\n  - 创建项目\n\n- 生成一个Token\n\n  - 点击用户头像->选择”Settings“->点击”Developer settings“->点击”Personal access tokens“->点击”Generate new token“\n  - 在“Node”栏键入token的备注\n  - 在“Select scopes”中勾选“repo”\n  - 点击“Generate token”按钮\n\n- 获取Token秘钥：<u>该秘钥只会显示一次，注意自己保存一下，方便后续使用</u>。\n\n##### 配置PicGo，并使用jsdelivr作为CDN加速\n\n- 下载PicGo\n\n- - [下载地址](https://github.com/Molunerfinn/PicGo)\n  - Linux系统下载`AppImage`文件，更改其权限为可执行，双击即可显示应用图标。\n\n- 右键点击图标选择“打开详细窗口”->点击“图床设置”->选择“GitHub图床”，进行GitHub设置\n\n  - 设定仓库名：Jovry-Lee/cdn\n\n  - 设定分支名：master\n\n  - 设定Token：<Github配置时生成的那个秘钥>\n\n  - 指定存储路径：img/   *(注: 指定存储路径，将会在仓库下创建设置名称的文件夹（eg：img），上传的图片将保存在里面。)*\n\n  - 设定自定义域名： eg：`https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn`  *(注: 自定义域名的作用是，在图片上传后，PicGo会按照自定义域名+上传图片名的方式生成访问链接，放到粘贴板上。因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名。)*\n\n\n##### 图片压缩工具\n\n​\t通常情况下，图片大小都是超过200KB的，网页加载会比较慢，所以需要对图片进行压缩。\n\n- 在线网站压缩\n\n  [网站地址](https://tinypng.com/)\n\n- Imagine工具压缩\n\n  [下载地址](https://github.com/meowtec/Imagine)\n\n##### 图片上传/获取\n\n- 上传: 上传区进行图片上传，PicGo工具支持多个图床,需要选择上传的图床,选择`GitHub图床`。\n\n\n- 获取: PicGo应用点击`相册`，选择图床，即可显示该图床下的所有图片。\n\n\n\n\n生成的图片的链接示例：`https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E7%9F%A9%E5%BD%A2@3x.png`\n\n\n\n#### Markdown编辑器安装\n\n​\tGitHub page支持Markdown语法,推荐使用Markdown进行编辑.\n\n##### Typora\n\n[Typora官网](https://typora.io/)\n\n安装方法：\n\n- 命令行安装\n\n```bash\n# or run:\n# sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE\n$ wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\n\n# add Typora's repository\n$ sudo add-apt-repository 'deb https://typora.io/linux ./'\n$ sudo apt-get update\n\n# install typora\n$ sudo apt-get install typora\n```\n\n- 源文件安装\n  - 官网下载二进制文件\n  - 解压到指定目录\n  - 配置环境变量\n\n```bash\n$ wget https://typora.io/linux/Typora-linux-x64.tar.gz\n$ sudo tar zxvf Typora-linux-x64.tar.gz -d /usr/local\n$ sudo vim ~/.bashrc\n```\n\n填入以下信息:\n\n```\n#set typora\nexport TYPORA_HOME=/usr/local/Typora-linux-x64\nexport PAHT=$TYPORA_HOME:$PATH\n```\n\n```bash\n$ source ~/.bashrc\n```\n\n\n\n---\n\n#### 参考资料\n\n[用 Hexo 和 GitHub Pages 搭建博客](https://ryanluoxu.github.io/2017/11/24/用-Hexo-和-GitHub-Pages-搭建博客/)\n\n[Ubuntu 16.04下Github配置](https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/) \n\n[Next使用文档](http://theme-next.iissnan.com/getting-started.html)\n\n[Getting Started](https://theme-next.js.org/docs/getting-started/)\n\n[Hexo中如何给一篇文章加多个tags？](https://www.zhihu.com/question/43517242)\n\n[创建分类页面](https://github.com/iissnan/hexo-theme-next/wiki/创建分类页面)\n\n[hexo之next主题添加分类](https://blog.csdn.net/u011240016/article/details/79422462)\n\n[使用多台电脑写Hexo博客](https://cccshuang.github.io/2018/09/28/使用多台电脑写Hexo博客/)\n\n[在WSL下快速搭建hexo](https://www.vivatakethat.com/2016/07/07/在Windows下快速搭建hexo/)\n\n[Hexo官网](https://hexo.io/zh-cn/)\n\n[Hexo Blog折腾笔记](https://ghamster0.github.io/2019/03/12/Hexo Blog折腾笔记/)\n\n[GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床 ](https://www.cnblogs.com/sitoi/p/11848816.html)\n\n[Hexo 的 Next 主题优化](https://ryanluoxu.github.io/2017/11/26/Hexo-的-Next-主题优化)\n\n[Hexo+Next主题优化](https://zhuanlan.zhihu.com/p/30836436)","source":"_posts/Ubuntu16-04-搭建Hexo-Blog.md","raw":"---\ntitle: Ubuntu16.04-搭建Hexo-Blog\ndate: 2020-08-20 17:19:56\ntags: [\"Ubuntu\",\"Config\",\"Hexo\"]\ncategories: [\"Ubuntu\", \"Config\"]\n---\n\n#### 简介\n\n​\tGitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，通过构建过程运行文件，然后发布网站。 Hexo是高效的静态站点生成框架，它基于Node.js. 通过Hexo，可以直接使用Markdown语法来撰写博客。\n\n<!--more-->\n\n#### 配置Git\n\n​\t配置方式参考：[Ubuntu16.04 Github配置及使用](https://jovry-lee.github.io/2020/08/18/Ubuntu16-04-Github%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/#more)\n\n#### 安装node.js\n\n​\t安装方式参考：[Ubuntu16.04 Node.js安装.note](https://jovry-lee.github.io/2020/08/21/Ubuntu16-04-Nodejs%E5%AE%89%E8%A3%85/)\n\n#### 安装Hexo\n\n​\t安装命令：\n\n```bash\n$ npm install -g hexo-cli\n```\n\n​\t检查hexo是否安装成功：\n\n```bash\n$ hexo -v\n```\n\n​\t*得到hexo-cli：4.2.0等一串数据，安装成功。*\n\n#### Hexo创建本地博客\n\n- 初始化本地站点\n\n  本地博客路径在`~/ProjectWork/githubBlog`下,本地博客搭建操作在此路径下进行操作.\n\n  ```bash\n  $ cd ~/ProjectWork\n  $ mkdir githubBlog # 创建本地博客路径\n  $ hexo init # 初始化本地站点\n  ```\n\n*注：hexo init 命令要求该当前文件夹为空文件夹。*\n\n- 安装依赖包\n\n```bash\n$ npm install\n```\n\n- 生成网页\n\n```bash\n$ hexo g\n```\n\n*注：由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。*\n\n- 将网页放在本地服务器\n\n```bash\n$ hexo s\n```\n\n- 测试本地博客\n\n  在浏览器里输入http://localhost:4000/ \n\n- 发布一篇博客\n\n  在本地博客路径下执行以下命令, 此时source/\\_posts下会生成一个“日志名.md”的文件，该文件即是日志文件。\n\n```bash\n$ hexo new \"<日志名>\"\n```\n\n- 生成网页并放到本地服务器\n\n```bash\n$ hexo g \n$ hexo s\n```\n\n#### 将本地Hexo博客部署到Github上\n\n##### 创建代码仓库\n\n- 在Github中创建一个以.github.io结尾的Repository。\n\n- - ①、Repository name:  `Jovry-Lee.github.io`\n  - ②、勾选 Initialize this repository with a README\n  - ③、Create repository\n\n- 简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog.. 保存(Commit changes)。\n\n- 打开网页：`jovry-Lee.github.io` 这里就可以看到 README.md 里的内容了。\n\n\n##### 配置本地代码仓库\n\n- 获取Github对应的Repository的链接。（git@github.com:Jovry-Lee/Jovry-Lee.github.io.git）\n\n\n- 修改本地站点配置文件。\n\n\n```bash\n$ sudo vim _config.yml # 打开配置文件\n```\n\n- 找到#Deployment，填入以下内容：\n\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/Jovry-Lee/Jovry-Lee.github.io.git\n  branch: master\n```\n\n- 部署\n\n```bash\n$ npm install hexo-deployer-git --save # 安装hexo-deployer-git，该步骤只需要做一次\n$ hexo d\n```\n\n*得到 INFO Deploy done: git 即为部署成功*\n\n此时访问`Jovry-Lee.github.io`即可看到博客页面。\n\n#### 使用Next主题\n\n##### 配置NexT主题\n\n- 获取主题代码\n\n​\t克隆主题代码到本地博客`themes/next`路径下.\t\n\n```bash\n$ git clone https://github.com/next-theme/hexo-theme-next.git themes/next\n```\n\n- 修改博客配置文件\n  - 打开 `~/ProjectWork/githubBlog/_config.yml`\n\n  - 找到 theme:\n\n  - 把 Hexo 默认的 lanscape 修改成 next。 即 theme: next\n\n  - 找到 # Site，添加博客名称，作者名字等。\n\n  - 在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。\n\n  - 找到 # URL, 填入 url。比如 url:https://jovry-lee.github.io/\n\n    \n\n    当前本地配置如下:\n\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n\n...\n\n# Site\ntitle: Jovry's blog\nsubtitle: ''\ndescription: Keeping learning and improving!\nkeywords:\nauthor: Jovry Lee\nlanguage: en\ntimezone: 'Asia/Shanghai'\n\n...\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: https://jovry-Lee.github.io\n```\n\n- 清除旧配置\n\n​\t*注意：修改配置后最好都进行一下清理操作，不然可能不生效。*\n\n```bash\n$ hexo clean\n```\n\n- 重新生成部署\n\n\n```bash\n$ hexo g -d\n```\n\n##### NexT主题优化\n\n###### 修改NexT主题Scheme\n\n​\tNexT当前支持4种风格,默认为Muse,在NexT主题配置文件(`themes/next/_config.yml`)中可以修改Scheme,配置如下:\n\n```\n# Schemes\n#scheme: Muse\n#scheme: Mist\n#scheme: Pisces\nscheme: Gemini\n```\n\n###### 添加访问统计\n\n​\t通过配置NexT主题配置文件,修改busuanzi_count.配置如下:\n\n```\n# Show Views / Visitors of the website / page with busuanzi.\n# Get more information on http://ibruce.info/2015/04/04/busuanzi\nbusuanzi_count:\n  enable: true\n  total_visitors: true\n  total_visitors_icon: fa fa-user\n  total_views: true\n  total_views_icon: fa fa-eye\n  post_views: true\n  post_views_icon: far fa-eye\n```\n\n###### 添加头像\n\n​\t添加的头像可以保存到主站目录下,或者主题目录下.\n\n- Site路径: 保存到`~/ProjectWork/Jovry-Lee.github.io/public/uploads`路径下.\n- theme路径下:`~/ProjectWork/Jovry-Lee.github.io/themes/next/source/images`路径下\n\n配置NexT主题配置文件,修改avatar项:\n\n```\n# Sidebar Avatar\navatar:\n  # in theme directory(source/images): /images/avatar.gif\n  # in site  directory(source/uploads): /uploads/avatar.gif\n  # Replace the default image and set the url here.\n  url: /uploads/princess.jpeg\n  # 配置为true时,头像会在一个圈圈中.\n  rounded: true\n  # 配置为true时,鼠标放在头像上,头像有旋转效果.\n  rotated: true\n```\n\n###### 添加About/Tags/Categories等页面\n\n​\t默认情况下,About页面是不存在的,即使将主页展示了About的图标,若不进行页面配置,点击跳转会报404. 配置方式如下:\n\n- 进入博客Bash路径,生成about等页面.\n\n```bash\n$ cd ~/ProjectWork/Jovry-Lee.github.io\n$ hexo new page \"about\" # 生成about页面\n$ hexo new page \"tags\" # 生成tags页面\n$ hexo new page \"categories\" # 生成分类页面\n```\n\n- 配置NexT主题配置文件,修改`munu`项,启用图标, 修改如下:\n\n```\nmenu:\n  home: / || fa fa-home\n  about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  categories: /categories/ || fa fa-th\n  archives: /archives/ || fa fa-archive\n  #schedule: /schedule/ || fa fa-calendar\n  #sitemap: /sitemap.xml || fa fa-sitemap\n  #commonweal: /404/ || fa fa-heartbeat\n```\n\n- ​\t添加about个人介绍,直接在`~/ProjectWork/Jovry-Lee.github.io/source/about/index.md`文件上进行编辑即可.\n\n###### 分类和标签页自动生成categories&tags\n\n- 分类页面配置\n\n​\t在生成的分类页面`~/ProjectWork/Jovry-Lee.github.io/source/categories/index.md`上进行如下修改:\n\n```\n---\ntitle: categories\ndate: 2020-08-21 15:08:25\ntype: \"categories\"\n---\n```\n\n- 标签页面配置\n\n​\t在生成的分类页面`~/ProjectWork/Jovry-Lee.github.io/source/tags/index.md`上进行如下修改:\t\n\n```\n---\ntitle: tags\ndate: 2020-08-19 15:30:01\ntype: tags\n---\n```\n\n###### 去掉目录栏序号\n\n配置NexT主题配置文件,修改`toc`项,将`number`项设置为`false`, 修改如下:\n\n```\n# Table of Contents in the Sidebar\n# Front-matter variable (unsupport wrap expand_all).\ntoc:\n  enable: true\n  # Automatically add list number to toc.\n  number: false\n```\n\n###### 设置侧边栏社交链接\n\n​\t社交连接也是在NexT配置文件中进行修改, 关键字`social`,进行修改,去掉`#`,添加个人链接即可.\n\n##### 基于NexT主题开启评论功能——Gitalk\n\n​\t该评论功能使用Gitalk服务实现。\n\n###### 注册OAuth Application\n\n- 登录GitHub\n- 前往 `https://github.com/settings/profile`\n- 点击左侧下方的 `Developer settings`\n- 点击绿色 `Register a new application`\n- 填写以下内容：\n\n```\nApplication name：gitalk-comment\nHomepage URL：https://jovry-lee.github.io/\nApplication description：Blog comment system\nAuthorization callback URL：https://jovry-lee.github.io/\n```\n\n- 点击 Register application\n\n- 得到：\n\n```\nClient ID：xxx \n\nClient Secret： xxxx\n```\n\n###### 创建存放Gitalk-comments的repository\n\n- 创建 repository。 Repository name 为：`gitalk-comments`\n- 地址：`https://github.com/Jovry-Lee/gitalk-comments`\n- 注意稍后配置中填的是 `gitalk-comments`，<u>不是地址</u>。\n\n###### 添加Gitalk到博客\n\n- 打开本地博客路径下next主题的配置文件\n\n```bash\n$ vim ~/ProjectWork/Jovry-Lee.github.io/themes/next/_config.yml\n```\n\n- 找到gitalk，进行如下修改：\n\n```\n# Gitalk\n# For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk\ngitalk:\n  enable: true\n  github_id: Jovry-Lee # GitHub repo owner\n  repo: gitalk-comments # Repository name to store issues\n  client_id: xxx # GitHub Application Client ID\n  client_secret: xxxx # GitHub Application Client Secret\n  admin_user: Jovry-Lee # GitHub repo owner and collaborators, only these guys can initialize gitHub issues\n  distraction_free_mode: true # Facebook-like distraction free mode\n  # Gitalk's display language depends on user's browser or system environment\n  # If you want everyone visiting your site to see a uniform language, you can set a force language value\n  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW\n  language: en\n```\n\n- 重新部署\n\n```bash\n$ hexo clean \n\n$ hexo g -d\n```\n\n\n\n#### 多端使用Hexo博客\n\n​\t首先应该确保某一台电脑搭建好了Hexo博客，然后进行后续操作。\n\n##### 主端配置\n\n- ①、登录Github，在`username.github.io`仓库上新建hexo分支。\n\n  在博客仓库上新建一个分支，例如“hexo”，切换到该分支，并设置该分支为默认分支（Setting->Branches->Default branch）\n\n- ②、克隆博客仓库到本地\n\n\n*注：不是本地Hexo目录。*\n\n```shell\n$ git clone git@github.com:Jovry-Lee/Jovry-Lee.github.io.git\n```\n\n查看当前分支，确保为新建的hexo分支\n\n```shell\n$ cd Jovry-Lee.github.io/ $ git branch * hexo\n```\n\n`后续操作均是在Jovry-Lee.github.io目录(Jovry-Lee.github.io与githubBlog目录同级)下完成。`\n\n- ③、拷贝本地博客的部署文件（Hexo目录下的全部文件到`username.github.io`文件目录中），然后删除`themes`目录中主题下的`.git`目录（如果存在的话），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后提交。\n\n\n```bash\n# 拷贝Hexo目录内容\n$ sudo cp -r ~/ProjectWork/githubBlog/* ./\n# 删除themes目录下主题的.git目录，我本地用的next主题\n$ sudo rm -r themes/next/.git\n# 提交修改\n$ git add .\n$ git commit -m \"back up hexo files\"\n$ git push\n```\n\n- ④、后续写博客，即在`username.github.io`文件目录中进行了，由于仓库有个`gitignore`文件，里面忽略掉了`node_modules`文件夹，也就是说仓库的`hexo分支`并没有存储该目录，所以需要重新install一下。\n\n\n```bash\n$ npm install\n```\n\n##### 其他电脑端配置\n\n​\t安装Hexo环境，然后克隆`username.github.io`仓库的hexo分支到本地，此时本地git仓库处于hexo分支；切换到username.github.io目录，安装依赖包。\n\n```bash\n $ git clone git@github.com:Jovry-Lee/Jovry-Lee.github.io.git\n $ cd Jovry-Lee.github.io\n $ npm install\n```\n\n这里，如果npm install出错，如”npm ERR! Unexpected end of JSON input while parsing near”,可尝试：\n\n- 删除package-lock.json文件\n- 清除cache: npm cache clean --force\n- 不要用淘宝镜像：npm set registry https://registry.npmjs.org/\n\n##### 发布更新博客\n\n​\t更新博客内容后提交到github,执行以下操作进行提交及其部署.\n\n```bash\n$ git add .\n$ git commint -m \"注释\"\n$ git push\n$ hexo d -g\n```\n\n*注：每次操作时，最好先git pull 一下。*\n\n\n\n#### 设置图床\n\n​\t为了解决图片的存储问题，使用第三方静态资源库，即图床，获取图片Url，目前可供选择的图床很多，小众一些的容易挂，大厂存储服务又需要花钱，因此，这里使用Github + jsDelivr + PicGo + Imagine打造自己的图床。\n\n##### 配置Github\n\n- 创建仓库\n\n- - 输入项目名称\n  - 选择权限为公开\n  - 初始化一个READMEmd文件\n  - 创建项目\n\n- 生成一个Token\n\n  - 点击用户头像->选择”Settings“->点击”Developer settings“->点击”Personal access tokens“->点击”Generate new token“\n  - 在“Node”栏键入token的备注\n  - 在“Select scopes”中勾选“repo”\n  - 点击“Generate token”按钮\n\n- 获取Token秘钥：<u>该秘钥只会显示一次，注意自己保存一下，方便后续使用</u>。\n\n##### 配置PicGo，并使用jsdelivr作为CDN加速\n\n- 下载PicGo\n\n- - [下载地址](https://github.com/Molunerfinn/PicGo)\n  - Linux系统下载`AppImage`文件，更改其权限为可执行，双击即可显示应用图标。\n\n- 右键点击图标选择“打开详细窗口”->点击“图床设置”->选择“GitHub图床”，进行GitHub设置\n\n  - 设定仓库名：Jovry-Lee/cdn\n\n  - 设定分支名：master\n\n  - 设定Token：<Github配置时生成的那个秘钥>\n\n  - 指定存储路径：img/   *(注: 指定存储路径，将会在仓库下创建设置名称的文件夹（eg：img），上传的图片将保存在里面。)*\n\n  - 设定自定义域名： eg：`https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn`  *(注: 自定义域名的作用是，在图片上传后，PicGo会按照自定义域名+上传图片名的方式生成访问链接，放到粘贴板上。因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名。)*\n\n\n##### 图片压缩工具\n\n​\t通常情况下，图片大小都是超过200KB的，网页加载会比较慢，所以需要对图片进行压缩。\n\n- 在线网站压缩\n\n  [网站地址](https://tinypng.com/)\n\n- Imagine工具压缩\n\n  [下载地址](https://github.com/meowtec/Imagine)\n\n##### 图片上传/获取\n\n- 上传: 上传区进行图片上传，PicGo工具支持多个图床,需要选择上传的图床,选择`GitHub图床`。\n\n\n- 获取: PicGo应用点击`相册`，选择图床，即可显示该图床下的所有图片。\n\n\n\n\n生成的图片的链接示例：`https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E7%9F%A9%E5%BD%A2@3x.png`\n\n\n\n#### Markdown编辑器安装\n\n​\tGitHub page支持Markdown语法,推荐使用Markdown进行编辑.\n\n##### Typora\n\n[Typora官网](https://typora.io/)\n\n安装方法：\n\n- 命令行安装\n\n```bash\n# or run:\n# sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE\n$ wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\n\n# add Typora's repository\n$ sudo add-apt-repository 'deb https://typora.io/linux ./'\n$ sudo apt-get update\n\n# install typora\n$ sudo apt-get install typora\n```\n\n- 源文件安装\n  - 官网下载二进制文件\n  - 解压到指定目录\n  - 配置环境变量\n\n```bash\n$ wget https://typora.io/linux/Typora-linux-x64.tar.gz\n$ sudo tar zxvf Typora-linux-x64.tar.gz -d /usr/local\n$ sudo vim ~/.bashrc\n```\n\n填入以下信息:\n\n```\n#set typora\nexport TYPORA_HOME=/usr/local/Typora-linux-x64\nexport PAHT=$TYPORA_HOME:$PATH\n```\n\n```bash\n$ source ~/.bashrc\n```\n\n\n\n---\n\n#### 参考资料\n\n[用 Hexo 和 GitHub Pages 搭建博客](https://ryanluoxu.github.io/2017/11/24/用-Hexo-和-GitHub-Pages-搭建博客/)\n\n[Ubuntu 16.04下Github配置](https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/) \n\n[Next使用文档](http://theme-next.iissnan.com/getting-started.html)\n\n[Getting Started](https://theme-next.js.org/docs/getting-started/)\n\n[Hexo中如何给一篇文章加多个tags？](https://www.zhihu.com/question/43517242)\n\n[创建分类页面](https://github.com/iissnan/hexo-theme-next/wiki/创建分类页面)\n\n[hexo之next主题添加分类](https://blog.csdn.net/u011240016/article/details/79422462)\n\n[使用多台电脑写Hexo博客](https://cccshuang.github.io/2018/09/28/使用多台电脑写Hexo博客/)\n\n[在WSL下快速搭建hexo](https://www.vivatakethat.com/2016/07/07/在Windows下快速搭建hexo/)\n\n[Hexo官网](https://hexo.io/zh-cn/)\n\n[Hexo Blog折腾笔记](https://ghamster0.github.io/2019/03/12/Hexo Blog折腾笔记/)\n\n[GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床 ](https://www.cnblogs.com/sitoi/p/11848816.html)\n\n[Hexo 的 Next 主题优化](https://ryanluoxu.github.io/2017/11/26/Hexo-的-Next-主题优化)\n\n[Hexo+Next主题优化](https://zhuanlan.zhihu.com/p/30836436)","slug":"Ubuntu16-04-搭建Hexo-Blog","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeia7ftk001q0sg31f7a5lid","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>​    GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，通过构建过程运行文件，然后发布网站。 Hexo是高效的静态站点生成框架，它基于Node.js. 通过Hexo，可以直接使用Markdown语法来撰写博客。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"配置Git\"><a href=\"#配置Git\" class=\"headerlink\" title=\"配置Git\"></a>配置Git</h4><p>​    配置方式参考：<a href=\"https://jovry-lee.github.io/2020/08/18/Ubuntu16-04-Github%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/#more\">Ubuntu16.04 Github配置及使用</a></p>\n<h4 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h4><p>​    安装方式参考：<a href=\"https://jovry-lee.github.io/2020/08/21/Ubuntu16-04-Nodejs%E5%AE%89%E8%A3%85/\">Ubuntu16.04 Node.js安装.note</a></p>\n<h4 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h4><p>​    安装命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>​    检查hexo是否安装成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n\n<p>​    <em>得到hexo-cli：4.2.0等一串数据，安装成功。</em></p>\n<h4 id=\"Hexo创建本地博客\"><a href=\"#Hexo创建本地博客\" class=\"headerlink\" title=\"Hexo创建本地博客\"></a>Hexo创建本地博客</h4><ul>\n<li><p>初始化本地站点</p>\n<p>本地博客路径在<code>~/ProjectWork/githubBlog</code>下,本地博客搭建操作在此路径下进行操作.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/ProjectWork</span><br><span class=\"line\">$ mkdir githubBlog <span class=\"comment\"># 创建本地博客路径</span></span><br><span class=\"line\">$ hexo init <span class=\"comment\"># 初始化本地站点</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><em>注：hexo init 命令要求该当前文件夹为空文件夹。</em></p>\n<ul>\n<li>安装依赖包</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成网页</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<p><em>注：由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</em></p>\n<ul>\n<li>将网页放在本地服务器</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>测试本地博客</p>\n<p>在浏览器里输入<a href=\"http://localhost:4000/\">http://localhost:4000/</a> </p>\n</li>\n<li><p>发布一篇博客</p>\n<p>在本地博客路径下执行以下命令, 此时source/_posts下会生成一个“日志名.md”的文件，该文件即是日志文件。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;&lt;日志名&gt;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成网页并放到本地服务器</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g </span><br><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将本地Hexo博客部署到Github上\"><a href=\"#将本地Hexo博客部署到Github上\" class=\"headerlink\" title=\"将本地Hexo博客部署到Github上\"></a>将本地Hexo博客部署到Github上</h4><h5 id=\"创建代码仓库\"><a href=\"#创建代码仓库\" class=\"headerlink\" title=\"创建代码仓库\"></a>创建代码仓库</h5><ul>\n<li><p>在Github中创建一个以.github.io结尾的Repository。</p>\n</li>\n<li><ul>\n<li>①、Repository name:  <code>Jovry-Lee.github.io</code></li>\n<li>②、勾选 Initialize this repository with a README</li>\n<li>③、Create repository</li>\n</ul>\n</li>\n<li><p>简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog.. 保存(Commit changes)。</p>\n</li>\n<li><p>打开网页：<code>jovry-Lee.github.io</code> 这里就可以看到 README.md 里的内容了。</p>\n</li>\n</ul>\n<h5 id=\"配置本地代码仓库\"><a href=\"#配置本地代码仓库\" class=\"headerlink\" title=\"配置本地代码仓库\"></a>配置本地代码仓库</h5><ul>\n<li>获取Github对应的Repository的链接。（<a href=\"mailto:&#103;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;\">&#103;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>:Jovry-Lee/Jovry-Lee.github.io.git）</li>\n</ul>\n<ul>\n<li>修改本地站点配置文件。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vim _config.yml <span class=\"comment\"># 打开配置文件</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到#Deployment，填入以下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: https:&#x2F;&#x2F;github.com&#x2F;Jovry-Lee&#x2F;Jovry-Lee.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save <span class=\"comment\"># 安装hexo-deployer-git，该步骤只需要做一次</span></span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<p><em>得到 INFO Deploy done: git 即为部署成功</em></p>\n<p>此时访问<code>Jovry-Lee.github.io</code>即可看到博客页面。</p>\n<h4 id=\"使用Next主题\"><a href=\"#使用Next主题\" class=\"headerlink\" title=\"使用Next主题\"></a>使用Next主题</h4><h5 id=\"配置NexT主题\"><a href=\"#配置NexT主题\" class=\"headerlink\" title=\"配置NexT主题\"></a>配置NexT主题</h5><ul>\n<li>获取主题代码</li>\n</ul>\n<p>​    克隆主题代码到本地博客<code>themes/next</code>路径下.    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/next-theme/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>修改博客配置文件</p>\n<ul>\n<li><p>打开 <code>~/ProjectWork/githubBlog/_config.yml</code></p>\n</li>\n<li><p>找到 theme:</p>\n</li>\n<li><p>把 Hexo 默认的 lanscape 修改成 next。 即 theme: next</p>\n</li>\n<li><p>找到 # Site，添加博客名称，作者名字等。</p>\n</li>\n<li><p>在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。</p>\n</li>\n<li><p>找到 # URL, 填入 url。比如 url:<a href=\"https://jovry-lee.github.io/\">https://jovry-lee.github.io/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>当前本地配置如下:</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class=\"line\">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class=\"line\">theme: next</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># Site</span><br><span class=\"line\">title: Jovry&#39;s blog</span><br><span class=\"line\">subtitle: &#39;&#39;</span><br><span class=\"line\">description: Keeping learning and improving!</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: Jovry Lee</span><br><span class=\"line\">language: en</span><br><span class=\"line\">timezone: &#39;Asia&#x2F;Shanghai&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># URL</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class=\"line\">url: https:&#x2F;&#x2F;jovry-Lee.github.io</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>清除旧配置</li>\n</ul>\n<p>​    <em>注意：修改配置后最好都进行一下清理操作，不然可能不生效。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重新生成部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"NexT主题优化\"><a href=\"#NexT主题优化\" class=\"headerlink\" title=\"NexT主题优化\"></a>NexT主题优化</h5><h6 id=\"修改NexT主题Scheme\"><a href=\"#修改NexT主题Scheme\" class=\"headerlink\" title=\"修改NexT主题Scheme\"></a>修改NexT主题Scheme</h6><p>​    NexT当前支持4种风格,默认为Muse,在NexT主题配置文件(<code>themes/next/_config.yml</code>)中可以修改Scheme,配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">#scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">scheme: Gemini</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"添加访问统计\"><a href=\"#添加访问统计\" class=\"headerlink\" title=\"添加访问统计\"></a>添加访问统计</h6><p>​    通过配置NexT主题配置文件,修改busuanzi_count.配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Show Views &#x2F; Visitors of the website &#x2F; page with busuanzi.</span><br><span class=\"line\"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi</span><br><span class=\"line\">busuanzi_count:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  total_visitors: true</span><br><span class=\"line\">  total_visitors_icon: fa fa-user</span><br><span class=\"line\">  total_views: true</span><br><span class=\"line\">  total_views_icon: fa fa-eye</span><br><span class=\"line\">  post_views: true</span><br><span class=\"line\">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"添加头像\"><a href=\"#添加头像\" class=\"headerlink\" title=\"添加头像\"></a>添加头像</h6><p>​    添加的头像可以保存到主站目录下,或者主题目录下.</p>\n<ul>\n<li>Site路径: 保存到<code>~/ProjectWork/Jovry-Lee.github.io/public/uploads</code>路径下.</li>\n<li>theme路径下:<code>~/ProjectWork/Jovry-Lee.github.io/themes/next/source/images</code>路径下</li>\n</ul>\n<p>配置NexT主题配置文件,修改avatar项:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Sidebar Avatar</span><br><span class=\"line\">avatar:</span><br><span class=\"line\">  # in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif</span><br><span class=\"line\">  # in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif</span><br><span class=\"line\">  # Replace the default image and set the url here.</span><br><span class=\"line\">  url: &#x2F;uploads&#x2F;princess.jpeg</span><br><span class=\"line\">  # 配置为true时,头像会在一个圈圈中.</span><br><span class=\"line\">  rounded: true</span><br><span class=\"line\">  # 配置为true时,鼠标放在头像上,头像有旋转效果.</span><br><span class=\"line\">  rotated: true</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"添加About-Tags-Categories等页面\"><a href=\"#添加About-Tags-Categories等页面\" class=\"headerlink\" title=\"添加About/Tags/Categories等页面\"></a>添加About/Tags/Categories等页面</h6><p>​    默认情况下,About页面是不存在的,即使将主页展示了About的图标,若不进行页面配置,点击跳转会报404. 配置方式如下:</p>\n<ul>\n<li>进入博客Bash路径,生成about等页面.</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/ProjectWork/Jovry-Lee.github.io</span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;about&quot;</span> <span class=\"comment\"># 生成about页面</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;tags&quot;</span> <span class=\"comment\"># 生成tags页面</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;categories&quot;</span> <span class=\"comment\"># 生成分类页面</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置NexT主题配置文件,修改<code>munu</code>项,启用图标, 修改如下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F; || fa fa-home</span><br><span class=\"line\">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class=\"line\">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class=\"line\">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class=\"line\">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class=\"line\">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class=\"line\">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class=\"line\">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>​    添加about个人介绍,直接在<code>~/ProjectWork/Jovry-Lee.github.io/source/about/index.md</code>文件上进行编辑即可.</li>\n</ul>\n<h6 id=\"分类和标签页自动生成categories-amp-tags\"><a href=\"#分类和标签页自动生成categories-amp-tags\" class=\"headerlink\" title=\"分类和标签页自动生成categories&amp;tags\"></a>分类和标签页自动生成categories&amp;tags</h6><ul>\n<li>分类页面配置</li>\n</ul>\n<p>​    在生成的分类页面<code>~/ProjectWork/Jovry-Lee.github.io/source/categories/index.md</code>上进行如下修改:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: categories</span><br><span class=\"line\">date: 2020-08-21 15:08:25</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>标签页面配置</li>\n</ul>\n<p>​    在生成的分类页面<code>~/ProjectWork/Jovry-Lee.github.io/source/tags/index.md</code>上进行如下修改:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2020-08-19 15:30:01</span><br><span class=\"line\">type: tags</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"去掉目录栏序号\"><a href=\"#去掉目录栏序号\" class=\"headerlink\" title=\"去掉目录栏序号\"></a>去掉目录栏序号</h6><p>配置NexT主题配置文件,修改<code>toc</code>项,将<code>number</code>项设置为<code>false</code>, 修改如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Table of Contents in the Sidebar</span><br><span class=\"line\"># Front-matter variable (unsupport wrap expand_all).</span><br><span class=\"line\">toc:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # Automatically add list number to toc.</span><br><span class=\"line\">  number: false</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"设置侧边栏社交链接\"><a href=\"#设置侧边栏社交链接\" class=\"headerlink\" title=\"设置侧边栏社交链接\"></a>设置侧边栏社交链接</h6><p>​    社交连接也是在NexT配置文件中进行修改, 关键字<code>social</code>,进行修改,去掉<code>#</code>,添加个人链接即可.</p>\n<h5 id=\"基于NexT主题开启评论功能——Gitalk\"><a href=\"#基于NexT主题开启评论功能——Gitalk\" class=\"headerlink\" title=\"基于NexT主题开启评论功能——Gitalk\"></a>基于NexT主题开启评论功能——Gitalk</h5><p>​    该评论功能使用Gitalk服务实现。</p>\n<h6 id=\"注册OAuth-Application\"><a href=\"#注册OAuth-Application\" class=\"headerlink\" title=\"注册OAuth Application\"></a>注册OAuth Application</h6><ul>\n<li>登录GitHub</li>\n<li>前往 <code>https://github.com/settings/profile</code></li>\n<li>点击左侧下方的 <code>Developer settings</code></li>\n<li>点击绿色 <code>Register a new application</code></li>\n<li>填写以下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application name：gitalk-comment</span><br><span class=\"line\">Homepage URL：https:&#x2F;&#x2F;jovry-lee.github.io&#x2F;</span><br><span class=\"line\">Application description：Blog comment system</span><br><span class=\"line\">Authorization callback URL：https:&#x2F;&#x2F;jovry-lee.github.io&#x2F;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>点击 Register application</p>\n</li>\n<li><p>得到：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Client ID：xxx </span><br><span class=\"line\"></span><br><span class=\"line\">Client Secret： xxxx</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"创建存放Gitalk-comments的repository\"><a href=\"#创建存放Gitalk-comments的repository\" class=\"headerlink\" title=\"创建存放Gitalk-comments的repository\"></a>创建存放Gitalk-comments的repository</h6><ul>\n<li>创建 repository。 Repository name 为：<code>gitalk-comments</code></li>\n<li>地址：<code>https://github.com/Jovry-Lee/gitalk-comments</code></li>\n<li>注意稍后配置中填的是 <code>gitalk-comments</code>，<u>不是地址</u>。</li>\n</ul>\n<h6 id=\"添加Gitalk到博客\"><a href=\"#添加Gitalk到博客\" class=\"headerlink\" title=\"添加Gitalk到博客\"></a>添加Gitalk到博客</h6><ul>\n<li>打开本地博客路径下next主题的配置文件</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim ~/ProjectWork/Jovry-Lee.github.io/themes/next/_config.yml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到gitalk，进行如下修改：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Gitalk</span><br><span class=\"line\"># For more information: https:&#x2F;&#x2F;gitalk.github.io, https:&#x2F;&#x2F;github.com&#x2F;gitalk&#x2F;gitalk</span><br><span class=\"line\">gitalk:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  github_id: Jovry-Lee # GitHub repo owner</span><br><span class=\"line\">  repo: gitalk-comments # Repository name to store issues</span><br><span class=\"line\">  client_id: xxx # GitHub Application Client ID</span><br><span class=\"line\">  client_secret: xxxx # GitHub Application Client Secret</span><br><span class=\"line\">  admin_user: Jovry-Lee # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class=\"line\">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class=\"line\">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class=\"line\">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class=\"line\">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class=\"line\">  language: en</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重新部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean </span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"多端使用Hexo博客\"><a href=\"#多端使用Hexo博客\" class=\"headerlink\" title=\"多端使用Hexo博客\"></a>多端使用Hexo博客</h4><p>​    首先应该确保某一台电脑搭建好了Hexo博客，然后进行后续操作。</p>\n<h5 id=\"主端配置\"><a href=\"#主端配置\" class=\"headerlink\" title=\"主端配置\"></a>主端配置</h5><ul>\n<li><p>①、登录Github，在<code>username.github.io</code>仓库上新建hexo分支。</p>\n<p>在博客仓库上新建一个分支，例如“hexo”，切换到该分支，并设置该分支为默认分支（Setting-&gt;Branches-&gt;Default branch）</p>\n</li>\n<li><p>②、克隆博客仓库到本地</p>\n</li>\n</ul>\n<p><em>注：不是本地Hexo目录。</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git@github.com:Jovry-Lee/Jovry-Lee.github.io.git</span></span><br></pre></td></tr></table></figure>\n\n<p>查看当前分支，确保为新建的hexo分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> Jovry-Lee.github.io/ $ git branch * hexo</span></span><br></pre></td></tr></table></figure>\n\n<p><code>后续操作均是在Jovry-Lee.github.io目录(Jovry-Lee.github.io与githubBlog目录同级)下完成。</code></p>\n<ul>\n<li>③、拷贝本地博客的部署文件（Hexo目录下的全部文件到<code>username.github.io</code>文件目录中），然后删除<code>themes</code>目录中主题下的<code>.git</code>目录（如果存在的话），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后提交。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拷贝Hexo目录内容</span></span><br><span class=\"line\">$ sudo cp -r ~/ProjectWork/githubBlog/* ./</span><br><span class=\"line\"><span class=\"comment\"># 删除themes目录下主题的.git目录，我本地用的next主题</span></span><br><span class=\"line\">$ sudo rm -r themes/next/.git</span><br><span class=\"line\"><span class=\"comment\"># 提交修改</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;back up hexo files&quot;</span></span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>④、后续写博客，即在<code>username.github.io</code>文件目录中进行了，由于仓库有个<code>gitignore</code>文件，里面忽略掉了<code>node_modules</code>文件夹，也就是说仓库的<code>hexo分支</code>并没有存储该目录，所以需要重新install一下。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"其他电脑端配置\"><a href=\"#其他电脑端配置\" class=\"headerlink\" title=\"其他电脑端配置\"></a>其他电脑端配置</h5><p>​    安装Hexo环境，然后克隆<code>username.github.io</code>仓库的hexo分支到本地，此时本地git仓库处于hexo分支；切换到username.github.io目录，安装依赖包。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:Jovry-Lee/Jovry-Lee.github.io.git</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> Jovry-Lee.github.io</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果npm install出错，如”npm ERR! Unexpected end of JSON input while parsing near”,可尝试：</p>\n<ul>\n<li>删除package-lock.json文件</li>\n<li>清除cache: npm cache clean –force</li>\n<li>不要用淘宝镜像：npm set registry <a href=\"https://registry.npmjs.org/\">https://registry.npmjs.org/</a></li>\n</ul>\n<h5 id=\"发布更新博客\"><a href=\"#发布更新博客\" class=\"headerlink\" title=\"发布更新博客\"></a>发布更新博客</h5><p>​    更新博客内容后提交到github,执行以下操作进行提交及其部署.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commint -m <span class=\"string\">&quot;注释&quot;</span></span><br><span class=\"line\">$ git push</span><br><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p><em>注：每次操作时，最好先git pull 一下。</em></p>\n<h4 id=\"设置图床\"><a href=\"#设置图床\" class=\"headerlink\" title=\"设置图床\"></a>设置图床</h4><p>​    为了解决图片的存储问题，使用第三方静态资源库，即图床，获取图片Url，目前可供选择的图床很多，小众一些的容易挂，大厂存储服务又需要花钱，因此，这里使用Github + jsDelivr + PicGo + Imagine打造自己的图床。</p>\n<h5 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h5><ul>\n<li><p>创建仓库</p>\n</li>\n<li><ul>\n<li>输入项目名称</li>\n<li>选择权限为公开</li>\n<li>初始化一个READMEmd文件</li>\n<li>创建项目</li>\n</ul>\n</li>\n<li><p>生成一个Token</p>\n<ul>\n<li>点击用户头像-&gt;选择”Settings“-&gt;点击”Developer settings“-&gt;点击”Personal access tokens“-&gt;点击”Generate new token“</li>\n<li>在“Node”栏键入token的备注</li>\n<li>在“Select scopes”中勾选“repo”</li>\n<li>点击“Generate token”按钮</li>\n</ul>\n</li>\n<li><p>获取Token秘钥：<u>该秘钥只会显示一次，注意自己保存一下，方便后续使用</u>。</p>\n</li>\n</ul>\n<h5 id=\"配置PicGo，并使用jsdelivr作为CDN加速\"><a href=\"#配置PicGo，并使用jsdelivr作为CDN加速\" class=\"headerlink\" title=\"配置PicGo，并使用jsdelivr作为CDN加速\"></a>配置PicGo，并使用jsdelivr作为CDN加速</h5><ul>\n<li><p>下载PicGo</p>\n</li>\n<li><ul>\n<li><a href=\"https://github.com/Molunerfinn/PicGo\">下载地址</a></li>\n<li>Linux系统下载<code>AppImage</code>文件，更改其权限为可执行，双击即可显示应用图标。</li>\n</ul>\n</li>\n<li><p>右键点击图标选择“打开详细窗口”-&gt;点击“图床设置”-&gt;选择“GitHub图床”，进行GitHub设置</p>\n<ul>\n<li><p>设定仓库名：Jovry-Lee/cdn</p>\n</li>\n<li><p>设定分支名：master</p>\n</li>\n<li><p>设定Token：&lt;Github配置时生成的那个秘钥&gt;</p>\n</li>\n<li><p>指定存储路径：img/   <em>(注: 指定存储路径，将会在仓库下创建设置名称的文件夹（eg：img），上传的图片将保存在里面。)</em></p>\n</li>\n<li><p>设定自定义域名： eg：<code>https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn</code>  <em>(注: 自定义域名的作用是，在图片上传后，PicGo会按照自定义域名+上传图片名的方式生成访问链接，放到粘贴板上。因为我们要使用 jsDelivr 加速访问，所以可以设置为<a href=\"https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D%E3%80%82\">https://cdn.jsdelivr.net/gh/用户名/图床仓库名。</a>)</em></p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"图片压缩工具\"><a href=\"#图片压缩工具\" class=\"headerlink\" title=\"图片压缩工具\"></a>图片压缩工具</h5><p>​    通常情况下，图片大小都是超过200KB的，网页加载会比较慢，所以需要对图片进行压缩。</p>\n<ul>\n<li><p>在线网站压缩</p>\n<p><a href=\"https://tinypng.com/\">网站地址</a></p>\n</li>\n<li><p>Imagine工具压缩</p>\n<p><a href=\"https://github.com/meowtec/Imagine\">下载地址</a></p>\n</li>\n</ul>\n<h5 id=\"图片上传-获取\"><a href=\"#图片上传-获取\" class=\"headerlink\" title=\"图片上传/获取\"></a>图片上传/获取</h5><ul>\n<li>上传: 上传区进行图片上传，PicGo工具支持多个图床,需要选择上传的图床,选择<code>GitHub图床</code>。</li>\n</ul>\n<ul>\n<li>获取: PicGo应用点击<code>相册</code>，选择图床，即可显示该图床下的所有图片。</li>\n</ul>\n<p>生成的图片的链接示例：<code>https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E7%9F%A9%E5%BD%A2@3x.png</code></p>\n<h4 id=\"Markdown编辑器安装\"><a href=\"#Markdown编辑器安装\" class=\"headerlink\" title=\"Markdown编辑器安装\"></a>Markdown编辑器安装</h4><p>​    GitHub page支持Markdown语法,推荐使用Markdown进行编辑.</p>\n<h5 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h5><p><a href=\"https://typora.io/\">Typora官网</a></p>\n<p>安装方法：</p>\n<ul>\n<li>命令行安装</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># or run:</span></span><br><span class=\"line\"><span class=\"comment\"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span></span><br><span class=\"line\">$ wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># add Typora&#x27;s repository</span></span><br><span class=\"line\">$ sudo add-apt-repository <span class=\"string\">&#x27;deb https://typora.io/linux ./&#x27;</span></span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># install typora</span></span><br><span class=\"line\">$ sudo apt-get install typora</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>源文件安装<ul>\n<li>官网下载二进制文件</li>\n<li>解压到指定目录</li>\n<li>配置环境变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://typora.io/linux/Typora-linux-x64.tar.gz</span><br><span class=\"line\">$ sudo tar zxvf Typora-linux-x64.tar.gz -d /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\">$ sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>填入以下信息:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#set typora</span><br><span class=\"line\">export TYPORA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Typora-linux-x64</span><br><span class=\"line\">export PAHT&#x3D;$TYPORA_HOME:$PATH</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://ryanluoxu.github.io/2017/11/24/%E7%94%A8-Hexo-%E5%92%8C-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\">用 Hexo 和 GitHub Pages 搭建博客</a></p>\n<p><a href=\"https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/\">Ubuntu 16.04下Github配置</a> </p>\n<p><a href=\"http://theme-next.iissnan.com/getting-started.html\">Next使用文档</a></p>\n<p><a href=\"https://theme-next.js.org/docs/getting-started/\">Getting Started</a></p>\n<p><a href=\"https://www.zhihu.com/question/43517242\">Hexo中如何给一篇文章加多个tags？</a></p>\n<p><a href=\"https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2\">创建分类页面</a></p>\n<p><a href=\"https://blog.csdn.net/u011240016/article/details/79422462\">hexo之next主题添加分类</a></p>\n<p><a href=\"https://cccshuang.github.io/2018/09/28/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%86%99Hexo%E5%8D%9A%E5%AE%A2/\">使用多台电脑写Hexo博客</a></p>\n<p><a href=\"https://www.vivatakethat.com/2016/07/07/%E5%9C%A8Windows%E4%B8%8B%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo/\">在WSL下快速搭建hexo</a></p>\n<p><a href=\"https://hexo.io/zh-cn/\">Hexo官网</a></p>\n<p>[Hexo Blog折腾笔记](<a href=\"https://ghamster0.github.io/2019/03/12/Hexo\">https://ghamster0.github.io/2019/03/12/Hexo</a> Blog折腾笔记/)</p>\n<p><a href=\"https://www.cnblogs.com/sitoi/p/11848816.html\">GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床 </a></p>\n<p><a href=\"https://ryanluoxu.github.io/2017/11/26/Hexo-%E7%9A%84-Next-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96\">Hexo 的 Next 主题优化</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/30836436\">Hexo+Next主题优化</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>​    GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，通过构建过程运行文件，然后发布网站。 Hexo是高效的静态站点生成框架，它基于Node.js. 通过Hexo，可以直接使用Markdown语法来撰写博客。</p>","more":"<h4 id=\"配置Git\"><a href=\"#配置Git\" class=\"headerlink\" title=\"配置Git\"></a>配置Git</h4><p>​    配置方式参考：<a href=\"https://jovry-lee.github.io/2020/08/18/Ubuntu16-04-Github%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/#more\">Ubuntu16.04 Github配置及使用</a></p>\n<h4 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h4><p>​    安装方式参考：<a href=\"https://jovry-lee.github.io/2020/08/21/Ubuntu16-04-Nodejs%E5%AE%89%E8%A3%85/\">Ubuntu16.04 Node.js安装.note</a></p>\n<h4 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h4><p>​    安装命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>​    检查hexo是否安装成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n\n<p>​    <em>得到hexo-cli：4.2.0等一串数据，安装成功。</em></p>\n<h4 id=\"Hexo创建本地博客\"><a href=\"#Hexo创建本地博客\" class=\"headerlink\" title=\"Hexo创建本地博客\"></a>Hexo创建本地博客</h4><ul>\n<li><p>初始化本地站点</p>\n<p>本地博客路径在<code>~/ProjectWork/githubBlog</code>下,本地博客搭建操作在此路径下进行操作.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/ProjectWork</span><br><span class=\"line\">$ mkdir githubBlog <span class=\"comment\"># 创建本地博客路径</span></span><br><span class=\"line\">$ hexo init <span class=\"comment\"># 初始化本地站点</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><em>注：hexo init 命令要求该当前文件夹为空文件夹。</em></p>\n<ul>\n<li>安装依赖包</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成网页</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<p><em>注：由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</em></p>\n<ul>\n<li>将网页放在本地服务器</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>测试本地博客</p>\n<p>在浏览器里输入<a href=\"http://localhost:4000/\">http://localhost:4000/</a> </p>\n</li>\n<li><p>发布一篇博客</p>\n<p>在本地博客路径下执行以下命令, 此时source/_posts下会生成一个“日志名.md”的文件，该文件即是日志文件。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;&lt;日志名&gt;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成网页并放到本地服务器</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g </span><br><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将本地Hexo博客部署到Github上\"><a href=\"#将本地Hexo博客部署到Github上\" class=\"headerlink\" title=\"将本地Hexo博客部署到Github上\"></a>将本地Hexo博客部署到Github上</h4><h5 id=\"创建代码仓库\"><a href=\"#创建代码仓库\" class=\"headerlink\" title=\"创建代码仓库\"></a>创建代码仓库</h5><ul>\n<li><p>在Github中创建一个以.github.io结尾的Repository。</p>\n</li>\n<li><ul>\n<li>①、Repository name:  <code>Jovry-Lee.github.io</code></li>\n<li>②、勾选 Initialize this repository with a README</li>\n<li>③、Create repository</li>\n</ul>\n</li>\n<li><p>简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog.. 保存(Commit changes)。</p>\n</li>\n<li><p>打开网页：<code>jovry-Lee.github.io</code> 这里就可以看到 README.md 里的内容了。</p>\n</li>\n</ul>\n<h5 id=\"配置本地代码仓库\"><a href=\"#配置本地代码仓库\" class=\"headerlink\" title=\"配置本地代码仓库\"></a>配置本地代码仓库</h5><ul>\n<li>获取Github对应的Repository的链接。（<a href=\"mailto:&#103;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;\">&#103;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>:Jovry-Lee/Jovry-Lee.github.io.git）</li>\n</ul>\n<ul>\n<li>修改本地站点配置文件。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vim _config.yml <span class=\"comment\"># 打开配置文件</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到#Deployment，填入以下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: https:&#x2F;&#x2F;github.com&#x2F;Jovry-Lee&#x2F;Jovry-Lee.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save <span class=\"comment\"># 安装hexo-deployer-git，该步骤只需要做一次</span></span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<p><em>得到 INFO Deploy done: git 即为部署成功</em></p>\n<p>此时访问<code>Jovry-Lee.github.io</code>即可看到博客页面。</p>\n<h4 id=\"使用Next主题\"><a href=\"#使用Next主题\" class=\"headerlink\" title=\"使用Next主题\"></a>使用Next主题</h4><h5 id=\"配置NexT主题\"><a href=\"#配置NexT主题\" class=\"headerlink\" title=\"配置NexT主题\"></a>配置NexT主题</h5><ul>\n<li>获取主题代码</li>\n</ul>\n<p>​    克隆主题代码到本地博客<code>themes/next</code>路径下.    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/next-theme/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>修改博客配置文件</p>\n<ul>\n<li><p>打开 <code>~/ProjectWork/githubBlog/_config.yml</code></p>\n</li>\n<li><p>找到 theme:</p>\n</li>\n<li><p>把 Hexo 默认的 lanscape 修改成 next。 即 theme: next</p>\n</li>\n<li><p>找到 # Site，添加博客名称，作者名字等。</p>\n</li>\n<li><p>在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。</p>\n</li>\n<li><p>找到 # URL, 填入 url。比如 url:<a href=\"https://jovry-lee.github.io/\">https://jovry-lee.github.io/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>当前本地配置如下:</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class=\"line\">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class=\"line\">theme: next</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># Site</span><br><span class=\"line\">title: Jovry&#39;s blog</span><br><span class=\"line\">subtitle: &#39;&#39;</span><br><span class=\"line\">description: Keeping learning and improving!</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: Jovry Lee</span><br><span class=\"line\">language: en</span><br><span class=\"line\">timezone: &#39;Asia&#x2F;Shanghai&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># URL</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class=\"line\">url: https:&#x2F;&#x2F;jovry-Lee.github.io</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>清除旧配置</li>\n</ul>\n<p>​    <em>注意：修改配置后最好都进行一下清理操作，不然可能不生效。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重新生成部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"NexT主题优化\"><a href=\"#NexT主题优化\" class=\"headerlink\" title=\"NexT主题优化\"></a>NexT主题优化</h5><h6 id=\"修改NexT主题Scheme\"><a href=\"#修改NexT主题Scheme\" class=\"headerlink\" title=\"修改NexT主题Scheme\"></a>修改NexT主题Scheme</h6><p>​    NexT当前支持4种风格,默认为Muse,在NexT主题配置文件(<code>themes/next/_config.yml</code>)中可以修改Scheme,配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">#scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">scheme: Gemini</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"添加访问统计\"><a href=\"#添加访问统计\" class=\"headerlink\" title=\"添加访问统计\"></a>添加访问统计</h6><p>​    通过配置NexT主题配置文件,修改busuanzi_count.配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Show Views &#x2F; Visitors of the website &#x2F; page with busuanzi.</span><br><span class=\"line\"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi</span><br><span class=\"line\">busuanzi_count:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  total_visitors: true</span><br><span class=\"line\">  total_visitors_icon: fa fa-user</span><br><span class=\"line\">  total_views: true</span><br><span class=\"line\">  total_views_icon: fa fa-eye</span><br><span class=\"line\">  post_views: true</span><br><span class=\"line\">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"添加头像\"><a href=\"#添加头像\" class=\"headerlink\" title=\"添加头像\"></a>添加头像</h6><p>​    添加的头像可以保存到主站目录下,或者主题目录下.</p>\n<ul>\n<li>Site路径: 保存到<code>~/ProjectWork/Jovry-Lee.github.io/public/uploads</code>路径下.</li>\n<li>theme路径下:<code>~/ProjectWork/Jovry-Lee.github.io/themes/next/source/images</code>路径下</li>\n</ul>\n<p>配置NexT主题配置文件,修改avatar项:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Sidebar Avatar</span><br><span class=\"line\">avatar:</span><br><span class=\"line\">  # in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif</span><br><span class=\"line\">  # in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif</span><br><span class=\"line\">  # Replace the default image and set the url here.</span><br><span class=\"line\">  url: &#x2F;uploads&#x2F;princess.jpeg</span><br><span class=\"line\">  # 配置为true时,头像会在一个圈圈中.</span><br><span class=\"line\">  rounded: true</span><br><span class=\"line\">  # 配置为true时,鼠标放在头像上,头像有旋转效果.</span><br><span class=\"line\">  rotated: true</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"添加About-Tags-Categories等页面\"><a href=\"#添加About-Tags-Categories等页面\" class=\"headerlink\" title=\"添加About/Tags/Categories等页面\"></a>添加About/Tags/Categories等页面</h6><p>​    默认情况下,About页面是不存在的,即使将主页展示了About的图标,若不进行页面配置,点击跳转会报404. 配置方式如下:</p>\n<ul>\n<li>进入博客Bash路径,生成about等页面.</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/ProjectWork/Jovry-Lee.github.io</span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;about&quot;</span> <span class=\"comment\"># 生成about页面</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;tags&quot;</span> <span class=\"comment\"># 生成tags页面</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;categories&quot;</span> <span class=\"comment\"># 生成分类页面</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置NexT主题配置文件,修改<code>munu</code>项,启用图标, 修改如下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F; || fa fa-home</span><br><span class=\"line\">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class=\"line\">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class=\"line\">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class=\"line\">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class=\"line\">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class=\"line\">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class=\"line\">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>​    添加about个人介绍,直接在<code>~/ProjectWork/Jovry-Lee.github.io/source/about/index.md</code>文件上进行编辑即可.</li>\n</ul>\n<h6 id=\"分类和标签页自动生成categories-amp-tags\"><a href=\"#分类和标签页自动生成categories-amp-tags\" class=\"headerlink\" title=\"分类和标签页自动生成categories&amp;tags\"></a>分类和标签页自动生成categories&amp;tags</h6><ul>\n<li>分类页面配置</li>\n</ul>\n<p>​    在生成的分类页面<code>~/ProjectWork/Jovry-Lee.github.io/source/categories/index.md</code>上进行如下修改:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: categories</span><br><span class=\"line\">date: 2020-08-21 15:08:25</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>标签页面配置</li>\n</ul>\n<p>​    在生成的分类页面<code>~/ProjectWork/Jovry-Lee.github.io/source/tags/index.md</code>上进行如下修改:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2020-08-19 15:30:01</span><br><span class=\"line\">type: tags</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"去掉目录栏序号\"><a href=\"#去掉目录栏序号\" class=\"headerlink\" title=\"去掉目录栏序号\"></a>去掉目录栏序号</h6><p>配置NexT主题配置文件,修改<code>toc</code>项,将<code>number</code>项设置为<code>false</code>, 修改如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Table of Contents in the Sidebar</span><br><span class=\"line\"># Front-matter variable (unsupport wrap expand_all).</span><br><span class=\"line\">toc:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # Automatically add list number to toc.</span><br><span class=\"line\">  number: false</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"设置侧边栏社交链接\"><a href=\"#设置侧边栏社交链接\" class=\"headerlink\" title=\"设置侧边栏社交链接\"></a>设置侧边栏社交链接</h6><p>​    社交连接也是在NexT配置文件中进行修改, 关键字<code>social</code>,进行修改,去掉<code>#</code>,添加个人链接即可.</p>\n<h5 id=\"基于NexT主题开启评论功能——Gitalk\"><a href=\"#基于NexT主题开启评论功能——Gitalk\" class=\"headerlink\" title=\"基于NexT主题开启评论功能——Gitalk\"></a>基于NexT主题开启评论功能——Gitalk</h5><p>​    该评论功能使用Gitalk服务实现。</p>\n<h6 id=\"注册OAuth-Application\"><a href=\"#注册OAuth-Application\" class=\"headerlink\" title=\"注册OAuth Application\"></a>注册OAuth Application</h6><ul>\n<li>登录GitHub</li>\n<li>前往 <code>https://github.com/settings/profile</code></li>\n<li>点击左侧下方的 <code>Developer settings</code></li>\n<li>点击绿色 <code>Register a new application</code></li>\n<li>填写以下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application name：gitalk-comment</span><br><span class=\"line\">Homepage URL：https:&#x2F;&#x2F;jovry-lee.github.io&#x2F;</span><br><span class=\"line\">Application description：Blog comment system</span><br><span class=\"line\">Authorization callback URL：https:&#x2F;&#x2F;jovry-lee.github.io&#x2F;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>点击 Register application</p>\n</li>\n<li><p>得到：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Client ID：xxx </span><br><span class=\"line\"></span><br><span class=\"line\">Client Secret： xxxx</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"创建存放Gitalk-comments的repository\"><a href=\"#创建存放Gitalk-comments的repository\" class=\"headerlink\" title=\"创建存放Gitalk-comments的repository\"></a>创建存放Gitalk-comments的repository</h6><ul>\n<li>创建 repository。 Repository name 为：<code>gitalk-comments</code></li>\n<li>地址：<code>https://github.com/Jovry-Lee/gitalk-comments</code></li>\n<li>注意稍后配置中填的是 <code>gitalk-comments</code>，<u>不是地址</u>。</li>\n</ul>\n<h6 id=\"添加Gitalk到博客\"><a href=\"#添加Gitalk到博客\" class=\"headerlink\" title=\"添加Gitalk到博客\"></a>添加Gitalk到博客</h6><ul>\n<li>打开本地博客路径下next主题的配置文件</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim ~/ProjectWork/Jovry-Lee.github.io/themes/next/_config.yml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到gitalk，进行如下修改：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Gitalk</span><br><span class=\"line\"># For more information: https:&#x2F;&#x2F;gitalk.github.io, https:&#x2F;&#x2F;github.com&#x2F;gitalk&#x2F;gitalk</span><br><span class=\"line\">gitalk:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  github_id: Jovry-Lee # GitHub repo owner</span><br><span class=\"line\">  repo: gitalk-comments # Repository name to store issues</span><br><span class=\"line\">  client_id: xxx # GitHub Application Client ID</span><br><span class=\"line\">  client_secret: xxxx # GitHub Application Client Secret</span><br><span class=\"line\">  admin_user: Jovry-Lee # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class=\"line\">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class=\"line\">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class=\"line\">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class=\"line\">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class=\"line\">  language: en</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重新部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean </span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"多端使用Hexo博客\"><a href=\"#多端使用Hexo博客\" class=\"headerlink\" title=\"多端使用Hexo博客\"></a>多端使用Hexo博客</h4><p>​    首先应该确保某一台电脑搭建好了Hexo博客，然后进行后续操作。</p>\n<h5 id=\"主端配置\"><a href=\"#主端配置\" class=\"headerlink\" title=\"主端配置\"></a>主端配置</h5><ul>\n<li><p>①、登录Github，在<code>username.github.io</code>仓库上新建hexo分支。</p>\n<p>在博客仓库上新建一个分支，例如“hexo”，切换到该分支，并设置该分支为默认分支（Setting-&gt;Branches-&gt;Default branch）</p>\n</li>\n<li><p>②、克隆博客仓库到本地</p>\n</li>\n</ul>\n<p><em>注：不是本地Hexo目录。</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git@github.com:Jovry-Lee/Jovry-Lee.github.io.git</span></span><br></pre></td></tr></table></figure>\n\n<p>查看当前分支，确保为新建的hexo分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> Jovry-Lee.github.io/ $ git branch * hexo</span></span><br></pre></td></tr></table></figure>\n\n<p><code>后续操作均是在Jovry-Lee.github.io目录(Jovry-Lee.github.io与githubBlog目录同级)下完成。</code></p>\n<ul>\n<li>③、拷贝本地博客的部署文件（Hexo目录下的全部文件到<code>username.github.io</code>文件目录中），然后删除<code>themes</code>目录中主题下的<code>.git</code>目录（如果存在的话），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后提交。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拷贝Hexo目录内容</span></span><br><span class=\"line\">$ sudo cp -r ~/ProjectWork/githubBlog/* ./</span><br><span class=\"line\"><span class=\"comment\"># 删除themes目录下主题的.git目录，我本地用的next主题</span></span><br><span class=\"line\">$ sudo rm -r themes/next/.git</span><br><span class=\"line\"><span class=\"comment\"># 提交修改</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;back up hexo files&quot;</span></span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>④、后续写博客，即在<code>username.github.io</code>文件目录中进行了，由于仓库有个<code>gitignore</code>文件，里面忽略掉了<code>node_modules</code>文件夹，也就是说仓库的<code>hexo分支</code>并没有存储该目录，所以需要重新install一下。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"其他电脑端配置\"><a href=\"#其他电脑端配置\" class=\"headerlink\" title=\"其他电脑端配置\"></a>其他电脑端配置</h5><p>​    安装Hexo环境，然后克隆<code>username.github.io</code>仓库的hexo分支到本地，此时本地git仓库处于hexo分支；切换到username.github.io目录，安装依赖包。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:Jovry-Lee/Jovry-Lee.github.io.git</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> Jovry-Lee.github.io</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果npm install出错，如”npm ERR! Unexpected end of JSON input while parsing near”,可尝试：</p>\n<ul>\n<li>删除package-lock.json文件</li>\n<li>清除cache: npm cache clean –force</li>\n<li>不要用淘宝镜像：npm set registry <a href=\"https://registry.npmjs.org/\">https://registry.npmjs.org/</a></li>\n</ul>\n<h5 id=\"发布更新博客\"><a href=\"#发布更新博客\" class=\"headerlink\" title=\"发布更新博客\"></a>发布更新博客</h5><p>​    更新博客内容后提交到github,执行以下操作进行提交及其部署.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commint -m <span class=\"string\">&quot;注释&quot;</span></span><br><span class=\"line\">$ git push</span><br><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p><em>注：每次操作时，最好先git pull 一下。</em></p>\n<h4 id=\"设置图床\"><a href=\"#设置图床\" class=\"headerlink\" title=\"设置图床\"></a>设置图床</h4><p>​    为了解决图片的存储问题，使用第三方静态资源库，即图床，获取图片Url，目前可供选择的图床很多，小众一些的容易挂，大厂存储服务又需要花钱，因此，这里使用Github + jsDelivr + PicGo + Imagine打造自己的图床。</p>\n<h5 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h5><ul>\n<li><p>创建仓库</p>\n</li>\n<li><ul>\n<li>输入项目名称</li>\n<li>选择权限为公开</li>\n<li>初始化一个READMEmd文件</li>\n<li>创建项目</li>\n</ul>\n</li>\n<li><p>生成一个Token</p>\n<ul>\n<li>点击用户头像-&gt;选择”Settings“-&gt;点击”Developer settings“-&gt;点击”Personal access tokens“-&gt;点击”Generate new token“</li>\n<li>在“Node”栏键入token的备注</li>\n<li>在“Select scopes”中勾选“repo”</li>\n<li>点击“Generate token”按钮</li>\n</ul>\n</li>\n<li><p>获取Token秘钥：<u>该秘钥只会显示一次，注意自己保存一下，方便后续使用</u>。</p>\n</li>\n</ul>\n<h5 id=\"配置PicGo，并使用jsdelivr作为CDN加速\"><a href=\"#配置PicGo，并使用jsdelivr作为CDN加速\" class=\"headerlink\" title=\"配置PicGo，并使用jsdelivr作为CDN加速\"></a>配置PicGo，并使用jsdelivr作为CDN加速</h5><ul>\n<li><p>下载PicGo</p>\n</li>\n<li><ul>\n<li><a href=\"https://github.com/Molunerfinn/PicGo\">下载地址</a></li>\n<li>Linux系统下载<code>AppImage</code>文件，更改其权限为可执行，双击即可显示应用图标。</li>\n</ul>\n</li>\n<li><p>右键点击图标选择“打开详细窗口”-&gt;点击“图床设置”-&gt;选择“GitHub图床”，进行GitHub设置</p>\n<ul>\n<li><p>设定仓库名：Jovry-Lee/cdn</p>\n</li>\n<li><p>设定分支名：master</p>\n</li>\n<li><p>设定Token：&lt;Github配置时生成的那个秘钥&gt;</p>\n</li>\n<li><p>指定存储路径：img/   <em>(注: 指定存储路径，将会在仓库下创建设置名称的文件夹（eg：img），上传的图片将保存在里面。)</em></p>\n</li>\n<li><p>设定自定义域名： eg：<code>https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn</code>  <em>(注: 自定义域名的作用是，在图片上传后，PicGo会按照自定义域名+上传图片名的方式生成访问链接，放到粘贴板上。因为我们要使用 jsDelivr 加速访问，所以可以设置为<a href=\"https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D%E3%80%82\">https://cdn.jsdelivr.net/gh/用户名/图床仓库名。</a>)</em></p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"图片压缩工具\"><a href=\"#图片压缩工具\" class=\"headerlink\" title=\"图片压缩工具\"></a>图片压缩工具</h5><p>​    通常情况下，图片大小都是超过200KB的，网页加载会比较慢，所以需要对图片进行压缩。</p>\n<ul>\n<li><p>在线网站压缩</p>\n<p><a href=\"https://tinypng.com/\">网站地址</a></p>\n</li>\n<li><p>Imagine工具压缩</p>\n<p><a href=\"https://github.com/meowtec/Imagine\">下载地址</a></p>\n</li>\n</ul>\n<h5 id=\"图片上传-获取\"><a href=\"#图片上传-获取\" class=\"headerlink\" title=\"图片上传/获取\"></a>图片上传/获取</h5><ul>\n<li>上传: 上传区进行图片上传，PicGo工具支持多个图床,需要选择上传的图床,选择<code>GitHub图床</code>。</li>\n</ul>\n<ul>\n<li>获取: PicGo应用点击<code>相册</code>，选择图床，即可显示该图床下的所有图片。</li>\n</ul>\n<p>生成的图片的链接示例：<code>https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E7%9F%A9%E5%BD%A2@3x.png</code></p>\n<h4 id=\"Markdown编辑器安装\"><a href=\"#Markdown编辑器安装\" class=\"headerlink\" title=\"Markdown编辑器安装\"></a>Markdown编辑器安装</h4><p>​    GitHub page支持Markdown语法,推荐使用Markdown进行编辑.</p>\n<h5 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h5><p><a href=\"https://typora.io/\">Typora官网</a></p>\n<p>安装方法：</p>\n<ul>\n<li>命令行安装</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># or run:</span></span><br><span class=\"line\"><span class=\"comment\"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span></span><br><span class=\"line\">$ wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># add Typora&#x27;s repository</span></span><br><span class=\"line\">$ sudo add-apt-repository <span class=\"string\">&#x27;deb https://typora.io/linux ./&#x27;</span></span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># install typora</span></span><br><span class=\"line\">$ sudo apt-get install typora</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>源文件安装<ul>\n<li>官网下载二进制文件</li>\n<li>解压到指定目录</li>\n<li>配置环境变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://typora.io/linux/Typora-linux-x64.tar.gz</span><br><span class=\"line\">$ sudo tar zxvf Typora-linux-x64.tar.gz -d /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\">$ sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>填入以下信息:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#set typora</span><br><span class=\"line\">export TYPORA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Typora-linux-x64</span><br><span class=\"line\">export PAHT&#x3D;$TYPORA_HOME:$PATH</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://ryanluoxu.github.io/2017/11/24/%E7%94%A8-Hexo-%E5%92%8C-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\">用 Hexo 和 GitHub Pages 搭建博客</a></p>\n<p><a href=\"https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/\">Ubuntu 16.04下Github配置</a> </p>\n<p><a href=\"http://theme-next.iissnan.com/getting-started.html\">Next使用文档</a></p>\n<p><a href=\"https://theme-next.js.org/docs/getting-started/\">Getting Started</a></p>\n<p><a href=\"https://www.zhihu.com/question/43517242\">Hexo中如何给一篇文章加多个tags？</a></p>\n<p><a href=\"https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2\">创建分类页面</a></p>\n<p><a href=\"https://blog.csdn.net/u011240016/article/details/79422462\">hexo之next主题添加分类</a></p>\n<p><a href=\"https://cccshuang.github.io/2018/09/28/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%86%99Hexo%E5%8D%9A%E5%AE%A2/\">使用多台电脑写Hexo博客</a></p>\n<p><a href=\"https://www.vivatakethat.com/2016/07/07/%E5%9C%A8Windows%E4%B8%8B%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo/\">在WSL下快速搭建hexo</a></p>\n<p><a href=\"https://hexo.io/zh-cn/\">Hexo官网</a></p>\n<p>[Hexo Blog折腾笔记](<a href=\"https://ghamster0.github.io/2019/03/12/Hexo\">https://ghamster0.github.io/2019/03/12/Hexo</a> Blog折腾笔记/)</p>\n<p><a href=\"https://www.cnblogs.com/sitoi/p/11848816.html\">GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床 </a></p>\n<p><a href=\"https://ryanluoxu.github.io/2017/11/26/Hexo-%E7%9A%84-Next-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96\">Hexo 的 Next 主题优化</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/30836436\">Hexo+Next主题优化</a></p>"},{"title":"Redis设计与实现-Redis对象","date":"2020-08-31T09:14:48.000Z","_content":"\n\n\nRedis基于其数据结构（例如，SDS、双端链表、字典、压缩列表、整数集合等）创建了一个对象系统，该系统包含`字符串对象`、`列表对象`、`哈希对象`、`集合对象`和`有序集合`对象这五种对象，每种对象都用到了至少一种数据结构。\n\n<!--more-->\n\n### 1 对象的类型与编码\n\nRedis使用`对象`来表示数据库中的健和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的健（键对象），另一个对象用作键值对的值（值对象）。\n\n\n\nRedis中每个对都由`redisObject`结构表示，如下所示：\n\n```c\ntypedef struct redisObject {\n    // 类型.\n    unsigned type:4;\n    // 编码.\n    unsigned encoding:4;\n    // 记录了对象最后一次被命令程序访问的时间。\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用次数\n    int refcount;\n    // 指向底层实现数据结构的指针。\n    void *ptr;\n} robj;\n```\n\n\n\n#### 1.1 类型\n\n对象的type属性记录了对象的类型，这个类型包括以下5中类型：\n\n- **REDIS_STRING**：字符串对象(type命令输出：“string”)\n- **REDIS_LIST**：列表对象(type命令输出：“list”)\n- **REDIS_HASH**：哈希对象(type命令输出：“hash”)\n- **REDIS_SET**：集合对象(type命令输出：“set”)\n- **REDIS_ZSET**：有序集合对象(type命令输出：“zset”)\n\n*使用`type命令`可以返回**数据库键对应的值对象类型***\n\n\n\n*对于Redis数据库保存的`键值`对来说，<u>键总是一个字符串对象</u>，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的一种，因此我们称“XX键”表示这个数据库键所对应的值为XX对象。*\n\n\n\n#### 1.2 编码和底层实现\n\n对象的`ptr`指向对象的底层实现数据结构，而这些数据结构由对象的`encoding`属性决定。\n\nencoding对象属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现，其对象的编码如下：\n\n- **REDIS_ENCODING_INT**：long类型的整数(object encoding命令输出：int)\n- **REDIS_ENCODING_EMBSTR**：embstr编码的简单动态字符串(object encoding命令输出：embstr)\n- **REDIS_ENCODING_RAW**：简单动态字符串(object encoding命令输出：raw)\n- **REDIS_ENCODING_HT**：字典(object encoding命令输出：hashtable)\n- **REDIS_ENCODING_LINKEDLIST**：双端链表(object encoding命令输出：linkedlist)\n- **REDIS_ENCODING_ZIPLIST**：压缩列表(object encoding命令输出：ziplist)\n- **REDIS_ENCODING_INTSET**：整数集合(object encoding命令输出：intset)\n- **REDIS_ENCODING_SKIPLIST**：跳跃表和字典(object encoding命令输出：skiplist)\n\n\n\n每种类型的对象都至少使用了两种不同的编码，如下所示：\n\n![每种类型的对象都至少使用了两种不同的编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/每种类型的对象都至少使用了两种不同的编码.png)\n\n*使用`object encoding命令`可以**查看一个数据库键的值对象的编码***\n\n\n\n**为什么Redis要使用encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码？**\n\n因为使用encoding属性设定编码方式可以<u>根据不同的适用场景设置不同的编码，从而优化对象在某一场景下的效率。</u>例如，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现，压缩列表比双向链表更节约内存，且在元素数量较少是，在内存中以连续块方式保存的压缩列表比起双向链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，是用压缩列表来保存元素的优势逐渐消失，对象就会将底层实现从压缩列表转向功能更强、也更合适保存大量元素的双端链表上。\n\n### 2 字符串对象\n\n字符串对象的编码可以是`int`、`raw`、`embstr`。\n\n- **int**：字符串对象保存的是`整数值，并且这个整数值可以用long类型类表示`，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *装换成long），并将字符串对象的编码设置为int。\n- **raw**：字符串对象保存的是一个`字符串值，并且这个字符串值的长度大于32字节`，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。\n- **embstr**：字符串对象保存的是一个`字符串值，并且这个字符串值的长度小于等于32字节`，那么字符串对象将使用embstr编码的方式来保存这个字符串值。\n\n示例：\n\n```bash\n127.0.0.1:6379> set number 10086\nOK\n127.0.0.1:6379> object encoding number\n\"int\"\n\n127.0.0.1:6379> set story \"Long, long ago there lived a king and a queen, they have a beautiful daughter...\"\nOK\n127.0.0.1:6379> strlen story\n(integer) 80\n127.0.0.1:6379> object encoding story\n\"raw\"\n\n127.0.0.1:6379> set msg \"hello\"\nOK\n127.0.0.1:6379> object encoding msg\n\"embstr\"\n```\n\n\n\n**问: 既然有raw编码方式，为什么还要有embstr编码呢？它们有什么异同点？**\n\n- 相同点:\n\n  - embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw一样，都是用redisObject结构和sdshdr结构来表示字符串对象。\n\n- 不同点：\n\n  - raw编码会<u>调用两次内存分配函数</u>分别创建redisObject结构和sdshdr结构。\n\n  - embstr则通过调用一次内存分配函数来分配<u>一块连续的空间</u>，空间中依次包含redisObject和sdshdr两个结构。\n\n    \n\n    embstr编码创建的内存块结构如下：\n\n![embstr编码创建的内存块结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/embstr编码创建的内存块结构.png)\n\n\n\n**问: 使用embstr编码的字符串对象来保存短字符串值有什么好处？**\n\n- ①、embstr编码将创建的字符串对象所需的内存分配次数从raw编码的两次降低为一次。\n- ②、释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。\n- ③、embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比raw编码的字符串对象能更好的利用缓存带来的优势。\n\n\n\n注：`long double类型表示的浮点数在Redis中也是作为字符串值来保存的`, 如下示例所示：\n\n```bash\n127.0.0.1:6379> set pi 3.14\nOK\n127.0.0.1:6379> object encoding pi\n\"embstr\"\n```\n\n\n\n下图为字符串对象保存各类型值的编码方式：\n\n![字符串对象保存各类型值的编码方式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/字符串对象保存各类型值的编码方式.png)\n\n\n\n#### 2.1 编码转换\n\n`int编码`的字符串对象和`embstr编码`的字符串对象在条件满足的情况下，会被转换为`raw编码`的字符串对象。\n\n- **int编码->raw编码**：执行一些命令，使得对象保存的值不再是整数值，而是一个字符串值时。例如APPEND命令。\n- **embstr编码->raw编码**：Redis并没有为embstr编码提供任何修改程序，因此`实际上embstr编码的字符串是只读的`，当对embstr编码的字符串进行修改时，程序会先将对象的编码从embstr转换为raw，再执行修改命令。\n\n\n\n示例1：\n\n```bash\n127.0.0.1:6379> set number 10086\nOK\n127.0.0.1:6379> object encoding number\n\"int\"\n127.0.0.1:6379> append number \" is a good number!\" # 使用append命令将对象变为一个字符串.\n(integer) 23\n127.0.0.1:6379> get number\n\"10086 is a good number!\"\n127.0.0.1:6379> object encoding number\n\"raw\"\n```\n\n示例2：\n\n```bash\n127.0.0.1:6379> set msg \"hello word\"\nOK\n127.0.0.1:6379> object encoding msg\n\"embstr\"\n127.0.0.1:6379> append msg \" again!\" # embstr字符串是只读的,当对其进行修改时,将强制转换为raw编码,再进行修改.\n(integer) 17\n127.0.0.1:6379> object encoding msg\n\"raw\"\n```\n\n\n\n### 3 列表对象\n\n列表对象的编码可以是`ziplist`或者`linkedlist`。\n\n- ziplist编码的列表对象: 使用`压缩列表`作为底层实现，每个压缩列表结点(entry)保存了一个列表元素。\n- linkedlist编码的列表对象: 使用`双端链表`作为底层实现，每个双端链表结点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。\n\n\n\n示例1：\n\n```bash\n127.0.0.1:6379> rpush numbers 1 \"three\" 5\n(integer) 3\n```\n\n`ziplist编码`的numbers列表对象如下：\n\n![ziplist编码的numbers列表对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的numbers列表对象.png)\n\n\n\nlinkedlist编码的numbers列表对象如下：\n\n![linkedlist编码的numbers列表对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/linkedlist编码的numbers列表对象.png)\n\n\n\n其中完整的StringObject表示方式如下：\n\n![完整的StringObject表示方式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/完整的StringObject表示方式.png)\n\n#### 3.1 编码转换\n\n当列表对象可以同时满足以下两个条件时，列表对象使用`ziplist`编码。其他情况下需要使用`linkedlist`编码。\n\n- ①、列表对象保存的所有字符串元素的长度都小于64字节（由配置`list-max-ziplist-value`决定）；\n- ②、列表对象保存的元素数量小于512个（由配置`hash-max-ziplist-entries`决定）。\n\n\n\n示例1：保存长度太大的元素而进行编码转换的情况。\n\n```bash\n127.0.0.1:6379> rpush blah \"hello\" \"world\" \"again\"\n(integer) 3\n127.0.0.1:6379> object encoding blah\n\"ziplist\"\n127.0.0.1:6379> rpush blah \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n(integer) 5\n127.0.0.1:6379> object encoding blah\n\"linkedlist\"\n```\n\n\n\n示例2：保存的元素数量过多而进行编码转换的情况。\n\n```bash\n# 俩比偶对象包含512个元素。\n127.0.0.1:6379> eval \"for i=1, 512 do redis.call('rpush', KEYS[1], i)end\" 1 \"integers\"\n(nil)\n# 获取列表长度.\n127.0.0.1:6379> llen integers\n(integer) 512\n127.0.0.1:6379> object encoding integers\n\"ziplist\"\n\n# 再向列表对象推入一个新元素，使得对象保存的元素数量达到513个。\n127.0.0.1:6379> rpush integers 512\n(integer) 513\n127.0.0.1:6379> object encoding integers\n\"linkedlist\"\n```\n\n\n\n### 4 哈希对象\n\n哈希对象的编码可以是`ziplist`或者`hashtable`。\n\n- **ziplist编码**：ziplist编码作为哈希对象使用`压缩列表`作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。因此，`保存了同一键值对的两个结点总是紧挨在一起的，键结点在前，值结点在后`。\n\n- **hashtable编码**: 哈希对象使用`字典`作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：字典中每个键/值都是一个字符串对象，对象中保存了键值对的键/值。\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> hset profile name \"Tom\"\n(integer) 1\n127.0.0.1:6379> hset profile age 25\n(integer) 1\n127.0.0.1:6379> hset profile career \"Programmer\"\n(integer) 1\n```\n\n\n\nziplist编码的profile哈希对象的底层实现如下：\n\n![ziplist编码的profile哈希对象的底层实现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的profile哈希对象的底层实现.png)\n\n\n\nhashtable编码的profile哈希对象底层实现如下：\n\n![hashtable编码的profile哈希对象底层实现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/hashtable编码的profile哈希对象底层实现.png)\n\n#### 4.1 编码转换\n\n**问: 什么情况下，哈希对象使用ziplist编码？**\n\n当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：\n\n- ①、哈希对象保存的所有键值对的键和值的字符串长度都小于64字节（`hash-max-ziplist-value`）；\n- ②、哈希对象保存的键值对数量小于512个（`hash-max-ziplist-entries`）；\n\n当以上两个条件任何一个不满足时，都会进行编码装换为hashtable。\n\n\n\n示例1：键值对的键太大而引起的编码转换。\n\n```bash\n127.0.0.1:6379> hset book name \"Mastering C++ in 21 days\"\n(integer) 1\n127.0.0.1:6379> object encoding book\n\"ziplist\"\n127.0.0.1:6379> hset book long_long_long_long_long_long_long_long_long_long_long_long_long_long_description \"content\"\n(integer) 1\n127.0.0.1:6379> object encoding book\n\"hashtable\"\n```\n\n\n\n示例2： 哈希对象因为包含的键值对数量过多而引起编码转换。\n\n```bash\n127.0.0.1:6379> EVAL \"for i=1, 512 do redis.call('HSET', KEYS[1], i, i)end\" 1 \"numbers\"\n(nil)\n127.0.0.1:6379> hlen numbers\n(integer) 512\n127.0.0.1:6379> object encoding numbers\n\"ziplist\"\n127.0.0.1:6379> hmset numbers \"key\" \"value\"\nOK\n127.0.0.1:6379> object encoding numbers\n\"hashtable\"\n```\n\n\n\n### 5 集合对象\n\n集合对象的编码可以是`intset`或者`hashtable`。\n\n- intset编码的集合对象: 使用`整数集合`作为底层实现，集合对象包含的所有元素都被存在整数集合里。\n- hashtable编码的集合对象: 使用`字典`作为底层实现，`字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为null。`\n\n\n\n示例：\n\n```bash\n# intset\n127.0.0.1:6379> sadd numbers 1 3 5\n(integer) 3\n127.0.0.1:6379> object encoding numbers\n\"intset\"\n\n#hashtable\n127.0.0.1:6379> sadd fruits \"apple\" \"banana\" \"cherry\"\n(integer) 3\n127.0.0.1:6379> object encoding fruits\n\"hashtable\"\n```\n\n\n\nintset编码的numbers集合对象\n\n![intset编码的numbers集合对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/intset编码的numbers集合对象.png)\n\nhashtable编码的fruits集合对象\n\n![hashtable编码的fruits集合对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/hashtable编码的fruits集合对象.png)\n\n#### 5.1 编码的转换\n\n**问: 什么情况下，集合对象使用intset编码？**\n\n当集合对象同时满足以下两个条件时，对象使用intset编码：\n\n- ①、结合兑现个保存的所有元素都是整数值；\n- ②、集合对象保存的元素数量不超过512个（`set-max-intset-entries`）。\n\n当其中一个条件不满足时，intset编码方式将自动变为hashtable编码方式。\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> sadd numbers 1 3 5\n(integer) 3\n127.0.0.1:6379> object encoding numbers\n\"intset\"\n127.0.0.1:6379> sadd numbers \"seven\" # 添加非整数元素, 使得集合编码变为为hashtable.\n(integer) 1\n127.0.0.1:6379> object encoding numbers\n\"hashtable\"\n```\n\n\n\n### 6 有序集合对象\n\n有序集合的编码可以是`ziplist`或者`skiplist`。\n\n- **ziplist编码**：ziplist编码的压缩列表对象使用`压缩列表`作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，`第一个节点保存元素的成员，第二个元素保存元素的分值`。`压缩列表内的集合元素按分值从小到大进行排序`，分值较小的元素被放置在靠近表头的方向，分值较大的元素则被放置在靠近表尾的方向。\n\n- **skiplist编码**：skiplist编码的有序集合对象使用`zset结构`作为底层实现，`一个zset结构同时包含一个字典和一个跳跃表`。\n\n\n\nzset结构如下：\n\n```c\ntypedef struct zset {\n    // 该字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了元素的成员，字典的值则保存了元素的分值。\n    dict *dict;\n    // 按分值从小到大保存了所有集合的元素。\n    zskiplist *zsl;\n} zset;\n```\n\n*注：有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。<u>跳跃表和字典均是通过指针来共享元素的成员和分值，因此同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会因此而浪费额外的内存</u>。*\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> zadd price 8.5 apple 5.0 banana 6.0 cherry\n(integer) 3\n```\n\n\n\nziplist编码的price对象：\n\n![ziplist编码的price对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的price对象.png)\n\n\n\nskiplist编码的price对象：\n\n![skiplist编码的price对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/skiplist编码的price对象.png)\n\n\n\n**问: 为什么有序集合需要同时使用跳跃表和字典来实现？**\n\n理论上，有序集合可以单独使用字典或者跳跃表的其中一个数据结构来实现，但无论单独使用字典还是跳跃表，其性能上对比同时视同字典和跳跃表都会有所降低。\n\n- 若单独使用字典来实现有序集合，那么虽然查找时时间复杂度保留，仍然是O(1)，但是当执行范围操作时，程序都要需要对所有元素进行排序操作。而完成排序操作至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间用于保存排序后的数组。\n- 若单独使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1上升为O(logN)。\n\n\n\n### 7 内存回收\n\nRedis在自己的对象系统中构建了一个`引用计数`技术实现内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象，并进行内存回收。\n\n每个对象的计数信息由`redisObject结构`中有一个`refcount属性`记录：\n\n```c\ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用计数。\n    int refcount;\n    void *ptr;\n} robj;\n```\n\n\n\n对象的引用计数信息会随着对象的使用状态而不断变化：\n\n- ①、在创建一个新对象时，引用计数的值会被初始化为1；\n- ②、当对象被一个新程序使用时，它的引用计数值会被赠一；\n- ③、当对象不再被一个程序引用时，它的引用计数值会被减一；\n- ④、当对象的引用计数值变为0时，对象所占用的内存会被释放掉。\n\n通过以下命令可以查键对应的值对象的引用计数：\n\n`object refcount xxx`\n\n\n\n示例：\n\n```\n127.0.0.1:6379> set a 100\nOK\n127.0.0.1:6379> object refcount a\n(integer) 2\n```\n\n**问: 为什么此处引用计数是为2呢？**\n\n因为对象引用计数属性还带有对象共享的作用，redis在初始化服务器时，创建一万个字符对象，这些对象包括从0到9999的所有整数值，当服务器需要用到这些值时，服务器就会使用这些共享对象，而不是新创建对象。\n\n\n\n此处持有这个值对象的两个程序分别是，其示意图如下：\n\n- ①、这个值对象的服务器程序；\n- ②、共享这个值对象的键a；\n\n![持有同一值对象的两个程序](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/持有同一值对象的两个程序.png)\n\n注：Redis会共享值为0~9999的字符串对象。\n\n\n\n**问: 为什么Redis不共享包含字符串的对象？**\n\n当服务器服务器考虑将一个共享对象设置为键的值对象时，程序需要先根据给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就越高，消耗的CPU时间也会越多。\n\n- 若共享对象是保存的整数值的字符串对象，那么验证操作的复杂度就是O(1).\n- 若共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)。\n- 若共享对象是包含多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。\n\n因此，尽管共享更复杂的对象可以节约更多的内存，但是收到CPU时间的限制，Redis值对包含整数值的字符串对象进行共享。\n\n\n\n### 8 对象的空转时长\n\nredisObject结构还包含一个`lru属性`，该属性`用于记录对象最后一次被命令程序访问的时间`：\n\n```c\ntypedef struct redisObject {\n    // 类型.\n    unsigned type:4;\n    // 编码.\n    unsigned encoding:4;\n    // 记录了对象最后一次被命令程序访问的时间。\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用次数\n    int refcount;\n    // 指向底层实现数据结构的指针。\n    void *ptr;\n} robj;\n```\n\n`空转时长`：通过当前时间减去键的值对象的lru时间计算得出的，通过以下命令可打印出给定键的空转时长：\n\n`object idletime xxx`\n\n*注：该命令的实现是特殊的，执行时并不会修改值的lru属性。*\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> set msg \"hello world\"\nOK\n127.0.0.1:6379> object idletime msg\n(integer) 8\n# 访问msg键的值\n127.0.0.1:6379> get msg\n\"hello world\"\n# 键处于活跃状态，空转时长为0.\n127.0.0.1:6379> object idletime msg\n(integer) 0\n```\n\n空转时长还有一项作用，若服务器打开了`maxmemory`选项，并且服务器用于回收内存算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那么部分键会优先被服务器释放，从而回收内存。\n\n\n\n### 参考资料\n\n1.redis设计与实现（第二版） 黄健宏","source":"_posts/Redis设计与实现-Redis对象.md","raw":"---\ntitle: Redis设计与实现-Redis对象\ndate: 2020-08-31 17:14:48\ntags: [\"Redis\",\"Note\"]\ncategories: [\"Redis\", \"Note\", \"Redis设计与实现\"]\n---\n\n\n\nRedis基于其数据结构（例如，SDS、双端链表、字典、压缩列表、整数集合等）创建了一个对象系统，该系统包含`字符串对象`、`列表对象`、`哈希对象`、`集合对象`和`有序集合`对象这五种对象，每种对象都用到了至少一种数据结构。\n\n<!--more-->\n\n### 1 对象的类型与编码\n\nRedis使用`对象`来表示数据库中的健和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的健（键对象），另一个对象用作键值对的值（值对象）。\n\n\n\nRedis中每个对都由`redisObject`结构表示，如下所示：\n\n```c\ntypedef struct redisObject {\n    // 类型.\n    unsigned type:4;\n    // 编码.\n    unsigned encoding:4;\n    // 记录了对象最后一次被命令程序访问的时间。\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用次数\n    int refcount;\n    // 指向底层实现数据结构的指针。\n    void *ptr;\n} robj;\n```\n\n\n\n#### 1.1 类型\n\n对象的type属性记录了对象的类型，这个类型包括以下5中类型：\n\n- **REDIS_STRING**：字符串对象(type命令输出：“string”)\n- **REDIS_LIST**：列表对象(type命令输出：“list”)\n- **REDIS_HASH**：哈希对象(type命令输出：“hash”)\n- **REDIS_SET**：集合对象(type命令输出：“set”)\n- **REDIS_ZSET**：有序集合对象(type命令输出：“zset”)\n\n*使用`type命令`可以返回**数据库键对应的值对象类型***\n\n\n\n*对于Redis数据库保存的`键值`对来说，<u>键总是一个字符串对象</u>，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的一种，因此我们称“XX键”表示这个数据库键所对应的值为XX对象。*\n\n\n\n#### 1.2 编码和底层实现\n\n对象的`ptr`指向对象的底层实现数据结构，而这些数据结构由对象的`encoding`属性决定。\n\nencoding对象属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现，其对象的编码如下：\n\n- **REDIS_ENCODING_INT**：long类型的整数(object encoding命令输出：int)\n- **REDIS_ENCODING_EMBSTR**：embstr编码的简单动态字符串(object encoding命令输出：embstr)\n- **REDIS_ENCODING_RAW**：简单动态字符串(object encoding命令输出：raw)\n- **REDIS_ENCODING_HT**：字典(object encoding命令输出：hashtable)\n- **REDIS_ENCODING_LINKEDLIST**：双端链表(object encoding命令输出：linkedlist)\n- **REDIS_ENCODING_ZIPLIST**：压缩列表(object encoding命令输出：ziplist)\n- **REDIS_ENCODING_INTSET**：整数集合(object encoding命令输出：intset)\n- **REDIS_ENCODING_SKIPLIST**：跳跃表和字典(object encoding命令输出：skiplist)\n\n\n\n每种类型的对象都至少使用了两种不同的编码，如下所示：\n\n![每种类型的对象都至少使用了两种不同的编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/每种类型的对象都至少使用了两种不同的编码.png)\n\n*使用`object encoding命令`可以**查看一个数据库键的值对象的编码***\n\n\n\n**为什么Redis要使用encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码？**\n\n因为使用encoding属性设定编码方式可以<u>根据不同的适用场景设置不同的编码，从而优化对象在某一场景下的效率。</u>例如，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现，压缩列表比双向链表更节约内存，且在元素数量较少是，在内存中以连续块方式保存的压缩列表比起双向链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，是用压缩列表来保存元素的优势逐渐消失，对象就会将底层实现从压缩列表转向功能更强、也更合适保存大量元素的双端链表上。\n\n### 2 字符串对象\n\n字符串对象的编码可以是`int`、`raw`、`embstr`。\n\n- **int**：字符串对象保存的是`整数值，并且这个整数值可以用long类型类表示`，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *装换成long），并将字符串对象的编码设置为int。\n- **raw**：字符串对象保存的是一个`字符串值，并且这个字符串值的长度大于32字节`，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。\n- **embstr**：字符串对象保存的是一个`字符串值，并且这个字符串值的长度小于等于32字节`，那么字符串对象将使用embstr编码的方式来保存这个字符串值。\n\n示例：\n\n```bash\n127.0.0.1:6379> set number 10086\nOK\n127.0.0.1:6379> object encoding number\n\"int\"\n\n127.0.0.1:6379> set story \"Long, long ago there lived a king and a queen, they have a beautiful daughter...\"\nOK\n127.0.0.1:6379> strlen story\n(integer) 80\n127.0.0.1:6379> object encoding story\n\"raw\"\n\n127.0.0.1:6379> set msg \"hello\"\nOK\n127.0.0.1:6379> object encoding msg\n\"embstr\"\n```\n\n\n\n**问: 既然有raw编码方式，为什么还要有embstr编码呢？它们有什么异同点？**\n\n- 相同点:\n\n  - embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw一样，都是用redisObject结构和sdshdr结构来表示字符串对象。\n\n- 不同点：\n\n  - raw编码会<u>调用两次内存分配函数</u>分别创建redisObject结构和sdshdr结构。\n\n  - embstr则通过调用一次内存分配函数来分配<u>一块连续的空间</u>，空间中依次包含redisObject和sdshdr两个结构。\n\n    \n\n    embstr编码创建的内存块结构如下：\n\n![embstr编码创建的内存块结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/embstr编码创建的内存块结构.png)\n\n\n\n**问: 使用embstr编码的字符串对象来保存短字符串值有什么好处？**\n\n- ①、embstr编码将创建的字符串对象所需的内存分配次数从raw编码的两次降低为一次。\n- ②、释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。\n- ③、embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比raw编码的字符串对象能更好的利用缓存带来的优势。\n\n\n\n注：`long double类型表示的浮点数在Redis中也是作为字符串值来保存的`, 如下示例所示：\n\n```bash\n127.0.0.1:6379> set pi 3.14\nOK\n127.0.0.1:6379> object encoding pi\n\"embstr\"\n```\n\n\n\n下图为字符串对象保存各类型值的编码方式：\n\n![字符串对象保存各类型值的编码方式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/字符串对象保存各类型值的编码方式.png)\n\n\n\n#### 2.1 编码转换\n\n`int编码`的字符串对象和`embstr编码`的字符串对象在条件满足的情况下，会被转换为`raw编码`的字符串对象。\n\n- **int编码->raw编码**：执行一些命令，使得对象保存的值不再是整数值，而是一个字符串值时。例如APPEND命令。\n- **embstr编码->raw编码**：Redis并没有为embstr编码提供任何修改程序，因此`实际上embstr编码的字符串是只读的`，当对embstr编码的字符串进行修改时，程序会先将对象的编码从embstr转换为raw，再执行修改命令。\n\n\n\n示例1：\n\n```bash\n127.0.0.1:6379> set number 10086\nOK\n127.0.0.1:6379> object encoding number\n\"int\"\n127.0.0.1:6379> append number \" is a good number!\" # 使用append命令将对象变为一个字符串.\n(integer) 23\n127.0.0.1:6379> get number\n\"10086 is a good number!\"\n127.0.0.1:6379> object encoding number\n\"raw\"\n```\n\n示例2：\n\n```bash\n127.0.0.1:6379> set msg \"hello word\"\nOK\n127.0.0.1:6379> object encoding msg\n\"embstr\"\n127.0.0.1:6379> append msg \" again!\" # embstr字符串是只读的,当对其进行修改时,将强制转换为raw编码,再进行修改.\n(integer) 17\n127.0.0.1:6379> object encoding msg\n\"raw\"\n```\n\n\n\n### 3 列表对象\n\n列表对象的编码可以是`ziplist`或者`linkedlist`。\n\n- ziplist编码的列表对象: 使用`压缩列表`作为底层实现，每个压缩列表结点(entry)保存了一个列表元素。\n- linkedlist编码的列表对象: 使用`双端链表`作为底层实现，每个双端链表结点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。\n\n\n\n示例1：\n\n```bash\n127.0.0.1:6379> rpush numbers 1 \"three\" 5\n(integer) 3\n```\n\n`ziplist编码`的numbers列表对象如下：\n\n![ziplist编码的numbers列表对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的numbers列表对象.png)\n\n\n\nlinkedlist编码的numbers列表对象如下：\n\n![linkedlist编码的numbers列表对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/linkedlist编码的numbers列表对象.png)\n\n\n\n其中完整的StringObject表示方式如下：\n\n![完整的StringObject表示方式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/完整的StringObject表示方式.png)\n\n#### 3.1 编码转换\n\n当列表对象可以同时满足以下两个条件时，列表对象使用`ziplist`编码。其他情况下需要使用`linkedlist`编码。\n\n- ①、列表对象保存的所有字符串元素的长度都小于64字节（由配置`list-max-ziplist-value`决定）；\n- ②、列表对象保存的元素数量小于512个（由配置`hash-max-ziplist-entries`决定）。\n\n\n\n示例1：保存长度太大的元素而进行编码转换的情况。\n\n```bash\n127.0.0.1:6379> rpush blah \"hello\" \"world\" \"again\"\n(integer) 3\n127.0.0.1:6379> object encoding blah\n\"ziplist\"\n127.0.0.1:6379> rpush blah \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n(integer) 5\n127.0.0.1:6379> object encoding blah\n\"linkedlist\"\n```\n\n\n\n示例2：保存的元素数量过多而进行编码转换的情况。\n\n```bash\n# 俩比偶对象包含512个元素。\n127.0.0.1:6379> eval \"for i=1, 512 do redis.call('rpush', KEYS[1], i)end\" 1 \"integers\"\n(nil)\n# 获取列表长度.\n127.0.0.1:6379> llen integers\n(integer) 512\n127.0.0.1:6379> object encoding integers\n\"ziplist\"\n\n# 再向列表对象推入一个新元素，使得对象保存的元素数量达到513个。\n127.0.0.1:6379> rpush integers 512\n(integer) 513\n127.0.0.1:6379> object encoding integers\n\"linkedlist\"\n```\n\n\n\n### 4 哈希对象\n\n哈希对象的编码可以是`ziplist`或者`hashtable`。\n\n- **ziplist编码**：ziplist编码作为哈希对象使用`压缩列表`作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。因此，`保存了同一键值对的两个结点总是紧挨在一起的，键结点在前，值结点在后`。\n\n- **hashtable编码**: 哈希对象使用`字典`作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：字典中每个键/值都是一个字符串对象，对象中保存了键值对的键/值。\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> hset profile name \"Tom\"\n(integer) 1\n127.0.0.1:6379> hset profile age 25\n(integer) 1\n127.0.0.1:6379> hset profile career \"Programmer\"\n(integer) 1\n```\n\n\n\nziplist编码的profile哈希对象的底层实现如下：\n\n![ziplist编码的profile哈希对象的底层实现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的profile哈希对象的底层实现.png)\n\n\n\nhashtable编码的profile哈希对象底层实现如下：\n\n![hashtable编码的profile哈希对象底层实现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/hashtable编码的profile哈希对象底层实现.png)\n\n#### 4.1 编码转换\n\n**问: 什么情况下，哈希对象使用ziplist编码？**\n\n当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：\n\n- ①、哈希对象保存的所有键值对的键和值的字符串长度都小于64字节（`hash-max-ziplist-value`）；\n- ②、哈希对象保存的键值对数量小于512个（`hash-max-ziplist-entries`）；\n\n当以上两个条件任何一个不满足时，都会进行编码装换为hashtable。\n\n\n\n示例1：键值对的键太大而引起的编码转换。\n\n```bash\n127.0.0.1:6379> hset book name \"Mastering C++ in 21 days\"\n(integer) 1\n127.0.0.1:6379> object encoding book\n\"ziplist\"\n127.0.0.1:6379> hset book long_long_long_long_long_long_long_long_long_long_long_long_long_long_description \"content\"\n(integer) 1\n127.0.0.1:6379> object encoding book\n\"hashtable\"\n```\n\n\n\n示例2： 哈希对象因为包含的键值对数量过多而引起编码转换。\n\n```bash\n127.0.0.1:6379> EVAL \"for i=1, 512 do redis.call('HSET', KEYS[1], i, i)end\" 1 \"numbers\"\n(nil)\n127.0.0.1:6379> hlen numbers\n(integer) 512\n127.0.0.1:6379> object encoding numbers\n\"ziplist\"\n127.0.0.1:6379> hmset numbers \"key\" \"value\"\nOK\n127.0.0.1:6379> object encoding numbers\n\"hashtable\"\n```\n\n\n\n### 5 集合对象\n\n集合对象的编码可以是`intset`或者`hashtable`。\n\n- intset编码的集合对象: 使用`整数集合`作为底层实现，集合对象包含的所有元素都被存在整数集合里。\n- hashtable编码的集合对象: 使用`字典`作为底层实现，`字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为null。`\n\n\n\n示例：\n\n```bash\n# intset\n127.0.0.1:6379> sadd numbers 1 3 5\n(integer) 3\n127.0.0.1:6379> object encoding numbers\n\"intset\"\n\n#hashtable\n127.0.0.1:6379> sadd fruits \"apple\" \"banana\" \"cherry\"\n(integer) 3\n127.0.0.1:6379> object encoding fruits\n\"hashtable\"\n```\n\n\n\nintset编码的numbers集合对象\n\n![intset编码的numbers集合对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/intset编码的numbers集合对象.png)\n\nhashtable编码的fruits集合对象\n\n![hashtable编码的fruits集合对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/hashtable编码的fruits集合对象.png)\n\n#### 5.1 编码的转换\n\n**问: 什么情况下，集合对象使用intset编码？**\n\n当集合对象同时满足以下两个条件时，对象使用intset编码：\n\n- ①、结合兑现个保存的所有元素都是整数值；\n- ②、集合对象保存的元素数量不超过512个（`set-max-intset-entries`）。\n\n当其中一个条件不满足时，intset编码方式将自动变为hashtable编码方式。\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> sadd numbers 1 3 5\n(integer) 3\n127.0.0.1:6379> object encoding numbers\n\"intset\"\n127.0.0.1:6379> sadd numbers \"seven\" # 添加非整数元素, 使得集合编码变为为hashtable.\n(integer) 1\n127.0.0.1:6379> object encoding numbers\n\"hashtable\"\n```\n\n\n\n### 6 有序集合对象\n\n有序集合的编码可以是`ziplist`或者`skiplist`。\n\n- **ziplist编码**：ziplist编码的压缩列表对象使用`压缩列表`作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，`第一个节点保存元素的成员，第二个元素保存元素的分值`。`压缩列表内的集合元素按分值从小到大进行排序`，分值较小的元素被放置在靠近表头的方向，分值较大的元素则被放置在靠近表尾的方向。\n\n- **skiplist编码**：skiplist编码的有序集合对象使用`zset结构`作为底层实现，`一个zset结构同时包含一个字典和一个跳跃表`。\n\n\n\nzset结构如下：\n\n```c\ntypedef struct zset {\n    // 该字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了元素的成员，字典的值则保存了元素的分值。\n    dict *dict;\n    // 按分值从小到大保存了所有集合的元素。\n    zskiplist *zsl;\n} zset;\n```\n\n*注：有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。<u>跳跃表和字典均是通过指针来共享元素的成员和分值，因此同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会因此而浪费额外的内存</u>。*\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> zadd price 8.5 apple 5.0 banana 6.0 cherry\n(integer) 3\n```\n\n\n\nziplist编码的price对象：\n\n![ziplist编码的price对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的price对象.png)\n\n\n\nskiplist编码的price对象：\n\n![skiplist编码的price对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/skiplist编码的price对象.png)\n\n\n\n**问: 为什么有序集合需要同时使用跳跃表和字典来实现？**\n\n理论上，有序集合可以单独使用字典或者跳跃表的其中一个数据结构来实现，但无论单独使用字典还是跳跃表，其性能上对比同时视同字典和跳跃表都会有所降低。\n\n- 若单独使用字典来实现有序集合，那么虽然查找时时间复杂度保留，仍然是O(1)，但是当执行范围操作时，程序都要需要对所有元素进行排序操作。而完成排序操作至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间用于保存排序后的数组。\n- 若单独使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1上升为O(logN)。\n\n\n\n### 7 内存回收\n\nRedis在自己的对象系统中构建了一个`引用计数`技术实现内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象，并进行内存回收。\n\n每个对象的计数信息由`redisObject结构`中有一个`refcount属性`记录：\n\n```c\ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用计数。\n    int refcount;\n    void *ptr;\n} robj;\n```\n\n\n\n对象的引用计数信息会随着对象的使用状态而不断变化：\n\n- ①、在创建一个新对象时，引用计数的值会被初始化为1；\n- ②、当对象被一个新程序使用时，它的引用计数值会被赠一；\n- ③、当对象不再被一个程序引用时，它的引用计数值会被减一；\n- ④、当对象的引用计数值变为0时，对象所占用的内存会被释放掉。\n\n通过以下命令可以查键对应的值对象的引用计数：\n\n`object refcount xxx`\n\n\n\n示例：\n\n```\n127.0.0.1:6379> set a 100\nOK\n127.0.0.1:6379> object refcount a\n(integer) 2\n```\n\n**问: 为什么此处引用计数是为2呢？**\n\n因为对象引用计数属性还带有对象共享的作用，redis在初始化服务器时，创建一万个字符对象，这些对象包括从0到9999的所有整数值，当服务器需要用到这些值时，服务器就会使用这些共享对象，而不是新创建对象。\n\n\n\n此处持有这个值对象的两个程序分别是，其示意图如下：\n\n- ①、这个值对象的服务器程序；\n- ②、共享这个值对象的键a；\n\n![持有同一值对象的两个程序](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/持有同一值对象的两个程序.png)\n\n注：Redis会共享值为0~9999的字符串对象。\n\n\n\n**问: 为什么Redis不共享包含字符串的对象？**\n\n当服务器服务器考虑将一个共享对象设置为键的值对象时，程序需要先根据给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就越高，消耗的CPU时间也会越多。\n\n- 若共享对象是保存的整数值的字符串对象，那么验证操作的复杂度就是O(1).\n- 若共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)。\n- 若共享对象是包含多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。\n\n因此，尽管共享更复杂的对象可以节约更多的内存，但是收到CPU时间的限制，Redis值对包含整数值的字符串对象进行共享。\n\n\n\n### 8 对象的空转时长\n\nredisObject结构还包含一个`lru属性`，该属性`用于记录对象最后一次被命令程序访问的时间`：\n\n```c\ntypedef struct redisObject {\n    // 类型.\n    unsigned type:4;\n    // 编码.\n    unsigned encoding:4;\n    // 记录了对象最后一次被命令程序访问的时间。\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用次数\n    int refcount;\n    // 指向底层实现数据结构的指针。\n    void *ptr;\n} robj;\n```\n\n`空转时长`：通过当前时间减去键的值对象的lru时间计算得出的，通过以下命令可打印出给定键的空转时长：\n\n`object idletime xxx`\n\n*注：该命令的实现是特殊的，执行时并不会修改值的lru属性。*\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> set msg \"hello world\"\nOK\n127.0.0.1:6379> object idletime msg\n(integer) 8\n# 访问msg键的值\n127.0.0.1:6379> get msg\n\"hello world\"\n# 键处于活跃状态，空转时长为0.\n127.0.0.1:6379> object idletime msg\n(integer) 0\n```\n\n空转时长还有一项作用，若服务器打开了`maxmemory`选项，并且服务器用于回收内存算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那么部分键会优先被服务器释放，从而回收内存。\n\n\n\n### 参考资料\n\n1.redis设计与实现（第二版） 黄健宏","slug":"Redis设计与实现-Redis对象","published":1,"updated":"2020-09-03T07:44:22.900Z","_id":"ckema1lg20000glg34llo5t1s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Redis基于其数据结构（例如，SDS、双端链表、字典、压缩列表、整数集合等）创建了一个对象系统，该系统包含<code>字符串对象</code>、<code>列表对象</code>、<code>哈希对象</code>、<code>集合对象</code>和<code>有序集合</code>对象这五种对象，每种对象都用到了至少一种数据结构。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-对象的类型与编码\"><a href=\"#1-对象的类型与编码\" class=\"headerlink\" title=\"1 对象的类型与编码\"></a>1 对象的类型与编码</h3><p>Redis使用<code>对象</code>来表示数据库中的健和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的健（键对象），另一个对象用作键值对的值（值对象）。</p>\n<p>Redis中每个对都由<code>redisObject</code>结构表示，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录了对象最后一次被命令程序访问的时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-1-类型\"><a href=\"#1-1-类型\" class=\"headerlink\" title=\"1.1 类型\"></a>1.1 类型</h4><p>对象的type属性记录了对象的类型，这个类型包括以下5中类型：</p>\n<ul>\n<li><strong>REDIS_STRING</strong>：字符串对象(type命令输出：“string”)</li>\n<li><strong>REDIS_LIST</strong>：列表对象(type命令输出：“list”)</li>\n<li><strong>REDIS_HASH</strong>：哈希对象(type命令输出：“hash”)</li>\n<li><strong>REDIS_SET</strong>：集合对象(type命令输出：“set”)</li>\n<li><strong>REDIS_ZSET</strong>：有序集合对象(type命令输出：“zset”)</li>\n</ul>\n<p><em>使用<code>type命令</code>可以返回<strong>数据库键对应的值对象类型</strong></em></p>\n<p><em>对于Redis数据库保存的<code>键值</code>对来说，<u>键总是一个字符串对象</u>，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的一种，因此我们称“XX键”表示这个数据库键所对应的值为XX对象。</em></p>\n<h4 id=\"1-2-编码和底层实现\"><a href=\"#1-2-编码和底层实现\" class=\"headerlink\" title=\"1.2 编码和底层实现\"></a>1.2 编码和底层实现</h4><p>对象的<code>ptr</code>指向对象的底层实现数据结构，而这些数据结构由对象的<code>encoding</code>属性决定。</p>\n<p>encoding对象属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现，其对象的编码如下：</p>\n<ul>\n<li><strong>REDIS_ENCODING_INT</strong>：long类型的整数(object encoding命令输出：int)</li>\n<li><strong>REDIS_ENCODING_EMBSTR</strong>：embstr编码的简单动态字符串(object encoding命令输出：embstr)</li>\n<li><strong>REDIS_ENCODING_RAW</strong>：简单动态字符串(object encoding命令输出：raw)</li>\n<li><strong>REDIS_ENCODING_HT</strong>：字典(object encoding命令输出：hashtable)</li>\n<li><strong>REDIS_ENCODING_LINKEDLIST</strong>：双端链表(object encoding命令输出：linkedlist)</li>\n<li><strong>REDIS_ENCODING_ZIPLIST</strong>：压缩列表(object encoding命令输出：ziplist)</li>\n<li><strong>REDIS_ENCODING_INTSET</strong>：整数集合(object encoding命令输出：intset)</li>\n<li><strong>REDIS_ENCODING_SKIPLIST</strong>：跳跃表和字典(object encoding命令输出：skiplist)</li>\n</ul>\n<p>每种类型的对象都至少使用了两种不同的编码，如下所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%83%BD%E8%87%B3%E5%B0%91%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E7%A0%81.png\" alt=\"每种类型的对象都至少使用了两种不同的编码\"></p>\n<p><em>使用<code>object encoding命令</code>可以<strong>查看一个数据库键的值对象的编码</strong></em></p>\n<p><strong>为什么Redis要使用encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码？</strong></p>\n<p>因为使用encoding属性设定编码方式可以<u>根据不同的适用场景设置不同的编码，从而优化对象在某一场景下的效率。</u>例如，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现，压缩列表比双向链表更节约内存，且在元素数量较少是，在内存中以连续块方式保存的压缩列表比起双向链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，是用压缩列表来保存元素的优势逐渐消失，对象就会将底层实现从压缩列表转向功能更强、也更合适保存大量元素的双端链表上。</p>\n<h3 id=\"2-字符串对象\"><a href=\"#2-字符串对象\" class=\"headerlink\" title=\"2 字符串对象\"></a>2 字符串对象</h3><p>字符串对象的编码可以是<code>int</code>、<code>raw</code>、<code>embstr</code>。</p>\n<ul>\n<li><strong>int</strong>：字符串对象保存的是<code>整数值，并且这个整数值可以用long类型类表示</code>，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *装换成long），并将字符串对象的编码设置为int。</li>\n<li><strong>raw</strong>：字符串对象保存的是一个<code>字符串值，并且这个字符串值的长度大于32字节</code>，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li>\n<li><strong>embstr</strong>：字符串对象保存的是一个<code>字符串值，并且这个字符串值的长度小于等于32字节</code>，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> number 10086</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;int&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> story <span class=\"string\">&quot;Long, long ago there lived a king and a queen, they have a beautiful daughter...&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; strlen story</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 80</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding story</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>问: 既然有raw编码方式，为什么还要有embstr编码呢？它们有什么异同点？</strong></p>\n<ul>\n<li><p>相同点:</p>\n<ul>\n<li>embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw一样，都是用redisObject结构和sdshdr结构来表示字符串对象。</li>\n</ul>\n</li>\n<li><p>不同点：</p>\n<ul>\n<li><p>raw编码会<u>调用两次内存分配函数</u>分别创建redisObject结构和sdshdr结构。</p>\n</li>\n<li><p>embstr则通过调用一次内存分配函数来分配<u>一块连续的空间</u>，空间中依次包含redisObject和sdshdr两个结构。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>embstr编码创建的内存块结构如下：</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/embstr%E7%BC%96%E7%A0%81%E5%88%9B%E5%BB%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E7%BB%93%E6%9E%84.png\" alt=\"embstr编码创建的内存块结构\"></p>\n<p><strong>问: 使用embstr编码的字符串对象来保存短字符串值有什么好处？</strong></p>\n<ul>\n<li>①、embstr编码将创建的字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li>\n<li>②、释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li>\n<li>③、embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比raw编码的字符串对象能更好的利用缓存带来的优势。</li>\n</ul>\n<p>注：<code>long double类型表示的浮点数在Redis中也是作为字符串值来保存的</code>, 如下示例所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> pi 3.14</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding pi</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>下图为字符串对象保存各类型值的编码方式：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E4%BF%9D%E5%AD%98%E5%90%84%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png\" alt=\"字符串对象保存各类型值的编码方式\"></p>\n<h4 id=\"2-1-编码转换\"><a href=\"#2-1-编码转换\" class=\"headerlink\" title=\"2.1 编码转换\"></a>2.1 编码转换</h4><p><code>int编码</code>的字符串对象和<code>embstr编码</code>的字符串对象在条件满足的情况下，会被转换为<code>raw编码</code>的字符串对象。</p>\n<ul>\n<li><strong>int编码-&gt;raw编码</strong>：执行一些命令，使得对象保存的值不再是整数值，而是一个字符串值时。例如APPEND命令。</li>\n<li><strong>embstr编码-&gt;raw编码</strong>：Redis并没有为embstr编码提供任何修改程序，因此<code>实际上embstr编码的字符串是只读的</code>，当对embstr编码的字符串进行修改时，程序会先将对象的编码从embstr转换为raw，再执行修改命令。</li>\n</ul>\n<p>示例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> number 10086</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;int&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append number <span class=\"string\">&quot; is a good number!&quot;</span> <span class=\"comment\"># 使用append命令将对象变为一个字符串.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 23</span><br><span class=\"line\">127.0.0.1:6379&gt; get number</span><br><span class=\"line\"><span class=\"string\">&quot;10086 is a good number!&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>示例2：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello word&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append msg <span class=\"string\">&quot; again!&quot;</span> <span class=\"comment\"># embstr字符串是只读的,当对其进行修改时,将强制转换为raw编码,再进行修改.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 17</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-列表对象\"><a href=\"#3-列表对象\" class=\"headerlink\" title=\"3 列表对象\"></a>3 列表对象</h3><p>列表对象的编码可以是<code>ziplist</code>或者<code>linkedlist</code>。</p>\n<ul>\n<li>ziplist编码的列表对象: 使用<code>压缩列表</code>作为底层实现，每个压缩列表结点(entry)保存了一个列表元素。</li>\n<li>linkedlist编码的列表对象: 使用<code>双端链表</code>作为底层实现，每个双端链表结点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</li>\n</ul>\n<p>示例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush numbers 1 <span class=\"string\">&quot;three&quot;</span> 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n\n<p><code>ziplist编码</code>的numbers列表对象如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84numbers%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1.png\" alt=\"ziplist编码的numbers列表对象\"></p>\n<p>linkedlist编码的numbers列表对象如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/linkedlist%E7%BC%96%E7%A0%81%E7%9A%84numbers%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1.png\" alt=\"linkedlist编码的numbers列表对象\"></p>\n<p>其中完整的StringObject表示方式如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E5%AE%8C%E6%95%B4%E7%9A%84StringObject%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F.png\" alt=\"完整的StringObject表示方式\"></p>\n<h4 id=\"3-1-编码转换\"><a href=\"#3-1-编码转换\" class=\"headerlink\" title=\"3.1 编码转换\"></a>3.1 编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用<code>ziplist</code>编码。其他情况下需要使用<code>linkedlist</code>编码。</p>\n<ul>\n<li>①、列表对象保存的所有字符串元素的长度都小于64字节（由配置<code>list-max-ziplist-value</code>决定）；</li>\n<li>②、列表对象保存的元素数量小于512个（由配置<code>hash-max-ziplist-entries</code>决定）。</li>\n</ul>\n<p>示例1：保存长度太大的元素而进行编码转换的情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush blah <span class=\"string\">&quot;hello&quot;</span> <span class=\"string\">&quot;world&quot;</span> <span class=\"string\">&quot;again&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding blah</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush blah <span class=\"string\">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding blah</span><br><span class=\"line\"><span class=\"string\">&quot;linkedlist&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例2：保存的元素数量过多而进行编码转换的情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 俩比偶对象包含512个元素。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">eval</span> <span class=\"string\">&quot;for i=1, 512 do redis.call(&#x27;rpush&#x27;, KEYS[1], i)end&quot;</span> 1 <span class=\"string\">&quot;integers&quot;</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"comment\"># 获取列表长度.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; llen integers</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding integers</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再向列表对象推入一个新元素，使得对象保存的元素数量达到513个。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush integers 512</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 513</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding integers</span><br><span class=\"line\"><span class=\"string\">&quot;linkedlist&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-哈希对象\"><a href=\"#4-哈希对象\" class=\"headerlink\" title=\"4 哈希对象\"></a>4 哈希对象</h3><p>哈希对象的编码可以是<code>ziplist</code>或者<code>hashtable</code>。</p>\n<ul>\n<li><p><strong>ziplist编码</strong>：ziplist编码作为哈希对象使用<code>压缩列表</code>作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。因此，<code>保存了同一键值对的两个结点总是紧挨在一起的，键结点在前，值结点在后</code>。</p>\n</li>\n<li><p><strong>hashtable编码</strong>: 哈希对象使用<code>字典</code>作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：字典中每个键/值都是一个字符串对象，对象中保存了键值对的键/值。</p>\n</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hset profile name <span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hset profile age 25</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hset profile career <span class=\"string\">&quot;Programmer&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ziplist编码的profile哈希对象的底层实现如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84profile%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png\" alt=\"ziplist编码的profile哈希对象的底层实现\"></p>\n<p>hashtable编码的profile哈希对象底层实现如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/hashtable%E7%BC%96%E7%A0%81%E7%9A%84profile%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png\" alt=\"hashtable编码的profile哈希对象底层实现\"></p>\n<h4 id=\"4-1-编码转换\"><a href=\"#4-1-编码转换\" class=\"headerlink\" title=\"4.1 编码转换\"></a>4.1 编码转换</h4><p><strong>问: 什么情况下，哈希对象使用ziplist编码？</strong></p>\n<p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p>\n<ul>\n<li>①、哈希对象保存的所有键值对的键和值的字符串长度都小于64字节（<code>hash-max-ziplist-value</code>）；</li>\n<li>②、哈希对象保存的键值对数量小于512个（<code>hash-max-ziplist-entries</code>）；</li>\n</ul>\n<p>当以上两个条件任何一个不满足时，都会进行编码装换为hashtable。</p>\n<p>示例1：键值对的键太大而引起的编码转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hset book name <span class=\"string\">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding book</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hset book long_long_long_long_long_long_long_long_long_long_long_long_long_long_description <span class=\"string\">&quot;content&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding book</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例2： 哈希对象因为包含的键值对数量过多而引起编码转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; EVAL <span class=\"string\">&quot;for i=1, 512 do redis.call(&#x27;HSET&#x27;, KEYS[1], i, i)end&quot;</span> 1 <span class=\"string\">&quot;numbers&quot;</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; hlen numbers</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hmset numbers <span class=\"string\">&quot;key&quot;</span> <span class=\"string\">&quot;value&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-集合对象\"><a href=\"#5-集合对象\" class=\"headerlink\" title=\"5 集合对象\"></a>5 集合对象</h3><p>集合对象的编码可以是<code>intset</code>或者<code>hashtable</code>。</p>\n<ul>\n<li>intset编码的集合对象: 使用<code>整数集合</code>作为底层实现，集合对象包含的所有元素都被存在整数集合里。</li>\n<li>hashtable编码的集合对象: 使用<code>字典</code>作为底层实现，<code>字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为null。</code></li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># intset</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd numbers 1 3 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;intset&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#hashtable</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd fruits <span class=\"string\">&quot;apple&quot;</span> <span class=\"string\">&quot;banana&quot;</span> <span class=\"string\">&quot;cherry&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding fruits</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>intset编码的numbers集合对象</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/intset%E7%BC%96%E7%A0%81%E7%9A%84numbers%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png\" alt=\"intset编码的numbers集合对象\"></p>\n<p>hashtable编码的fruits集合对象</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/hashtable%E7%BC%96%E7%A0%81%E7%9A%84fruits%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png\" alt=\"hashtable编码的fruits集合对象\"></p>\n<h4 id=\"5-1-编码的转换\"><a href=\"#5-1-编码的转换\" class=\"headerlink\" title=\"5.1 编码的转换\"></a>5.1 编码的转换</h4><p><strong>问: 什么情况下，集合对象使用intset编码？</strong></p>\n<p>当集合对象同时满足以下两个条件时，对象使用intset编码：</p>\n<ul>\n<li>①、结合兑现个保存的所有元素都是整数值；</li>\n<li>②、集合对象保存的元素数量不超过512个（<code>set-max-intset-entries</code>）。</li>\n</ul>\n<p>当其中一个条件不满足时，intset编码方式将自动变为hashtable编码方式。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sadd numbers 1 3 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;intset&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd numbers <span class=\"string\">&quot;seven&quot;</span> <span class=\"comment\"># 添加非整数元素, 使得集合编码变为为hashtable.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-有序集合对象\"><a href=\"#6-有序集合对象\" class=\"headerlink\" title=\"6 有序集合对象\"></a>6 有序集合对象</h3><p>有序集合的编码可以是<code>ziplist</code>或者<code>skiplist</code>。</p>\n<ul>\n<li><p><strong>ziplist编码</strong>：ziplist编码的压缩列表对象使用<code>压缩列表</code>作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，<code>第一个节点保存元素的成员，第二个元素保存元素的分值</code>。<code>压缩列表内的集合元素按分值从小到大进行排序</code>，分值较小的元素被放置在靠近表头的方向，分值较大的元素则被放置在靠近表尾的方向。</p>\n</li>\n<li><p><strong>skiplist编码</strong>：skiplist编码的有序集合对象使用<code>zset结构</code>作为底层实现，<code>一个zset结构同时包含一个字典和一个跳跃表</code>。</p>\n</li>\n</ul>\n<p>zset结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 该字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了元素的成员，字典的值则保存了元素的分值。</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    <span class=\"comment\">// 按分值从小到大保存了所有集合的元素。</span></span><br><span class=\"line\">    zskiplist *zsl;</span><br><span class=\"line\">&#125; zset;</span><br></pre></td></tr></table></figure>\n\n<p><em>注：有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。<u>跳跃表和字典均是通过指针来共享元素的成员和分值，因此同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会因此而浪费额外的内存</u>。</em></p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zadd price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ziplist编码的price对象：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84price%E5%AF%B9%E8%B1%A1.png\" alt=\"ziplist编码的price对象\"></p>\n<p>skiplist编码的price对象：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/skiplist%E7%BC%96%E7%A0%81%E7%9A%84price%E5%AF%B9%E8%B1%A1.png\" alt=\"skiplist编码的price对象\"></p>\n<p><strong>问: 为什么有序集合需要同时使用跳跃表和字典来实现？</strong></p>\n<p>理论上，有序集合可以单独使用字典或者跳跃表的其中一个数据结构来实现，但无论单独使用字典还是跳跃表，其性能上对比同时视同字典和跳跃表都会有所降低。</p>\n<ul>\n<li>若单独使用字典来实现有序集合，那么虽然查找时时间复杂度保留，仍然是O(1)，但是当执行范围操作时，程序都要需要对所有元素进行排序操作。而完成排序操作至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间用于保存排序后的数组。</li>\n<li>若单独使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1上升为O(logN)。</li>\n</ul>\n<h3 id=\"7-内存回收\"><a href=\"#7-内存回收\" class=\"headerlink\" title=\"7 内存回收\"></a>7 内存回收</h3><p>Redis在自己的对象系统中构建了一个<code>引用计数</code>技术实现内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象，并进行内存回收。</p>\n<p>每个对象的计数信息由<code>redisObject结构</code>中有一个<code>refcount属性</code>记录：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>\n<ul>\n<li>①、在创建一个新对象时，引用计数的值会被初始化为1；</li>\n<li>②、当对象被一个新程序使用时，它的引用计数值会被赠一；</li>\n<li>③、当对象不再被一个程序引用时，它的引用计数值会被减一；</li>\n<li>④、当对象的引用计数值变为0时，对象所占用的内存会被释放掉。</li>\n</ul>\n<p>通过以下命令可以查键对应的值对象的引用计数：</p>\n<p><code>object refcount xxx</code></p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set a 100</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object refcount a</span><br><span class=\"line\">(integer) 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>问: 为什么此处引用计数是为2呢？</strong></p>\n<p>因为对象引用计数属性还带有对象共享的作用，redis在初始化服务器时，创建一万个字符对象，这些对象包括从0到9999的所有整数值，当服务器需要用到这些值时，服务器就会使用这些共享对象，而不是新创建对象。</p>\n<p>此处持有这个值对象的两个程序分别是，其示意图如下：</p>\n<ul>\n<li>①、这个值对象的服务器程序；</li>\n<li>②、共享这个值对象的键a；</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E6%8C%81%E6%9C%89%E5%90%8C%E4%B8%80%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%A8%8B%E5%BA%8F.png\" alt=\"持有同一值对象的两个程序\"></p>\n<p>注：Redis会共享值为0~9999的字符串对象。</p>\n<p><strong>问: 为什么Redis不共享包含字符串的对象？</strong></p>\n<p>当服务器服务器考虑将一个共享对象设置为键的值对象时，程序需要先根据给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就越高，消耗的CPU时间也会越多。</p>\n<ul>\n<li>若共享对象是保存的整数值的字符串对象，那么验证操作的复杂度就是O(1).</li>\n<li>若共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)。</li>\n<li>若共享对象是包含多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。</li>\n</ul>\n<p>因此，尽管共享更复杂的对象可以节约更多的内存，但是收到CPU时间的限制，Redis值对包含整数值的字符串对象进行共享。</p>\n<h3 id=\"8-对象的空转时长\"><a href=\"#8-对象的空转时长\" class=\"headerlink\" title=\"8 对象的空转时长\"></a>8 对象的空转时长</h3><p>redisObject结构还包含一个<code>lru属性</code>，该属性<code>用于记录对象最后一次被命令程序访问的时间</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录了对象最后一次被命令程序访问的时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n<p><code>空转时长</code>：通过当前时间减去键的值对象的lru时间计算得出的，通过以下命令可打印出给定键的空转时长：</p>\n<p><code>object idletime xxx</code></p>\n<p><em>注：该命令的实现是特殊的，执行时并不会修改值的lru属性。</em></p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object idletime msg</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 8</span><br><span class=\"line\"><span class=\"comment\"># 访问msg键的值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get msg</span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 键处于活跃状态，空转时长为0.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; object idletime msg</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n\n<p>空转时长还有一项作用，若服务器打开了<code>maxmemory</code>选项，并且服务器用于回收内存算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那么部分键会优先被服务器释放，从而回收内存。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>1.redis设计与实现（第二版） 黄健宏</p>\n","site":{"data":{}},"excerpt":"<p>Redis基于其数据结构（例如，SDS、双端链表、字典、压缩列表、整数集合等）创建了一个对象系统，该系统包含<code>字符串对象</code>、<code>列表对象</code>、<code>哈希对象</code>、<code>集合对象</code>和<code>有序集合</code>对象这五种对象，每种对象都用到了至少一种数据结构。</p>","more":"<h3 id=\"1-对象的类型与编码\"><a href=\"#1-对象的类型与编码\" class=\"headerlink\" title=\"1 对象的类型与编码\"></a>1 对象的类型与编码</h3><p>Redis使用<code>对象</code>来表示数据库中的健和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的健（键对象），另一个对象用作键值对的值（值对象）。</p>\n<p>Redis中每个对都由<code>redisObject</code>结构表示，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录了对象最后一次被命令程序访问的时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-1-类型\"><a href=\"#1-1-类型\" class=\"headerlink\" title=\"1.1 类型\"></a>1.1 类型</h4><p>对象的type属性记录了对象的类型，这个类型包括以下5中类型：</p>\n<ul>\n<li><strong>REDIS_STRING</strong>：字符串对象(type命令输出：“string”)</li>\n<li><strong>REDIS_LIST</strong>：列表对象(type命令输出：“list”)</li>\n<li><strong>REDIS_HASH</strong>：哈希对象(type命令输出：“hash”)</li>\n<li><strong>REDIS_SET</strong>：集合对象(type命令输出：“set”)</li>\n<li><strong>REDIS_ZSET</strong>：有序集合对象(type命令输出：“zset”)</li>\n</ul>\n<p><em>使用<code>type命令</code>可以返回<strong>数据库键对应的值对象类型</strong></em></p>\n<p><em>对于Redis数据库保存的<code>键值</code>对来说，<u>键总是一个字符串对象</u>，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的一种，因此我们称“XX键”表示这个数据库键所对应的值为XX对象。</em></p>\n<h4 id=\"1-2-编码和底层实现\"><a href=\"#1-2-编码和底层实现\" class=\"headerlink\" title=\"1.2 编码和底层实现\"></a>1.2 编码和底层实现</h4><p>对象的<code>ptr</code>指向对象的底层实现数据结构，而这些数据结构由对象的<code>encoding</code>属性决定。</p>\n<p>encoding对象属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现，其对象的编码如下：</p>\n<ul>\n<li><strong>REDIS_ENCODING_INT</strong>：long类型的整数(object encoding命令输出：int)</li>\n<li><strong>REDIS_ENCODING_EMBSTR</strong>：embstr编码的简单动态字符串(object encoding命令输出：embstr)</li>\n<li><strong>REDIS_ENCODING_RAW</strong>：简单动态字符串(object encoding命令输出：raw)</li>\n<li><strong>REDIS_ENCODING_HT</strong>：字典(object encoding命令输出：hashtable)</li>\n<li><strong>REDIS_ENCODING_LINKEDLIST</strong>：双端链表(object encoding命令输出：linkedlist)</li>\n<li><strong>REDIS_ENCODING_ZIPLIST</strong>：压缩列表(object encoding命令输出：ziplist)</li>\n<li><strong>REDIS_ENCODING_INTSET</strong>：整数集合(object encoding命令输出：intset)</li>\n<li><strong>REDIS_ENCODING_SKIPLIST</strong>：跳跃表和字典(object encoding命令输出：skiplist)</li>\n</ul>\n<p>每种类型的对象都至少使用了两种不同的编码，如下所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%83%BD%E8%87%B3%E5%B0%91%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E7%A0%81.png\" alt=\"每种类型的对象都至少使用了两种不同的编码\"></p>\n<p><em>使用<code>object encoding命令</code>可以<strong>查看一个数据库键的值对象的编码</strong></em></p>\n<p><strong>为什么Redis要使用encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码？</strong></p>\n<p>因为使用encoding属性设定编码方式可以<u>根据不同的适用场景设置不同的编码，从而优化对象在某一场景下的效率。</u>例如，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现，压缩列表比双向链表更节约内存，且在元素数量较少是，在内存中以连续块方式保存的压缩列表比起双向链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，是用压缩列表来保存元素的优势逐渐消失，对象就会将底层实现从压缩列表转向功能更强、也更合适保存大量元素的双端链表上。</p>\n<h3 id=\"2-字符串对象\"><a href=\"#2-字符串对象\" class=\"headerlink\" title=\"2 字符串对象\"></a>2 字符串对象</h3><p>字符串对象的编码可以是<code>int</code>、<code>raw</code>、<code>embstr</code>。</p>\n<ul>\n<li><strong>int</strong>：字符串对象保存的是<code>整数值，并且这个整数值可以用long类型类表示</code>，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *装换成long），并将字符串对象的编码设置为int。</li>\n<li><strong>raw</strong>：字符串对象保存的是一个<code>字符串值，并且这个字符串值的长度大于32字节</code>，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li>\n<li><strong>embstr</strong>：字符串对象保存的是一个<code>字符串值，并且这个字符串值的长度小于等于32字节</code>，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> number 10086</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;int&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> story <span class=\"string\">&quot;Long, long ago there lived a king and a queen, they have a beautiful daughter...&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; strlen story</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 80</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding story</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>问: 既然有raw编码方式，为什么还要有embstr编码呢？它们有什么异同点？</strong></p>\n<ul>\n<li><p>相同点:</p>\n<ul>\n<li>embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw一样，都是用redisObject结构和sdshdr结构来表示字符串对象。</li>\n</ul>\n</li>\n<li><p>不同点：</p>\n<ul>\n<li><p>raw编码会<u>调用两次内存分配函数</u>分别创建redisObject结构和sdshdr结构。</p>\n</li>\n<li><p>embstr则通过调用一次内存分配函数来分配<u>一块连续的空间</u>，空间中依次包含redisObject和sdshdr两个结构。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>embstr编码创建的内存块结构如下：</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/embstr%E7%BC%96%E7%A0%81%E5%88%9B%E5%BB%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E7%BB%93%E6%9E%84.png\" alt=\"embstr编码创建的内存块结构\"></p>\n<p><strong>问: 使用embstr编码的字符串对象来保存短字符串值有什么好处？</strong></p>\n<ul>\n<li>①、embstr编码将创建的字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li>\n<li>②、释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li>\n<li>③、embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比raw编码的字符串对象能更好的利用缓存带来的优势。</li>\n</ul>\n<p>注：<code>long double类型表示的浮点数在Redis中也是作为字符串值来保存的</code>, 如下示例所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> pi 3.14</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding pi</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>下图为字符串对象保存各类型值的编码方式：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E4%BF%9D%E5%AD%98%E5%90%84%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png\" alt=\"字符串对象保存各类型值的编码方式\"></p>\n<h4 id=\"2-1-编码转换\"><a href=\"#2-1-编码转换\" class=\"headerlink\" title=\"2.1 编码转换\"></a>2.1 编码转换</h4><p><code>int编码</code>的字符串对象和<code>embstr编码</code>的字符串对象在条件满足的情况下，会被转换为<code>raw编码</code>的字符串对象。</p>\n<ul>\n<li><strong>int编码-&gt;raw编码</strong>：执行一些命令，使得对象保存的值不再是整数值，而是一个字符串值时。例如APPEND命令。</li>\n<li><strong>embstr编码-&gt;raw编码</strong>：Redis并没有为embstr编码提供任何修改程序，因此<code>实际上embstr编码的字符串是只读的</code>，当对embstr编码的字符串进行修改时，程序会先将对象的编码从embstr转换为raw，再执行修改命令。</li>\n</ul>\n<p>示例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> number 10086</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;int&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append number <span class=\"string\">&quot; is a good number!&quot;</span> <span class=\"comment\"># 使用append命令将对象变为一个字符串.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 23</span><br><span class=\"line\">127.0.0.1:6379&gt; get number</span><br><span class=\"line\"><span class=\"string\">&quot;10086 is a good number!&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>示例2：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello word&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append msg <span class=\"string\">&quot; again!&quot;</span> <span class=\"comment\"># embstr字符串是只读的,当对其进行修改时,将强制转换为raw编码,再进行修改.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 17</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-列表对象\"><a href=\"#3-列表对象\" class=\"headerlink\" title=\"3 列表对象\"></a>3 列表对象</h3><p>列表对象的编码可以是<code>ziplist</code>或者<code>linkedlist</code>。</p>\n<ul>\n<li>ziplist编码的列表对象: 使用<code>压缩列表</code>作为底层实现，每个压缩列表结点(entry)保存了一个列表元素。</li>\n<li>linkedlist编码的列表对象: 使用<code>双端链表</code>作为底层实现，每个双端链表结点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</li>\n</ul>\n<p>示例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush numbers 1 <span class=\"string\">&quot;three&quot;</span> 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n\n<p><code>ziplist编码</code>的numbers列表对象如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84numbers%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1.png\" alt=\"ziplist编码的numbers列表对象\"></p>\n<p>linkedlist编码的numbers列表对象如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/linkedlist%E7%BC%96%E7%A0%81%E7%9A%84numbers%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1.png\" alt=\"linkedlist编码的numbers列表对象\"></p>\n<p>其中完整的StringObject表示方式如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E5%AE%8C%E6%95%B4%E7%9A%84StringObject%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F.png\" alt=\"完整的StringObject表示方式\"></p>\n<h4 id=\"3-1-编码转换\"><a href=\"#3-1-编码转换\" class=\"headerlink\" title=\"3.1 编码转换\"></a>3.1 编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用<code>ziplist</code>编码。其他情况下需要使用<code>linkedlist</code>编码。</p>\n<ul>\n<li>①、列表对象保存的所有字符串元素的长度都小于64字节（由配置<code>list-max-ziplist-value</code>决定）；</li>\n<li>②、列表对象保存的元素数量小于512个（由配置<code>hash-max-ziplist-entries</code>决定）。</li>\n</ul>\n<p>示例1：保存长度太大的元素而进行编码转换的情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush blah <span class=\"string\">&quot;hello&quot;</span> <span class=\"string\">&quot;world&quot;</span> <span class=\"string\">&quot;again&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding blah</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush blah <span class=\"string\">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding blah</span><br><span class=\"line\"><span class=\"string\">&quot;linkedlist&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例2：保存的元素数量过多而进行编码转换的情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 俩比偶对象包含512个元素。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">eval</span> <span class=\"string\">&quot;for i=1, 512 do redis.call(&#x27;rpush&#x27;, KEYS[1], i)end&quot;</span> 1 <span class=\"string\">&quot;integers&quot;</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"comment\"># 获取列表长度.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; llen integers</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding integers</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再向列表对象推入一个新元素，使得对象保存的元素数量达到513个。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush integers 512</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 513</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding integers</span><br><span class=\"line\"><span class=\"string\">&quot;linkedlist&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-哈希对象\"><a href=\"#4-哈希对象\" class=\"headerlink\" title=\"4 哈希对象\"></a>4 哈希对象</h3><p>哈希对象的编码可以是<code>ziplist</code>或者<code>hashtable</code>。</p>\n<ul>\n<li><p><strong>ziplist编码</strong>：ziplist编码作为哈希对象使用<code>压缩列表</code>作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。因此，<code>保存了同一键值对的两个结点总是紧挨在一起的，键结点在前，值结点在后</code>。</p>\n</li>\n<li><p><strong>hashtable编码</strong>: 哈希对象使用<code>字典</code>作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：字典中每个键/值都是一个字符串对象，对象中保存了键值对的键/值。</p>\n</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hset profile name <span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hset profile age 25</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hset profile career <span class=\"string\">&quot;Programmer&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ziplist编码的profile哈希对象的底层实现如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84profile%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png\" alt=\"ziplist编码的profile哈希对象的底层实现\"></p>\n<p>hashtable编码的profile哈希对象底层实现如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/hashtable%E7%BC%96%E7%A0%81%E7%9A%84profile%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png\" alt=\"hashtable编码的profile哈希对象底层实现\"></p>\n<h4 id=\"4-1-编码转换\"><a href=\"#4-1-编码转换\" class=\"headerlink\" title=\"4.1 编码转换\"></a>4.1 编码转换</h4><p><strong>问: 什么情况下，哈希对象使用ziplist编码？</strong></p>\n<p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p>\n<ul>\n<li>①、哈希对象保存的所有键值对的键和值的字符串长度都小于64字节（<code>hash-max-ziplist-value</code>）；</li>\n<li>②、哈希对象保存的键值对数量小于512个（<code>hash-max-ziplist-entries</code>）；</li>\n</ul>\n<p>当以上两个条件任何一个不满足时，都会进行编码装换为hashtable。</p>\n<p>示例1：键值对的键太大而引起的编码转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hset book name <span class=\"string\">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding book</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hset book long_long_long_long_long_long_long_long_long_long_long_long_long_long_description <span class=\"string\">&quot;content&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding book</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例2： 哈希对象因为包含的键值对数量过多而引起编码转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; EVAL <span class=\"string\">&quot;for i=1, 512 do redis.call(&#x27;HSET&#x27;, KEYS[1], i, i)end&quot;</span> 1 <span class=\"string\">&quot;numbers&quot;</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; hlen numbers</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hmset numbers <span class=\"string\">&quot;key&quot;</span> <span class=\"string\">&quot;value&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-集合对象\"><a href=\"#5-集合对象\" class=\"headerlink\" title=\"5 集合对象\"></a>5 集合对象</h3><p>集合对象的编码可以是<code>intset</code>或者<code>hashtable</code>。</p>\n<ul>\n<li>intset编码的集合对象: 使用<code>整数集合</code>作为底层实现，集合对象包含的所有元素都被存在整数集合里。</li>\n<li>hashtable编码的集合对象: 使用<code>字典</code>作为底层实现，<code>字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为null。</code></li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># intset</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd numbers 1 3 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;intset&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#hashtable</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd fruits <span class=\"string\">&quot;apple&quot;</span> <span class=\"string\">&quot;banana&quot;</span> <span class=\"string\">&quot;cherry&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding fruits</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>intset编码的numbers集合对象</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/intset%E7%BC%96%E7%A0%81%E7%9A%84numbers%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png\" alt=\"intset编码的numbers集合对象\"></p>\n<p>hashtable编码的fruits集合对象</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/hashtable%E7%BC%96%E7%A0%81%E7%9A%84fruits%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png\" alt=\"hashtable编码的fruits集合对象\"></p>\n<h4 id=\"5-1-编码的转换\"><a href=\"#5-1-编码的转换\" class=\"headerlink\" title=\"5.1 编码的转换\"></a>5.1 编码的转换</h4><p><strong>问: 什么情况下，集合对象使用intset编码？</strong></p>\n<p>当集合对象同时满足以下两个条件时，对象使用intset编码：</p>\n<ul>\n<li>①、结合兑现个保存的所有元素都是整数值；</li>\n<li>②、集合对象保存的元素数量不超过512个（<code>set-max-intset-entries</code>）。</li>\n</ul>\n<p>当其中一个条件不满足时，intset编码方式将自动变为hashtable编码方式。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sadd numbers 1 3 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;intset&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd numbers <span class=\"string\">&quot;seven&quot;</span> <span class=\"comment\"># 添加非整数元素, 使得集合编码变为为hashtable.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-有序集合对象\"><a href=\"#6-有序集合对象\" class=\"headerlink\" title=\"6 有序集合对象\"></a>6 有序集合对象</h3><p>有序集合的编码可以是<code>ziplist</code>或者<code>skiplist</code>。</p>\n<ul>\n<li><p><strong>ziplist编码</strong>：ziplist编码的压缩列表对象使用<code>压缩列表</code>作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，<code>第一个节点保存元素的成员，第二个元素保存元素的分值</code>。<code>压缩列表内的集合元素按分值从小到大进行排序</code>，分值较小的元素被放置在靠近表头的方向，分值较大的元素则被放置在靠近表尾的方向。</p>\n</li>\n<li><p><strong>skiplist编码</strong>：skiplist编码的有序集合对象使用<code>zset结构</code>作为底层实现，<code>一个zset结构同时包含一个字典和一个跳跃表</code>。</p>\n</li>\n</ul>\n<p>zset结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 该字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了元素的成员，字典的值则保存了元素的分值。</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    <span class=\"comment\">// 按分值从小到大保存了所有集合的元素。</span></span><br><span class=\"line\">    zskiplist *zsl;</span><br><span class=\"line\">&#125; zset;</span><br></pre></td></tr></table></figure>\n\n<p><em>注：有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。<u>跳跃表和字典均是通过指针来共享元素的成员和分值，因此同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会因此而浪费额外的内存</u>。</em></p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zadd price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ziplist编码的price对象：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84price%E5%AF%B9%E8%B1%A1.png\" alt=\"ziplist编码的price对象\"></p>\n<p>skiplist编码的price对象：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/skiplist%E7%BC%96%E7%A0%81%E7%9A%84price%E5%AF%B9%E8%B1%A1.png\" alt=\"skiplist编码的price对象\"></p>\n<p><strong>问: 为什么有序集合需要同时使用跳跃表和字典来实现？</strong></p>\n<p>理论上，有序集合可以单独使用字典或者跳跃表的其中一个数据结构来实现，但无论单独使用字典还是跳跃表，其性能上对比同时视同字典和跳跃表都会有所降低。</p>\n<ul>\n<li>若单独使用字典来实现有序集合，那么虽然查找时时间复杂度保留，仍然是O(1)，但是当执行范围操作时，程序都要需要对所有元素进行排序操作。而完成排序操作至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间用于保存排序后的数组。</li>\n<li>若单独使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1上升为O(logN)。</li>\n</ul>\n<h3 id=\"7-内存回收\"><a href=\"#7-内存回收\" class=\"headerlink\" title=\"7 内存回收\"></a>7 内存回收</h3><p>Redis在自己的对象系统中构建了一个<code>引用计数</code>技术实现内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象，并进行内存回收。</p>\n<p>每个对象的计数信息由<code>redisObject结构</code>中有一个<code>refcount属性</code>记录：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>\n<ul>\n<li>①、在创建一个新对象时，引用计数的值会被初始化为1；</li>\n<li>②、当对象被一个新程序使用时，它的引用计数值会被赠一；</li>\n<li>③、当对象不再被一个程序引用时，它的引用计数值会被减一；</li>\n<li>④、当对象的引用计数值变为0时，对象所占用的内存会被释放掉。</li>\n</ul>\n<p>通过以下命令可以查键对应的值对象的引用计数：</p>\n<p><code>object refcount xxx</code></p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set a 100</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object refcount a</span><br><span class=\"line\">(integer) 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>问: 为什么此处引用计数是为2呢？</strong></p>\n<p>因为对象引用计数属性还带有对象共享的作用，redis在初始化服务器时，创建一万个字符对象，这些对象包括从0到9999的所有整数值，当服务器需要用到这些值时，服务器就会使用这些共享对象，而不是新创建对象。</p>\n<p>此处持有这个值对象的两个程序分别是，其示意图如下：</p>\n<ul>\n<li>①、这个值对象的服务器程序；</li>\n<li>②、共享这个值对象的键a；</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E6%8C%81%E6%9C%89%E5%90%8C%E4%B8%80%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%A8%8B%E5%BA%8F.png\" alt=\"持有同一值对象的两个程序\"></p>\n<p>注：Redis会共享值为0~9999的字符串对象。</p>\n<p><strong>问: 为什么Redis不共享包含字符串的对象？</strong></p>\n<p>当服务器服务器考虑将一个共享对象设置为键的值对象时，程序需要先根据给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就越高，消耗的CPU时间也会越多。</p>\n<ul>\n<li>若共享对象是保存的整数值的字符串对象，那么验证操作的复杂度就是O(1).</li>\n<li>若共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)。</li>\n<li>若共享对象是包含多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。</li>\n</ul>\n<p>因此，尽管共享更复杂的对象可以节约更多的内存，但是收到CPU时间的限制，Redis值对包含整数值的字符串对象进行共享。</p>\n<h3 id=\"8-对象的空转时长\"><a href=\"#8-对象的空转时长\" class=\"headerlink\" title=\"8 对象的空转时长\"></a>8 对象的空转时长</h3><p>redisObject结构还包含一个<code>lru属性</code>，该属性<code>用于记录对象最后一次被命令程序访问的时间</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录了对象最后一次被命令程序访问的时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n<p><code>空转时长</code>：通过当前时间减去键的值对象的lru时间计算得出的，通过以下命令可打印出给定键的空转时长：</p>\n<p><code>object idletime xxx</code></p>\n<p><em>注：该命令的实现是特殊的，执行时并不会修改值的lru属性。</em></p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object idletime msg</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 8</span><br><span class=\"line\"><span class=\"comment\"># 访问msg键的值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get msg</span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 键处于活跃状态，空转时长为0.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; object idletime msg</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n\n<p>空转时长还有一项作用，若服务器打开了<code>maxmemory</code>选项，并且服务器用于回收内存算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那么部分键会优先被服务器释放，从而回收内存。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>1.redis设计与实现（第二版） 黄健宏</p>"},{"title":"Redis设计与实现-Redis键过期及删除策略","date":"2020-09-03T06:51:51.000Z","_content":"\n### 1 设置键的生存时间或过期时间\n\n通过以下命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置`生存时间`（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。\n\n<!--more-->\n\n- 以`秒`为单位设置过期时间命令：\n\n\n```\nEXPIRE key seconds\n```\n\n- 以`毫秒`为单位设置过期时间命令：\n\n\n```\nPEXPIRE key milliseconds\n```\n\n- 若过期时间是一个UNIX时间戳，以秒为单位设置过期时间命令:\n\n\n```\nEXPIREAT key timestamp\n```\n\n- 若过期时间是一个UNIX时间戳，以微秒为单位设置过期时间命令:\n\n\n```\nPEXPIREAT key milliseconds-timestamp\n```\n\n**注：虽然过期的单位及命令不同，但<u>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</u>。**\n\n\n\n#### 1.1 保存过期时间\n\nredisDb结构的`expires字典`保存了数据库中所有键的过期时间，我们称这个字典为过期字典。\n\n```c\ntypedef struct redisDb {\n    // ...\n    // 过期字典，保存着键的过期时间.\n    dict *expires;\n    // ...\n} redisDb;\n```\n\n其中，\n\n- 过期字典的`键是一个指针`，这个指针指向键空间中的某个键对象。（也就是某个数据库键）。\n- 过期字典的`值是一个long long类型的整数`，这个整数保存了键所指向的数据库键的过期时间——`一个毫秒精度的UNIX时间戳`。\n\n\n\n当客户端执行`PEXPIREAT`等命令设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。\n\n\n\n示例：带有过期字典的数据库示意图\n\n![带有过期字典的数据库示意图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis键过期及删除策略/带有过期字典的数据库示意图.png)\n\n\n\n其中，alphabet和book键对象出现了两次，实际上，键空间和过期字典的键都指向同一个键对象，所以并不会出现任何重复对象。\n\n\n\n#### 1.2 移除过期时间\n\n通过以下命令可以`移除一个键的过期时间`：\n\n```\nPERSIST <key>\n```\n\nPERSIST命令就是PEXPIREAT命令的反操作，PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联。\n\n\n\n#### 1.3 计算并返回剩余生存时间\n\n通过以下命令可以返回键的剩余生存时间：\n\n- ①、以秒为单位返回\n\n```\nTTL <key>\n```\n\n- ②、以毫秒为单位返回\n\n```\nPTTL <key>\n```\n\n\n\n### 2 过期删除策略\n\n**若一个键过期了，它什么时候会被删除呢？可能情况有哪些？**\n\n- ①、`定时删除`：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。\n- ②、`惰性删除`：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，吐过过期的话，就删除该键，如果没有过期，则返回该键。\n- ③、`定期删除`：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。\n\n\n\n#### 2.1 定时删除\n\n定时删除策略的**优点**：通过使用定时器，定时删除策略可以保证过期键会尽快地被删除，并释放过期键所占用的内存。(内存友好)\n\n但定时删除策略的**缺点**：它对CPU时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张，但CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐造成影响。另外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个时间的时间复杂度为O(N)，并不能高效地处理大量时间事件。(CPU不友好)\n\n因此，要让服务器创建大量的定时器，从而实现定时删除策略，现阶段来说并不现实。\n\n\n\n#### 2.2 惰性删除\n\n惰性删除的**优点**：对CPU时间友好，程序只会在取出键时才对建进行过期检查，保证删除过期键的操作只会在费做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的国期间上花费任何CPU时间。\n\n惰性删除的**缺点**：对内存不友好，若一个键已经过期，而这个键又仍然留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。若数据库中有非常多的过期键，而这些过期键又恰好没有访问的话，那么他们也许永远不会被删除（除非用户手动执行flushdb），我们甚至可以将这种情况看做`内存泄漏`。\n\n\n\n#### 2.3 定期删除\n\n对于定时删除及惰性删除，均有一些明显的缺陷：\n\n- 定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。\n- 惰性删除浪费太多内存，有内存泄露的风险。\n\n\n\n定期删除策略是前两种策略的一种整合和折中。\n\n- 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。\n- 通过定期删除过期键，定期删除策略有效的减少了因为过期键而带来的内存浪费。\n\n\n\n#### 2.4 Redis的过期键删除策略\n\nRedis实际上用的`惰性删除及定期删除策略`，通过配合使用这两种删除策略，服务器可以很好地合理使用CPU时间和避免浪费内存空间之间取得平衡。\n\n\n\n##### 2.4.1 惰性删除策略的实现\n\n过期键的惰性删除策略是由`db.c/expireIfNeeded`函数实现的，所有读写数据库的Redis命令在执行前都会调用expireIdNeeded函数对输入键进行检查：\n\n- 若输入键`已经过期`，那么expireIfNeeded函数将输入键从数据库中删除。\n- 若输入键`未过期`，那么expireIfNeeded函数不做动作。\n\n注：由于expireIfNeeded函数会将过期键删除，所以每个命令的实现都要能同时处理键存在及键不存在两种情况。\n\n\n\n##### 2.4.2定期删除策略的实现\n\n过期键的定期删除策略由`redis.c/activeExpireCycle`函数实现，每当Redis的服务周期性操作`redis.c/serverCron`函数执行时，activeExpireCycle函数就会被调用。\n\n**activeExpireCycle函数的逻辑**：在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中`随机检查一部分键的过期时间`，并删除其中的过期键。\n\n\n\n### 3 AOF、RDB和复制功能对过期键的处理\n\n#### 3.1 生成RDB文件\n\n执行以下命令将创建一个新的RDB文件，此时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。\n\n- ①、同步保存到磁盘命令\n\n```\nSAVE\n```\n\n- ②、在后台异步保存当前数据到磁盘命令\n\n```\nBGSAVE\n```\n\n\n\n#### 3.2 载入RDB文件\n\n在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：\n\n- ①、若服务器以**主服务器模式**运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。\n- ②、若服务器以**从服务器模式**运行，那么在载入RDB文件时，文件保存的所有键，无论是否过期，都会被载入到数据库中。（*注：因为主从服务器在进行数据同步时，从服务器的数据库就会被清空，所以，一般来说，过期键对载入RDB文件的从服务器也不会造成影响*）\n\n\n\n#### 3.3 AOF文件写入\n\n当服务器以**AOF（AppendOnlyFile）持久化模式**运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。\n\n当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式记录该键已经被删除。\n\n\n\n示例：若客户端使用`GET message`命令试图访问过期的message键，那么服务器将执行以下三个动作。\n\n- ①、从数据库中删除message键。\n- ②、追加一条DEL message命令到AOF文件。\n- ③、向执行GET命令的客户端返回空回复。\n\n\n\n#### 3.4 AOF重写\n\n在执行AOF重写的过程中，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。因此，数据库中包含过期键不会对AOF重写造成影响。\n\n\n\n#### 3.5 复制\n\n当服务器运行在**复制模式**下时，从服务器的过期键删除动作由主服务器控制。\n\n- 当主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。\n- 当从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。\n- 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。\n\n\n\n**为什么要通过主服务器来控制从服务器统一的删除过期键呢**？\n\n保证主从服务器数据库的一致性。\n\n\n\n### 参考资料\n\n1.redis设计与实现（第二版） 黄健宏","source":"_posts/Redis设计与实现-Redis键过期及删除策略.md","raw":"---\ntitle: Redis设计与实现-Redis键过期及删除策略\ndate: 2020-09-03 14:51:51\ntags: [\"Redis\",\"Note\"]\ncategories: [\"Redis\", \"Note\", \"Redis设计与实现\"]\n---\n\n### 1 设置键的生存时间或过期时间\n\n通过以下命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置`生存时间`（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。\n\n<!--more-->\n\n- 以`秒`为单位设置过期时间命令：\n\n\n```\nEXPIRE key seconds\n```\n\n- 以`毫秒`为单位设置过期时间命令：\n\n\n```\nPEXPIRE key milliseconds\n```\n\n- 若过期时间是一个UNIX时间戳，以秒为单位设置过期时间命令:\n\n\n```\nEXPIREAT key timestamp\n```\n\n- 若过期时间是一个UNIX时间戳，以微秒为单位设置过期时间命令:\n\n\n```\nPEXPIREAT key milliseconds-timestamp\n```\n\n**注：虽然过期的单位及命令不同，但<u>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</u>。**\n\n\n\n#### 1.1 保存过期时间\n\nredisDb结构的`expires字典`保存了数据库中所有键的过期时间，我们称这个字典为过期字典。\n\n```c\ntypedef struct redisDb {\n    // ...\n    // 过期字典，保存着键的过期时间.\n    dict *expires;\n    // ...\n} redisDb;\n```\n\n其中，\n\n- 过期字典的`键是一个指针`，这个指针指向键空间中的某个键对象。（也就是某个数据库键）。\n- 过期字典的`值是一个long long类型的整数`，这个整数保存了键所指向的数据库键的过期时间——`一个毫秒精度的UNIX时间戳`。\n\n\n\n当客户端执行`PEXPIREAT`等命令设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。\n\n\n\n示例：带有过期字典的数据库示意图\n\n![带有过期字典的数据库示意图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis键过期及删除策略/带有过期字典的数据库示意图.png)\n\n\n\n其中，alphabet和book键对象出现了两次，实际上，键空间和过期字典的键都指向同一个键对象，所以并不会出现任何重复对象。\n\n\n\n#### 1.2 移除过期时间\n\n通过以下命令可以`移除一个键的过期时间`：\n\n```\nPERSIST <key>\n```\n\nPERSIST命令就是PEXPIREAT命令的反操作，PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联。\n\n\n\n#### 1.3 计算并返回剩余生存时间\n\n通过以下命令可以返回键的剩余生存时间：\n\n- ①、以秒为单位返回\n\n```\nTTL <key>\n```\n\n- ②、以毫秒为单位返回\n\n```\nPTTL <key>\n```\n\n\n\n### 2 过期删除策略\n\n**若一个键过期了，它什么时候会被删除呢？可能情况有哪些？**\n\n- ①、`定时删除`：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。\n- ②、`惰性删除`：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，吐过过期的话，就删除该键，如果没有过期，则返回该键。\n- ③、`定期删除`：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。\n\n\n\n#### 2.1 定时删除\n\n定时删除策略的**优点**：通过使用定时器，定时删除策略可以保证过期键会尽快地被删除，并释放过期键所占用的内存。(内存友好)\n\n但定时删除策略的**缺点**：它对CPU时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张，但CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐造成影响。另外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个时间的时间复杂度为O(N)，并不能高效地处理大量时间事件。(CPU不友好)\n\n因此，要让服务器创建大量的定时器，从而实现定时删除策略，现阶段来说并不现实。\n\n\n\n#### 2.2 惰性删除\n\n惰性删除的**优点**：对CPU时间友好，程序只会在取出键时才对建进行过期检查，保证删除过期键的操作只会在费做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的国期间上花费任何CPU时间。\n\n惰性删除的**缺点**：对内存不友好，若一个键已经过期，而这个键又仍然留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。若数据库中有非常多的过期键，而这些过期键又恰好没有访问的话，那么他们也许永远不会被删除（除非用户手动执行flushdb），我们甚至可以将这种情况看做`内存泄漏`。\n\n\n\n#### 2.3 定期删除\n\n对于定时删除及惰性删除，均有一些明显的缺陷：\n\n- 定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。\n- 惰性删除浪费太多内存，有内存泄露的风险。\n\n\n\n定期删除策略是前两种策略的一种整合和折中。\n\n- 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。\n- 通过定期删除过期键，定期删除策略有效的减少了因为过期键而带来的内存浪费。\n\n\n\n#### 2.4 Redis的过期键删除策略\n\nRedis实际上用的`惰性删除及定期删除策略`，通过配合使用这两种删除策略，服务器可以很好地合理使用CPU时间和避免浪费内存空间之间取得平衡。\n\n\n\n##### 2.4.1 惰性删除策略的实现\n\n过期键的惰性删除策略是由`db.c/expireIfNeeded`函数实现的，所有读写数据库的Redis命令在执行前都会调用expireIdNeeded函数对输入键进行检查：\n\n- 若输入键`已经过期`，那么expireIfNeeded函数将输入键从数据库中删除。\n- 若输入键`未过期`，那么expireIfNeeded函数不做动作。\n\n注：由于expireIfNeeded函数会将过期键删除，所以每个命令的实现都要能同时处理键存在及键不存在两种情况。\n\n\n\n##### 2.4.2定期删除策略的实现\n\n过期键的定期删除策略由`redis.c/activeExpireCycle`函数实现，每当Redis的服务周期性操作`redis.c/serverCron`函数执行时，activeExpireCycle函数就会被调用。\n\n**activeExpireCycle函数的逻辑**：在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中`随机检查一部分键的过期时间`，并删除其中的过期键。\n\n\n\n### 3 AOF、RDB和复制功能对过期键的处理\n\n#### 3.1 生成RDB文件\n\n执行以下命令将创建一个新的RDB文件，此时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。\n\n- ①、同步保存到磁盘命令\n\n```\nSAVE\n```\n\n- ②、在后台异步保存当前数据到磁盘命令\n\n```\nBGSAVE\n```\n\n\n\n#### 3.2 载入RDB文件\n\n在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：\n\n- ①、若服务器以**主服务器模式**运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。\n- ②、若服务器以**从服务器模式**运行，那么在载入RDB文件时，文件保存的所有键，无论是否过期，都会被载入到数据库中。（*注：因为主从服务器在进行数据同步时，从服务器的数据库就会被清空，所以，一般来说，过期键对载入RDB文件的从服务器也不会造成影响*）\n\n\n\n#### 3.3 AOF文件写入\n\n当服务器以**AOF（AppendOnlyFile）持久化模式**运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。\n\n当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式记录该键已经被删除。\n\n\n\n示例：若客户端使用`GET message`命令试图访问过期的message键，那么服务器将执行以下三个动作。\n\n- ①、从数据库中删除message键。\n- ②、追加一条DEL message命令到AOF文件。\n- ③、向执行GET命令的客户端返回空回复。\n\n\n\n#### 3.4 AOF重写\n\n在执行AOF重写的过程中，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。因此，数据库中包含过期键不会对AOF重写造成影响。\n\n\n\n#### 3.5 复制\n\n当服务器运行在**复制模式**下时，从服务器的过期键删除动作由主服务器控制。\n\n- 当主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。\n- 当从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。\n- 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。\n\n\n\n**为什么要通过主服务器来控制从服务器统一的删除过期键呢**？\n\n保证主从服务器数据库的一致性。\n\n\n\n### 参考资料\n\n1.redis设计与实现（第二版） 黄健宏","slug":"Redis设计与实现-Redis键过期及删除策略","published":1,"updated":"2020-09-03T07:45:04.060Z","_id":"ckemhsii20000llg3geoo8711","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-设置键的生存时间或过期时间\"><a href=\"#1-设置键的生存时间或过期时间\" class=\"headerlink\" title=\"1 设置键的生存时间或过期时间\"></a>1 设置键的生存时间或过期时间</h3><p>通过以下命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置<code>生存时间</code>（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p>\n<a id=\"more\"></a>\n\n<ul>\n<li>以<code>秒</code>为单位设置过期时间命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPIRE key seconds</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以<code>毫秒</code>为单位设置过期时间命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PEXPIRE key milliseconds</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若过期时间是一个UNIX时间戳，以秒为单位设置过期时间命令:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPIREAT key timestamp</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若过期时间是一个UNIX时间戳，以微秒为单位设置过期时间命令:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PEXPIREAT key milliseconds-timestamp</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：虽然过期的单位及命令不同，但<u>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</u>。</strong></p>\n<h4 id=\"1-1-保存过期时间\"><a href=\"#1-1-保存过期时间\" class=\"headerlink\" title=\"1.1 保存过期时间\"></a>1.1 保存过期时间</h4><p>redisDb结构的<code>expires字典</code>保存了数据库中所有键的过期时间，我们称这个字典为过期字典。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDb</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 过期字典，保存着键的过期时间.</span></span><br><span class=\"line\">    dict *expires;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; redisDb;</span><br></pre></td></tr></table></figure>\n\n<p>其中，</p>\n<ul>\n<li>过期字典的<code>键是一个指针</code>，这个指针指向键空间中的某个键对象。（也就是某个数据库键）。</li>\n<li>过期字典的<code>值是一个long long类型的整数</code>，这个整数保存了键所指向的数据库键的过期时间——<code>一个毫秒精度的UNIX时间戳</code>。</li>\n</ul>\n<p>当客户端执行<code>PEXPIREAT</code>等命令设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。</p>\n<p>示例：带有过期字典的数据库示意图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E9%94%AE%E8%BF%87%E6%9C%9F%E5%8F%8A%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/%E5%B8%A6%E6%9C%89%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"带有过期字典的数据库示意图\"></p>\n<p>其中，alphabet和book键对象出现了两次，实际上，键空间和过期字典的键都指向同一个键对象，所以并不会出现任何重复对象。</p>\n<h4 id=\"1-2-移除过期时间\"><a href=\"#1-2-移除过期时间\" class=\"headerlink\" title=\"1.2 移除过期时间\"></a>1.2 移除过期时间</h4><p>通过以下命令可以<code>移除一个键的过期时间</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PERSIST &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>PERSIST命令就是PEXPIREAT命令的反操作，PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联。</p>\n<h4 id=\"1-3-计算并返回剩余生存时间\"><a href=\"#1-3-计算并返回剩余生存时间\" class=\"headerlink\" title=\"1.3 计算并返回剩余生存时间\"></a>1.3 计算并返回剩余生存时间</h4><p>通过以下命令可以返回键的剩余生存时间：</p>\n<ul>\n<li>①、以秒为单位返回</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、以毫秒为单位返回</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PTTL &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-过期删除策略\"><a href=\"#2-过期删除策略\" class=\"headerlink\" title=\"2 过期删除策略\"></a>2 过期删除策略</h3><p><strong>若一个键过期了，它什么时候会被删除呢？可能情况有哪些？</strong></p>\n<ul>\n<li>①、<code>定时删除</code>：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>\n<li>②、<code>惰性删除</code>：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，吐过过期的话，就删除该键，如果没有过期，则返回该键。</li>\n<li>③、<code>定期删除</code>：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>\n</ul>\n<h4 id=\"2-1-定时删除\"><a href=\"#2-1-定时删除\" class=\"headerlink\" title=\"2.1 定时删除\"></a>2.1 定时删除</h4><p>定时删除策略的<strong>优点</strong>：通过使用定时器，定时删除策略可以保证过期键会尽快地被删除，并释放过期键所占用的内存。(内存友好)</p>\n<p>但定时删除策略的<strong>缺点</strong>：它对CPU时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张，但CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐造成影响。另外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个时间的时间复杂度为O(N)，并不能高效地处理大量时间事件。(CPU不友好)</p>\n<p>因此，要让服务器创建大量的定时器，从而实现定时删除策略，现阶段来说并不现实。</p>\n<h4 id=\"2-2-惰性删除\"><a href=\"#2-2-惰性删除\" class=\"headerlink\" title=\"2.2 惰性删除\"></a>2.2 惰性删除</h4><p>惰性删除的<strong>优点</strong>：对CPU时间友好，程序只会在取出键时才对建进行过期检查，保证删除过期键的操作只会在费做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的国期间上花费任何CPU时间。</p>\n<p>惰性删除的<strong>缺点</strong>：对内存不友好，若一个键已经过期，而这个键又仍然留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。若数据库中有非常多的过期键，而这些过期键又恰好没有访问的话，那么他们也许永远不会被删除（除非用户手动执行flushdb），我们甚至可以将这种情况看做<code>内存泄漏</code>。</p>\n<h4 id=\"2-3-定期删除\"><a href=\"#2-3-定期删除\" class=\"headerlink\" title=\"2.3 定期删除\"></a>2.3 定期删除</h4><p>对于定时删除及惰性删除，均有一些明显的缺陷：</p>\n<ul>\n<li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li>\n<li>惰性删除浪费太多内存，有内存泄露的风险。</li>\n</ul>\n<p>定期删除策略是前两种策略的一种整合和折中。</p>\n<ul>\n<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>\n<li>通过定期删除过期键，定期删除策略有效的减少了因为过期键而带来的内存浪费。</li>\n</ul>\n<h4 id=\"2-4-Redis的过期键删除策略\"><a href=\"#2-4-Redis的过期键删除策略\" class=\"headerlink\" title=\"2.4 Redis的过期键删除策略\"></a>2.4 Redis的过期键删除策略</h4><p>Redis实际上用的<code>惰性删除及定期删除策略</code>，通过配合使用这两种删除策略，服务器可以很好地合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>\n<h5 id=\"2-4-1-惰性删除策略的实现\"><a href=\"#2-4-1-惰性删除策略的实现\" class=\"headerlink\" title=\"2.4.1 惰性删除策略的实现\"></a>2.4.1 惰性删除策略的实现</h5><p>过期键的惰性删除策略是由<code>db.c/expireIfNeeded</code>函数实现的，所有读写数据库的Redis命令在执行前都会调用expireIdNeeded函数对输入键进行检查：</p>\n<ul>\n<li>若输入键<code>已经过期</code>，那么expireIfNeeded函数将输入键从数据库中删除。</li>\n<li>若输入键<code>未过期</code>，那么expireIfNeeded函数不做动作。</li>\n</ul>\n<p>注：由于expireIfNeeded函数会将过期键删除，所以每个命令的实现都要能同时处理键存在及键不存在两种情况。</p>\n<h5 id=\"2-4-2定期删除策略的实现\"><a href=\"#2-4-2定期删除策略的实现\" class=\"headerlink\" title=\"2.4.2定期删除策略的实现\"></a>2.4.2定期删除策略的实现</h5><p>过期键的定期删除策略由<code>redis.c/activeExpireCycle</code>函数实现，每当Redis的服务周期性操作<code>redis.c/serverCron</code>函数执行时，activeExpireCycle函数就会被调用。</p>\n<p><strong>activeExpireCycle函数的逻辑</strong>：在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中<code>随机检查一部分键的过期时间</code>，并删除其中的过期键。</p>\n<h3 id=\"3-AOF、RDB和复制功能对过期键的处理\"><a href=\"#3-AOF、RDB和复制功能对过期键的处理\" class=\"headerlink\" title=\"3 AOF、RDB和复制功能对过期键的处理\"></a>3 AOF、RDB和复制功能对过期键的处理</h3><h4 id=\"3-1-生成RDB文件\"><a href=\"#3-1-生成RDB文件\" class=\"headerlink\" title=\"3.1 生成RDB文件\"></a>3.1 生成RDB文件</h4><p>执行以下命令将创建一个新的RDB文件，此时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p>\n<ul>\n<li>①、同步保存到磁盘命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAVE</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、在后台异步保存当前数据到磁盘命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BGSAVE</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-载入RDB文件\"><a href=\"#3-2-载入RDB文件\" class=\"headerlink\" title=\"3.2 载入RDB文件\"></a>3.2 载入RDB文件</h4><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p>\n<ul>\n<li>①、若服务器以<strong>主服务器模式</strong>运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li>\n<li>②、若服务器以<strong>从服务器模式</strong>运行，那么在载入RDB文件时，文件保存的所有键，无论是否过期，都会被载入到数据库中。（<em>注：因为主从服务器在进行数据同步时，从服务器的数据库就会被清空，所以，一般来说，过期键对载入RDB文件的从服务器也不会造成影响</em>）</li>\n</ul>\n<h4 id=\"3-3-AOF文件写入\"><a href=\"#3-3-AOF文件写入\" class=\"headerlink\" title=\"3.3 AOF文件写入\"></a>3.3 AOF文件写入</h4><p>当服务器以<strong>AOF（AppendOnlyFile）持久化模式</strong>运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p>\n<p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式记录该键已经被删除。</p>\n<p>示例：若客户端使用<code>GET message</code>命令试图访问过期的message键，那么服务器将执行以下三个动作。</p>\n<ul>\n<li>①、从数据库中删除message键。</li>\n<li>②、追加一条DEL message命令到AOF文件。</li>\n<li>③、向执行GET命令的客户端返回空回复。</li>\n</ul>\n<h4 id=\"3-4-AOF重写\"><a href=\"#3-4-AOF重写\" class=\"headerlink\" title=\"3.4 AOF重写\"></a>3.4 AOF重写</h4><p>在执行AOF重写的过程中，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。因此，数据库中包含过期键不会对AOF重写造成影响。</p>\n<h4 id=\"3-5-复制\"><a href=\"#3-5-复制\" class=\"headerlink\" title=\"3.5 复制\"></a>3.5 复制</h4><p>当服务器运行在<strong>复制模式</strong>下时，从服务器的过期键删除动作由主服务器控制。</p>\n<ul>\n<li>当主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li>\n<li>当从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li>\n<li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li>\n</ul>\n<p><strong>为什么要通过主服务器来控制从服务器统一的删除过期键呢</strong>？</p>\n<p>保证主从服务器数据库的一致性。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>1.redis设计与实现（第二版） 黄健宏</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-设置键的生存时间或过期时间\"><a href=\"#1-设置键的生存时间或过期时间\" class=\"headerlink\" title=\"1 设置键的生存时间或过期时间\"></a>1 设置键的生存时间或过期时间</h3><p>通过以下命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置<code>生存时间</code>（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p>","more":"<ul>\n<li>以<code>秒</code>为单位设置过期时间命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPIRE key seconds</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以<code>毫秒</code>为单位设置过期时间命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PEXPIRE key milliseconds</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若过期时间是一个UNIX时间戳，以秒为单位设置过期时间命令:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPIREAT key timestamp</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若过期时间是一个UNIX时间戳，以微秒为单位设置过期时间命令:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PEXPIREAT key milliseconds-timestamp</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：虽然过期的单位及命令不同，但<u>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</u>。</strong></p>\n<h4 id=\"1-1-保存过期时间\"><a href=\"#1-1-保存过期时间\" class=\"headerlink\" title=\"1.1 保存过期时间\"></a>1.1 保存过期时间</h4><p>redisDb结构的<code>expires字典</code>保存了数据库中所有键的过期时间，我们称这个字典为过期字典。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDb</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 过期字典，保存着键的过期时间.</span></span><br><span class=\"line\">    dict *expires;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; redisDb;</span><br></pre></td></tr></table></figure>\n\n<p>其中，</p>\n<ul>\n<li>过期字典的<code>键是一个指针</code>，这个指针指向键空间中的某个键对象。（也就是某个数据库键）。</li>\n<li>过期字典的<code>值是一个long long类型的整数</code>，这个整数保存了键所指向的数据库键的过期时间——<code>一个毫秒精度的UNIX时间戳</code>。</li>\n</ul>\n<p>当客户端执行<code>PEXPIREAT</code>等命令设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。</p>\n<p>示例：带有过期字典的数据库示意图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E9%94%AE%E8%BF%87%E6%9C%9F%E5%8F%8A%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/%E5%B8%A6%E6%9C%89%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"带有过期字典的数据库示意图\"></p>\n<p>其中，alphabet和book键对象出现了两次，实际上，键空间和过期字典的键都指向同一个键对象，所以并不会出现任何重复对象。</p>\n<h4 id=\"1-2-移除过期时间\"><a href=\"#1-2-移除过期时间\" class=\"headerlink\" title=\"1.2 移除过期时间\"></a>1.2 移除过期时间</h4><p>通过以下命令可以<code>移除一个键的过期时间</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PERSIST &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>PERSIST命令就是PEXPIREAT命令的反操作，PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联。</p>\n<h4 id=\"1-3-计算并返回剩余生存时间\"><a href=\"#1-3-计算并返回剩余生存时间\" class=\"headerlink\" title=\"1.3 计算并返回剩余生存时间\"></a>1.3 计算并返回剩余生存时间</h4><p>通过以下命令可以返回键的剩余生存时间：</p>\n<ul>\n<li>①、以秒为单位返回</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、以毫秒为单位返回</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PTTL &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-过期删除策略\"><a href=\"#2-过期删除策略\" class=\"headerlink\" title=\"2 过期删除策略\"></a>2 过期删除策略</h3><p><strong>若一个键过期了，它什么时候会被删除呢？可能情况有哪些？</strong></p>\n<ul>\n<li>①、<code>定时删除</code>：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>\n<li>②、<code>惰性删除</code>：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，吐过过期的话，就删除该键，如果没有过期，则返回该键。</li>\n<li>③、<code>定期删除</code>：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>\n</ul>\n<h4 id=\"2-1-定时删除\"><a href=\"#2-1-定时删除\" class=\"headerlink\" title=\"2.1 定时删除\"></a>2.1 定时删除</h4><p>定时删除策略的<strong>优点</strong>：通过使用定时器，定时删除策略可以保证过期键会尽快地被删除，并释放过期键所占用的内存。(内存友好)</p>\n<p>但定时删除策略的<strong>缺点</strong>：它对CPU时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张，但CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐造成影响。另外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个时间的时间复杂度为O(N)，并不能高效地处理大量时间事件。(CPU不友好)</p>\n<p>因此，要让服务器创建大量的定时器，从而实现定时删除策略，现阶段来说并不现实。</p>\n<h4 id=\"2-2-惰性删除\"><a href=\"#2-2-惰性删除\" class=\"headerlink\" title=\"2.2 惰性删除\"></a>2.2 惰性删除</h4><p>惰性删除的<strong>优点</strong>：对CPU时间友好，程序只会在取出键时才对建进行过期检查，保证删除过期键的操作只会在费做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的国期间上花费任何CPU时间。</p>\n<p>惰性删除的<strong>缺点</strong>：对内存不友好，若一个键已经过期，而这个键又仍然留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。若数据库中有非常多的过期键，而这些过期键又恰好没有访问的话，那么他们也许永远不会被删除（除非用户手动执行flushdb），我们甚至可以将这种情况看做<code>内存泄漏</code>。</p>\n<h4 id=\"2-3-定期删除\"><a href=\"#2-3-定期删除\" class=\"headerlink\" title=\"2.3 定期删除\"></a>2.3 定期删除</h4><p>对于定时删除及惰性删除，均有一些明显的缺陷：</p>\n<ul>\n<li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li>\n<li>惰性删除浪费太多内存，有内存泄露的风险。</li>\n</ul>\n<p>定期删除策略是前两种策略的一种整合和折中。</p>\n<ul>\n<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>\n<li>通过定期删除过期键，定期删除策略有效的减少了因为过期键而带来的内存浪费。</li>\n</ul>\n<h4 id=\"2-4-Redis的过期键删除策略\"><a href=\"#2-4-Redis的过期键删除策略\" class=\"headerlink\" title=\"2.4 Redis的过期键删除策略\"></a>2.4 Redis的过期键删除策略</h4><p>Redis实际上用的<code>惰性删除及定期删除策略</code>，通过配合使用这两种删除策略，服务器可以很好地合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>\n<h5 id=\"2-4-1-惰性删除策略的实现\"><a href=\"#2-4-1-惰性删除策略的实现\" class=\"headerlink\" title=\"2.4.1 惰性删除策略的实现\"></a>2.4.1 惰性删除策略的实现</h5><p>过期键的惰性删除策略是由<code>db.c/expireIfNeeded</code>函数实现的，所有读写数据库的Redis命令在执行前都会调用expireIdNeeded函数对输入键进行检查：</p>\n<ul>\n<li>若输入键<code>已经过期</code>，那么expireIfNeeded函数将输入键从数据库中删除。</li>\n<li>若输入键<code>未过期</code>，那么expireIfNeeded函数不做动作。</li>\n</ul>\n<p>注：由于expireIfNeeded函数会将过期键删除，所以每个命令的实现都要能同时处理键存在及键不存在两种情况。</p>\n<h5 id=\"2-4-2定期删除策略的实现\"><a href=\"#2-4-2定期删除策略的实现\" class=\"headerlink\" title=\"2.4.2定期删除策略的实现\"></a>2.4.2定期删除策略的实现</h5><p>过期键的定期删除策略由<code>redis.c/activeExpireCycle</code>函数实现，每当Redis的服务周期性操作<code>redis.c/serverCron</code>函数执行时，activeExpireCycle函数就会被调用。</p>\n<p><strong>activeExpireCycle函数的逻辑</strong>：在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中<code>随机检查一部分键的过期时间</code>，并删除其中的过期键。</p>\n<h3 id=\"3-AOF、RDB和复制功能对过期键的处理\"><a href=\"#3-AOF、RDB和复制功能对过期键的处理\" class=\"headerlink\" title=\"3 AOF、RDB和复制功能对过期键的处理\"></a>3 AOF、RDB和复制功能对过期键的处理</h3><h4 id=\"3-1-生成RDB文件\"><a href=\"#3-1-生成RDB文件\" class=\"headerlink\" title=\"3.1 生成RDB文件\"></a>3.1 生成RDB文件</h4><p>执行以下命令将创建一个新的RDB文件，此时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p>\n<ul>\n<li>①、同步保存到磁盘命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAVE</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、在后台异步保存当前数据到磁盘命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BGSAVE</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-载入RDB文件\"><a href=\"#3-2-载入RDB文件\" class=\"headerlink\" title=\"3.2 载入RDB文件\"></a>3.2 载入RDB文件</h4><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p>\n<ul>\n<li>①、若服务器以<strong>主服务器模式</strong>运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li>\n<li>②、若服务器以<strong>从服务器模式</strong>运行，那么在载入RDB文件时，文件保存的所有键，无论是否过期，都会被载入到数据库中。（<em>注：因为主从服务器在进行数据同步时，从服务器的数据库就会被清空，所以，一般来说，过期键对载入RDB文件的从服务器也不会造成影响</em>）</li>\n</ul>\n<h4 id=\"3-3-AOF文件写入\"><a href=\"#3-3-AOF文件写入\" class=\"headerlink\" title=\"3.3 AOF文件写入\"></a>3.3 AOF文件写入</h4><p>当服务器以<strong>AOF（AppendOnlyFile）持久化模式</strong>运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p>\n<p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式记录该键已经被删除。</p>\n<p>示例：若客户端使用<code>GET message</code>命令试图访问过期的message键，那么服务器将执行以下三个动作。</p>\n<ul>\n<li>①、从数据库中删除message键。</li>\n<li>②、追加一条DEL message命令到AOF文件。</li>\n<li>③、向执行GET命令的客户端返回空回复。</li>\n</ul>\n<h4 id=\"3-4-AOF重写\"><a href=\"#3-4-AOF重写\" class=\"headerlink\" title=\"3.4 AOF重写\"></a>3.4 AOF重写</h4><p>在执行AOF重写的过程中，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。因此，数据库中包含过期键不会对AOF重写造成影响。</p>\n<h4 id=\"3-5-复制\"><a href=\"#3-5-复制\" class=\"headerlink\" title=\"3.5 复制\"></a>3.5 复制</h4><p>当服务器运行在<strong>复制模式</strong>下时，从服务器的过期键删除动作由主服务器控制。</p>\n<ul>\n<li>当主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li>\n<li>当从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li>\n<li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li>\n</ul>\n<p><strong>为什么要通过主服务器来控制从服务器统一的删除过期键呢</strong>？</p>\n<p>保证主从服务器数据库的一致性。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>1.redis设计与实现（第二版） 黄健宏</p>"},{"title":"redis设计与实现-单机数据库的实现","date":"2020-09-03T06:29:25.000Z","_content":"\n\n\n### 1 服务器中的数据库\n\nRedis服务器将所有数据库都保存在服务器状态`redis.h/redisServer`结构的`db数组`中，db数组的每个项都是一个`redis.h/redisDb`结构，每个redisDb结构代表了一个数据库。\n\n<!--more-->\n\n```c\nstruct redisServer {\n    // ...\n    // 一个数组，保存着服务器中的所有数据库.\n    redisDb *db;\n    // 总配置的数据库的数量.\n    int dbnum;\n    // ...\n};\n```\n\ndbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。\n\n\n\n### 2 切换数据库\n\n默认情况下，Redis客户端的目标数据库为`0号数据库`，通过`select命令`可切换数据库。\n\n\n\n示例：\n\n```bash\n# 切换到数据库2.\nredis> select 2\n```\n\n\n\n其中`redisClient`结构中的`db属性记录了当前客户端的目标数据库`，该属性是一个指向`redisDb`结构的指针，`redisClient.db`指向`redisServer.db`数组的其中一个元素，`被指向的元素即为目标数据库`。\n\n```c\ntypedef struct redisClient {\n    // ...\n    // 记录客户端当前正在使用的数据库.\n    redisDb *db;\n    // ...\n} redisClient;\n```\n\n\n\n下图为客户端的目标数据库为1号数据库。\n\n![客户端的目标数据库为1号数据库](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-单机数据库的实现/客户端的目标数据库为1号数据库.png)\n\n**问: SELECT命令的实现原理是什么？**\n\n通过修改redisClient.db指针，让它指向服务器中不同数据库，从而实现切换目标数据库的功能。\n\n\n\n### 3 数据库键空间\n\nRedis是一个键值对数据库服务器，服务器中的每个数据库都由一个`redis.h/redisDb`结构表示，其中，`redisDb`结构的`dict`字典保存了数据库中的所有键值对，我们将这个字典称为**键空间（key space）**。\n\n`redis.h/redisDb`结构:\n\n```c\ntypedef struct redisDb {\n    // ...\n    // 数据库键空间，保存着数据库中的所有键值对.\n    dict *dict;\n    // ...\n}redisDb;\n```\n\n\n\n其中，\n\n- 键空间的键就是**数据库的键**，每个键都是一个`字符串对象`；\n- 键空间的值就是**数据库的值**，每个值都可以是`字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象`。\n\n\n\n示例：下图为包含了列表键、哈希表键、字符串键的结构图\n\n![包含了列表键、哈希表键、字符串键的结构图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-单机数据库的实现/包含了列表键、哈希表键、字符串键的结构图.png)\n\n*注：数据库的键空间是一个字典，所以所有针对数据库的操作，实际上都是通过对键空间字典进行操作来实现的。*\n\n\n\n- 添加新键: 添加新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。\n- 删除键: 删除数据库中的一个键，实际上就是在键空间里面删除键所对应额键值对对象。（**键对象和值对象都要删除！**）\n- 更新键: 更新数据库键，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。\n- 对键取值: 取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。\n\n\n\n#### 3.1 其他键空间的操作\n\n除了以上增删改查的操作，还有其他一些命令是通过对键空间进行处理来完成的。\n\n比如说：\n\n- `flushdb`命令: 通过删除键空间中的所有键值对来实现的。\n- `randomkey`命令: 随机返回某个键，也是在键空间中随机返回的。\n- `dbsize`命令: 返回数据库键数量，通过返回键空间中包含的键值对的数量来完成。\n- `exist、rename、keys`等。\n\n\n\n#### 3.2 读写键空间时的维护操作\n\n当时用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操纵，还会执行一些额外的维护操作，比如：\n\n- ①、在读取一个键之后（读写操作都会对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（keyspace_hit）/未命中(keyspace_misses)的次数。通过以下命令可查看其属性。\n\n  ```\n  INFO stats\n  ```\n\n- ②、在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用以下命令可查看键的闲置时间。\n\n  ```\n  object idletime <key>\n  ```\n\n- ③、若服务器在读取一个键时发现该键已过期，那么服务器会先删除这个过期键，然后执行余下的其他操作。\n- ④、若有客户端使用watch命令监视了这个键，那么服务器在对被监视的键进行修改之后，会标记这个键为脏（dirty），从而让事务成武注意到这个键已经被修改过。\n- ⑤、服务器每次修改一个键之后，都会对dity键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。\n- ⑥、若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据通知。\n\n### 4 数据库通知\n\n数据库通知可以让客户端通过订阅给定频道或者模式，来获悉数据库中键的变化，以及数据中命令的执行情况。","source":"_posts/redis设计与实现-单机数据库的实现.md","raw":"---\ntitle: redis设计与实现-单机数据库的实现\ndate: 2020-09-03 14:29:25\ntags: [\"Redis\",\"Note\"]\ncategories: [\"Redis\", \"Note\", \"Redis设计与实现\"]\n---\n\n\n\n### 1 服务器中的数据库\n\nRedis服务器将所有数据库都保存在服务器状态`redis.h/redisServer`结构的`db数组`中，db数组的每个项都是一个`redis.h/redisDb`结构，每个redisDb结构代表了一个数据库。\n\n<!--more-->\n\n```c\nstruct redisServer {\n    // ...\n    // 一个数组，保存着服务器中的所有数据库.\n    redisDb *db;\n    // 总配置的数据库的数量.\n    int dbnum;\n    // ...\n};\n```\n\ndbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。\n\n\n\n### 2 切换数据库\n\n默认情况下，Redis客户端的目标数据库为`0号数据库`，通过`select命令`可切换数据库。\n\n\n\n示例：\n\n```bash\n# 切换到数据库2.\nredis> select 2\n```\n\n\n\n其中`redisClient`结构中的`db属性记录了当前客户端的目标数据库`，该属性是一个指向`redisDb`结构的指针，`redisClient.db`指向`redisServer.db`数组的其中一个元素，`被指向的元素即为目标数据库`。\n\n```c\ntypedef struct redisClient {\n    // ...\n    // 记录客户端当前正在使用的数据库.\n    redisDb *db;\n    // ...\n} redisClient;\n```\n\n\n\n下图为客户端的目标数据库为1号数据库。\n\n![客户端的目标数据库为1号数据库](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-单机数据库的实现/客户端的目标数据库为1号数据库.png)\n\n**问: SELECT命令的实现原理是什么？**\n\n通过修改redisClient.db指针，让它指向服务器中不同数据库，从而实现切换目标数据库的功能。\n\n\n\n### 3 数据库键空间\n\nRedis是一个键值对数据库服务器，服务器中的每个数据库都由一个`redis.h/redisDb`结构表示，其中，`redisDb`结构的`dict`字典保存了数据库中的所有键值对，我们将这个字典称为**键空间（key space）**。\n\n`redis.h/redisDb`结构:\n\n```c\ntypedef struct redisDb {\n    // ...\n    // 数据库键空间，保存着数据库中的所有键值对.\n    dict *dict;\n    // ...\n}redisDb;\n```\n\n\n\n其中，\n\n- 键空间的键就是**数据库的键**，每个键都是一个`字符串对象`；\n- 键空间的值就是**数据库的值**，每个值都可以是`字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象`。\n\n\n\n示例：下图为包含了列表键、哈希表键、字符串键的结构图\n\n![包含了列表键、哈希表键、字符串键的结构图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-单机数据库的实现/包含了列表键、哈希表键、字符串键的结构图.png)\n\n*注：数据库的键空间是一个字典，所以所有针对数据库的操作，实际上都是通过对键空间字典进行操作来实现的。*\n\n\n\n- 添加新键: 添加新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。\n- 删除键: 删除数据库中的一个键，实际上就是在键空间里面删除键所对应额键值对对象。（**键对象和值对象都要删除！**）\n- 更新键: 更新数据库键，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。\n- 对键取值: 取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。\n\n\n\n#### 3.1 其他键空间的操作\n\n除了以上增删改查的操作，还有其他一些命令是通过对键空间进行处理来完成的。\n\n比如说：\n\n- `flushdb`命令: 通过删除键空间中的所有键值对来实现的。\n- `randomkey`命令: 随机返回某个键，也是在键空间中随机返回的。\n- `dbsize`命令: 返回数据库键数量，通过返回键空间中包含的键值对的数量来完成。\n- `exist、rename、keys`等。\n\n\n\n#### 3.2 读写键空间时的维护操作\n\n当时用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操纵，还会执行一些额外的维护操作，比如：\n\n- ①、在读取一个键之后（读写操作都会对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（keyspace_hit）/未命中(keyspace_misses)的次数。通过以下命令可查看其属性。\n\n  ```\n  INFO stats\n  ```\n\n- ②、在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用以下命令可查看键的闲置时间。\n\n  ```\n  object idletime <key>\n  ```\n\n- ③、若服务器在读取一个键时发现该键已过期，那么服务器会先删除这个过期键，然后执行余下的其他操作。\n- ④、若有客户端使用watch命令监视了这个键，那么服务器在对被监视的键进行修改之后，会标记这个键为脏（dirty），从而让事务成武注意到这个键已经被修改过。\n- ⑤、服务器每次修改一个键之后，都会对dity键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。\n- ⑥、若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据通知。\n\n### 4 数据库通知\n\n数据库通知可以让客户端通过订阅给定频道或者模式，来获悉数据库中键的变化，以及数据中命令的执行情况。","slug":"redis设计与实现-单机数据库的实现","published":1,"updated":"2020-09-03T07:45:36.184Z","_id":"ckemhsiij0001llg3dtxw9b1g","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-服务器中的数据库\"><a href=\"#1-服务器中的数据库\" class=\"headerlink\" title=\"1 服务器中的数据库\"></a>1 服务器中的数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态<code>redis.h/redisServer</code>结构的<code>db数组</code>中，db数组的每个项都是一个<code>redis.h/redisDb</code>结构，每个redisDb结构代表了一个数据库。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 一个数组，保存着服务器中的所有数据库.</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">    <span class=\"comment\">// 总配置的数据库的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dbnum;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。</p>\n<h3 id=\"2-切换数据库\"><a href=\"#2-切换数据库\" class=\"headerlink\" title=\"2 切换数据库\"></a>2 切换数据库</h3><p>默认情况下，Redis客户端的目标数据库为<code>0号数据库</code>，通过<code>select命令</code>可切换数据库。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到数据库2.</span></span><br><span class=\"line\">redis&gt; select 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中<code>redisClient</code>结构中的<code>db属性记录了当前客户端的目标数据库</code>，该属性是一个指向<code>redisDb</code>结构的指针，<code>redisClient.db</code>指向<code>redisServer.db</code>数组的其中一个元素，<code>被指向的元素即为目标数据库</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisClient</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录客户端当前正在使用的数据库.</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; redisClient;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>下图为客户端的目标数据库为1号数据库。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%9B%AE%E6%A0%87%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA1%E5%8F%B7%E6%95%B0%E6%8D%AE%E5%BA%93.png\" alt=\"客户端的目标数据库为1号数据库\"></p>\n<p><strong>问: SELECT命令的实现原理是什么？</strong></p>\n<p>通过修改redisClient.db指针，让它指向服务器中不同数据库，从而实现切换目标数据库的功能。</p>\n<h3 id=\"3-数据库键空间\"><a href=\"#3-数据库键空间\" class=\"headerlink\" title=\"3 数据库键空间\"></a>3 数据库键空间</h3><p>Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个<code>redis.h/redisDb</code>结构表示，其中，<code>redisDb</code>结构的<code>dict</code>字典保存了数据库中的所有键值对，我们将这个字典称为<strong>键空间（key space）</strong>。</p>\n<p><code>redis.h/redisDb</code>结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDb</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 数据库键空间，保存着数据库中的所有键值对.</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;redisDb;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中，</p>\n<ul>\n<li>键空间的键就是<strong>数据库的键</strong>，每个键都是一个<code>字符串对象</code>；</li>\n<li>键空间的值就是<strong>数据库的值</strong>，每个值都可以是<code>字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象</code>。</li>\n</ul>\n<p>示例：下图为包含了列表键、哈希表键、字符串键的结构图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%8C%85%E5%90%AB%E4%BA%86%E5%88%97%E8%A1%A8%E9%94%AE%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E9%94%AE%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%94%AE%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.png\" alt=\"包含了列表键、哈希表键、字符串键的结构图\"></p>\n<p><em>注：数据库的键空间是一个字典，所以所有针对数据库的操作，实际上都是通过对键空间字典进行操作来实现的。</em></p>\n<ul>\n<li>添加新键: 添加新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</li>\n<li>删除键: 删除数据库中的一个键，实际上就是在键空间里面删除键所对应额键值对对象。（<strong>键对象和值对象都要删除！</strong>）</li>\n<li>更新键: 更新数据库键，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</li>\n<li>对键取值: 取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</li>\n</ul>\n<h4 id=\"3-1-其他键空间的操作\"><a href=\"#3-1-其他键空间的操作\" class=\"headerlink\" title=\"3.1 其他键空间的操作\"></a>3.1 其他键空间的操作</h4><p>除了以上增删改查的操作，还有其他一些命令是通过对键空间进行处理来完成的。</p>\n<p>比如说：</p>\n<ul>\n<li><code>flushdb</code>命令: 通过删除键空间中的所有键值对来实现的。</li>\n<li><code>randomkey</code>命令: 随机返回某个键，也是在键空间中随机返回的。</li>\n<li><code>dbsize</code>命令: 返回数据库键数量，通过返回键空间中包含的键值对的数量来完成。</li>\n<li><code>exist、rename、keys</code>等。</li>\n</ul>\n<h4 id=\"3-2-读写键空间时的维护操作\"><a href=\"#3-2-读写键空间时的维护操作\" class=\"headerlink\" title=\"3.2 读写键空间时的维护操作\"></a>3.2 读写键空间时的维护操作</h4><p>当时用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操纵，还会执行一些额外的维护操作，比如：</p>\n<ul>\n<li><p>①、在读取一个键之后（读写操作都会对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（keyspace_hit）/未命中(keyspace_misses)的次数。通过以下命令可查看其属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO stats</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>②、在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用以下命令可查看键的闲置时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object idletime &lt;key&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>③、若服务器在读取一个键时发现该键已过期，那么服务器会先删除这个过期键，然后执行余下的其他操作。</p>\n</li>\n<li><p>④、若有客户端使用watch命令监视了这个键，那么服务器在对被监视的键进行修改之后，会标记这个键为脏（dirty），从而让事务成武注意到这个键已经被修改过。</p>\n</li>\n<li><p>⑤、服务器每次修改一个键之后，都会对dity键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</p>\n</li>\n<li><p>⑥、若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据通知。</p>\n</li>\n</ul>\n<h3 id=\"4-数据库通知\"><a href=\"#4-数据库通知\" class=\"headerlink\" title=\"4 数据库通知\"></a>4 数据库通知</h3><p>数据库通知可以让客户端通过订阅给定频道或者模式，来获悉数据库中键的变化，以及数据中命令的执行情况。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-服务器中的数据库\"><a href=\"#1-服务器中的数据库\" class=\"headerlink\" title=\"1 服务器中的数据库\"></a>1 服务器中的数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态<code>redis.h/redisServer</code>结构的<code>db数组</code>中，db数组的每个项都是一个<code>redis.h/redisDb</code>结构，每个redisDb结构代表了一个数据库。</p>","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 一个数组，保存着服务器中的所有数据库.</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">    <span class=\"comment\">// 总配置的数据库的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dbnum;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。</p>\n<h3 id=\"2-切换数据库\"><a href=\"#2-切换数据库\" class=\"headerlink\" title=\"2 切换数据库\"></a>2 切换数据库</h3><p>默认情况下，Redis客户端的目标数据库为<code>0号数据库</code>，通过<code>select命令</code>可切换数据库。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到数据库2.</span></span><br><span class=\"line\">redis&gt; select 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中<code>redisClient</code>结构中的<code>db属性记录了当前客户端的目标数据库</code>，该属性是一个指向<code>redisDb</code>结构的指针，<code>redisClient.db</code>指向<code>redisServer.db</code>数组的其中一个元素，<code>被指向的元素即为目标数据库</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisClient</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录客户端当前正在使用的数据库.</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; redisClient;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>下图为客户端的目标数据库为1号数据库。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%9B%AE%E6%A0%87%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA1%E5%8F%B7%E6%95%B0%E6%8D%AE%E5%BA%93.png\" alt=\"客户端的目标数据库为1号数据库\"></p>\n<p><strong>问: SELECT命令的实现原理是什么？</strong></p>\n<p>通过修改redisClient.db指针，让它指向服务器中不同数据库，从而实现切换目标数据库的功能。</p>\n<h3 id=\"3-数据库键空间\"><a href=\"#3-数据库键空间\" class=\"headerlink\" title=\"3 数据库键空间\"></a>3 数据库键空间</h3><p>Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个<code>redis.h/redisDb</code>结构表示，其中，<code>redisDb</code>结构的<code>dict</code>字典保存了数据库中的所有键值对，我们将这个字典称为<strong>键空间（key space）</strong>。</p>\n<p><code>redis.h/redisDb</code>结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDb</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 数据库键空间，保存着数据库中的所有键值对.</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;redisDb;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中，</p>\n<ul>\n<li>键空间的键就是<strong>数据库的键</strong>，每个键都是一个<code>字符串对象</code>；</li>\n<li>键空间的值就是<strong>数据库的值</strong>，每个值都可以是<code>字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象</code>。</li>\n</ul>\n<p>示例：下图为包含了列表键、哈希表键、字符串键的结构图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%8C%85%E5%90%AB%E4%BA%86%E5%88%97%E8%A1%A8%E9%94%AE%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E9%94%AE%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%94%AE%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.png\" alt=\"包含了列表键、哈希表键、字符串键的结构图\"></p>\n<p><em>注：数据库的键空间是一个字典，所以所有针对数据库的操作，实际上都是通过对键空间字典进行操作来实现的。</em></p>\n<ul>\n<li>添加新键: 添加新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</li>\n<li>删除键: 删除数据库中的一个键，实际上就是在键空间里面删除键所对应额键值对对象。（<strong>键对象和值对象都要删除！</strong>）</li>\n<li>更新键: 更新数据库键，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</li>\n<li>对键取值: 取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</li>\n</ul>\n<h4 id=\"3-1-其他键空间的操作\"><a href=\"#3-1-其他键空间的操作\" class=\"headerlink\" title=\"3.1 其他键空间的操作\"></a>3.1 其他键空间的操作</h4><p>除了以上增删改查的操作，还有其他一些命令是通过对键空间进行处理来完成的。</p>\n<p>比如说：</p>\n<ul>\n<li><code>flushdb</code>命令: 通过删除键空间中的所有键值对来实现的。</li>\n<li><code>randomkey</code>命令: 随机返回某个键，也是在键空间中随机返回的。</li>\n<li><code>dbsize</code>命令: 返回数据库键数量，通过返回键空间中包含的键值对的数量来完成。</li>\n<li><code>exist、rename、keys</code>等。</li>\n</ul>\n<h4 id=\"3-2-读写键空间时的维护操作\"><a href=\"#3-2-读写键空间时的维护操作\" class=\"headerlink\" title=\"3.2 读写键空间时的维护操作\"></a>3.2 读写键空间时的维护操作</h4><p>当时用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操纵，还会执行一些额外的维护操作，比如：</p>\n<ul>\n<li><p>①、在读取一个键之后（读写操作都会对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（keyspace_hit）/未命中(keyspace_misses)的次数。通过以下命令可查看其属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO stats</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>②、在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用以下命令可查看键的闲置时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object idletime &lt;key&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>③、若服务器在读取一个键时发现该键已过期，那么服务器会先删除这个过期键，然后执行余下的其他操作。</p>\n</li>\n<li><p>④、若有客户端使用watch命令监视了这个键，那么服务器在对被监视的键进行修改之后，会标记这个键为脏（dirty），从而让事务成武注意到这个键已经被修改过。</p>\n</li>\n<li><p>⑤、服务器每次修改一个键之后，都会对dity键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</p>\n</li>\n<li><p>⑥、若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据通知。</p>\n</li>\n</ul>\n<h3 id=\"4-数据库通知\"><a href=\"#4-数据库通知\" class=\"headerlink\" title=\"4 数据库通知\"></a>4 数据库通知</h3><p>数据库通知可以让客户端通过订阅给定频道或者模式，来获悉数据库中键的变化，以及数据中命令的执行情况。</p>"},{"title":"Redis设计与实现-RDB持久化","date":"2020-09-03T07:52:31.000Z","_content":"\nRedis是内存数据库，它将自己的数据库状态储存在内存里面，若不将其保存到磁盘上，一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此Redis提供了RDB持久化功能，将Redis内存中的数据库状态保存到磁盘里面，避免数据意外丢失。\n\n<!--more-->\n\nRDB持久化可以手动执行，也可以根据服务器配选项定期执行，将某个时间点的数据库状态保存到RDB文件中，也可通过该文件还原生成RDB文件时的数据库状态。\n\n### 1 RDB文件的创建与载入\n\n#### 1.1 RDB文件的创建\n\nRedis通过以下两个命令，可生成RDB文件。\n\n- ①、`同步保存到磁盘命令`\n\n```\nSAVE\n```\n\n- ②、`在后台异步保存当前数据到磁盘命令`\n\n```\nBGSAVE\n```\n\n其中，\n\n- `SAVE命令会阻塞Redis服务器进程`，直到RDB文件创建完毕。\n- `BGSAVE命令是异步的，它将派生出一个子进程`，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。\n\n创建RDB文件实际工作由`rdb.c/rdbSave函数`完成，SAVE和BGSAVE命令会以不同的方式调用该函数。\n\n\n\nBGSAVE以子进程方式执行，在执行时，会拒绝新进入的SAVE、BGSAGE命令。而BGREWRITEAOF命令将会被延迟到BGSAVE命令执行结束。\n\nBGREWRITEAOF命令执行时，新进入的BGSAVE命令将被拒绝。\n\n\n\n#### 1.2 RDB文件的载入\n\nRDB`文件的载入工作是在服务器启动时自动执行的`，Redis并没有提供专门用于载入RDB文件的命令。\n\n*注：AOP文件的更新频率通常比RDB文件的更频率高，因此，若服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。*\n\n\n\nRDB文件载入时，服务器将一直处于阻塞状态，直到载入工作完成为止。\n\n\n\n### 2 自动间隔保存\n\n由于BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置（`/etc/redis/redis.conf`配置文件）的`save`选项，让服务器每隔一段时间自动执行一次BGSAVE命令。\n\n\n\n示例：当前Redis默认配置save选项如下，当条件满足时，BGSAVE命令将被执行。\n\n```\n# 服务器在900秒之内，对数据库进行了至少1次修改。\nsave 900 1\n# 服务器在300秒之内，对数据库进行了至少10次修改。\nsave 300 10\n# 服务器在60秒之内，对数据库进行了至少10000次修改。\nsave 60 10000\n```\n\n\n\n#### 2.1 设置保存条件\n\n当Redis服务启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，若未主动设置save选项，那么服务器将使用redis.conf文件中默认的save条件：\n\n```\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n\n\n在`redisServer结构`中有一个`saveparams`属性，用于保存save设置的保存条件。\n\n```c\nstruct redisServer {\n    // ...\n    // 记录了保存条件的数组.\n    struct saveparam *saveparams;\n    // ...\n};\n```\n\n\n\n默认条件下服务器状态中的`saveparams`数组示意如下：\n\n![默认条件下服务器状态中的saveparams数组示意](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/默认条件下服务器状态中的saveparams数组示意.png)\n\n\n\n#### 2.2 dirty计数器和lastsave属性\n\n- **dirty计数器属性**: 记录距离上一次成功执行`SAVE`或者`BGSAVE`命令之后，服务器对数据状态（服务器中所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。\n\n- **lastsave属性**: 是一个UNIX时间戳，记录了服务器上一次成功执行`SAVE`或者`BGSAVE`命令的时间。\n\n\n\n#### 2.3 检查保存条件是否满足\n\nRedis的服务器周期性操作函数serverCron默认每隔`100ms`就执行一次，`该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的条件是否满足，若满足，则执行BGSAVE命令。`\n\n\n\n示例：服务器状态如下，其中dirty为123，表示距离上一次执行SAVE或者BGSAVE命令后，数据状态修改了123次，此时，若时间来到1378271101时，即301秒后，服务器将自动执行一次BGSAVE命令。执行完成后dirty属性将被清零。\n\n![服务器状态如下，其中dirty为123](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/服务器状态如下，其中dirty为123.png)\n\n\n\n### 3 RDB文件结构\n\n`RDB文件是一个经过压缩的二进制文件，由多个部分组成`，对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。\n\n\n\n一个完整的RDB文件包含以下几个部分，如下图所示：\n\n![一个完整的RDB文件包含以下几个部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/一个完整的RDB文件包含以下几个部分.png)\n\n- ①、`REDIS`：长度为5字节的常量，保存着`\"REDIS\"`5个字符，通过这5个字符，程序在载入文件时，快速检查所在入的文件是否RDB文件。\n- ②、`db_version`：长度为4字节，它的值是一个字符串表示整数，记录了RDB文件的版本号，例如“0006”就代表RDB文件的版本为第六版。\n- ③、`databases`：包含着零个或任意多个数据库，以及各个数据库中的键值对数据。\n- ④、`EOF`：长度为1字节的常量，标志着RDB文件正文内容的结束。\n- ⑤、`check_sum`：长度为8字节的无符号整数，保存着通过REDIS、db_version、databases、EOF四个部分计算出的校验和。\n\n\n\n#### 3.1 databases部分\n\n一个RDB文件的`databases`部分可以`保存任意多个非空数据库`。\n\n每个非空数据库在RDB文件中都保存着以下三个部分：\n\n![每个非空数据库在RDB文件中都保存着以下三个部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/每个非空数据库在RDB文件中都保存着以下三个部分.png)\n\n- ①、`SELECTDB`：长度为1字节的常量，表示接下来读取的将是一个数据库号码。\n- ②、`db_number`：长度为1字节/2字节/5字节的数据库号码。程序根据该号码，调用SELECT命令切换数据库。\n- ③、`key_value_pairs`：保存数据库中所有的键值对数据（注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起）。\n\n\n\n#### 3.2 key_value_pairs部分\n\nRDB文件的每个`key_value_pairs`：保存数据库中所有的键值对数据（*注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起*）。\n\n\n\n##### 3.2.1 不带过期时间的键值对组成\n\n不带过期时间的键值对由以下三个部分组成：\n\n![不带过期时间的键值对由以下三个部分组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/不带过期时间的键值对由以下三个部分组成.png)\n\n- ①、`Type`：记录了value的类型，长度为1字节的常量，包括以下常量，每种常量都代表了一种类型或者底层编码，服务器根据type的值决定如何读入和解释value数据。\n\n- - REDIS_RDB_TYPE_STRING\n  - REDIS_RDB_TYPE_LIST\n  - REDIS_RDB_TYPE_SET\n  - REDIS_RDB_TYPE_ZSET\n  - REDIS_RDB_TYPE_HASH\n  - REDIS_RDB_TYPE_LIST_ZIPLIST\n  - REDIS_RDB_TYPE_SET_INTSET\n  - REDIS_RDB_TYPE_ZSET_ZIPLIST\n  - REDIS_RDB_TYPE_HASH_ZIPLIST\n\n- ②、`key`：保存了键值对的键对象\n\n- ③、`value`：保存了键值对的值对象。\n\n\n\n##### 3.2.2 带过期时间的键值对组成\n\n带过期时间的键值对在RDB文件中的组成如下：\n\n![带过期时间的键值对在RDB文件中的组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/带过期时间的键值对在RDB文件中的组成.png)\n\n其中TYPE、key、value三个部分的意义均与不带过期时间的组成相同。\n\n- ①、EXPIRETIME_MS：长度为1字节的常量，表示接下来读入的是一个以毫秒为单位的过期时间。\n- ②、ms：8字节长的带符号的整数，记录了一个以毫秒为单位的UNIX时间戳。\n\n\n\n#### 3.3 value编码\n\nRDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都有与之对应的Type记录，根据类型的不同，value部分的结构，长度也会有所不同。\n\n\n\n### 4 分析RDB文件\n\n通过Linux的`od指令`来分析Redis服务器产生的RDB文件，使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。RDB文件路径可通过`/etc/redis/redis.conf`文件中查看，如下所示，因此RDB文件路径为：`/var/lib/redis/dump.rdb`\n\n\n\n`/etc/redis/redis.conf`中配置如下:\n\n```\n# 打印的RDB文件名。\ndbfilename dump.rdb\n#\n# 路径.\ndir /var/lib/redis\n```\n\n\n\n#### 4.1 不包含任何键值对的RDB文件\n\n执行以下命令，创建一个数据库状态为空的RDB文件：\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> save\nOK\n```\n\n\n\n通过od命令打印RDB文件内容，并使用ASCII或反斜杠序列展示结果(`-c参数`), 如下所示：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 377 334 263   C 360   Z 334\n0000020 362   V\n0000022\n```\n\n其中：\n\n- 五个字节的“REDIS”字符串\n- 四个字节的版本号（0006）\n- 377是EOF常量\n- 334 263   C 360   Z 334 362   V为8个字节的校验和\n\n\n\n#### 4.2 包含字符串键的RDB文件\n\n执行以下命令，分析一个带有单个字符串键的数据库：\n\n```bash\n127.0.0.1:6379> flushdb\nOK\n127.0.0.1:6379> set msg \"HELLO\"\nOK\n127.0.0.1:6379> save\nOK\n```\n\n\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0  \\0 003   m   s   g\n0000020 005   H   E   L   L   O 377  \\n   < 342 005   <   A 217   4\n0000037\n```\n\n其中:\n\n- 五个字节的“REDIS”字符串\n- 四个字节的版本号（0006）\n- 376表示SELECTED常量\n- \\0表示数据库0\n- \\0表示表示字符串\n- 003表示msg的长度\n- msg表示key\n- 005表示value的长度\n- HEELO为value\n- 377是EOF常量\n-  \\n   < 342 005   <   A 217   4为8个字节的校验和\n\n\n\n#### 4.3 包含过期时间的字符串键的RDB文件\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> setex msg 10086 \"HELLO\"\nOK\n127.0.0.1:6379> save\nOK\n```\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0 374 375   3   {   3\n0000020   r 001  \\0  \\0  \\0 003   m   s   g 005   H   E   L   L   O 377\n0000040 317   W 312 301 337 313 364 201\n0000050\n```\n\n\n\n#### 4.4 包含一个集合键的RDB文件\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> sadd lang \"C\" \"JAVA\" \"RUBY\"\n(integer) 3\n127.0.0.1:6379> SAVE\nOK\n```\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0 002 004   l   a   n\n0000020   g 003 004   J   A   V   A 004   R   U   B   Y 001   C 377   u\n0000040 177 235 372   z 334  \\f 216\n0000047\n```\n\n","source":"_posts/Redis设计与实现-RDB持久化.md","raw":"---\ntitle: Redis设计与实现-RDB持久化\ndate: 2020-09-03 15:52:31\ntags: [\"Redis\",\"Note\"]\ncategories: [\"Redis\", \"Note\", \"Redis设计与实现\"]\n---\n\nRedis是内存数据库，它将自己的数据库状态储存在内存里面，若不将其保存到磁盘上，一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此Redis提供了RDB持久化功能，将Redis内存中的数据库状态保存到磁盘里面，避免数据意外丢失。\n\n<!--more-->\n\nRDB持久化可以手动执行，也可以根据服务器配选项定期执行，将某个时间点的数据库状态保存到RDB文件中，也可通过该文件还原生成RDB文件时的数据库状态。\n\n### 1 RDB文件的创建与载入\n\n#### 1.1 RDB文件的创建\n\nRedis通过以下两个命令，可生成RDB文件。\n\n- ①、`同步保存到磁盘命令`\n\n```\nSAVE\n```\n\n- ②、`在后台异步保存当前数据到磁盘命令`\n\n```\nBGSAVE\n```\n\n其中，\n\n- `SAVE命令会阻塞Redis服务器进程`，直到RDB文件创建完毕。\n- `BGSAVE命令是异步的，它将派生出一个子进程`，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。\n\n创建RDB文件实际工作由`rdb.c/rdbSave函数`完成，SAVE和BGSAVE命令会以不同的方式调用该函数。\n\n\n\nBGSAVE以子进程方式执行，在执行时，会拒绝新进入的SAVE、BGSAGE命令。而BGREWRITEAOF命令将会被延迟到BGSAVE命令执行结束。\n\nBGREWRITEAOF命令执行时，新进入的BGSAVE命令将被拒绝。\n\n\n\n#### 1.2 RDB文件的载入\n\nRDB`文件的载入工作是在服务器启动时自动执行的`，Redis并没有提供专门用于载入RDB文件的命令。\n\n*注：AOP文件的更新频率通常比RDB文件的更频率高，因此，若服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。*\n\n\n\nRDB文件载入时，服务器将一直处于阻塞状态，直到载入工作完成为止。\n\n\n\n### 2 自动间隔保存\n\n由于BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置（`/etc/redis/redis.conf`配置文件）的`save`选项，让服务器每隔一段时间自动执行一次BGSAVE命令。\n\n\n\n示例：当前Redis默认配置save选项如下，当条件满足时，BGSAVE命令将被执行。\n\n```\n# 服务器在900秒之内，对数据库进行了至少1次修改。\nsave 900 1\n# 服务器在300秒之内，对数据库进行了至少10次修改。\nsave 300 10\n# 服务器在60秒之内，对数据库进行了至少10000次修改。\nsave 60 10000\n```\n\n\n\n#### 2.1 设置保存条件\n\n当Redis服务启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，若未主动设置save选项，那么服务器将使用redis.conf文件中默认的save条件：\n\n```\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n\n\n在`redisServer结构`中有一个`saveparams`属性，用于保存save设置的保存条件。\n\n```c\nstruct redisServer {\n    // ...\n    // 记录了保存条件的数组.\n    struct saveparam *saveparams;\n    // ...\n};\n```\n\n\n\n默认条件下服务器状态中的`saveparams`数组示意如下：\n\n![默认条件下服务器状态中的saveparams数组示意](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/默认条件下服务器状态中的saveparams数组示意.png)\n\n\n\n#### 2.2 dirty计数器和lastsave属性\n\n- **dirty计数器属性**: 记录距离上一次成功执行`SAVE`或者`BGSAVE`命令之后，服务器对数据状态（服务器中所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。\n\n- **lastsave属性**: 是一个UNIX时间戳，记录了服务器上一次成功执行`SAVE`或者`BGSAVE`命令的时间。\n\n\n\n#### 2.3 检查保存条件是否满足\n\nRedis的服务器周期性操作函数serverCron默认每隔`100ms`就执行一次，`该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的条件是否满足，若满足，则执行BGSAVE命令。`\n\n\n\n示例：服务器状态如下，其中dirty为123，表示距离上一次执行SAVE或者BGSAVE命令后，数据状态修改了123次，此时，若时间来到1378271101时，即301秒后，服务器将自动执行一次BGSAVE命令。执行完成后dirty属性将被清零。\n\n![服务器状态如下，其中dirty为123](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/服务器状态如下，其中dirty为123.png)\n\n\n\n### 3 RDB文件结构\n\n`RDB文件是一个经过压缩的二进制文件，由多个部分组成`，对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。\n\n\n\n一个完整的RDB文件包含以下几个部分，如下图所示：\n\n![一个完整的RDB文件包含以下几个部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/一个完整的RDB文件包含以下几个部分.png)\n\n- ①、`REDIS`：长度为5字节的常量，保存着`\"REDIS\"`5个字符，通过这5个字符，程序在载入文件时，快速检查所在入的文件是否RDB文件。\n- ②、`db_version`：长度为4字节，它的值是一个字符串表示整数，记录了RDB文件的版本号，例如“0006”就代表RDB文件的版本为第六版。\n- ③、`databases`：包含着零个或任意多个数据库，以及各个数据库中的键值对数据。\n- ④、`EOF`：长度为1字节的常量，标志着RDB文件正文内容的结束。\n- ⑤、`check_sum`：长度为8字节的无符号整数，保存着通过REDIS、db_version、databases、EOF四个部分计算出的校验和。\n\n\n\n#### 3.1 databases部分\n\n一个RDB文件的`databases`部分可以`保存任意多个非空数据库`。\n\n每个非空数据库在RDB文件中都保存着以下三个部分：\n\n![每个非空数据库在RDB文件中都保存着以下三个部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/每个非空数据库在RDB文件中都保存着以下三个部分.png)\n\n- ①、`SELECTDB`：长度为1字节的常量，表示接下来读取的将是一个数据库号码。\n- ②、`db_number`：长度为1字节/2字节/5字节的数据库号码。程序根据该号码，调用SELECT命令切换数据库。\n- ③、`key_value_pairs`：保存数据库中所有的键值对数据（注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起）。\n\n\n\n#### 3.2 key_value_pairs部分\n\nRDB文件的每个`key_value_pairs`：保存数据库中所有的键值对数据（*注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起*）。\n\n\n\n##### 3.2.1 不带过期时间的键值对组成\n\n不带过期时间的键值对由以下三个部分组成：\n\n![不带过期时间的键值对由以下三个部分组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/不带过期时间的键值对由以下三个部分组成.png)\n\n- ①、`Type`：记录了value的类型，长度为1字节的常量，包括以下常量，每种常量都代表了一种类型或者底层编码，服务器根据type的值决定如何读入和解释value数据。\n\n- - REDIS_RDB_TYPE_STRING\n  - REDIS_RDB_TYPE_LIST\n  - REDIS_RDB_TYPE_SET\n  - REDIS_RDB_TYPE_ZSET\n  - REDIS_RDB_TYPE_HASH\n  - REDIS_RDB_TYPE_LIST_ZIPLIST\n  - REDIS_RDB_TYPE_SET_INTSET\n  - REDIS_RDB_TYPE_ZSET_ZIPLIST\n  - REDIS_RDB_TYPE_HASH_ZIPLIST\n\n- ②、`key`：保存了键值对的键对象\n\n- ③、`value`：保存了键值对的值对象。\n\n\n\n##### 3.2.2 带过期时间的键值对组成\n\n带过期时间的键值对在RDB文件中的组成如下：\n\n![带过期时间的键值对在RDB文件中的组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/带过期时间的键值对在RDB文件中的组成.png)\n\n其中TYPE、key、value三个部分的意义均与不带过期时间的组成相同。\n\n- ①、EXPIRETIME_MS：长度为1字节的常量，表示接下来读入的是一个以毫秒为单位的过期时间。\n- ②、ms：8字节长的带符号的整数，记录了一个以毫秒为单位的UNIX时间戳。\n\n\n\n#### 3.3 value编码\n\nRDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都有与之对应的Type记录，根据类型的不同，value部分的结构，长度也会有所不同。\n\n\n\n### 4 分析RDB文件\n\n通过Linux的`od指令`来分析Redis服务器产生的RDB文件，使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。RDB文件路径可通过`/etc/redis/redis.conf`文件中查看，如下所示，因此RDB文件路径为：`/var/lib/redis/dump.rdb`\n\n\n\n`/etc/redis/redis.conf`中配置如下:\n\n```\n# 打印的RDB文件名。\ndbfilename dump.rdb\n#\n# 路径.\ndir /var/lib/redis\n```\n\n\n\n#### 4.1 不包含任何键值对的RDB文件\n\n执行以下命令，创建一个数据库状态为空的RDB文件：\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> save\nOK\n```\n\n\n\n通过od命令打印RDB文件内容，并使用ASCII或反斜杠序列展示结果(`-c参数`), 如下所示：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 377 334 263   C 360   Z 334\n0000020 362   V\n0000022\n```\n\n其中：\n\n- 五个字节的“REDIS”字符串\n- 四个字节的版本号（0006）\n- 377是EOF常量\n- 334 263   C 360   Z 334 362   V为8个字节的校验和\n\n\n\n#### 4.2 包含字符串键的RDB文件\n\n执行以下命令，分析一个带有单个字符串键的数据库：\n\n```bash\n127.0.0.1:6379> flushdb\nOK\n127.0.0.1:6379> set msg \"HELLO\"\nOK\n127.0.0.1:6379> save\nOK\n```\n\n\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0  \\0 003   m   s   g\n0000020 005   H   E   L   L   O 377  \\n   < 342 005   <   A 217   4\n0000037\n```\n\n其中:\n\n- 五个字节的“REDIS”字符串\n- 四个字节的版本号（0006）\n- 376表示SELECTED常量\n- \\0表示数据库0\n- \\0表示表示字符串\n- 003表示msg的长度\n- msg表示key\n- 005表示value的长度\n- HEELO为value\n- 377是EOF常量\n-  \\n   < 342 005   <   A 217   4为8个字节的校验和\n\n\n\n#### 4.3 包含过期时间的字符串键的RDB文件\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> setex msg 10086 \"HELLO\"\nOK\n127.0.0.1:6379> save\nOK\n```\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0 374 375   3   {   3\n0000020   r 001  \\0  \\0  \\0 003   m   s   g 005   H   E   L   L   O 377\n0000040 317   W 312 301 337 313 364 201\n0000050\n```\n\n\n\n#### 4.4 包含一个集合键的RDB文件\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> sadd lang \"C\" \"JAVA\" \"RUBY\"\n(integer) 3\n127.0.0.1:6379> SAVE\nOK\n```\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0 002 004   l   a   n\n0000020   g 003 004   J   A   V   A 004   R   U   B   Y 001   C 377   u\n0000040 177 235 372   z 334  \\f 216\n0000047\n```\n\n","slug":"Redis设计与实现-RDB持久化","published":1,"updated":"2020-09-04T02:45:36.130Z","_id":"ckemo6ffl000095g3arceblzo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Redis是内存数据库，它将自己的数据库状态储存在内存里面，若不将其保存到磁盘上，一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此Redis提供了RDB持久化功能，将Redis内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p>\n<a id=\"more\"></a>\n\n<p>RDB持久化可以手动执行，也可以根据服务器配选项定期执行，将某个时间点的数据库状态保存到RDB文件中，也可通过该文件还原生成RDB文件时的数据库状态。</p>\n<h3 id=\"1-RDB文件的创建与载入\"><a href=\"#1-RDB文件的创建与载入\" class=\"headerlink\" title=\"1 RDB文件的创建与载入\"></a>1 RDB文件的创建与载入</h3><h4 id=\"1-1-RDB文件的创建\"><a href=\"#1-1-RDB文件的创建\" class=\"headerlink\" title=\"1.1 RDB文件的创建\"></a>1.1 RDB文件的创建</h4><p>Redis通过以下两个命令，可生成RDB文件。</p>\n<ul>\n<li>①、<code>同步保存到磁盘命令</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAVE</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、<code>在后台异步保存当前数据到磁盘命令</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BGSAVE</span><br></pre></td></tr></table></figure>\n\n<p>其中，</p>\n<ul>\n<li><code>SAVE命令会阻塞Redis服务器进程</code>，直到RDB文件创建完毕。</li>\n<li><code>BGSAVE命令是异步的，它将派生出一个子进程</code>，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</li>\n</ul>\n<p>创建RDB文件实际工作由<code>rdb.c/rdbSave函数</code>完成，SAVE和BGSAVE命令会以不同的方式调用该函数。</p>\n<p>BGSAVE以子进程方式执行，在执行时，会拒绝新进入的SAVE、BGSAGE命令。而BGREWRITEAOF命令将会被延迟到BGSAVE命令执行结束。</p>\n<p>BGREWRITEAOF命令执行时，新进入的BGSAVE命令将被拒绝。</p>\n<h4 id=\"1-2-RDB文件的载入\"><a href=\"#1-2-RDB文件的载入\" class=\"headerlink\" title=\"1.2 RDB文件的载入\"></a>1.2 RDB文件的载入</h4><p>RDB<code>文件的载入工作是在服务器启动时自动执行的</code>，Redis并没有提供专门用于载入RDB文件的命令。</p>\n<p><em>注：AOP文件的更新频率通常比RDB文件的更频率高，因此，若服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</em></p>\n<p>RDB文件载入时，服务器将一直处于阻塞状态，直到载入工作完成为止。</p>\n<h3 id=\"2-自动间隔保存\"><a href=\"#2-自动间隔保存\" class=\"headerlink\" title=\"2 自动间隔保存\"></a>2 自动间隔保存</h3><p>由于BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置（<code>/etc/redis/redis.conf</code>配置文件）的<code>save</code>选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p>\n<p>示例：当前Redis默认配置save选项如下，当条件满足时，BGSAVE命令将被执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 服务器在900秒之内，对数据库进行了至少1次修改。</span><br><span class=\"line\">save 900 1</span><br><span class=\"line\"># 服务器在300秒之内，对数据库进行了至少10次修改。</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\"># 服务器在60秒之内，对数据库进行了至少10000次修改。</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-设置保存条件\"><a href=\"#2-1-设置保存条件\" class=\"headerlink\" title=\"2.1 设置保存条件\"></a>2.1 设置保存条件</h4><p>当Redis服务启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，若未主动设置save选项，那么服务器将使用redis.conf文件中默认的save条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save 900 1</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在<code>redisServer结构</code>中有一个<code>saveparams</code>属性，用于保存save设置的保存条件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录了保存条件的数组.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">saveparam</span> *<span class=\"title\">saveparams</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认条件下服务器状态中的<code>saveparams</code>数组示意如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E9%BB%98%E8%AE%A4%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84saveparams%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F.png\" alt=\"默认条件下服务器状态中的saveparams数组示意\"></p>\n<h4 id=\"2-2-dirty计数器和lastsave属性\"><a href=\"#2-2-dirty计数器和lastsave属性\" class=\"headerlink\" title=\"2.2 dirty计数器和lastsave属性\"></a>2.2 dirty计数器和lastsave属性</h4><ul>\n<li><p><strong>dirty计数器属性</strong>: 记录距离上一次成功执行<code>SAVE</code>或者<code>BGSAVE</code>命令之后，服务器对数据状态（服务器中所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</p>\n</li>\n<li><p><strong>lastsave属性</strong>: 是一个UNIX时间戳，记录了服务器上一次成功执行<code>SAVE</code>或者<code>BGSAVE</code>命令的时间。</p>\n</li>\n</ul>\n<h4 id=\"2-3-检查保存条件是否满足\"><a href=\"#2-3-检查保存条件是否满足\" class=\"headerlink\" title=\"2.3 检查保存条件是否满足\"></a>2.3 检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数serverCron默认每隔<code>100ms</code>就执行一次，<code>该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的条件是否满足，若满足，则执行BGSAVE命令。</code></p>\n<p>示例：服务器状态如下，其中dirty为123，表示距离上一次执行SAVE或者BGSAVE命令后，数据状态修改了123次，此时，若时间来到1378271101时，即301秒后，服务器将自动执行一次BGSAVE命令。执行完成后dirty属性将被清零。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E5%A6%82%E4%B8%8B%EF%BC%8C%E5%85%B6%E4%B8%ADdirty%E4%B8%BA123.png\" alt=\"服务器状态如下，其中dirty为123\"></p>\n<h3 id=\"3-RDB文件结构\"><a href=\"#3-RDB文件结构\" class=\"headerlink\" title=\"3 RDB文件结构\"></a>3 RDB文件结构</h3><p><code>RDB文件是一个经过压缩的二进制文件，由多个部分组成</code>，对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。</p>\n<p>一个完整的RDB文件包含以下几个部分，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84RDB%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86.png\" alt=\"一个完整的RDB文件包含以下几个部分\"></p>\n<ul>\n<li>①、<code>REDIS</code>：长度为5字节的常量，保存着<code>&quot;REDIS&quot;</code>5个字符，通过这5个字符，程序在载入文件时，快速检查所在入的文件是否RDB文件。</li>\n<li>②、<code>db_version</code>：长度为4字节，它的值是一个字符串表示整数，记录了RDB文件的版本号，例如“0006”就代表RDB文件的版本为第六版。</li>\n<li>③、<code>databases</code>：包含着零个或任意多个数据库，以及各个数据库中的键值对数据。</li>\n<li>④、<code>EOF</code>：长度为1字节的常量，标志着RDB文件正文内容的结束。</li>\n<li>⑤、<code>check_sum</code>：长度为8字节的无符号整数，保存着通过REDIS、db_version、databases、EOF四个部分计算出的校验和。</li>\n</ul>\n<h4 id=\"3-1-databases部分\"><a href=\"#3-1-databases部分\" class=\"headerlink\" title=\"3.1 databases部分\"></a>3.1 databases部分</h4><p>一个RDB文件的<code>databases</code>部分可以<code>保存任意多个非空数据库</code>。</p>\n<p>每个非空数据库在RDB文件中都保存着以下三个部分：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E6%AF%8F%E4%B8%AA%E9%9D%9E%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E9%83%BD%E4%BF%9D%E5%AD%98%E7%9D%80%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86.png\" alt=\"每个非空数据库在RDB文件中都保存着以下三个部分\"></p>\n<ul>\n<li>①、<code>SELECTDB</code>：长度为1字节的常量，表示接下来读取的将是一个数据库号码。</li>\n<li>②、<code>db_number</code>：长度为1字节/2字节/5字节的数据库号码。程序根据该号码，调用SELECT命令切换数据库。</li>\n<li>③、<code>key_value_pairs</code>：保存数据库中所有的键值对数据（注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起）。</li>\n</ul>\n<h4 id=\"3-2-key-value-pairs部分\"><a href=\"#3-2-key-value-pairs部分\" class=\"headerlink\" title=\"3.2 key_value_pairs部分\"></a>3.2 key_value_pairs部分</h4><p>RDB文件的每个<code>key_value_pairs</code>：保存数据库中所有的键值对数据（<em>注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起</em>）。</p>\n<h5 id=\"3-2-1-不带过期时间的键值对组成\"><a href=\"#3-2-1-不带过期时间的键值对组成\" class=\"headerlink\" title=\"3.2.1 不带过期时间的键值对组成\"></a>3.2.1 不带过期时间的键值对组成</h5><p>不带过期时间的键值对由以下三个部分组成：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E4%B8%8D%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E7%94%B1%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png\" alt=\"不带过期时间的键值对由以下三个部分组成\"></p>\n<ul>\n<li><p>①、<code>Type</code>：记录了value的类型，长度为1字节的常量，包括以下常量，每种常量都代表了一种类型或者底层编码，服务器根据type的值决定如何读入和解释value数据。</p>\n</li>\n<li><ul>\n<li>REDIS_RDB_TYPE_STRING</li>\n<li>REDIS_RDB_TYPE_LIST</li>\n<li>REDIS_RDB_TYPE_SET</li>\n<li>REDIS_RDB_TYPE_ZSET</li>\n<li>REDIS_RDB_TYPE_HASH</li>\n<li>REDIS_RDB_TYPE_LIST_ZIPLIST</li>\n<li>REDIS_RDB_TYPE_SET_INTSET</li>\n<li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li>\n<li>REDIS_RDB_TYPE_HASH_ZIPLIST</li>\n</ul>\n</li>\n<li><p>②、<code>key</code>：保存了键值对的键对象</p>\n</li>\n<li><p>③、<code>value</code>：保存了键值对的值对象。</p>\n</li>\n</ul>\n<h5 id=\"3-2-2-带过期时间的键值对组成\"><a href=\"#3-2-2-带过期时间的键值对组成\" class=\"headerlink\" title=\"3.2.2 带过期时间的键值对组成\"></a>3.2.2 带过期时间的键值对组成</h5><p>带过期时间的键值对在RDB文件中的组成如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E5%9C%A8RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BB%84%E6%88%90.png\" alt=\"带过期时间的键值对在RDB文件中的组成\"></p>\n<p>其中TYPE、key、value三个部分的意义均与不带过期时间的组成相同。</p>\n<ul>\n<li>①、EXPIRETIME_MS：长度为1字节的常量，表示接下来读入的是一个以毫秒为单位的过期时间。</li>\n<li>②、ms：8字节长的带符号的整数，记录了一个以毫秒为单位的UNIX时间戳。</li>\n</ul>\n<h4 id=\"3-3-value编码\"><a href=\"#3-3-value编码\" class=\"headerlink\" title=\"3.3 value编码\"></a>3.3 value编码</h4><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都有与之对应的Type记录，根据类型的不同，value部分的结构，长度也会有所不同。</p>\n<h3 id=\"4-分析RDB文件\"><a href=\"#4-分析RDB文件\" class=\"headerlink\" title=\"4 分析RDB文件\"></a>4 分析RDB文件</h3><p>通过Linux的<code>od指令</code>来分析Redis服务器产生的RDB文件，使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。RDB文件路径可通过<code>/etc/redis/redis.conf</code>文件中查看，如下所示，因此RDB文件路径为：<code>/var/lib/redis/dump.rdb</code></p>\n<p><code>/etc/redis/redis.conf</code>中配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 打印的RDB文件名。</span><br><span class=\"line\">dbfilename dump.rdb</span><br><span class=\"line\">#</span><br><span class=\"line\"># 路径.</span><br><span class=\"line\">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-1-不包含任何键值对的RDB文件\"><a href=\"#4-1-不包含任何键值对的RDB文件\" class=\"headerlink\" title=\"4.1 不包含任何键值对的RDB文件\"></a>4.1 不包含任何键值对的RDB文件</h4><p>执行以下命令，创建一个数据库状态为空的RDB文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过od命令打印RDB文件内容，并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>), 如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 377 334 263   C 360   Z 334</span><br><span class=\"line\">0000020 362   V</span><br><span class=\"line\">0000022</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li>五个字节的“REDIS”字符串</li>\n<li>四个字节的版本号（0006）</li>\n<li>377是EOF常量</li>\n<li>334 263   C 360   Z 334 362   V为8个字节的校验和</li>\n</ul>\n<h4 id=\"4-2-包含字符串键的RDB文件\"><a href=\"#4-2-包含字符串键的RDB文件\" class=\"headerlink\" title=\"4.2 包含字符串键的RDB文件\"></a>4.2 包含字符串键的RDB文件</h4><p>执行以下命令，分析一个带有单个字符串键的数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushdb</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;HELLO&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0  \\0 003   m   s   g</span><br><span class=\"line\">0000020 005   H   E   L   L   O 377  \\n   &lt; 342 005   &lt;   A 217   4</span><br><span class=\"line\">0000037</span><br></pre></td></tr></table></figure>\n\n<p>其中:</p>\n<ul>\n<li>五个字节的“REDIS”字符串</li>\n<li>四个字节的版本号（0006）</li>\n<li>376表示SELECTED常量</li>\n<li>\\0表示数据库0</li>\n<li>\\0表示表示字符串</li>\n<li>003表示msg的长度</li>\n<li>msg表示key</li>\n<li>005表示value的长度</li>\n<li>HEELO为value</li>\n<li>377是EOF常量</li>\n<li>\\n   &lt; 342 005   &lt;   A 217   4为8个字节的校验和</li>\n</ul>\n<h4 id=\"4-3-包含过期时间的字符串键的RDB文件\"><a href=\"#4-3-包含过期时间的字符串键的RDB文件\" class=\"headerlink\" title=\"4.3 包含过期时间的字符串键的RDB文件\"></a>4.3 包含过期时间的字符串键的RDB文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; setex msg 10086 <span class=\"string\">&quot;HELLO&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0 374 375   3   &#123;   3</span><br><span class=\"line\">0000020   r 001  \\0  \\0  \\0 003   m   s   g 005   H   E   L   L   O 377</span><br><span class=\"line\">0000040 317   W 312 301 337 313 364 201</span><br><span class=\"line\">0000050</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-4-包含一个集合键的RDB文件\"><a href=\"#4-4-包含一个集合键的RDB文件\" class=\"headerlink\" title=\"4.4 包含一个集合键的RDB文件\"></a>4.4 包含一个集合键的RDB文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd lang <span class=\"string\">&quot;C&quot;</span> <span class=\"string\">&quot;JAVA&quot;</span> <span class=\"string\">&quot;RUBY&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SAVE</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0 002 004   l   a   n</span><br><span class=\"line\">0000020   g 003 004   J   A   V   A 004   R   U   B   Y 001   C 377   u</span><br><span class=\"line\">0000040 177 235 372   z 334  \\f 216</span><br><span class=\"line\">0000047</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Redis是内存数据库，它将自己的数据库状态储存在内存里面，若不将其保存到磁盘上，一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此Redis提供了RDB持久化功能，将Redis内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p>","more":"<p>RDB持久化可以手动执行，也可以根据服务器配选项定期执行，将某个时间点的数据库状态保存到RDB文件中，也可通过该文件还原生成RDB文件时的数据库状态。</p>\n<h3 id=\"1-RDB文件的创建与载入\"><a href=\"#1-RDB文件的创建与载入\" class=\"headerlink\" title=\"1 RDB文件的创建与载入\"></a>1 RDB文件的创建与载入</h3><h4 id=\"1-1-RDB文件的创建\"><a href=\"#1-1-RDB文件的创建\" class=\"headerlink\" title=\"1.1 RDB文件的创建\"></a>1.1 RDB文件的创建</h4><p>Redis通过以下两个命令，可生成RDB文件。</p>\n<ul>\n<li>①、<code>同步保存到磁盘命令</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAVE</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、<code>在后台异步保存当前数据到磁盘命令</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BGSAVE</span><br></pre></td></tr></table></figure>\n\n<p>其中，</p>\n<ul>\n<li><code>SAVE命令会阻塞Redis服务器进程</code>，直到RDB文件创建完毕。</li>\n<li><code>BGSAVE命令是异步的，它将派生出一个子进程</code>，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</li>\n</ul>\n<p>创建RDB文件实际工作由<code>rdb.c/rdbSave函数</code>完成，SAVE和BGSAVE命令会以不同的方式调用该函数。</p>\n<p>BGSAVE以子进程方式执行，在执行时，会拒绝新进入的SAVE、BGSAGE命令。而BGREWRITEAOF命令将会被延迟到BGSAVE命令执行结束。</p>\n<p>BGREWRITEAOF命令执行时，新进入的BGSAVE命令将被拒绝。</p>\n<h4 id=\"1-2-RDB文件的载入\"><a href=\"#1-2-RDB文件的载入\" class=\"headerlink\" title=\"1.2 RDB文件的载入\"></a>1.2 RDB文件的载入</h4><p>RDB<code>文件的载入工作是在服务器启动时自动执行的</code>，Redis并没有提供专门用于载入RDB文件的命令。</p>\n<p><em>注：AOP文件的更新频率通常比RDB文件的更频率高，因此，若服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</em></p>\n<p>RDB文件载入时，服务器将一直处于阻塞状态，直到载入工作完成为止。</p>\n<h3 id=\"2-自动间隔保存\"><a href=\"#2-自动间隔保存\" class=\"headerlink\" title=\"2 自动间隔保存\"></a>2 自动间隔保存</h3><p>由于BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置（<code>/etc/redis/redis.conf</code>配置文件）的<code>save</code>选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p>\n<p>示例：当前Redis默认配置save选项如下，当条件满足时，BGSAVE命令将被执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 服务器在900秒之内，对数据库进行了至少1次修改。</span><br><span class=\"line\">save 900 1</span><br><span class=\"line\"># 服务器在300秒之内，对数据库进行了至少10次修改。</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\"># 服务器在60秒之内，对数据库进行了至少10000次修改。</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-设置保存条件\"><a href=\"#2-1-设置保存条件\" class=\"headerlink\" title=\"2.1 设置保存条件\"></a>2.1 设置保存条件</h4><p>当Redis服务启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，若未主动设置save选项，那么服务器将使用redis.conf文件中默认的save条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save 900 1</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在<code>redisServer结构</code>中有一个<code>saveparams</code>属性，用于保存save设置的保存条件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录了保存条件的数组.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">saveparam</span> *<span class=\"title\">saveparams</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认条件下服务器状态中的<code>saveparams</code>数组示意如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E9%BB%98%E8%AE%A4%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84saveparams%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F.png\" alt=\"默认条件下服务器状态中的saveparams数组示意\"></p>\n<h4 id=\"2-2-dirty计数器和lastsave属性\"><a href=\"#2-2-dirty计数器和lastsave属性\" class=\"headerlink\" title=\"2.2 dirty计数器和lastsave属性\"></a>2.2 dirty计数器和lastsave属性</h4><ul>\n<li><p><strong>dirty计数器属性</strong>: 记录距离上一次成功执行<code>SAVE</code>或者<code>BGSAVE</code>命令之后，服务器对数据状态（服务器中所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</p>\n</li>\n<li><p><strong>lastsave属性</strong>: 是一个UNIX时间戳，记录了服务器上一次成功执行<code>SAVE</code>或者<code>BGSAVE</code>命令的时间。</p>\n</li>\n</ul>\n<h4 id=\"2-3-检查保存条件是否满足\"><a href=\"#2-3-检查保存条件是否满足\" class=\"headerlink\" title=\"2.3 检查保存条件是否满足\"></a>2.3 检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数serverCron默认每隔<code>100ms</code>就执行一次，<code>该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的条件是否满足，若满足，则执行BGSAVE命令。</code></p>\n<p>示例：服务器状态如下，其中dirty为123，表示距离上一次执行SAVE或者BGSAVE命令后，数据状态修改了123次，此时，若时间来到1378271101时，即301秒后，服务器将自动执行一次BGSAVE命令。执行完成后dirty属性将被清零。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E5%A6%82%E4%B8%8B%EF%BC%8C%E5%85%B6%E4%B8%ADdirty%E4%B8%BA123.png\" alt=\"服务器状态如下，其中dirty为123\"></p>\n<h3 id=\"3-RDB文件结构\"><a href=\"#3-RDB文件结构\" class=\"headerlink\" title=\"3 RDB文件结构\"></a>3 RDB文件结构</h3><p><code>RDB文件是一个经过压缩的二进制文件，由多个部分组成</code>，对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。</p>\n<p>一个完整的RDB文件包含以下几个部分，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84RDB%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86.png\" alt=\"一个完整的RDB文件包含以下几个部分\"></p>\n<ul>\n<li>①、<code>REDIS</code>：长度为5字节的常量，保存着<code>&quot;REDIS&quot;</code>5个字符，通过这5个字符，程序在载入文件时，快速检查所在入的文件是否RDB文件。</li>\n<li>②、<code>db_version</code>：长度为4字节，它的值是一个字符串表示整数，记录了RDB文件的版本号，例如“0006”就代表RDB文件的版本为第六版。</li>\n<li>③、<code>databases</code>：包含着零个或任意多个数据库，以及各个数据库中的键值对数据。</li>\n<li>④、<code>EOF</code>：长度为1字节的常量，标志着RDB文件正文内容的结束。</li>\n<li>⑤、<code>check_sum</code>：长度为8字节的无符号整数，保存着通过REDIS、db_version、databases、EOF四个部分计算出的校验和。</li>\n</ul>\n<h4 id=\"3-1-databases部分\"><a href=\"#3-1-databases部分\" class=\"headerlink\" title=\"3.1 databases部分\"></a>3.1 databases部分</h4><p>一个RDB文件的<code>databases</code>部分可以<code>保存任意多个非空数据库</code>。</p>\n<p>每个非空数据库在RDB文件中都保存着以下三个部分：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E6%AF%8F%E4%B8%AA%E9%9D%9E%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E9%83%BD%E4%BF%9D%E5%AD%98%E7%9D%80%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86.png\" alt=\"每个非空数据库在RDB文件中都保存着以下三个部分\"></p>\n<ul>\n<li>①、<code>SELECTDB</code>：长度为1字节的常量，表示接下来读取的将是一个数据库号码。</li>\n<li>②、<code>db_number</code>：长度为1字节/2字节/5字节的数据库号码。程序根据该号码，调用SELECT命令切换数据库。</li>\n<li>③、<code>key_value_pairs</code>：保存数据库中所有的键值对数据（注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起）。</li>\n</ul>\n<h4 id=\"3-2-key-value-pairs部分\"><a href=\"#3-2-key-value-pairs部分\" class=\"headerlink\" title=\"3.2 key_value_pairs部分\"></a>3.2 key_value_pairs部分</h4><p>RDB文件的每个<code>key_value_pairs</code>：保存数据库中所有的键值对数据（<em>注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起</em>）。</p>\n<h5 id=\"3-2-1-不带过期时间的键值对组成\"><a href=\"#3-2-1-不带过期时间的键值对组成\" class=\"headerlink\" title=\"3.2.1 不带过期时间的键值对组成\"></a>3.2.1 不带过期时间的键值对组成</h5><p>不带过期时间的键值对由以下三个部分组成：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E4%B8%8D%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E7%94%B1%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png\" alt=\"不带过期时间的键值对由以下三个部分组成\"></p>\n<ul>\n<li><p>①、<code>Type</code>：记录了value的类型，长度为1字节的常量，包括以下常量，每种常量都代表了一种类型或者底层编码，服务器根据type的值决定如何读入和解释value数据。</p>\n</li>\n<li><ul>\n<li>REDIS_RDB_TYPE_STRING</li>\n<li>REDIS_RDB_TYPE_LIST</li>\n<li>REDIS_RDB_TYPE_SET</li>\n<li>REDIS_RDB_TYPE_ZSET</li>\n<li>REDIS_RDB_TYPE_HASH</li>\n<li>REDIS_RDB_TYPE_LIST_ZIPLIST</li>\n<li>REDIS_RDB_TYPE_SET_INTSET</li>\n<li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li>\n<li>REDIS_RDB_TYPE_HASH_ZIPLIST</li>\n</ul>\n</li>\n<li><p>②、<code>key</code>：保存了键值对的键对象</p>\n</li>\n<li><p>③、<code>value</code>：保存了键值对的值对象。</p>\n</li>\n</ul>\n<h5 id=\"3-2-2-带过期时间的键值对组成\"><a href=\"#3-2-2-带过期时间的键值对组成\" class=\"headerlink\" title=\"3.2.2 带过期时间的键值对组成\"></a>3.2.2 带过期时间的键值对组成</h5><p>带过期时间的键值对在RDB文件中的组成如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E5%9C%A8RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BB%84%E6%88%90.png\" alt=\"带过期时间的键值对在RDB文件中的组成\"></p>\n<p>其中TYPE、key、value三个部分的意义均与不带过期时间的组成相同。</p>\n<ul>\n<li>①、EXPIRETIME_MS：长度为1字节的常量，表示接下来读入的是一个以毫秒为单位的过期时间。</li>\n<li>②、ms：8字节长的带符号的整数，记录了一个以毫秒为单位的UNIX时间戳。</li>\n</ul>\n<h4 id=\"3-3-value编码\"><a href=\"#3-3-value编码\" class=\"headerlink\" title=\"3.3 value编码\"></a>3.3 value编码</h4><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都有与之对应的Type记录，根据类型的不同，value部分的结构，长度也会有所不同。</p>\n<h3 id=\"4-分析RDB文件\"><a href=\"#4-分析RDB文件\" class=\"headerlink\" title=\"4 分析RDB文件\"></a>4 分析RDB文件</h3><p>通过Linux的<code>od指令</code>来分析Redis服务器产生的RDB文件，使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。RDB文件路径可通过<code>/etc/redis/redis.conf</code>文件中查看，如下所示，因此RDB文件路径为：<code>/var/lib/redis/dump.rdb</code></p>\n<p><code>/etc/redis/redis.conf</code>中配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 打印的RDB文件名。</span><br><span class=\"line\">dbfilename dump.rdb</span><br><span class=\"line\">#</span><br><span class=\"line\"># 路径.</span><br><span class=\"line\">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-1-不包含任何键值对的RDB文件\"><a href=\"#4-1-不包含任何键值对的RDB文件\" class=\"headerlink\" title=\"4.1 不包含任何键值对的RDB文件\"></a>4.1 不包含任何键值对的RDB文件</h4><p>执行以下命令，创建一个数据库状态为空的RDB文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过od命令打印RDB文件内容，并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>), 如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 377 334 263   C 360   Z 334</span><br><span class=\"line\">0000020 362   V</span><br><span class=\"line\">0000022</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li>五个字节的“REDIS”字符串</li>\n<li>四个字节的版本号（0006）</li>\n<li>377是EOF常量</li>\n<li>334 263   C 360   Z 334 362   V为8个字节的校验和</li>\n</ul>\n<h4 id=\"4-2-包含字符串键的RDB文件\"><a href=\"#4-2-包含字符串键的RDB文件\" class=\"headerlink\" title=\"4.2 包含字符串键的RDB文件\"></a>4.2 包含字符串键的RDB文件</h4><p>执行以下命令，分析一个带有单个字符串键的数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushdb</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;HELLO&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0  \\0 003   m   s   g</span><br><span class=\"line\">0000020 005   H   E   L   L   O 377  \\n   &lt; 342 005   &lt;   A 217   4</span><br><span class=\"line\">0000037</span><br></pre></td></tr></table></figure>\n\n<p>其中:</p>\n<ul>\n<li>五个字节的“REDIS”字符串</li>\n<li>四个字节的版本号（0006）</li>\n<li>376表示SELECTED常量</li>\n<li>\\0表示数据库0</li>\n<li>\\0表示表示字符串</li>\n<li>003表示msg的长度</li>\n<li>msg表示key</li>\n<li>005表示value的长度</li>\n<li>HEELO为value</li>\n<li>377是EOF常量</li>\n<li>\\n   &lt; 342 005   &lt;   A 217   4为8个字节的校验和</li>\n</ul>\n<h4 id=\"4-3-包含过期时间的字符串键的RDB文件\"><a href=\"#4-3-包含过期时间的字符串键的RDB文件\" class=\"headerlink\" title=\"4.3 包含过期时间的字符串键的RDB文件\"></a>4.3 包含过期时间的字符串键的RDB文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; setex msg 10086 <span class=\"string\">&quot;HELLO&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0 374 375   3   &#123;   3</span><br><span class=\"line\">0000020   r 001  \\0  \\0  \\0 003   m   s   g 005   H   E   L   L   O 377</span><br><span class=\"line\">0000040 317   W 312 301 337 313 364 201</span><br><span class=\"line\">0000050</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-4-包含一个集合键的RDB文件\"><a href=\"#4-4-包含一个集合键的RDB文件\" class=\"headerlink\" title=\"4.4 包含一个集合键的RDB文件\"></a>4.4 包含一个集合键的RDB文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd lang <span class=\"string\">&quot;C&quot;</span> <span class=\"string\">&quot;JAVA&quot;</span> <span class=\"string\">&quot;RUBY&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SAVE</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0 002 004   l   a   n</span><br><span class=\"line\">0000020   g 003 004   J   A   V   A 004   R   U   B   Y 001   C 377   u</span><br><span class=\"line\">0000040 177 235 372   z 334  \\f 216</span><br><span class=\"line\">0000047</span><br></pre></td></tr></table></figure>"},{"title":"Redis-踩坑记录","date":"2020-09-04T02:54:33.000Z","_content":"\n记录一些平时遇到的Redis的坑...\n\n<!--more-->\n\n### 1 Bitmap使用踩坑\n\n#### 1.1 引入\n\n最近在做RTA功能，实现精准投放，主要流程是媒体平台将用户加密设备号下发给广告主，广告主根据自有数据，对设备号进行过滤，并返回投放竞价信息, 实现个性化用户筛选(是否参与竞价)及流量实时优选(根据返回信息实现优选).\n\n#### 1.2 问题\n\n- 媒体平台对RTA接口响应要求高(例如,广点通限制请求响应时间在60ms之内),其中网络耗时已经高达40~50ms,因此,对于我们提供的RTA接口的逻辑处理时间必须限制在10~15ms之内.\n- QPS高达15W,若直接丛数据库查询,将导致数据库实例单机负载高,查询速度降低.\n- 现在用户设备号数量约为2.3亿.\n\n\n\n#### 1.3 解决方案\n\n考虑其响应时间限制,使用Redis存储的方案，减少直接的DB访问,提高响应速度。\n\n- - 方案一：使用bitmap方式进行存储\n  - 方案二：将设备信息通过key-value方式存储。\n\n\n\n##### 1.3.1 使用bitmap方式进行存储\n\n思路: bitmap中bit映射被限制在512M之内，所以最大为32位，即offset最大为‭2^(32)-1 (即4294967295)‬，对于2.3亿多的数据直接通过一个key就能存储。\n\n媒体平台推送过来的设备号是md5加密后的imei或者idfa，是128位（16字节）的散列值。而offset应该为整数，因此需将设备号转换为唯一对应的整型数值。但查询了一堆资料均没有找到方法直接转换。\n\n考虑使用CRC32方式，对设备号进行转换，然后将crc32的结果作为offset，为了减少冲突，将设备号的最后3位拼接在key上，即key的数量为4096个。\n\n问题来了，crc32的结果非常大，导致一个key的内存占用高达几百兆，DBA分配的测试集群一共20G，只写入了73个key，内存就满了。。。\n\n后续是将设备号的最后1位拼接在key上，即key的数量为16个，这样能保证内存占用少（16个key对应的内存占用最大为：8G）。\n\n但是新的问题又来了，由于key的数量减少了，可能导致所有的key都被哈希到一个分片，且还是无法保证其唯一性。另外crc32转换为数字方式仍然有冲突的风险。\n\n\n\n##### 1.3.2 使用key-value的方式\n\n之前因为2亿的数据，担心内存占用太大，但在后续测试过程中，发现10000条数据写入占用1.11M，即2亿占用内存大约为20多G，是在能接收的范围，且数据可靠。\n\n### 1.4 总结：\n\n`bitmap的offset需要数字方式或者能转换为数字形式，且offset应该尽可能小！！！！`\n\n\n\n### 2 Redis 热键访问\n\n#### 2.1 引入\n\n也是处理RTA逻辑,在公司内部处理逻辑中,需要根据用户设备命中的策略,返回相应的排除竞价的账户id.\n\n#### 2.2 问题\n\n由于QPS过高，直接通过查询数据库，对数据库造成的压力大,DBA同学开始找麻烦了...\n\n#### 2.3 解决\n\n在数据库层之前增加一层缓存层,优先从缓存中获取数据,若数据不存在,再查询数据库,并写入缓存.从而减少数据库压力.账户信息属于变动不频繁的数据, 设置1小时的过期时间,期间的数据不一致,尚且可以接收.\n\n\n\n#### 2.4 踩坑\n\n目前公司对接了多个渠道的RTA,例如,头条的穿山甲,腾讯的广点通,华为的Ads等等,每个渠道的账户均不同,因此将账户id写入缓存时是以渠道为key,即一个渠道对应一个key.每个请求过来时均会获取该渠道的账户信息.\n\n此时,在高QPS的下,Redis key分布不均匀,造成一个实例负载非常高,读缓存时长增加,整体响应时间增加,造成大量请求超时的情况.\n\n##### 2.4.1 解决\n\n多设置几个key，使redis分布均匀...\n\n\n\n### 参考资料\n\n[一看就懂系列之 详解redis的bitmap在亿级项目中的应用](https://blog.csdn.net/u011957758/article/details/74783347)\n\n[精准营销系列:RTA投放](https://zhuanlan.zhihu.com/p/103574447)\n\n","source":"_posts/Redis-踩坑记录.md","raw":"---\ntitle: Redis-踩坑记录\ndate: 2020-09-04 10:54:33\ntags: [\"Redis\"]\ncategories: [\"Redis\"]\n---\n\n记录一些平时遇到的Redis的坑...\n\n<!--more-->\n\n### 1 Bitmap使用踩坑\n\n#### 1.1 引入\n\n最近在做RTA功能，实现精准投放，主要流程是媒体平台将用户加密设备号下发给广告主，广告主根据自有数据，对设备号进行过滤，并返回投放竞价信息, 实现个性化用户筛选(是否参与竞价)及流量实时优选(根据返回信息实现优选).\n\n#### 1.2 问题\n\n- 媒体平台对RTA接口响应要求高(例如,广点通限制请求响应时间在60ms之内),其中网络耗时已经高达40~50ms,因此,对于我们提供的RTA接口的逻辑处理时间必须限制在10~15ms之内.\n- QPS高达15W,若直接丛数据库查询,将导致数据库实例单机负载高,查询速度降低.\n- 现在用户设备号数量约为2.3亿.\n\n\n\n#### 1.3 解决方案\n\n考虑其响应时间限制,使用Redis存储的方案，减少直接的DB访问,提高响应速度。\n\n- - 方案一：使用bitmap方式进行存储\n  - 方案二：将设备信息通过key-value方式存储。\n\n\n\n##### 1.3.1 使用bitmap方式进行存储\n\n思路: bitmap中bit映射被限制在512M之内，所以最大为32位，即offset最大为‭2^(32)-1 (即4294967295)‬，对于2.3亿多的数据直接通过一个key就能存储。\n\n媒体平台推送过来的设备号是md5加密后的imei或者idfa，是128位（16字节）的散列值。而offset应该为整数，因此需将设备号转换为唯一对应的整型数值。但查询了一堆资料均没有找到方法直接转换。\n\n考虑使用CRC32方式，对设备号进行转换，然后将crc32的结果作为offset，为了减少冲突，将设备号的最后3位拼接在key上，即key的数量为4096个。\n\n问题来了，crc32的结果非常大，导致一个key的内存占用高达几百兆，DBA分配的测试集群一共20G，只写入了73个key，内存就满了。。。\n\n后续是将设备号的最后1位拼接在key上，即key的数量为16个，这样能保证内存占用少（16个key对应的内存占用最大为：8G）。\n\n但是新的问题又来了，由于key的数量减少了，可能导致所有的key都被哈希到一个分片，且还是无法保证其唯一性。另外crc32转换为数字方式仍然有冲突的风险。\n\n\n\n##### 1.3.2 使用key-value的方式\n\n之前因为2亿的数据，担心内存占用太大，但在后续测试过程中，发现10000条数据写入占用1.11M，即2亿占用内存大约为20多G，是在能接收的范围，且数据可靠。\n\n### 1.4 总结：\n\n`bitmap的offset需要数字方式或者能转换为数字形式，且offset应该尽可能小！！！！`\n\n\n\n### 2 Redis 热键访问\n\n#### 2.1 引入\n\n也是处理RTA逻辑,在公司内部处理逻辑中,需要根据用户设备命中的策略,返回相应的排除竞价的账户id.\n\n#### 2.2 问题\n\n由于QPS过高，直接通过查询数据库，对数据库造成的压力大,DBA同学开始找麻烦了...\n\n#### 2.3 解决\n\n在数据库层之前增加一层缓存层,优先从缓存中获取数据,若数据不存在,再查询数据库,并写入缓存.从而减少数据库压力.账户信息属于变动不频繁的数据, 设置1小时的过期时间,期间的数据不一致,尚且可以接收.\n\n\n\n#### 2.4 踩坑\n\n目前公司对接了多个渠道的RTA,例如,头条的穿山甲,腾讯的广点通,华为的Ads等等,每个渠道的账户均不同,因此将账户id写入缓存时是以渠道为key,即一个渠道对应一个key.每个请求过来时均会获取该渠道的账户信息.\n\n此时,在高QPS的下,Redis key分布不均匀,造成一个实例负载非常高,读缓存时长增加,整体响应时间增加,造成大量请求超时的情况.\n\n##### 2.4.1 解决\n\n多设置几个key，使redis分布均匀...\n\n\n\n### 参考资料\n\n[一看就懂系列之 详解redis的bitmap在亿级项目中的应用](https://blog.csdn.net/u011957758/article/details/74783347)\n\n[精准营销系列:RTA投放](https://zhuanlan.zhihu.com/p/103574447)\n\n","slug":"Redis-踩坑记录","published":1,"updated":"2020-09-04T03:53:05.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckenpedq40000ing32667dlwt","content":"<p>记录一些平时遇到的Redis的坑…</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-Bitmap使用踩坑\"><a href=\"#1-Bitmap使用踩坑\" class=\"headerlink\" title=\"1 Bitmap使用踩坑\"></a>1 Bitmap使用踩坑</h3><h4 id=\"1-1-引入\"><a href=\"#1-1-引入\" class=\"headerlink\" title=\"1.1 引入\"></a>1.1 引入</h4><p>最近在做RTA功能，实现精准投放，主要流程是媒体平台将用户加密设备号下发给广告主，广告主根据自有数据，对设备号进行过滤，并返回投放竞价信息, 实现个性化用户筛选(是否参与竞价)及流量实时优选(根据返回信息实现优选).</p>\n<h4 id=\"1-2-问题\"><a href=\"#1-2-问题\" class=\"headerlink\" title=\"1.2 问题\"></a>1.2 问题</h4><ul>\n<li>媒体平台对RTA接口响应要求高(例如,广点通限制请求响应时间在60ms之内),其中网络耗时已经高达40<del>50ms,因此,对于我们提供的RTA接口的逻辑处理时间必须限制在10</del>15ms之内.</li>\n<li>QPS高达15W,若直接丛数据库查询,将导致数据库实例单机负载高,查询速度降低.</li>\n<li>现在用户设备号数量约为2.3亿.</li>\n</ul>\n<h4 id=\"1-3-解决方案\"><a href=\"#1-3-解决方案\" class=\"headerlink\" title=\"1.3 解决方案\"></a>1.3 解决方案</h4><p>考虑其响应时间限制,使用Redis存储的方案，减少直接的DB访问,提高响应速度。</p>\n<ul>\n<li><ul>\n<li>方案一：使用bitmap方式进行存储</li>\n<li>方案二：将设备信息通过key-value方式存储。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"1-3-1-使用bitmap方式进行存储\"><a href=\"#1-3-1-使用bitmap方式进行存储\" class=\"headerlink\" title=\"1.3.1 使用bitmap方式进行存储\"></a>1.3.1 使用bitmap方式进行存储</h5><p>思路: bitmap中bit映射被限制在512M之内，所以最大为32位，即offset最大为‭2^(32)-1 (即4294967295)‬，对于2.3亿多的数据直接通过一个key就能存储。</p>\n<p>媒体平台推送过来的设备号是md5加密后的imei或者idfa，是128位（16字节）的散列值。而offset应该为整数，因此需将设备号转换为唯一对应的整型数值。但查询了一堆资料均没有找到方法直接转换。</p>\n<p>考虑使用CRC32方式，对设备号进行转换，然后将crc32的结果作为offset，为了减少冲突，将设备号的最后3位拼接在key上，即key的数量为4096个。</p>\n<p>问题来了，crc32的结果非常大，导致一个key的内存占用高达几百兆，DBA分配的测试集群一共20G，只写入了73个key，内存就满了。。。</p>\n<p>后续是将设备号的最后1位拼接在key上，即key的数量为16个，这样能保证内存占用少（16个key对应的内存占用最大为：8G）。</p>\n<p>但是新的问题又来了，由于key的数量减少了，可能导致所有的key都被哈希到一个分片，且还是无法保证其唯一性。另外crc32转换为数字方式仍然有冲突的风险。</p>\n<h5 id=\"1-3-2-使用key-value的方式\"><a href=\"#1-3-2-使用key-value的方式\" class=\"headerlink\" title=\"1.3.2 使用key-value的方式\"></a>1.3.2 使用key-value的方式</h5><p>之前因为2亿的数据，担心内存占用太大，但在后续测试过程中，发现10000条数据写入占用1.11M，即2亿占用内存大约为20多G，是在能接收的范围，且数据可靠。</p>\n<h3 id=\"1-4-总结：\"><a href=\"#1-4-总结：\" class=\"headerlink\" title=\"1.4 总结：\"></a>1.4 总结：</h3><p><code>bitmap的offset需要数字方式或者能转换为数字形式，且offset应该尽可能小！！！！</code></p>\n<h3 id=\"2-Redis-热键访问\"><a href=\"#2-Redis-热键访问\" class=\"headerlink\" title=\"2 Redis 热键访问\"></a>2 Redis 热键访问</h3><h4 id=\"2-1-引入\"><a href=\"#2-1-引入\" class=\"headerlink\" title=\"2.1 引入\"></a>2.1 引入</h4><p>也是处理RTA逻辑,在公司内部处理逻辑中,需要根据用户设备命中的策略,返回相应的排除竞价的账户id.</p>\n<h4 id=\"2-2-问题\"><a href=\"#2-2-问题\" class=\"headerlink\" title=\"2.2 问题\"></a>2.2 问题</h4><p>由于QPS过高，直接通过查询数据库，对数据库造成的压力大,DBA同学开始找麻烦了…</p>\n<h4 id=\"2-3-解决\"><a href=\"#2-3-解决\" class=\"headerlink\" title=\"2.3 解决\"></a>2.3 解决</h4><p>在数据库层之前增加一层缓存层,优先从缓存中获取数据,若数据不存在,再查询数据库,并写入缓存.从而减少数据库压力.账户信息属于变动不频繁的数据, 设置1小时的过期时间,期间的数据不一致,尚且可以接收.</p>\n<h4 id=\"2-4-踩坑\"><a href=\"#2-4-踩坑\" class=\"headerlink\" title=\"2.4 踩坑\"></a>2.4 踩坑</h4><p>目前公司对接了多个渠道的RTA,例如,头条的穿山甲,腾讯的广点通,华为的Ads等等,每个渠道的账户均不同,因此将账户id写入缓存时是以渠道为key,即一个渠道对应一个key.每个请求过来时均会获取该渠道的账户信息.</p>\n<p>此时,在高QPS的下,Redis key分布不均匀,造成一个实例负载非常高,读缓存时长增加,整体响应时间增加,造成大量请求超时的情况.</p>\n<h5 id=\"2-4-1-解决\"><a href=\"#2-4-1-解决\" class=\"headerlink\" title=\"2.4.1 解决\"></a>2.4.1 解决</h5><p>多设置几个key，使redis分布均匀…</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/u011957758/article/details/74783347\">一看就懂系列之 详解redis的bitmap在亿级项目中的应用</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/103574447\">精准营销系列:RTA投放</a></p>\n","site":{"data":{}},"excerpt":"<p>记录一些平时遇到的Redis的坑…</p>","more":"<h3 id=\"1-Bitmap使用踩坑\"><a href=\"#1-Bitmap使用踩坑\" class=\"headerlink\" title=\"1 Bitmap使用踩坑\"></a>1 Bitmap使用踩坑</h3><h4 id=\"1-1-引入\"><a href=\"#1-1-引入\" class=\"headerlink\" title=\"1.1 引入\"></a>1.1 引入</h4><p>最近在做RTA功能，实现精准投放，主要流程是媒体平台将用户加密设备号下发给广告主，广告主根据自有数据，对设备号进行过滤，并返回投放竞价信息, 实现个性化用户筛选(是否参与竞价)及流量实时优选(根据返回信息实现优选).</p>\n<h4 id=\"1-2-问题\"><a href=\"#1-2-问题\" class=\"headerlink\" title=\"1.2 问题\"></a>1.2 问题</h4><ul>\n<li>媒体平台对RTA接口响应要求高(例如,广点通限制请求响应时间在60ms之内),其中网络耗时已经高达40<del>50ms,因此,对于我们提供的RTA接口的逻辑处理时间必须限制在10</del>15ms之内.</li>\n<li>QPS高达15W,若直接丛数据库查询,将导致数据库实例单机负载高,查询速度降低.</li>\n<li>现在用户设备号数量约为2.3亿.</li>\n</ul>\n<h4 id=\"1-3-解决方案\"><a href=\"#1-3-解决方案\" class=\"headerlink\" title=\"1.3 解决方案\"></a>1.3 解决方案</h4><p>考虑其响应时间限制,使用Redis存储的方案，减少直接的DB访问,提高响应速度。</p>\n<ul>\n<li><ul>\n<li>方案一：使用bitmap方式进行存储</li>\n<li>方案二：将设备信息通过key-value方式存储。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"1-3-1-使用bitmap方式进行存储\"><a href=\"#1-3-1-使用bitmap方式进行存储\" class=\"headerlink\" title=\"1.3.1 使用bitmap方式进行存储\"></a>1.3.1 使用bitmap方式进行存储</h5><p>思路: bitmap中bit映射被限制在512M之内，所以最大为32位，即offset最大为‭2^(32)-1 (即4294967295)‬，对于2.3亿多的数据直接通过一个key就能存储。</p>\n<p>媒体平台推送过来的设备号是md5加密后的imei或者idfa，是128位（16字节）的散列值。而offset应该为整数，因此需将设备号转换为唯一对应的整型数值。但查询了一堆资料均没有找到方法直接转换。</p>\n<p>考虑使用CRC32方式，对设备号进行转换，然后将crc32的结果作为offset，为了减少冲突，将设备号的最后3位拼接在key上，即key的数量为4096个。</p>\n<p>问题来了，crc32的结果非常大，导致一个key的内存占用高达几百兆，DBA分配的测试集群一共20G，只写入了73个key，内存就满了。。。</p>\n<p>后续是将设备号的最后1位拼接在key上，即key的数量为16个，这样能保证内存占用少（16个key对应的内存占用最大为：8G）。</p>\n<p>但是新的问题又来了，由于key的数量减少了，可能导致所有的key都被哈希到一个分片，且还是无法保证其唯一性。另外crc32转换为数字方式仍然有冲突的风险。</p>\n<h5 id=\"1-3-2-使用key-value的方式\"><a href=\"#1-3-2-使用key-value的方式\" class=\"headerlink\" title=\"1.3.2 使用key-value的方式\"></a>1.3.2 使用key-value的方式</h5><p>之前因为2亿的数据，担心内存占用太大，但在后续测试过程中，发现10000条数据写入占用1.11M，即2亿占用内存大约为20多G，是在能接收的范围，且数据可靠。</p>\n<h3 id=\"1-4-总结：\"><a href=\"#1-4-总结：\" class=\"headerlink\" title=\"1.4 总结：\"></a>1.4 总结：</h3><p><code>bitmap的offset需要数字方式或者能转换为数字形式，且offset应该尽可能小！！！！</code></p>\n<h3 id=\"2-Redis-热键访问\"><a href=\"#2-Redis-热键访问\" class=\"headerlink\" title=\"2 Redis 热键访问\"></a>2 Redis 热键访问</h3><h4 id=\"2-1-引入\"><a href=\"#2-1-引入\" class=\"headerlink\" title=\"2.1 引入\"></a>2.1 引入</h4><p>也是处理RTA逻辑,在公司内部处理逻辑中,需要根据用户设备命中的策略,返回相应的排除竞价的账户id.</p>\n<h4 id=\"2-2-问题\"><a href=\"#2-2-问题\" class=\"headerlink\" title=\"2.2 问题\"></a>2.2 问题</h4><p>由于QPS过高，直接通过查询数据库，对数据库造成的压力大,DBA同学开始找麻烦了…</p>\n<h4 id=\"2-3-解决\"><a href=\"#2-3-解决\" class=\"headerlink\" title=\"2.3 解决\"></a>2.3 解决</h4><p>在数据库层之前增加一层缓存层,优先从缓存中获取数据,若数据不存在,再查询数据库,并写入缓存.从而减少数据库压力.账户信息属于变动不频繁的数据, 设置1小时的过期时间,期间的数据不一致,尚且可以接收.</p>\n<h4 id=\"2-4-踩坑\"><a href=\"#2-4-踩坑\" class=\"headerlink\" title=\"2.4 踩坑\"></a>2.4 踩坑</h4><p>目前公司对接了多个渠道的RTA,例如,头条的穿山甲,腾讯的广点通,华为的Ads等等,每个渠道的账户均不同,因此将账户id写入缓存时是以渠道为key,即一个渠道对应一个key.每个请求过来时均会获取该渠道的账户信息.</p>\n<p>此时,在高QPS的下,Redis key分布不均匀,造成一个实例负载非常高,读缓存时长增加,整体响应时间增加,造成大量请求超时的情况.</p>\n<h5 id=\"2-4-1-解决\"><a href=\"#2-4-1-解决\" class=\"headerlink\" title=\"2.4.1 解决\"></a>2.4.1 解决</h5><p>多设置几个key，使redis分布均匀…</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/u011957758/article/details/74783347\">一看就懂系列之 详解redis的bitmap在亿级项目中的应用</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/103574447\">精准营销系列:RTA投放</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckeia7fso00010sg3bgyf6qqv","category_id":"ckeia7fst00040sg36k1k4zjs","_id":"ckeia7ft2000f0sg3bpcw4ct5"},{"post_id":"ckeia7fsr00030sg30appcwzh","category_id":"ckeia7fst00040sg36k1k4zjs","_id":"ckeia7ft3000i0sg3gy3p5wcm"},{"post_id":"ckeia7fsw00070sg3b903bz8g","category_id":"ckeia7ft2000e0sg398d4fxk2","_id":"ckeia7ft5000m0sg33gth9nre"},{"post_id":"ckeia7fsx00080sg39jap1ybi","category_id":"ckeia7ft4000j0sg31nvj6b83","_id":"ckeia7ft9000z0sg3e6xi7g9m"},{"post_id":"ckeia7fsx00080sg39jap1ybi","category_id":"ckeia7ft6000r0sg3avrjdlrk","_id":"ckeia7ft900110sg3gr4k2ldr"},{"post_id":"ckeia7fsy00090sg33ay9c94w","category_id":"ckeia7ft4000j0sg31nvj6b83","_id":"ckeia7fta00120sg3gart2mx2"},{"post_id":"ckeia7fsy00090sg33ay9c94w","category_id":"ckeia7ft6000r0sg3avrjdlrk","_id":"ckeia7fta00140sg3fz983sdm"},{"post_id":"ckeia7ft1000d0sg3128zdzbn","category_id":"ckeia7ft4000j0sg31nvj6b83","_id":"ckeia7ftb00160sg33orhamcs"},{"post_id":"ckeia7ft1000d0sg3128zdzbn","category_id":"ckeia7ft6000r0sg3avrjdlrk","_id":"ckeia7ftb00190sg3dyzd3gq7"},{"post_id":"ckeia7fte001f0sg37itwgqmr","category_id":"ckeia7fst00040sg36k1k4zjs","_id":"ckeia7fti001l0sg35e8ie9ly"},{"post_id":"ckeia7ftf001g0sg3boif2j7u","category_id":"ckeia7fst00040sg36k1k4zjs","_id":"ckeia7ftj001o0sg3bn1qfb4s"},{"post_id":"ckeia7ftg001i0sg3civ1fzxu","category_id":"ckeia7fst00040sg36k1k4zjs","_id":"ckeia7ftl001r0sg3chwtggk1"},{"post_id":"ckeia7fth001k0sg32kil4ne6","category_id":"ckeia7fst00040sg36k1k4zjs","_id":"ckeia7ftm001u0sg313cqdxbk"},{"post_id":"ckeia7ftk001q0sg31f7a5lid","category_id":"ckeia7ft4000j0sg31nvj6b83","_id":"ckeia7ftn001w0sg3ei4v5fun"},{"post_id":"ckeia7ftk001q0sg31f7a5lid","category_id":"ckeia7ft6000r0sg3avrjdlrk","_id":"ckeia7ftn001y0sg3g0e34e84"},{"post_id":"ckeia7fti001n0sg3gnxj0c1q","category_id":"ckeia7ftl001s0sg3hrbkbr89","_id":"ckeia7ftp00260sg33bhq4u7x"},{"post_id":"ckeia7fti001n0sg3gnxj0c1q","category_id":"ckeia7ftn001x0sg36sz1hwiq","_id":"ckeia7ftp00270sg3ava86x5b"},{"post_id":"ckeia7fti001n0sg3gnxj0c1q","category_id":"ckeia7fto00220sg3fw6e9i73","_id":"ckeia7ftp00280sg3153pc7oz"},{"post_id":"ckema1lg20000glg34llo5t1s","category_id":"ckeia7ftl001s0sg3hrbkbr89","_id":"ckema1lge0003glg34zg604n3"},{"post_id":"ckema1lg20000glg34llo5t1s","category_id":"ckeia7ftn001x0sg36sz1hwiq","_id":"ckema1lge0004glg31w17ac9j"},{"post_id":"ckema1lg20000glg34llo5t1s","category_id":"ckeia7fto00220sg3fw6e9i73","_id":"ckema1lge0005glg3aod6fdet"},{"post_id":"ckemhsii20000llg3geoo8711","category_id":"ckeia7ftl001s0sg3hrbkbr89","_id":"ckemhsiin0004llg322n90co7"},{"post_id":"ckemhsii20000llg3geoo8711","category_id":"ckeia7ftn001x0sg36sz1hwiq","_id":"ckemhsiin0006llg34jblbh3f"},{"post_id":"ckemhsii20000llg3geoo8711","category_id":"ckeia7fto00220sg3fw6e9i73","_id":"ckemhsiio0008llg3hp9e3a6g"},{"post_id":"ckemhsiij0001llg3dtxw9b1g","category_id":"ckeia7ftl001s0sg3hrbkbr89","_id":"ckemhsiio0009llg3bu5d1609"},{"post_id":"ckemhsiij0001llg3dtxw9b1g","category_id":"ckeia7ftn001x0sg36sz1hwiq","_id":"ckemhsiio000allg36z9l0axb"},{"post_id":"ckemhsiij0001llg3dtxw9b1g","category_id":"ckeia7fto00220sg3fw6e9i73","_id":"ckemhsiio000bllg361pzcmwy"},{"post_id":"ckemo6ffl000095g3arceblzo","category_id":"ckeia7ftl001s0sg3hrbkbr89","_id":"ckemo6fg5000395g36qf8dt4b"},{"post_id":"ckemo6ffl000095g3arceblzo","category_id":"ckeia7ftn001x0sg36sz1hwiq","_id":"ckemo6fg5000495g332ia1hj1"},{"post_id":"ckemo6ffl000095g3arceblzo","category_id":"ckeia7fto00220sg3fw6e9i73","_id":"ckemo6fg5000595g3bhk24dq7"},{"post_id":"ckenpedq40000ing32667dlwt","category_id":"ckeia7ftl001s0sg3hrbkbr89","_id":"ckenpedq70002ing3bo4v26il"}],"PostTag":[{"post_id":"ckeia7fso00010sg3bgyf6qqv","tag_id":"ckeia7fsv00050sg36kck8ko9","_id":"ckeia7ft1000c0sg37wt1a324"},{"post_id":"ckeia7fsr00030sg30appcwzh","tag_id":"ckeia7fsv00050sg36kck8ko9","_id":"ckeia7ft3000h0sg3h511eg7g"},{"post_id":"ckeia7fsw00070sg3b903bz8g","tag_id":"ckeia7ft2000g0sg3fzm0cjgs","_id":"ckeia7ft4000l0sg3d5j60zkw"},{"post_id":"ckeia7fsx00080sg39jap1ybi","tag_id":"ckeia7ft4000k0sg3c08zg5lp","_id":"ckeia7ft7000t0sg38fp7ekyn"},{"post_id":"ckeia7fsx00080sg39jap1ybi","tag_id":"ckeia7ft5000o0sg3ae8d4xs5","_id":"ckeia7ft8000v0sg3cqdgf6ag"},{"post_id":"ckeia7fsx00080sg39jap1ybi","tag_id":"ckeia7ft6000q0sg35brr34fo","_id":"ckeia7ft8000x0sg3hm4b7crc"},{"post_id":"ckeia7fsy00090sg33ay9c94w","tag_id":"ckeia7ft4000k0sg3c08zg5lp","_id":"ckeia7fta00150sg38s9q9h6e"},{"post_id":"ckeia7fsy00090sg33ay9c94w","tag_id":"ckeia7ft5000o0sg3ae8d4xs5","_id":"ckeia7ftb00170sg3dkjkejt8"},{"post_id":"ckeia7fsy00090sg33ay9c94w","tag_id":"ckeia7ft900100sg31u1wfv69","_id":"ckeia7ftb001a0sg3gc0d700d"},{"post_id":"ckeia7ft1000d0sg3128zdzbn","tag_id":"ckeia7ft4000k0sg3c08zg5lp","_id":"ckeia7ftc001c0sg35mvk1s2g"},{"post_id":"ckeia7ft1000d0sg3128zdzbn","tag_id":"ckeia7ft5000o0sg3ae8d4xs5","_id":"ckeia7ftc001d0sg37e09adrz"},{"post_id":"ckeia7ft1000d0sg3128zdzbn","tag_id":"ckeia7ftb001b0sg384k6ercl","_id":"ckeia7ftc001e0sg3bx21h35g"},{"post_id":"ckeia7fte001f0sg37itwgqmr","tag_id":"ckeia7fsv00050sg36kck8ko9","_id":"ckeia7ftg001h0sg39ro80k91"},{"post_id":"ckeia7ftf001g0sg3boif2j7u","tag_id":"ckeia7fsv00050sg36kck8ko9","_id":"ckeia7fth001j0sg31dda3is4"},{"post_id":"ckeia7ftg001i0sg3civ1fzxu","tag_id":"ckeia7fsv00050sg36kck8ko9","_id":"ckeia7fti001m0sg3abh79wjx"},{"post_id":"ckeia7fth001k0sg32kil4ne6","tag_id":"ckeia7fsv00050sg36kck8ko9","_id":"ckeia7ftj001p0sg33ukp2ivr"},{"post_id":"ckeia7fti001n0sg3gnxj0c1q","tag_id":"ckeia7ftm001t0sg39ebuce2f","_id":"ckeia7fto00200sg321sl5j73"},{"post_id":"ckeia7fti001n0sg3gnxj0c1q","tag_id":"ckeia7ftn001v0sg3d451ccnw","_id":"ckeia7fto00210sg3c1aahxsg"},{"post_id":"ckeia7ftk001q0sg31f7a5lid","tag_id":"ckeia7ft4000k0sg3c08zg5lp","_id":"ckeia7ftp00230sg3aptyc7ln"},{"post_id":"ckeia7ftk001q0sg31f7a5lid","tag_id":"ckeia7ft5000o0sg3ae8d4xs5","_id":"ckeia7ftp00240sg3hj4b3zur"},{"post_id":"ckeia7ftk001q0sg31f7a5lid","tag_id":"ckeia7ftn001z0sg3gogjat40","_id":"ckeia7ftp00250sg3fupa3k1f"},{"post_id":"ckema1lg20000glg34llo5t1s","tag_id":"ckeia7ftm001t0sg39ebuce2f","_id":"ckema1lgc0001glg3epz0hrbg"},{"post_id":"ckema1lg20000glg34llo5t1s","tag_id":"ckeia7ftn001v0sg3d451ccnw","_id":"ckema1lgd0002glg3c16m3dcc"},{"post_id":"ckemhsii20000llg3geoo8711","tag_id":"ckeia7ftm001t0sg39ebuce2f","_id":"ckemhsiim0002llg36v3gh90k"},{"post_id":"ckemhsii20000llg3geoo8711","tag_id":"ckeia7ftn001v0sg3d451ccnw","_id":"ckemhsiin0003llg382q9bsn0"},{"post_id":"ckemhsiij0001llg3dtxw9b1g","tag_id":"ckeia7ftm001t0sg39ebuce2f","_id":"ckemhsiin0005llg3aub66kmz"},{"post_id":"ckemhsiij0001llg3dtxw9b1g","tag_id":"ckeia7ftn001v0sg3d451ccnw","_id":"ckemhsiio0007llg3670g2ia0"},{"post_id":"ckemo6ffl000095g3arceblzo","tag_id":"ckeia7ftm001t0sg39ebuce2f","_id":"ckemo6fg4000195g3801pc8un"},{"post_id":"ckemo6ffl000095g3arceblzo","tag_id":"ckeia7ftn001v0sg3d451ccnw","_id":"ckemo6fg5000295g33wnke87c"},{"post_id":"ckenpedq40000ing32667dlwt","tag_id":"ckeia7ftm001t0sg39ebuce2f","_id":"ckenpedq60001ing344qt2v6r"}],"Tag":[{"name":"PHP","_id":"ckeia7fsv00050sg36kck8ko9"},{"name":"Protobuf","_id":"ckeia7ft2000g0sg3fzm0cjgs"},{"name":"Ubuntu","_id":"ckeia7ft4000k0sg3c08zg5lp"},{"name":"Config","_id":"ckeia7ft5000o0sg3ae8d4xs5"},{"name":"Git","_id":"ckeia7ft6000q0sg35brr34fo"},{"name":"Node.js","_id":"ckeia7ft900100sg31u1wfv69"},{"name":"SSH","_id":"ckeia7ftb001b0sg384k6ercl"},{"name":"Redis","_id":"ckeia7ftm001t0sg39ebuce2f"},{"name":"Note","_id":"ckeia7ftn001v0sg3d451ccnw"},{"name":"Hexo","_id":"ckeia7ftn001z0sg3gogjat40"}]}}