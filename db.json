{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/princess.jpg","path":"images/princess.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Architecture-前后端分离.md","hash":"f9cac1ba8587a00c30269d7b9e5a8308a61b4f1f","modified":1600656582560},{"_id":"source/_posts/DesignPattern-Observer.md","hash":"4320f575f4ba4dc8cf6c1aeea8dd3c762d86d162","modified":1601003951424},{"_id":"source/_posts/Docker-Dockerfile指令.md","hash":"6e94c3e8249f82f51bae65b23b67d6242aad880c","modified":1600394325296},{"_id":"source/_posts/DesignPattern-Factory.md","hash":"b699b3b323d62f47b39d394dd2c489861016aa7b","modified":1601345956973},{"_id":"source/_posts/DesignPattern-Singleton.md","hash":"b19ede2ff1674772c677b316cc426f9dde2455e5","modified":1601345976389},{"_id":"source/_posts/Docker-容器.md","hash":"6494028af127be81869934f51c26907b03e77a20","modified":1600424191620},{"_id":"source/_posts/Docker-错误处理.md","hash":"d1fdca79b13d08bd01726a3b45e9f751f1301c77","modified":1600417750019},{"_id":"source/_posts/Docker-是什么？.md","hash":"c70d2fb53c966850fef67b5cb1a218e52095e631","modified":1600330429440},{"_id":"source/_posts/Architecture-既然有HTTP请求，为何要用RPC调用.md","hash":"f47889c4cc2d4a01106be36cade800906d3df964","modified":1600855213078},{"_id":"source/_posts/HTTP-GET与POST的区别？.md","hash":"ae41d01ca887c90fd6bb77c8c7ee73b68b001588","modified":1600855247822},{"_id":"source/_posts/MySQL-InnoDB事务的实现.md","hash":"fbe14ba107e2a67f12cc4c3ed63ed4be956df8f7","modified":1600845050760},{"_id":"source/_posts/MySQL-为什么使用B-树作为索引结构.md","hash":"26d81e150ee5bf739c3e3d072851a8d56598d09a","modified":1600942728554},{"_id":"source/_posts/MySQL-命令及方法备忘录.md","hash":"8d8a6adf97a10043b4d7f189c0ec266a3ebee7d3","modified":1600139507717},{"_id":"source/_posts/MySQL-并发控制.md","hash":"733b9acf87e3dbbffd050c9b7ca3ff5e8bfc34a7","modified":1600942738902},{"_id":"source/_posts/MySQL-索引分类.md","hash":"87e34fcdead410bed5f2b94a589ccf07bf8caded","modified":1600942747371},{"_id":"source/_posts/MySQL-脏读-不可重复读-幻读.md","hash":"65ea87c0dbd445b03115feaf5d4bba929d972853","modified":1600936140085},{"_id":"source/_posts/PHP-使用PDO访问数据库.md","hash":"c02f1e8c785aee54bf58f13cc88953389a4534ae","modified":1600770520414},{"_id":"source/_posts/PHP7内核-Cli.md","hash":"0b4a9111589d5564d4a372ea06244bee5f493778","modified":1598791356923},{"_id":"source/_posts/FastCGI和PHP-FPM的关系.md","hash":"f669280b73738dfd9ae55b6adb6734c3c90dbe20","modified":1598791356923},{"_id":"source/_posts/PHP7内核-FPM.md","hash":"ac2a826542c492bd9237f61a7d44072478da13b1","modified":1598791356923},{"_id":"source/_posts/PHP7内核-内存管理-GC机制.md","hash":"61e476df4502059d21a242e78f2abd9b58270d5e","modified":1598791356923},{"_id":"source/_posts/PHP7内核-内存管理-内存池.md","hash":"9f25cab4f28be74781ea804c77298c98321e4b26","modified":1598791356923},{"_id":"source/_posts/PHP7内核-变量.md","hash":"a9b5ab98f428a7fd8ad273c9f259e6306af1ba54","modified":1598791356923},{"_id":"source/_posts/Protobuf简介及安装.md","hash":"fa57857281eaadea1779eeae764a4854f4137bb3","modified":1600330473752},{"_id":"source/_posts/Redis设计与实现-RDB持久化.md","hash":"0f8d1e2815ab4e72f70cd64b530d0a45b5fcbde2","modified":1600942564834},{"_id":"source/_posts/Redis设计与实现-Redis对象.md","hash":"d07ad1715981caf678fbb04bc1b20ad17f083712","modified":1600941659804},{"_id":"source/_posts/Redis设计与实现-Redis键过期及删除策略.md","hash":"a4e123ded96fe1440cd44ca6f125b8360299afd6","modified":1600941877249},{"_id":"source/_posts/Redis设计与实现-数据结构.md","hash":"c29a8260fde22ecaaa663a6dc8c38f7604471a88","modified":1600939717850},{"_id":"source/_posts/MySQL-Explain详解.md","hash":"27da263e73bf8f95301956153f8b84549ca43260","modified":1599445053971},{"_id":"source/_posts/Ubuntu16-04-Github配置及使用.md","hash":"81e5bb4612a283c618bc4f5f1b8f31c6283837a0","modified":1598791356923},{"_id":"source/_posts/Ubuntu16-04-Nodejs安装.md","hash":"e725e313832c4137ff2a2ac4276eba4571380d7b","modified":1598791356923},{"_id":"source/_posts/TCP-IP-三次握手与四次挥手.md","hash":"6370b307c68ddfe47db960a5abf5c364d62323d9","modified":1600855154762},{"_id":"source/_posts/Ubuntu16-04-设置SSH密钥.md","hash":"990bfe70f61d8408efee31e03054b14d6d3bdee8","modified":1598791356923},{"_id":"source/_posts/WEB-会话管理.md","hash":"1d87bd89fdc2c7a9772980d9a48118051a19f93c","modified":1600850625616},{"_id":"source/_posts/redis设计与实现-单机数据库的实现.md","hash":"ee4fe3df0e5590d77f1dc8314038fdc4f2cf3cb5","modified":1600942339054},{"_id":"source/_posts/高性能MySQL-Schema与数据类型优化.md","hash":"38f8faf318df32af0253ae291fb251e13d5401f1","modified":1600655101268},{"_id":"source/_posts/Docker-镜像.md","hash":"08932205ef8c89db6e8ffec73a681bb6f613bb92","modified":1600394325296},{"_id":"source/_posts/高性能MySQL-事务基础.md","hash":"9ba1c9ddda36ebb60b71ae48fd2a803ff6b8d99d","modified":1600308879485},{"_id":"source/about/index.md","hash":"8be2f2c38ce0acac1dec63a2e72c1b563705b25c","modified":1598791356923},{"_id":"source/categories/index.md","hash":"01a1708e13b00d653fa0c83748da326f2a0cc4bd","modified":1598791356923},{"_id":"source/tags/index.md","hash":"c8218dc6d63771c380dd0bb657bbf55290300844","modified":1598791356923},{"_id":"source/_posts/Redis-踩坑记录.md","hash":"c09c98ef1ac4170ed72f6a6cd503b2f0b3204d71","modified":1599191932794},{"_id":"source/_posts/高性能MySQL-创建高性能索引.md","hash":"644637a6e1d8d7f5d5f78f44f66f76581af2ceae","modified":1599555216911},{"_id":"source/_posts/Ubuntu16-04-搭建Hexo-Blog.md","hash":"afd3cad8361aad157e5e135873fb8d7a64ba6179","modified":1599724045992},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1598791356931},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1598791356931},{"_id":"themes/next/.npmignore","hash":"b5753ace1856548855d1f2c31c05da85781629e6","modified":1598791356931},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1598791356931},{"_id":"themes/next/.gitignore","hash":"10fa9758d8f934669c1781564ed9ce83436b11f7","modified":1598791356931},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1598791356931},{"_id":"themes/next/_vendors.yml","hash":"6620a40231c6d90334dd938939fe7e10a8429a70","modified":1598791356931},{"_id":"themes/next/LICENSE.md","hash":"63ea7df5a8dc1b23cc92ca9de3ed16d53367f360","modified":1598791356931},{"_id":"themes/next/package.json","hash":"632f07c15b39584217015f97d37badf201abb7e9","modified":1598791356935},{"_id":"themes/next/README.md","hash":"d5559b6910919a69bbde2e72e504a470d84afbe2","modified":1598791356931},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1598791356931},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1598791356935},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"81dbb25800165f68c21859cd3c09276b9f4cc417","modified":1598791356931},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"eefd073dfb68884cd946f7ec6d3b3619031d7650","modified":1598791356931},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1598791356931},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1598791356931},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1598791356931},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1598791356931},{"_id":"themes/next/.github/labeler.yml","hash":"a45e489c62bf5bb5eb1866371af331b8cb9c6320","modified":1598791356931},{"_id":"themes/next/scripts/renderer.js","hash":"c53dbede2ad5f68d7349bc5ed8ac7157d723e987","modified":1598791356935},{"_id":"themes/next/.github/release-drafter.yml","hash":"7662e31224a24154c4fe06b95ccbdff51ab8f2cc","modified":1598791356931},{"_id":"themes/next/.github/stale.yml","hash":"0e40b9975455152a690eaf7047135be348966e39","modified":1598791356931},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1598791356931},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1598791356931},{"_id":"themes/next/docs/LICENSE.txt","hash":"8ef5fc1147c196680b06e1accab80c8d236ab951","modified":1598791356931},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1598791356931},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1598791356931},{"_id":"themes/next/languages/de.yml","hash":"2986eac01218406f45bbd46f98769e1826822b56","modified":1598791356931},{"_id":"themes/next/languages/default.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1598791356931},{"_id":"themes/next/languages/en.yml","hash":"48a76170d70ef7c1fac96720bc5064b43061708d","modified":1598791356931},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1598791356931},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1598791356931},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1598791356931},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1598791356931},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1598791356931},{"_id":"themes/next/languages/ja.yml","hash":"a4208ac966fa7c740b4acf72faaec025d8d6e57b","modified":1598791356931},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1598791356931},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1598791356931},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1598791356931},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1598791356931},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1598791356931},{"_id":"themes/next/languages/tr.yml","hash":"cea795fb74bfd48d5aa2dd10a5aff2242f703c65","modified":1598791356931},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1598791356931},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1598791356931},{"_id":"themes/next/languages/zh-CN.yml","hash":"1a1ec7aa00340cefdec5e3241de2d8c8efb29f54","modified":1598791356931},{"_id":"themes/next/languages/zh-HK.yml","hash":"59ed4f9e879004f0f4e2f56acce4ad0f8031c172","modified":1598791356931},{"_id":"themes/next/languages/zh-TW.yml","hash":"e4a6326a97fa72127325179a563dd0bbfc6d565e","modified":1598791356931},{"_id":"themes/next/layout/_layout.njk","hash":"bf7e6ca826b6c3f85e14da61d56d7b836d2414c4","modified":1598791356931},{"_id":"themes/next/layout/archive.njk","hash":"08885f48d5878c92c910f8c41e3209eb07b9b80e","modified":1598791356935},{"_id":"themes/next/layout/category.njk","hash":"434fc2b27120ebae91522002eb40e16f2158bd4f","modified":1598791356935},{"_id":"themes/next/layout/index.njk","hash":"d8fa14549fa061e7bdba4ec1472cb45ecea96382","modified":1598791356935},{"_id":"themes/next/layout/page.njk","hash":"4f8f377e4f5511e27de1c2e4a1c13374b6a5d9bd","modified":1598791356935},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1598791356935},{"_id":"themes/next/scripts/events/index.js","hash":"89091bc943cd8b8c63b8af3d26fb0a027048e9ba","modified":1598791356935},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1598791356935},{"_id":"themes/next/scripts/filters/locals.js","hash":"fa1e558f058f93455acdd553ab1be30b26f137e4","modified":1598791356935},{"_id":"themes/next/scripts/filters/minify.js","hash":"be0574c64a38210e449c99d38a760452015060a3","modified":1598791356935},{"_id":"themes/next/scripts/filters/post.js","hash":"bac5646993153f9f6a630c9f0052bb17fa760a9c","modified":1598791356935},{"_id":"themes/next/scripts/helpers/engine.js","hash":"2861b738b6f03114b6f922e794fe2b20090d1438","modified":1598791356935},{"_id":"themes/next/scripts/helpers/font.js","hash":"9cf01a3cf62d9b5a1a0db8145088774bf94045c8","modified":1598791356935},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"3b2261da74c7b33cabfbc82cbb3ce9c8046314d4","modified":1598791356935},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"577c510374cf9bcfa8d3a1027e42411a9324805e","modified":1598791356935},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"2f4152bb450dc4ca8e802e78a21c1858fae298b9","modified":1598791356935},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1598791356935},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1598791356935},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1598791356935},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9836e3212f889e94ada4c354c7b83f7d7caa9aa7","modified":1598791356935},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1598791356935},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1598791356935},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"9e2c58d1a4d1dd84fa86144e5b4576b2fd10a37f","modified":1598791356935},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"464effc08e757ce8e1bb094707d06ad829af9d62","modified":1598791356935},{"_id":"themes/next/scripts/tags/note.js","hash":"05be417a17385a31e1a021e1a54b15046cfd8408","modified":1598791356935},{"_id":"themes/next/scripts/tags/pdf.js","hash":"27129fc4014d723ba93ac77b11342da2ee445d96","modified":1598791356935},{"_id":"themes/next/scripts/tags/tabs.js","hash":"2bf00d56b3b289a7dd27e9b5820430a2457a19f3","modified":1598791356935},{"_id":"themes/next/scripts/tags/video.js","hash":"911851fb3a56570b761d133a6e1531ebf864ea83","modified":1598791356935},{"_id":"themes/next/layout/tag.njk","hash":"09075c80b53b06826e7eb9ce838bca9dc363fac1","modified":1598791356935},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fb2046f2a865e649fe96cb27096d622e4275da1a","modified":1598791356931},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"0200bed29dad088a192ce8e9497980ce86d33002","modified":1598791356931},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"2cd96d9033b77e4496dc4d0efd1873dfc1b0031a","modified":1598791356931},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"7eb808d9b534a9d9d4d3dfc4e38ad63f59b942b8","modified":1598791356931},{"_id":"themes/next/_config.yml","hash":"3bcedec1896162717e08b5195ff9e88ac47e9396","modified":1600938489461},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"b6d8162264dc4d6d31f1f9c2a940718f12cff874","modified":1598791356931},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"3acd5189488e720f23e904f2d9d24cf4b15ac1de","modified":1598791356931},{"_id":"themes/next/.github/workflows/linter.yml","hash":"f499ad31aea9ec598308475ef0b19b7e4177103c","modified":1598791356931},{"_id":"themes/next/.github/workflows/lock.yml","hash":"70bd0be3f33774e4b0ada3a59c901f8f9cff1013","modified":1598791356931},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1598791356931},{"_id":"themes/next/.github/workflows/tester.yml","hash":"f0fe6d5c4242135d9cde0d830d407094ddf7c062","modified":1598791356931},{"_id":"themes/next/docs/ru/README.md","hash":"f0255b119e28102aef403609c29a605f15b95b70","modified":1598791356931},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"0e204dde6d21f100cba6ca7751de71848490759e","modified":1598791356931},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"8ee5ca39ac4a372a5c0f16e344bbe578af4aeae4","modified":1598791356931},{"_id":"themes/next/docs/zh-CN/README.md","hash":"fc9df0ab84387f0468baa0f4a53c7dd9931dbc6d","modified":1598791356931},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1598791356931},{"_id":"themes/next/layout/_macro/post.njk","hash":"f381d4c485ae484a114040d5654db648e4ac7473","modified":1598791356931},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"3481594d36df9eb5e220a6b981d3e5630376a597","modified":1598791356931},{"_id":"themes/next/layout/_partials/comments.njk","hash":"334e8d8117a46c8c097788811322a62627952219","modified":1598791356931},{"_id":"themes/next/layout/_partials/footer.njk","hash":"9c69b85c9ad86ef5c11d2245f91d98f1be248c40","modified":1598791356931},{"_id":"themes/next/layout/_partials/languages.njk","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1598791356931},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1598791356931},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"24eb5b683310810f93c1d7f68f8f70f1a29fd217","modified":1598791356935},{"_id":"themes/next/layout/_scripts/index.njk","hash":"48cbbca0e4f97b8c25f2a5c408071603cd257a65","modified":1598791356935},{"_id":"themes/next/layout/_scripts/noscript.njk","hash":"4f250d0bf80be06dd2c95c1d4c2ba2624b59cf2a","modified":1598791356935},{"_id":"themes/next/layout/_scripts/pjax.njk","hash":"28a3bcb1ce50924a5a48b0f3756ac3a8736867f1","modified":1598791356935},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"bada07da2a47ed6de6081796367b19dd9e906cfb","modified":1598791356935},{"_id":"themes/next/layout/_third-party/baidu-push.njk","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1598791356935},{"_id":"themes/next/layout/_third-party/index.njk","hash":"dc4d2dec2f726b8c5c9f5ac7d6dd0eef0814a0d0","modified":1598791356935},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"294b7f6a4fa566e369d8be0ce7b28f35b6c14563","modified":1598791356935},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1598791356935},{"_id":"themes/next/source/css/_colors.styl","hash":"b37f9847d2f95632e911df670b51921a7d748068","modified":1598791356935},{"_id":"themes/next/source/css/_mixins.styl","hash":"b9c3d3087a917c94cf34ffd6621528d377af8fc9","modified":1598791356935},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1598791356939},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1598791356939},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1598791356939},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1598791356939},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1598791356939},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1598791356939},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1598791356939},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1598791356939},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1598791356939},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1598791356939},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1598791356939},{"_id":"themes/next/source/images/princess.jpg","hash":"a762fc4359785d54e0845f8656b17679af45d40c","modified":1598791356939},{"_id":"themes/next/source/js/algolia-search.js","hash":"a6f78c4cfffa976e4b8043e3486ce99aaba02bda","modified":1598791356939},{"_id":"themes/next/source/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1598791356939},{"_id":"themes/next/source/js/local-search.js","hash":"d57be5b0349610b5b0de303a9574117365d6d554","modified":1598791356939},{"_id":"themes/next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1598791356939},{"_id":"themes/next/scripts/events/lib/config.js","hash":"545ebbd9f5aeb9f7a8e23737664c1f7d701275e1","modified":1598791356935},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1598791356935},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"7b0ea8d28ced63977dc6539920eb044b1098adcb","modified":1598791356935},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"e227174a8ebab8d5b6e8e26faf4fd66c43f045ca","modified":1598791356935},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"f76c7e13fc4304f86260068c9d83d3477b64ee4b","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"199fa9a70914d0019cf0e47f55491183d53d1533","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"a9b18b7447cd5a56cb692c574463a27356eb7fa6","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7b8ce8e9a71cf083f5337fb7c9586be8f7c316e8","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"387e59cd396c62fe095b388c8ff8d4191cfbdeb9","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"1198cb63375a53400431c2e65e3361416cdf8eb6","modified":1598791356935},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"c67984fc868d4799b3aa6d3b3cd060e5260b3a98","modified":1598791356935},{"_id":"themes/next/source/js/next-boot.js","hash":"da67f3eed604dcdc4e89280c9db69fe1f62818e9","modified":1598791356939},{"_id":"themes/next/source/js/schedule.js","hash":"ababd67895ce49049271601c6928fce56a1c6bbb","modified":1598791356939},{"_id":"themes/next/test/helpers/font.js","hash":"8930b1f16facc18dc6764bf6efd753ca50d3f1cb","modified":1598791356939},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1598791356939},{"_id":"themes/next/source/js/utils.js","hash":"eed4ec020dbf499b6479cbe4e1a90b0b4fe4d1e8","modified":1598791356939},{"_id":"themes/next/test/helpers/next-url.js","hash":"abc4ee5149df6172b2c36b6e85d1993ec748ddea","modified":1598791356939},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1598791356939},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1598791356939},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1598791356939},{"_id":"themes/next/test/tags/group-pictures.js","hash":"caf9f6b9a72e41fb30aa24468a54496fba1fcdd8","modified":1598791356939},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1598791356939},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1598791356939},{"_id":"themes/next/test/tags/link-grid.js","hash":"88ec69e4dc1d493d21254ed9296a2514e91f0f8b","modified":1598791356939},{"_id":"themes/next/test/tags/mermaid.js","hash":"ed5b5a70ee49842501c952c4d62483f1fc8eba6b","modified":1598791356939},{"_id":"themes/next/test/tags/note.js","hash":"1b6bac741212e7ca763ab7f92ed2d4e2868126f4","modified":1598791356939},{"_id":"themes/next/test/tags/pdf.js","hash":"bac003317e5bb5e046848522c5c4a7cf231e53f6","modified":1598791356939},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1598791356939},{"_id":"themes/next/test/tags/video.js","hash":"43aaebbc60f19aa69c03b212afff4c4a3fc3b862","modified":1598791356939},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"37bdf020591feb0cf72327c9efd755bf78a0afd6","modified":1598791356931},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"6b502f9e682d1e0083abe229a2f48523ff852c62","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"c082a16163d1fb5d7cf858fb7522fca9d18f1ba6","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1598791356931},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"1b6f08cd884081cc67f02c09ce4696c2df4a9d20","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"789915339a6234d6dd7c710cc1f8e728d9b81d35","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"9d650333160ad1977fe42d9770869ff1660a95fe","modified":1598791356931},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"1d1eba50a28518dea5bba34b2737cfb9b0f2cf49","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"fbdb5cdbd80970f201f5c75369eaa00aea369235","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1598791356931},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"a9bb52d0537d27cfe670d80e716da6780786ab8a","modified":1598791356935},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"c2ccaac9caeea1a43dc31f4f8368f8f548aab0af","modified":1598791356935},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"b7a66a465e897c27624f0c441375c95c4cb7a5aa","modified":1598791356935},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"f1f5be7b5c40a0b611a50e52d27fa4cc82e01bd9","modified":1598791356935},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"a27b994ab99c684765895ffebf72ae30dcfa0703","modified":1598791356935},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1598791356935},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"ad197fd728dd7ac90f910fdf80ce848eab3ff187","modified":1598791356935},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1598791356935},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"d87df68dff14cfb4d91a77230cd1ac795c2a22d5","modified":1598791356935},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1598791356935},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5c2cd9b6f02bcb6248d3f18638a58e329fe8c0d1","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"cc1450d62d76e59968bdd25836694b8339207384","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"54eab4840443262432ec7c47e56e9859ace2a902","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"ec0474e23ca122b34858ffb0bb8c99f241749c61","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"6252b0353c6a36d03c68ebec1073293442221bd1","modified":1598791356935},{"_id":"themes/next/layout/_third-party/comments/valine.njk","hash":"ae2cca696dba96dda7958f0d2b642257599dc11c","modified":1598791356935},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"b0efe26601037e621b5cb16f0fe2f347ee27acdb","modified":1598791356935},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"b6746dfad32cc8a46ff8f4194a7a16ca41744803","modified":1598791356935},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"4193e659b5f742f61dcab7d8a36bf3feb546307a","modified":1598791356935},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"97035261aa85c7d39c6ce1211cdefc6248c0446d","modified":1598791356935},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1598791356935},{"_id":"themes/next/layout/_third-party/search/swiftype.njk","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.njk","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"b70157965285a8c1e003c570cfd4b40bcc1fa719","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"8b956fb56284e8fa4a4731b1efd1f25e1b2b4a78","modified":1598791356935},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"7f01be99413143c5158bda6d83d72bfae6ea5864","modified":1598791356935},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"007da98b913a62946c03a87f8fa25b3db856caa1","modified":1598791356935},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"67d80a57f6b2cf23d56276ca8f30f25e3e8707e9","modified":1598791356935},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1598791356935},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f2bd7a213c35b37233c687bd4ce0fc1de37bc988","modified":1598791356935},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1598791356935},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1598791356935},{"_id":"themes/next/source/css/_variables/base.styl","hash":"0bda922162bca08b0191e5b54857772e4bdabe3a","modified":1598791356935},{"_id":"themes/next/source/js/schemes/muse.js","hash":"d7a6c12bb534810eb748d0ba28aff67cccf0bb3f","modified":1598791356939},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d4809783ded05625675b1b4bbd9e99d7f5f7d7f9","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"92915560810c0311dada43ed629b8fc4ff0fc7a4","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"1c75a837faae9aa2d0a5f30d2078aa8d2ccc2552","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"ee8fb8348aa76a9b346927ba4cae5666d8d777f7","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"28368ac06d04ccf0bbf3dc9e0dfcf341c200b28c","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"0c9f72ad98807521cbdcee7b5bbe2e884311db39","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"ea96e86b6bcb160351c18a7edc4a561918a820cb","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"a472fb1afc6486266b85f773501a290e0a80c370","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e1c85ab2831fd7d4bb84aea1850a0160be0023e8","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7ad04d5a02a7618ebb09c1d5a435d46c4df2c620","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"06786e1ed8774f8f08cbfc711296cf189aaf1b8c","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f6d165dae928c12bde3f271d299a93b334116433","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"0c4390d3a394c5ba96daec864b118fd0c4a934ff","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"e1550114d6f5e828d791831153ef0912a14b4d49","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"be5c46b983df08b9dbac1b4749b1a101b54b6b50","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"c435cfd858bf82726fff2c85d384e2207bea0370","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"826c7f523f1b3a95fedbae7ef3b13ae2f5d41231","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"78f0b6edc296a9ed5144da9f9752c0b96bebfaa5","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"19fc5ca0784f5d2befddb9d8bc463b916c5c2518","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1598791356935},{"_id":"themes/next/test/validate/index.js","hash":"ef716c1db8e3c93c320f73b6da4010e03b4eb0ae","modified":1598791356939},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8998a07acf0dbd10811835c8dfc91d92e680bcae","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"76d0dfb3a8b873a6180604ac6daecf38b6a963a2","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"8a2e724df3d5cd14765eb951f0a9e1dba399fd35","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"d6ecc5dfd15c588782ba5e1df9f915b305622aef","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cf6540e12c2de5befcfb7e92d915e3b75fd53dfa","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"27001ad06f69ff035639210ab2f614861b21a4f4","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"b3fa752f72ca1413289b76c56fbd33a00e3d25d7","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"48ee817d05ddc788423d7f10e9823e23fda81d04","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"2c534d2b2dbc932ad65d335a720a7ba9612bac04","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2896840ab8ac8ab2a7f76d18df893f290ac31625","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"5d8fc91cdb7ee313eb367dcec7d5b2429f98242f","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"f11dca93e334b68a29e792f7abe682993fab7568","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"8cb89864e8245a356d08ef0fee3133810f646fea","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"254e781e7b25e31a1a589c8b38dc608802f1cc6e","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"f1778d2c56974b96dae429456d5c55be325c4946","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"6d8afd8e23c40bb2b2a2edbe4eb0d2671cd81188","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"57e6b5d82a2d85cabfc7275eb0ac758f3c06991d","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"9c8abc55c9d94d384a245013951aba5ecca2f4fe","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"66782e68f1c74a7d0aecef20e2ca16bbe6b52592","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"521b36ea7bb3a843029cbfbb6b5e76e91c40a19f","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"55060cade4547779ba5996643d93763373b5127c","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"469855a72d2c2b63a21df8fbcb8cc41d32cb9bde","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"432e73bc4f99322af6af1852e0ea6e674919c31a","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"43f7d37948232553873ee346d625457bfe704e74","modified":1598791356935},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"77398b426f182823776f38071de3c839e401fbe0","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"920f21dc03b28f006aef7e9d0fd444c2cd283efc","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"15a5e273a8137550c93c8d2a60f9fcf86e04a89e","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"f09bc97e3681d73c38d7d3c5c271486c2c6537e2","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"acfdec45e56cdd6a5ea61e0154f8a6d1bc068214","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"3c029a003e9bf747e1b9cc7c0c127f6028374876","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"29bef220307d86b1eafbb3714381df32d48b5a60","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"dcf426c2a4836386c0c27235de3f9a95c5de67cc","modified":1598791356935},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"cef4e779473daa3761709958243c6b8a57bbd814","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c706733f5196776fe2657a9bebe0a727cf8fe8e5","modified":1598791356935},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1598791356935},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"ae638f4c4f92fc13eb14b154ad3ca9bfd9334c85","modified":1599720909205},{"_id":"public/about/index.html","hash":"b7a0cd4b863e134b1189b1d04bf4b5a2e92bdab5","modified":1616341760417},{"_id":"public/categories/index.html","hash":"cd7d842ed73767a209837a4b5d636d706869a028","modified":1616341760417},{"_id":"public/tags/index.html","hash":"10bdf0d6efbd2ace534b10d676e9aa9eb4fa4b47","modified":1616341760417},{"_id":"public/archives/index.html","hash":"6b55f642b8d608d83082315c8e153d2b5ee6d942","modified":1616341760417},{"_id":"public/archives/page/2/index.html","hash":"37b9de91940d71517800aa2473f814da61049b99","modified":1616341760417},{"_id":"public/archives/page/4/index.html","hash":"b0a28dbe25e01f138714fcaea0dacaaf6102dd04","modified":1616341760417},{"_id":"public/archives/page/5/index.html","hash":"f134da32c3b35d4d4f89b406224d338265868088","modified":1616341760417},{"_id":"public/archives/2020/index.html","hash":"3b07e8daaf17708d217a49e93a4b1c01c67545b9","modified":1616341760417},{"_id":"public/archives/2020/page/2/index.html","hash":"46db2ad4bc77466871058362e310d40ba8b0ddef","modified":1616341760417},{"_id":"public/archives/2020/page/4/index.html","hash":"b1cfa3e587195bcff6456474e75b99c09dbc19ed","modified":1616341760417},{"_id":"public/archives/2020/page/5/index.html","hash":"d04e05c29ad7832cb27baad7f28cc923dcd6d464","modified":1616341760417},{"_id":"public/archives/2020/08/index.html","hash":"602b697763e51ef962e941b81f0dbd0a56c800c4","modified":1616341760417},{"_id":"public/archives/2020/08/page/2/index.html","hash":"5c34ba71d374c886b9a0cccf2e81e2f9a29b3235","modified":1616341760417},{"_id":"public/archives/2020/09/index.html","hash":"0a10823b0f28d32a34e6d41e9e0efa22b04773fb","modified":1616341760417},{"_id":"public/archives/2020/09/page/2/index.html","hash":"4db39934936b83f7709febb89bac83712a533ab9","modified":1616341760417},{"_id":"public/archives/2020/09/page/3/index.html","hash":"180f0a4d32cbd17dbd6384b578aa8bb4c75a9b6f","modified":1616341760417},{"_id":"public/categories/Architecture/index.html","hash":"73d26d64972a49b7c69d2bad8fe80dbeb3cfb303","modified":1616341760417},{"_id":"public/categories/DesignPattern/index.html","hash":"1428fc1dc4cca57e7eb8f4d002bf9b37c1ccd000","modified":1616341760417},{"_id":"public/categories/Docker/index.html","hash":"678a1272327b17639d15f4fe1d953a0907dd8c61","modified":1616341760417},{"_id":"public/categories/DesignPattern/Factory/index.html","hash":"caf6ca4e7894ba973ccd990ad148e0b1e693a59b","modified":1600943266702},{"_id":"public/categories/DesignPattern/Observer/index.html","hash":"bcf73aed8ccd658a9342c5f6877b97b31ad373c4","modified":1600943266702},{"_id":"public/categories/DesignPattern/Singleton/index.html","hash":"ea6b92a3220e15602c388cd3ccb528c30a8c1b64","modified":1600943266702},{"_id":"public/categories/Docker/Dockerfile/index.html","hash":"918840a2eaa0c22a176af064201c6577a8c62d48","modified":1616341760417},{"_id":"public/categories/PHP/index.html","hash":"decf81c57c4cdcd31ab4c68346562cdea3e26e5c","modified":1616341760417},{"_id":"public/categories/HTTP/index.html","hash":"834eda99190c1704a245c7e82b770cf4a997f0f0","modified":1616341760417},{"_id":"public/categories/MySQL/index.html","hash":"ba28401dad7494bd0a2e117ed1193c0f672ac309","modified":1616341760417},{"_id":"public/categories/PHP/PDO/index.html","hash":"ce73e24fed50eaed7260775d3fe06bdfbad5f79f","modified":1616341760417},{"_id":"public/categories/Protobuf/index.html","hash":"7e92eba905b853f6ce90f8eae4acfed523d99ed7","modified":1616341760417},{"_id":"public/categories/Redis/index.html","hash":"235f92f0f6c2cc01609da8213fa54c453c23ff2d","modified":1616341760417},{"_id":"public/categories/MySQL/InnoDB/index.html","hash":"5748ef70265e67b661419797c965911ad26c7108","modified":1616341760417},{"_id":"public/categories/TCP-IP/index.html","hash":"e3593269a01e43ba18eb4fedc9a86746c5e918ce","modified":1616341760417},{"_id":"public/categories/Ubuntu/index.html","hash":"266bb9fe3ef95a6b2791277df8277749f754d485","modified":1616341760417},{"_id":"public/categories/WEB/index.html","hash":"c66592a24a276e90b28881c6e2236cf8750604e2","modified":1616341760417},{"_id":"public/categories/Ubuntu/Config/index.html","hash":"bacb86a9987507a49a18bba3946256e27ef6ab40","modified":1616341760417},{"_id":"public/categories/MySQL/Note/index.html","hash":"a34fd3b9d4de9672267f87bcc2a9d00a582c237d","modified":1616341760417},{"_id":"public/categories/MySQL/Note/高性能MySQL/index.html","hash":"33642d420687b783d1f8ff956d10e1385b3a77ca","modified":1616341760417},{"_id":"public/tags/Architecture/index.html","hash":"6672d3bdc2acb4c7db09ea8cbb80887bf87f34ca","modified":1616341760417},{"_id":"public/tags/RPC/index.html","hash":"0d29475078e78037c0c9953e9a72fd7ee65c218f","modified":1616341760417},{"_id":"public/tags/Interview/index.html","hash":"0e0da4b25f81583ac042b59ef2362fcac9d17238","modified":1616341760417},{"_id":"public/tags/DesignPattern/index.html","hash":"7d0bb503ac14bb7b0b070a592420eaf255997073","modified":1616341760417},{"_id":"public/tags/Factory/index.html","hash":"74d7c775860c6b9cca3e82dca057dc02859bccfb","modified":1616341760417},{"_id":"public/tags/Observer/index.html","hash":"7b423c280d1b37b9469cec6383e2cc3cff2ec258","modified":1616341760417},{"_id":"public/tags/Singleton/index.html","hash":"f54de652fe159394ad61841cf5c84dc3e425e829","modified":1616341760417},{"_id":"public/tags/Docker/index.html","hash":"a53c813d7ced957815269b91de734259f42e8069","modified":1616341760417},{"_id":"public/tags/Dockerfile/index.html","hash":"f3f14c841291cc40a43bcac6d0b7e7e3e3b98a87","modified":1616341760417},{"_id":"public/tags/PHP/index.html","hash":"435249780a05716813d4dd22af8efc25dc109fc1","modified":1616341760417},{"_id":"public/tags/HTTP/index.html","hash":"06c8f4ff64a9b99466c24b18f86487f6438c868c","modified":1616341760417},{"_id":"public/tags/MySQL/index.html","hash":"6efb8ccf14c6720c3c8a5018c40af6815b7161b6","modified":1616341760417},{"_id":"public/tags/B-Tree/index.html","hash":"2ed32e7a8653744ac56382d1b5436f05670ae83b","modified":1616341760417},{"_id":"public/tags/InnoDB/index.html","hash":"66152b625fbb3532e78c7c072f7b2664937fce04","modified":1616341760417},{"_id":"public/tags/索引/index.html","hash":"6fceb173b86a8de465d70539e4a7feabd5481d6e","modified":1616341760417},{"_id":"public/tags/事务/index.html","hash":"00767c9d2282ec64ca10894522945b9bc42d43a0","modified":1616341760417},{"_id":"public/tags/锁/index.html","hash":"58779af6bd41aa042a7a2c670c08bd4f90fcd1e9","modified":1616341760417},{"_id":"public/tags/PDO/index.html","hash":"56c77d13cd34e38aaee54e7915f3a5baf30868db","modified":1616341760417},{"_id":"public/tags/Protobuf/index.html","hash":"58ad7bc3646bd7143891f1ac58f7356c823e3b15","modified":1616341760417},{"_id":"public/tags/Redis/index.html","hash":"6021c48d05bbb0c9050032944132e250597b0f5e","modified":1616341760417},{"_id":"public/tags/Note/index.html","hash":"fb93e51dcb99b6dd94b4f2ba4d0bd2610d3742fc","modified":1616341760417},{"_id":"public/tags/Redis设计与实现/index.html","hash":"2dbb5c604ed9e2e1e681eefdff856ead1d1ddda9","modified":1616341760417},{"_id":"public/tags/TCP-IP/index.html","hash":"857e193cd535524fa1a75ee610e81b23b621db0e","modified":1616341760417},{"_id":"public/tags/Ubuntu/index.html","hash":"95d468df967ec4e3d272b9e493a1e9f19906cefb","modified":1616341760417},{"_id":"public/tags/Config/index.html","hash":"e51bcbd21d6c59f25a61929d1f610833c45f3dca","modified":1616341760417},{"_id":"public/tags/Git/index.html","hash":"b8ef56bfe595a209b52bb3c78332980bde2b42a8","modified":1616341760417},{"_id":"public/tags/Node-js/index.html","hash":"4c634ec4879d27d87721e85bcfc538d5b4b56d96","modified":1616341760417},{"_id":"public/tags/SSH/index.html","hash":"f24032805f5361e3944de665c191750ea56b87dc","modified":1616341760417},{"_id":"public/tags/WEB/index.html","hash":"4e765a69b2d6307cca1b58617f5098f89189bf27","modified":1616341760417},{"_id":"public/tags/SESSION/index.html","hash":"d5d81277ddc00d8fce1e92498f5106aac5bc5157","modified":1616341760417},{"_id":"public/tags/COOKIE/index.html","hash":"1b0253f22d82f94ac2170567a735e90e6f9a1df4","modified":1616341760417},{"_id":"public/tags/TOKEN/index.html","hash":"5abbd91d62f3c9e05d52bc556fe6c26800fa0631","modified":1616341760417},{"_id":"public/tags/JWT/index.html","hash":"100288d64f4418aa10e72e4747f534f751b04940","modified":1616341760417},{"_id":"public/tags/高性能MySQL/index.html","hash":"dd806bfeb9704ef048fbce2b2103186741d236be","modified":1616341760417},{"_id":"public/tags/死锁/index.html","hash":"8e566adc1cfacdc8c9ab2baed388854ac90863fc","modified":1616341760417},{"_id":"public/tags/一致性非锁定读/index.html","hash":"09d74fdb40f36024fe9effe8ade69ff2115e32fa","modified":1616341760417},{"_id":"public/tags/Hexo/index.html","hash":"58d0d6df7562c5f1b4d057f0314cb0121da88127","modified":1616341760417},{"_id":"public/page/5/index.html","hash":"de993f3af8c78b1cc00381bcdd572a5eef291f5c","modified":1616341760417},{"_id":"public/2020/09/23/TCP-IP-三次握手与四次挥手/index.html","hash":"0007c16cfc5e96f63f82b03d3b1f528c56b3b26d","modified":1616341760417},{"_id":"public/2020/09/23/Architecture-既然有HTTP请求，为何要用RPC调用/index.html","hash":"4b709a3e9a1a878e157935ce0c2afa55196ab81a","modified":1616341760417},{"_id":"public/2020/09/23/WEB-会话管理/index.html","hash":"2b62d0f45cf9b002cccbfc37f73d9386461b59b2","modified":1616341760417},{"_id":"public/2020/09/23/HTTP-GET与POST的区别？/index.html","hash":"484a0bd9abcde6e7eb146a2b515b19d1b8ae1228","modified":1616341760417},{"_id":"public/2020/09/22/MySQL-InnoDB事务的实现/index.html","hash":"2ab0fc8c581e5ee2ced86ad78c578663a874b9b7","modified":1616341760417},{"_id":"public/2020/09/22/PHP-使用PDO访问数据库/index.html","hash":"4a005405c6501630ac44c8e26851b27fe2c41dc2","modified":1616341760417},{"_id":"public/2020/09/22/DesignPattern-Observer/index.html","hash":"a02ddf43babfffd8febf256600e0d0c335d00333","modified":1616341760417},{"_id":"public/2020/09/21/DesignPattern-Factory/index.html","hash":"677a4c2a9939b26786cb282ce2142339ce0620fd","modified":1616341760417},{"_id":"public/2020/09/21/DesignPattern-Singleton/index.html","hash":"33dd0f71c2092528dc67dc8bdf5eebc26a4129b1","modified":1616341760417},{"_id":"public/2020/09/20/Architecture-前后端分离/index.html","hash":"43a4bddfaa951470dbe71fe79447f812a909d209","modified":1616341760417},{"_id":"public/2020/09/17/Docker-Dockerfile指令/index.html","hash":"a048682cde08918c28f8dd1cf26461d4b0d24d71","modified":1616341760417},{"_id":"public/2020/09/16/Docker-错误处理/index.html","hash":"8e9eebfe9bdc51af2e61be0c3e7a3a7e395de962","modified":1616341760417},{"_id":"public/2020/09/16/Docker-镜像/index.html","hash":"29895c238d4507c40d8021f9f248b97de067e872","modified":1616341760417},{"_id":"public/2020/09/16/Docker-容器/index.html","hash":"ccae394b3a30a4ad84f5300b3493531cd9ab7f9f","modified":1616341760417},{"_id":"public/2020/09/16/Docker-是什么？/index.html","hash":"5a345ed96e0d2329b4b9d1b99ed08285cf50ac9b","modified":1616341760417},{"_id":"public/2020/09/14/MySQL-脏读-不可重复读-幻读/index.html","hash":"d4f07076f8faecdc749e28c41171b422a1ddb7b2","modified":1616341760417},{"_id":"public/2020/09/11/MySQL-命令及方法备忘录/index.html","hash":"194a00334f08f6bce8c20e050774c14f32c36e5a","modified":1616341760417},{"_id":"public/2020/09/10/MySQL-并发控制/index.html","hash":"2df198e76ee9b39d526ce6cdfefac1c328535e75","modified":1616341760417},{"_id":"public/2020/09/09/高性能MySQL-事务基础/index.html","hash":"280b7067428e56ee32dd5bb61a86eb99235b2336","modified":1616341760417},{"_id":"public/2020/09/07/MySQL-为什么使用B-树作为索引结构/index.html","hash":"53d95319bfe042c2a5580bc48ccf7040dbf6ab35","modified":1616341760417},{"_id":"public/2020/09/06/高性能MySQL-创建高性能索引/index.html","hash":"0805ae42489f076287ffef8f291a26ffb24239c8","modified":1616341760417},{"_id":"public/2020/09/06/MySQL-索引分类/index.html","hash":"b1dffbaf270fda922a89bd1d0291c5dfbf724e19","modified":1616341760417},{"_id":"public/2020/09/05/MySQL-Explain详解/index.html","hash":"2b261ead08baf94a1a9d0f0374b70369bf277de1","modified":1616341760417},{"_id":"public/2020/09/04/高性能MySQL-Schema与数据类型优化/index.html","hash":"dbd15ca438ec6002c86b0d6b006e038bfcf16b4f","modified":1616341760417},{"_id":"public/2020/09/04/Redis-踩坑记录/index.html","hash":"006729d9141553f18275c0fac759f3d96f90a225","modified":1616341760417},{"_id":"public/2020/09/03/Redis设计与实现-RDB持久化/index.html","hash":"c644cc56488ea88f05d890f743e2635e52f6d010","modified":1616341760417},{"_id":"public/2020/09/03/Redis设计与实现-Redis键过期及删除策略/index.html","hash":"e7220a0b5b6109006a1cb3ec6bdd4959e78fdd34","modified":1616341760417},{"_id":"public/2020/09/03/redis设计与实现-单机数据库的实现/index.html","hash":"45eaa0253b6dcf80318011e8db8171a8ae3ac8f8","modified":1616341760417},{"_id":"public/2020/08/31/Redis设计与实现-Redis对象/index.html","hash":"32d549c9cda7aa92df11a9196cfaefe39126ea5c","modified":1616341760417},{"_id":"public/2020/08/25/Redis设计与实现-数据结构/index.html","hash":"490f032613f86815f069d8c08af981af88ec5153","modified":1616341760417},{"_id":"public/2020/08/25/Protobuf简介及安装/index.html","hash":"e62aa316a31f3ef044e8d8f2a2a5bc7a17802419","modified":1616341760417},{"_id":"public/2020/08/25/PHP7内核-内存管理-内存池/index.html","hash":"23b75faa8eff4453af76073eca909f681177d3fe","modified":1616341760417},{"_id":"public/2020/08/25/PHP7内核-内存管理-GC机制/index.html","hash":"fb4c5f5470f147d03f7121e3b1efcb7ed7f55799","modified":1616341760417},{"_id":"public/2020/08/25/FastCGI和PHP-FPM的关系/index.html","hash":"3e542fbfea075725ba01b6129547ed6f3d55465a","modified":1616341760417},{"_id":"public/2020/08/21/PHP7内核-FPM/index.html","hash":"c57b5a8f8d398eed5a574d7b23dacec32a3c7de3","modified":1616341760417},{"_id":"public/2020/08/21/PHP7内核-Cli/index.html","hash":"9d8cc1cc570838379ba8165f79799f2a7ea271ea","modified":1616341760417},{"_id":"public/2020/08/21/PHP7内核-变量/index.html","hash":"c57250859f9557ec654bd5ffa08b6f082b30d8d8","modified":1616341760417},{"_id":"public/2020/08/21/Ubuntu16-04-Nodejs安装/index.html","hash":"e1ab7b5dcd1202d397cb06dde9d534cf2efa1b19","modified":1616341760417},{"_id":"public/2020/08/20/Ubuntu16-04-搭建Hexo-Blog/index.html","hash":"05f8996e7953bbdbd4160afb28bec601fd59473e","modified":1616341760417},{"_id":"public/2020/08/19/Ubuntu16-04-设置SSH密钥/index.html","hash":"a120a99f3b5bc339c063f6dd30f71e50c99519d7","modified":1616341760417},{"_id":"public/2020/08/18/Ubuntu16-04-Github配置及使用/index.html","hash":"11d5d45f1fe665be8d29108866550e62ffc08421","modified":1616341760417},{"_id":"public/archives/page/3/index.html","hash":"4a7d8454faac20218677259d4febea1fb1ce9342","modified":1616341760417},{"_id":"public/archives/2020/page/3/index.html","hash":"8d489ac3cb465a78693768bfcab84ae50e33a572","modified":1616341760417},{"_id":"public/index.html","hash":"98cd73d2be4c409a753efc0bbcc9837d105f7eab","modified":1616341760417},{"_id":"public/page/2/index.html","hash":"454a860b78b2f795046212a42546c0db422e19fd","modified":1616341760417},{"_id":"public/page/3/index.html","hash":"53ad4724109f3e2201d12432cc66765373ccc8be","modified":1616341760417},{"_id":"public/page/4/index.html","hash":"7b11abf61e47fec342ff89f5422900c1cb725a1b","modified":1616341760417},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1600943266702},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1600943266702},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1600943266702},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1600943266702},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1600943266702},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1600943266702},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1600943266702},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1600943266702},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1600943266702},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1600943266702},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1600943266702},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1600943266702},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1600943266702},{"_id":"public/images/princess.jpg","hash":"a762fc4359785d54e0845f8656b17679af45d40c","modified":1600943266702},{"_id":"public/js/algolia-search.js","hash":"a6f78c4cfffa976e4b8043e3486ce99aaba02bda","modified":1600943266702},{"_id":"public/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1600943266702},{"_id":"public/js/local-search.js","hash":"d57be5b0349610b5b0de303a9574117365d6d554","modified":1600943266702},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1600943266702},{"_id":"public/js/next-boot.js","hash":"da67f3eed604dcdc4e89280c9db69fe1f62818e9","modified":1600943266702},{"_id":"public/js/schedule.js","hash":"ababd67895ce49049271601c6928fce56a1c6bbb","modified":1600943266702},{"_id":"public/js/utils.js","hash":"eed4ec020dbf499b6479cbe4e1a90b0b4fe4d1e8","modified":1600943266702},{"_id":"public/js/schemes/muse.js","hash":"d7a6c12bb534810eb748d0ba28aff67cccf0bb3f","modified":1600943266702},{"_id":"public/css/main.css","hash":"d8b99fe952c14577a390aa85474274ca022f92e4","modified":1600943266702},{"_id":"source/_posts/DesignPattern-Command.md","hash":"deafd69a6cb45b4daf2dfe6b0350e5053be224c8","modified":1601026628499},{"_id":"public/tags/Command/index.html","hash":"d7a632d3c1baa6706b0215af1e5ace60e12de435","modified":1616341760417},{"_id":"public/2020/09/25/DesignPattern-Command/index.html","hash":"2050837a51d530fff3d98edc4d48719aed491e5d","modified":1616341760417},{"_id":"source/_drafts/Differences-OOP和POP的区别？.md","hash":"99829941dd65339abbcc1406e2f5f3bebe737d95","modified":1601136221027},{"_id":"source/_posts/Concept-ORM是什么？.md","hash":"fabd0c53f01c86328405c18787e5314e07c74e60","modified":1601201035601},{"_id":"public/categories/Concept/index.html","hash":"e7ac71feeb463d1c21276918436fd6726ea65948","modified":1616341760417},{"_id":"public/tags/Concept/index.html","hash":"2f0c6268a481cb9e880af42fa9686817f81b48df","modified":1616341760417},{"_id":"public/tags/ORM/index.html","hash":"9dc5e165d519bc4451ef83ecd22cc85fef801b9f","modified":1616341760417},{"_id":"public/2020/09/25/Concept-ORM是什么？/index.html","hash":"400420f10c13bee0da2e9885bfc01392081a4195","modified":1616341760417},{"_id":"source/_posts/Differences-OOP和POP的区别？.md","hash":"4713ef7bbeecfa8917df46915fd8719a960a192c","modified":1601192960013},{"_id":"public/archives/2020/09/page/4/index.html","hash":"e7349073d298213a50e0dbad03a632b2d7829952","modified":1616341760417},{"_id":"public/tags/Differences/index.html","hash":"c35a96470176f239f33fbd9b0fe17885830bc785","modified":1616341760417},{"_id":"public/tags/OOP/index.html","hash":"02bf20db63d4796fc646bafdfeb74fa3a5210aeb","modified":1616341760417},{"_id":"public/tags/POP/index.html","hash":"b23d81589f902556df3f67000fc43c541a48a18d","modified":1616341760417},{"_id":"public/categories/Differences/index.html","hash":"60848d364831a1068464ed96e209216679c6ba2d","modified":1616341760417},{"_id":"public/2020/09/26/Differences-OOP和POP的区别？/index.html","hash":"bcb84f84ae13d2d3a4325a2a2a1ce8157d8d03d1","modified":1616341760417},{"_id":"source/_posts/DesignPattern-Decorator.md","hash":"cd4d9a4903595465f66799c473c547adf646b1c9","modified":1601345936769},{"_id":"public/2020/09/28/DesignPattern-Decorator/index.html","hash":"a40934ce7db1ff0f07df0a04ccf630b2f4992333","modified":1616341760417},{"_id":"public/tags/Decorator/index.html","hash":"eb460dff67140ad695985c5f7c5722aa57f83852","modified":1616341760417},{"_id":"source/_posts/DesignPattern-Adapter.md","hash":"17474da26868b81ee726497f18a63935062496ee","modified":1601373083598},{"_id":"public/2020/09/29/DesignPattern-Adapter/index.html","hash":"9cfa681d220578a56f40f71371d09a440298a7b9","modified":1616341760417},{"_id":"public/tags/Adapter/index.html","hash":"7b0d81f9aa290bc4de4b50df8181442e415913b0","modified":1616341760417},{"_id":"source/_posts/PHP-Laravel安装.md","hash":"902d1b4d54f581690ee66c19ccbadaf960fce065","modified":1602002650796},{"_id":"public/archives/2020/10/index.html","hash":"6fd48c16d2fddbd38139980ae3a9d53ccaa247d9","modified":1616341760417},{"_id":"public/categories/PHP/Laravel/index.html","hash":"7af621453e39a9efc2a867e1c698f6db1669f2e7","modified":1616341760417},{"_id":"public/tags/Laravel/index.html","hash":"a6a6b8feb1103beb9b81695b7b6dae5ce4e9e6cb","modified":1616341760417},{"_id":"public/2020/10/05/PHP-Laravel安装/index.html","hash":"b47707f7345b18bbb86f0586e3dbc0cc34edf597","modified":1616341760417},{"_id":"source/_posts/操作系统-进程.md","hash":"9cd712705c7a812399dadec7aead22914687c21e","modified":1616086598611},{"_id":"public/archives/2021/index.html","hash":"db907462baa84aa66cfe0954c7a70c6c29e3c517","modified":1616341760417},{"_id":"public/archives/2021/03/index.html","hash":"99efeaf05491618efdd4b9547873e31c327f99dd","modified":1616341760417},{"_id":"public/categories/操作系统/index.html","hash":"ca92d366764a2731e27a690c7a9eb7c219d3319f","modified":1616341760417},{"_id":"public/categories/操作系统/进程/index.html","hash":"907bee7fc3a2ef0d5e5481dac14660c87d07703b","modified":1616341760417},{"_id":"public/categories/操作系统/进程/Note/index.html","hash":"c6b946adb51c25be60612558b2d40aed8df44161","modified":1616341760417},{"_id":"public/tags/操作系统/index.html","hash":"092f9309d8691e7178685edf81849bd5a768758e","modified":1616341760417},{"_id":"public/tags/进程/index.html","hash":"3838130808b66a857625aa528d6656dbacb72ebd","modified":1616341760417},{"_id":"public/tags/现代操作系统/index.html","hash":"b8d8875a205c883558bfab49e8dc39cad0ede205","modified":1616341760417},{"_id":"public/2021/03/18/操作系统-进程/index.html","hash":"690f305b88943808cae79413f4fca8c49f96f6bf","modified":1616341760417},{"_id":"source/_posts/操作系统-线程.md","hash":"e5e39003fdb9124a0466c64bfc5ae3e8e6a09364","modified":1616341712960},{"_id":"public/categories/操作系统/线程/index.html","hash":"235d4804399ce30f9b60de56bcefabb925324440","modified":1616341760417},{"_id":"public/categories/操作系统/线程/Note/index.html","hash":"cd54cf3124d8c016a7ea9b4a60a88c57cde552ec","modified":1616341760417},{"_id":"public/tags/线程/index.html","hash":"ef443e1a321e6e14dfbc79a7db192b29bf8c680f","modified":1616341760417},{"_id":"public/2021/03/20/操作系统-线程/index.html","hash":"52bb63201e03ae92dff292fd6951c04de569920a","modified":1616341760417}],"Category":[{"name":"Architecture","_id":"ckfgoabis000445g3beng43ot"},{"name":"DesignPattern","_id":"ckfgoabj2000f45g3fktxhv7n"},{"name":"Docker","_id":"ckfgoabj7000o45g3hsjcdykp"},{"name":"Factory","parent":"ckfgoabj2000f45g3fktxhv7n","_id":"ckfgoabj9000v45g3fjk89etv"},{"name":"Observer","parent":"ckfgoabj2000f45g3fktxhv7n","_id":"ckfgoabja000z45g35qwsfnap"},{"name":"Singleton","parent":"ckfgoabj2000f45g3fktxhv7n","_id":"ckfgoabjb001345g32wovb0kh"},{"name":"Dockerfile","parent":"ckfgoabj7000o45g3hsjcdykp","_id":"ckfgoabjc001845g3e6psajoj"},{"name":"PHP","_id":"ckfgoabki001w45g3hrk58osp"},{"name":"HTTP","_id":"ckfgoabkl002245g356xoe9xw"},{"name":"MySQL","_id":"ckfgoabko002845g32wcr0i0j"},{"name":"PDO","parent":"ckfgoabki001w45g3hrk58osp","_id":"ckfgoabl1002x45g3glsdd15i"},{"name":"Protobuf","_id":"ckfgoabl4003445g3bhk8dny4"},{"name":"Redis","_id":"ckfgoabl9003945g3bfs03ljy"},{"name":"InnoDB","parent":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoablb003f45g32gnr8qon"},{"name":"TCP/IP","_id":"ckfgoabli003p45g3dyia87to"},{"name":"Ubuntu","_id":"ckfgoablj003w45g3dlrhcyxv"},{"name":"WEB","_id":"ckfgoablr004645g3394d7bp3"},{"name":"Config","parent":"ckfgoablj003w45g3dlrhcyxv","_id":"ckfgoabm3004b45g3eahkcb2c"},{"name":"Note","parent":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabob006v45g32nle6ilk"},{"name":"高性能MySQL","parent":"ckfgoabob006v45g32nle6ilk","_id":"ckfgoaboj007745g38l2n9m6z"},{"name":"Differences","_id":"ckfjv880y00022svthri1c2x6"},{"name":"Concept","_id":"ckfjv881f00042svt8u2s1fi9"},{"name":"Laravel","parent":"ckfgoabki001w45g3hrk58osp","_id":"ckgb0888h00021hvt7icra4cx"},{"name":"操作系统","_id":"ckmf4b6an0001qetl4jeh1af6"},{"name":"进程","parent":"ckmf4b6an0001qetl4jeh1af6","_id":"ckmf4b6az0004qetl8pcg4lbg"},{"name":"Note","parent":"ckmf4b6az0004qetl8pcg4lbg","_id":"ckmf4b6b00006qetl2did495e"},{"name":"线程","parent":"ckmf4b6an0001qetl4jeh1af6","_id":"ckmjc5hes0002g5tlcf6le7au"},{"name":"Note","parent":"ckmjc5hes0002g5tlcf6le7au","_id":"ckmjc5het0004g5tl1wjf9p9e"}],"Data":[],"Page":[{"title":"about","date":"2020-08-30T10:41:26.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-08-30 18:41:26\n---\n","updated":"2020-08-30T12:42:36.923Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckfgoabd0000045g3gvavagjf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2020-08-30T10:41:50.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-08-30 18:41:50\ntype: \"categories\"\n---\n","updated":"2020-08-30T12:42:36.923Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckfgoabiq000245g3avk50a8t","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-08-30T10:41:43.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-08-30 18:41:43\ntype: tags\n---\n","updated":"2020-08-30T12:42:36.923Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckfgoabiu000645g3eehb8ve1","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Architecture-前后端分离","date":"2020-09-20T07:13:11.000Z","_content":"\n\n\n\n### 1 为什么要进行前后端分离\n\n一个典型的互联网分层架构为：`web->webServer->service->db`。随着业务的发展，原先可能只有PC端，后来需要增加Mobile、App、小程序等版本。他们的webServer层大部分业务是相同的，只有少数的逻辑/展现/交互不一样，在不进行前后端分离的情况，基本靠拷贝代码实现。\n\n<!--more-->\n\n这样就可能会存在一些问题：\n\n- 一旦一个服务的RPC接口有稍许变化，所有的webServer系统都需要升级修改；\n- webServer之间存在大量代码拷贝；\n- 一旦拷贝代码，出现一个bug，多个系统都需要升级修改。\n\n\n\n### 2 怎样进行前后端分离\n\n通过对前后端分离分层抽象：\n\n- `站点展示层`：负责数据的展现与交互，由FE维护；\n- `站点数据层`：负责处理业务逻辑与json数据接口的提供，由后端工程师维护。\n\n\n\n#### 2.1 前后端分离的好处\n\n- 复杂的业务逻辑与数据生成，只有在站点数据层处写了一次，没有代码拷贝；\n- 底层service接口发生变化，只有站点数据层一处需要升级修改；\n- 底层service如果有bug，只有站点数据层一处需要升级修改；\n- 站点展现层可以根据产品的不同形态，传入不同的参数，调用不同的站点数据层接口；\n- 关于产品展示、设备兼容性要求高，由更专业的FE对接；\n- 产品展示的改动，不在需要后端重新编译、打包、上线等操作；\n- 在约定好json接口后，前后端可以同时进行开发，FE可以自行mock数据进行自测，不用等待一起联调。\n\n\n\n#### 2.2 前后端分离的缺点\n\n- 前后端分离会给系统架构带来更多的复杂性。\n- 前后端分离，将引入“联调”一说（即FE与后端开发对接联调），增加沟通成本，可能导致产品迭代的速度降低。\n\n\n\n### 3 前后端分离的适用场景\n\n产品追求炫酷的前端效果，并且对前端兼容性要求较高，前端产品改版频率较高的情况，进行前后端分离是有必要的。\n\n------\n\n### 参考资料\n\n[互联网分层架构，为啥要前后端分离？](https://mp.weixin.qq.com/s/-XF_w768tSDFKKqMSxlVyQ)\n\n","source":"_posts/Architecture-前后端分离.md","raw":"---\ntitle: Architecture-前后端分离\ntags:\n  - Architecture\ncategories:\n  - Architecture\ndate: 2020-09-20 15:13:11\n---\n\n\n\n\n### 1 为什么要进行前后端分离\n\n一个典型的互联网分层架构为：`web->webServer->service->db`。随着业务的发展，原先可能只有PC端，后来需要增加Mobile、App、小程序等版本。他们的webServer层大部分业务是相同的，只有少数的逻辑/展现/交互不一样，在不进行前后端分离的情况，基本靠拷贝代码实现。\n\n<!--more-->\n\n这样就可能会存在一些问题：\n\n- 一旦一个服务的RPC接口有稍许变化，所有的webServer系统都需要升级修改；\n- webServer之间存在大量代码拷贝；\n- 一旦拷贝代码，出现一个bug，多个系统都需要升级修改。\n\n\n\n### 2 怎样进行前后端分离\n\n通过对前后端分离分层抽象：\n\n- `站点展示层`：负责数据的展现与交互，由FE维护；\n- `站点数据层`：负责处理业务逻辑与json数据接口的提供，由后端工程师维护。\n\n\n\n#### 2.1 前后端分离的好处\n\n- 复杂的业务逻辑与数据生成，只有在站点数据层处写了一次，没有代码拷贝；\n- 底层service接口发生变化，只有站点数据层一处需要升级修改；\n- 底层service如果有bug，只有站点数据层一处需要升级修改；\n- 站点展现层可以根据产品的不同形态，传入不同的参数，调用不同的站点数据层接口；\n- 关于产品展示、设备兼容性要求高，由更专业的FE对接；\n- 产品展示的改动，不在需要后端重新编译、打包、上线等操作；\n- 在约定好json接口后，前后端可以同时进行开发，FE可以自行mock数据进行自测，不用等待一起联调。\n\n\n\n#### 2.2 前后端分离的缺点\n\n- 前后端分离会给系统架构带来更多的复杂性。\n- 前后端分离，将引入“联调”一说（即FE与后端开发对接联调），增加沟通成本，可能导致产品迭代的速度降低。\n\n\n\n### 3 前后端分离的适用场景\n\n产品追求炫酷的前端效果，并且对前端兼容性要求较高，前端产品改版频率较高的情况，进行前后端分离是有必要的。\n\n------\n\n### 参考资料\n\n[互联网分层架构，为啥要前后端分离？](https://mp.weixin.qq.com/s/-XF_w768tSDFKKqMSxlVyQ)\n\n","slug":"Architecture-前后端分离","published":1,"updated":"2020-09-21T02:49:42.560Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabin000145g3cxf6gz6j","content":"<h3 id=\"1-为什么要进行前后端分离\"><a href=\"#1-为什么要进行前后端分离\" class=\"headerlink\" title=\"1 为什么要进行前后端分离\"></a>1 为什么要进行前后端分离</h3><p>一个典型的互联网分层架构为：<code>web-&gt;webServer-&gt;service-&gt;db</code>。随着业务的发展，原先可能只有PC端，后来需要增加Mobile、App、小程序等版本。他们的webServer层大部分业务是相同的，只有少数的逻辑/展现/交互不一样，在不进行前后端分离的情况，基本靠拷贝代码实现。</p>\n<a id=\"more\"></a>\n\n<p>这样就可能会存在一些问题：</p>\n<ul>\n<li>一旦一个服务的RPC接口有稍许变化，所有的webServer系统都需要升级修改；</li>\n<li>webServer之间存在大量代码拷贝；</li>\n<li>一旦拷贝代码，出现一个bug，多个系统都需要升级修改。</li>\n</ul>\n<h3 id=\"2-怎样进行前后端分离\"><a href=\"#2-怎样进行前后端分离\" class=\"headerlink\" title=\"2 怎样进行前后端分离\"></a>2 怎样进行前后端分离</h3><p>通过对前后端分离分层抽象：</p>\n<ul>\n<li><code>站点展示层</code>：负责数据的展现与交互，由FE维护；</li>\n<li><code>站点数据层</code>：负责处理业务逻辑与json数据接口的提供，由后端工程师维护。</li>\n</ul>\n<h4 id=\"2-1-前后端分离的好处\"><a href=\"#2-1-前后端分离的好处\" class=\"headerlink\" title=\"2.1 前后端分离的好处\"></a>2.1 前后端分离的好处</h4><ul>\n<li>复杂的业务逻辑与数据生成，只有在站点数据层处写了一次，没有代码拷贝；</li>\n<li>底层service接口发生变化，只有站点数据层一处需要升级修改；</li>\n<li>底层service如果有bug，只有站点数据层一处需要升级修改；</li>\n<li>站点展现层可以根据产品的不同形态，传入不同的参数，调用不同的站点数据层接口；</li>\n<li>关于产品展示、设备兼容性要求高，由更专业的FE对接；</li>\n<li>产品展示的改动，不在需要后端重新编译、打包、上线等操作；</li>\n<li>在约定好json接口后，前后端可以同时进行开发，FE可以自行mock数据进行自测，不用等待一起联调。</li>\n</ul>\n<h4 id=\"2-2-前后端分离的缺点\"><a href=\"#2-2-前后端分离的缺点\" class=\"headerlink\" title=\"2.2 前后端分离的缺点\"></a>2.2 前后端分离的缺点</h4><ul>\n<li>前后端分离会给系统架构带来更多的复杂性。</li>\n<li>前后端分离，将引入“联调”一说（即FE与后端开发对接联调），增加沟通成本，可能导致产品迭代的速度降低。</li>\n</ul>\n<h3 id=\"3-前后端分离的适用场景\"><a href=\"#3-前后端分离的适用场景\" class=\"headerlink\" title=\"3 前后端分离的适用场景\"></a>3 前后端分离的适用场景</h3><p>产品追求炫酷的前端效果，并且对前端兼容性要求较高，前端产品改版频率较高的情况，进行前后端分离是有必要的。</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://mp.weixin.qq.com/s/-XF_w768tSDFKKqMSxlVyQ\">互联网分层架构，为啥要前后端分离？</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-为什么要进行前后端分离\"><a href=\"#1-为什么要进行前后端分离\" class=\"headerlink\" title=\"1 为什么要进行前后端分离\"></a>1 为什么要进行前后端分离</h3><p>一个典型的互联网分层架构为：<code>web-&gt;webServer-&gt;service-&gt;db</code>。随着业务的发展，原先可能只有PC端，后来需要增加Mobile、App、小程序等版本。他们的webServer层大部分业务是相同的，只有少数的逻辑/展现/交互不一样，在不进行前后端分离的情况，基本靠拷贝代码实现。</p>","more":"<p>这样就可能会存在一些问题：</p>\n<ul>\n<li>一旦一个服务的RPC接口有稍许变化，所有的webServer系统都需要升级修改；</li>\n<li>webServer之间存在大量代码拷贝；</li>\n<li>一旦拷贝代码，出现一个bug，多个系统都需要升级修改。</li>\n</ul>\n<h3 id=\"2-怎样进行前后端分离\"><a href=\"#2-怎样进行前后端分离\" class=\"headerlink\" title=\"2 怎样进行前后端分离\"></a>2 怎样进行前后端分离</h3><p>通过对前后端分离分层抽象：</p>\n<ul>\n<li><code>站点展示层</code>：负责数据的展现与交互，由FE维护；</li>\n<li><code>站点数据层</code>：负责处理业务逻辑与json数据接口的提供，由后端工程师维护。</li>\n</ul>\n<h4 id=\"2-1-前后端分离的好处\"><a href=\"#2-1-前后端分离的好处\" class=\"headerlink\" title=\"2.1 前后端分离的好处\"></a>2.1 前后端分离的好处</h4><ul>\n<li>复杂的业务逻辑与数据生成，只有在站点数据层处写了一次，没有代码拷贝；</li>\n<li>底层service接口发生变化，只有站点数据层一处需要升级修改；</li>\n<li>底层service如果有bug，只有站点数据层一处需要升级修改；</li>\n<li>站点展现层可以根据产品的不同形态，传入不同的参数，调用不同的站点数据层接口；</li>\n<li>关于产品展示、设备兼容性要求高，由更专业的FE对接；</li>\n<li>产品展示的改动，不在需要后端重新编译、打包、上线等操作；</li>\n<li>在约定好json接口后，前后端可以同时进行开发，FE可以自行mock数据进行自测，不用等待一起联调。</li>\n</ul>\n<h4 id=\"2-2-前后端分离的缺点\"><a href=\"#2-2-前后端分离的缺点\" class=\"headerlink\" title=\"2.2 前后端分离的缺点\"></a>2.2 前后端分离的缺点</h4><ul>\n<li>前后端分离会给系统架构带来更多的复杂性。</li>\n<li>前后端分离，将引入“联调”一说（即FE与后端开发对接联调），增加沟通成本，可能导致产品迭代的速度降低。</li>\n</ul>\n<h3 id=\"3-前后端分离的适用场景\"><a href=\"#3-前后端分离的适用场景\" class=\"headerlink\" title=\"3 前后端分离的适用场景\"></a>3 前后端分离的适用场景</h3><p>产品追求炫酷的前端效果，并且对前端兼容性要求较高，前端产品改版频率较高的情况，进行前后端分离是有必要的。</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://mp.weixin.qq.com/s/-XF_w768tSDFKKqMSxlVyQ\">互联网分层架构，为啥要前后端分离？</a></p>"},{"title":"Architecture-既然有HTTP请求，为何要用RPC调用","date":"2020-09-23T08:56:17.000Z","_content":"\n### 1 引言\n\n之前在一次面试中，面试官提到服务之间的调用，为什么要选择RPC？HTTP也能实现服务之间的通信，为什么不使用HTTP呢？或者说RPC比Http好在哪里？\n\n<!--more-->\n\n### 2 RPC\n\n#### 2.1 什么是RPC？\n\nRPC(Remote Procedure Call，远程过程调用)，是指计算机程序在不同的地址空间执行时，其编码方式与本地过程调用类似，无需显式编码远程交互的详细信息[*参考资料3*]。\n<u>RPC只是一种概念、一种设计，用于解决不同服务之间的调用问题</u>，通常包含传输协议（*可以直接建立在TCP之上，也可以建立在HTTP协议之上*）和序列化协议这两个。\n\n#### 2.2 RPC解决的问题\n\nRPC主要解决的问题是：让分布式或微服务系统中不同服务之间的调用向本地调用一样简单[*参考资料2*]。\n\n#### 2.3 RPC的基本流程\n\n**RPC的基本流程图**如下：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/RPC基本流程.png\" alt=\"RPC基本流程\" style=\"zoom:80%;\" />\n\n一次完整的RPC调用流程如下：\n\n- 1）client调用以本地调用方式调用服务； \n- 2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； \n- 3）client stub找到服务地址，并将消息发送到服务端； \n- 4）server stub收到消息后进行解码；\n- 5）server stub根据解码结果调用本地的服务；\n- 6）本地服务执行并将结果返回给server stub； \n- 7）server stub将返回结果打包成消息并发送至消费方； \n- 8）client stub接收到消息，并进行解码；\n- 9）服务消费方得到最终结果。 \n\n<u>RPC框架的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</u>\n　　\n**时序图如**下：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/RPC调用时序图.png\" alt=\"RPC调用时序图\" style=\"zoom:80%;\" />\n\n#### 2.4 服务注册&发现\n\n​    ![服务注册-发现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/服务注册-发现.png)\n\n- Server：暴露服务的服务提供方。\n- Client：调用远程服务的服务消费方。\n- Register：服务注册与发现的注册中心。\n\n\n\n服务提供者启动后想注册中心注册机器IP、Port以及提供服务列表；\n\n服务消费者启动时向注册中心获取服务提供方提供地址列表，可实现软负载均衡以及故障转移、\n\n\n\n### 3 HTTP\n\n#### 3.1 什么是HTTP？\n\nHTTP（Hypertext Transfer Protocol，超文本传输协议）是一种应用协议，用于分布式、协作、超媒体信息系统。\n\n\n\n### 4 RPC和HTTP的关系是什么\n\n**RPC是一种概念，HTTP是RPC实现的一种方式，至于为什么要这么用，因为业务场景不同。**\n\n- 对于HTTP：为应用层提供服务，需要支持web网页或其他请求的各种诉求，本身数据报文包含的内容较多，有很多的头信息。\n\n- 对于RPC：可直接使用TCP、UDP等协议，在提供服务上更简洁，报文更小，性能更快，可专注于提高远程服务调用。\n\n\n\n### 5 对于微服务使用RPC调用的好处\n\n- 调用简单，真正提供了类似于调用本地方方法一样调用接口的功能。\n- 参数返回值简单明了，自定义返回结果，无需二次解析。\n- 轻量，没有多余的信息\n- 便于管理，基于注册中心。\n- 解耦，通过RPC解耦服务，\n\n------\n\n参考资料：\n\n[微服务调用为啥用RPC框架，Http不更简单吗？](https://developer.51cto.com/art/201904/595840.htm)\n[服务之间的调用 HTTP代替RPC？](http://blog.itpub.net/31559985/viewspace-2676573/)\n[Remote procedure call](https://en.wikipedia.org/wiki/Remote_procedure_call)\n[RPC框架面试总结-RPC原理及实现](http://www.360doc.com/content/18/1116/23/99071_795390393.shtml)\n[Hypertext Transfer Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)","source":"_posts/Architecture-既然有HTTP请求，为何要用RPC调用.md","raw":"---\ntitle: Architecture-既然有HTTP请求，为何要用RPC调用\ndate: 2020-09-23 16:56:17\ntags:\n  - Architecture\n  - RPC\n  - Interview\ncategories:\n  - Architecture\n---\n\n### 1 引言\n\n之前在一次面试中，面试官提到服务之间的调用，为什么要选择RPC？HTTP也能实现服务之间的通信，为什么不使用HTTP呢？或者说RPC比Http好在哪里？\n\n<!--more-->\n\n### 2 RPC\n\n#### 2.1 什么是RPC？\n\nRPC(Remote Procedure Call，远程过程调用)，是指计算机程序在不同的地址空间执行时，其编码方式与本地过程调用类似，无需显式编码远程交互的详细信息[*参考资料3*]。\n<u>RPC只是一种概念、一种设计，用于解决不同服务之间的调用问题</u>，通常包含传输协议（*可以直接建立在TCP之上，也可以建立在HTTP协议之上*）和序列化协议这两个。\n\n#### 2.2 RPC解决的问题\n\nRPC主要解决的问题是：让分布式或微服务系统中不同服务之间的调用向本地调用一样简单[*参考资料2*]。\n\n#### 2.3 RPC的基本流程\n\n**RPC的基本流程图**如下：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/RPC基本流程.png\" alt=\"RPC基本流程\" style=\"zoom:80%;\" />\n\n一次完整的RPC调用流程如下：\n\n- 1）client调用以本地调用方式调用服务； \n- 2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； \n- 3）client stub找到服务地址，并将消息发送到服务端； \n- 4）server stub收到消息后进行解码；\n- 5）server stub根据解码结果调用本地的服务；\n- 6）本地服务执行并将结果返回给server stub； \n- 7）server stub将返回结果打包成消息并发送至消费方； \n- 8）client stub接收到消息，并进行解码；\n- 9）服务消费方得到最终结果。 \n\n<u>RPC框架的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</u>\n　　\n**时序图如**下：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/RPC调用时序图.png\" alt=\"RPC调用时序图\" style=\"zoom:80%;\" />\n\n#### 2.4 服务注册&发现\n\n​    ![服务注册-发现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/服务注册-发现.png)\n\n- Server：暴露服务的服务提供方。\n- Client：调用远程服务的服务消费方。\n- Register：服务注册与发现的注册中心。\n\n\n\n服务提供者启动后想注册中心注册机器IP、Port以及提供服务列表；\n\n服务消费者启动时向注册中心获取服务提供方提供地址列表，可实现软负载均衡以及故障转移、\n\n\n\n### 3 HTTP\n\n#### 3.1 什么是HTTP？\n\nHTTP（Hypertext Transfer Protocol，超文本传输协议）是一种应用协议，用于分布式、协作、超媒体信息系统。\n\n\n\n### 4 RPC和HTTP的关系是什么\n\n**RPC是一种概念，HTTP是RPC实现的一种方式，至于为什么要这么用，因为业务场景不同。**\n\n- 对于HTTP：为应用层提供服务，需要支持web网页或其他请求的各种诉求，本身数据报文包含的内容较多，有很多的头信息。\n\n- 对于RPC：可直接使用TCP、UDP等协议，在提供服务上更简洁，报文更小，性能更快，可专注于提高远程服务调用。\n\n\n\n### 5 对于微服务使用RPC调用的好处\n\n- 调用简单，真正提供了类似于调用本地方方法一样调用接口的功能。\n- 参数返回值简单明了，自定义返回结果，无需二次解析。\n- 轻量，没有多余的信息\n- 便于管理，基于注册中心。\n- 解耦，通过RPC解耦服务，\n\n------\n\n参考资料：\n\n[微服务调用为啥用RPC框架，Http不更简单吗？](https://developer.51cto.com/art/201904/595840.htm)\n[服务之间的调用 HTTP代替RPC？](http://blog.itpub.net/31559985/viewspace-2676573/)\n[Remote procedure call](https://en.wikipedia.org/wiki/Remote_procedure_call)\n[RPC框架面试总结-RPC原理及实现](http://www.360doc.com/content/18/1116/23/99071_795390393.shtml)\n[Hypertext Transfer Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)","slug":"Architecture-既然有HTTP请求，为何要用RPC调用","published":1,"updated":"2020-09-23T10:00:13.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabir000345g3a7vo2uxg","content":"<h3 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h3><p>之前在一次面试中，面试官提到服务之间的调用，为什么要选择RPC？HTTP也能实现服务之间的通信，为什么不使用HTTP呢？或者说RPC比Http好在哪里？</p>\n<a id=\"more\"></a>\n\n<h3 id=\"2-RPC\"><a href=\"#2-RPC\" class=\"headerlink\" title=\"2 RPC\"></a>2 RPC</h3><h4 id=\"2-1-什么是RPC？\"><a href=\"#2-1-什么是RPC？\" class=\"headerlink\" title=\"2.1 什么是RPC？\"></a>2.1 什么是RPC？</h4><p>RPC(Remote Procedure Call，远程过程调用)，是指计算机程序在不同的地址空间执行时，其编码方式与本地过程调用类似，无需显式编码远程交互的详细信息[<em>参考资料3</em>]。<br><u>RPC只是一种概念、一种设计，用于解决不同服务之间的调用问题</u>，通常包含传输协议（<em>可以直接建立在TCP之上，也可以建立在HTTP协议之上</em>）和序列化协议这两个。</p>\n<h4 id=\"2-2-RPC解决的问题\"><a href=\"#2-2-RPC解决的问题\" class=\"headerlink\" title=\"2.2 RPC解决的问题\"></a>2.2 RPC解决的问题</h4><p>RPC主要解决的问题是：让分布式或微服务系统中不同服务之间的调用向本地调用一样简单[<em>参考资料2</em>]。</p>\n<h4 id=\"2-3-RPC的基本流程\"><a href=\"#2-3-RPC的基本流程\" class=\"headerlink\" title=\"2.3 RPC的基本流程\"></a>2.3 RPC的基本流程</h4><p><strong>RPC的基本流程图</strong>如下：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/RPC基本流程.png\" alt=\"RPC基本流程\" style=\"zoom:80%;\" />\n\n<p>一次完整的RPC调用流程如下：</p>\n<ul>\n<li>1）client调用以本地调用方式调用服务； </li>\n<li>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </li>\n<li>3）client stub找到服务地址，并将消息发送到服务端； </li>\n<li>4）server stub收到消息后进行解码；</li>\n<li>5）server stub根据解码结果调用本地的服务；</li>\n<li>6）本地服务执行并将结果返回给server stub； </li>\n<li>7）server stub将返回结果打包成消息并发送至消费方； </li>\n<li>8）client stub接收到消息，并进行解码；</li>\n<li>9）服务消费方得到最终结果。 </li>\n</ul>\n<p><u>RPC框架的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</u><br>　　<br><strong>时序图如</strong>下：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/RPC调用时序图.png\" alt=\"RPC调用时序图\" style=\"zoom:80%;\" />\n\n<h4 id=\"2-4-服务注册-amp-发现\"><a href=\"#2-4-服务注册-amp-发现\" class=\"headerlink\" title=\"2.4 服务注册&amp;发现\"></a>2.4 服务注册&amp;发现</h4><p>​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-%E5%8F%91%E7%8E%B0.png\" alt=\"服务注册-发现\"></p>\n<ul>\n<li>Server：暴露服务的服务提供方。</li>\n<li>Client：调用远程服务的服务消费方。</li>\n<li>Register：服务注册与发现的注册中心。</li>\n</ul>\n<p>服务提供者启动后想注册中心注册机器IP、Port以及提供服务列表；</p>\n<p>服务消费者启动时向注册中心获取服务提供方提供地址列表，可实现软负载均衡以及故障转移、</p>\n<h3 id=\"3-HTTP\"><a href=\"#3-HTTP\" class=\"headerlink\" title=\"3 HTTP\"></a>3 HTTP</h3><h4 id=\"3-1-什么是HTTP？\"><a href=\"#3-1-什么是HTTP？\" class=\"headerlink\" title=\"3.1 什么是HTTP？\"></a>3.1 什么是HTTP？</h4><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是一种应用协议，用于分布式、协作、超媒体信息系统。</p>\n<h3 id=\"4-RPC和HTTP的关系是什么\"><a href=\"#4-RPC和HTTP的关系是什么\" class=\"headerlink\" title=\"4 RPC和HTTP的关系是什么\"></a>4 RPC和HTTP的关系是什么</h3><p><strong>RPC是一种概念，HTTP是RPC实现的一种方式，至于为什么要这么用，因为业务场景不同。</strong></p>\n<ul>\n<li><p>对于HTTP：为应用层提供服务，需要支持web网页或其他请求的各种诉求，本身数据报文包含的内容较多，有很多的头信息。</p>\n</li>\n<li><p>对于RPC：可直接使用TCP、UDP等协议，在提供服务上更简洁，报文更小，性能更快，可专注于提高远程服务调用。</p>\n</li>\n</ul>\n<h3 id=\"5-对于微服务使用RPC调用的好处\"><a href=\"#5-对于微服务使用RPC调用的好处\" class=\"headerlink\" title=\"5 对于微服务使用RPC调用的好处\"></a>5 对于微服务使用RPC调用的好处</h3><ul>\n<li>调用简单，真正提供了类似于调用本地方方法一样调用接口的功能。</li>\n<li>参数返回值简单明了，自定义返回结果，无需二次解析。</li>\n<li>轻量，没有多余的信息</li>\n<li>便于管理，基于注册中心。</li>\n<li>解耦，通过RPC解耦服务，</li>\n</ul>\n<hr>\n<p>参考资料：</p>\n<p><a href=\"https://developer.51cto.com/art/201904/595840.htm\">微服务调用为啥用RPC框架，Http不更简单吗？</a><br><a href=\"http://blog.itpub.net/31559985/viewspace-2676573/\">服务之间的调用 HTTP代替RPC？</a><br><a href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\">Remote procedure call</a><br><a href=\"http://www.360doc.com/content/18/1116/23/99071_795390393.shtml\">RPC框架面试总结-RPC原理及实现</a><br><a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol\">Hypertext Transfer Protocol</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h3><p>之前在一次面试中，面试官提到服务之间的调用，为什么要选择RPC？HTTP也能实现服务之间的通信，为什么不使用HTTP呢？或者说RPC比Http好在哪里？</p>","more":"<h3 id=\"2-RPC\"><a href=\"#2-RPC\" class=\"headerlink\" title=\"2 RPC\"></a>2 RPC</h3><h4 id=\"2-1-什么是RPC？\"><a href=\"#2-1-什么是RPC？\" class=\"headerlink\" title=\"2.1 什么是RPC？\"></a>2.1 什么是RPC？</h4><p>RPC(Remote Procedure Call，远程过程调用)，是指计算机程序在不同的地址空间执行时，其编码方式与本地过程调用类似，无需显式编码远程交互的详细信息[<em>参考资料3</em>]。<br><u>RPC只是一种概念、一种设计，用于解决不同服务之间的调用问题</u>，通常包含传输协议（<em>可以直接建立在TCP之上，也可以建立在HTTP协议之上</em>）和序列化协议这两个。</p>\n<h4 id=\"2-2-RPC解决的问题\"><a href=\"#2-2-RPC解决的问题\" class=\"headerlink\" title=\"2.2 RPC解决的问题\"></a>2.2 RPC解决的问题</h4><p>RPC主要解决的问题是：让分布式或微服务系统中不同服务之间的调用向本地调用一样简单[<em>参考资料2</em>]。</p>\n<h4 id=\"2-3-RPC的基本流程\"><a href=\"#2-3-RPC的基本流程\" class=\"headerlink\" title=\"2.3 RPC的基本流程\"></a>2.3 RPC的基本流程</h4><p><strong>RPC的基本流程图</strong>如下：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/RPC基本流程.png\" alt=\"RPC基本流程\" style=\"zoom:80%;\" />\n\n<p>一次完整的RPC调用流程如下：</p>\n<ul>\n<li>1）client调用以本地调用方式调用服务； </li>\n<li>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </li>\n<li>3）client stub找到服务地址，并将消息发送到服务端； </li>\n<li>4）server stub收到消息后进行解码；</li>\n<li>5）server stub根据解码结果调用本地的服务；</li>\n<li>6）本地服务执行并将结果返回给server stub； </li>\n<li>7）server stub将返回结果打包成消息并发送至消费方； </li>\n<li>8）client stub接收到消息，并进行解码；</li>\n<li>9）服务消费方得到最终结果。 </li>\n</ul>\n<p><u>RPC框架的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</u><br>　　<br><strong>时序图如</strong>下：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/RPC调用时序图.png\" alt=\"RPC调用时序图\" style=\"zoom:80%;\" />\n\n<h4 id=\"2-4-服务注册-amp-发现\"><a href=\"#2-4-服务注册-amp-发现\" class=\"headerlink\" title=\"2.4 服务注册&amp;发现\"></a>2.4 服务注册&amp;发现</h4><p>​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Architecture/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-%E5%8F%91%E7%8E%B0.png\" alt=\"服务注册-发现\"></p>\n<ul>\n<li>Server：暴露服务的服务提供方。</li>\n<li>Client：调用远程服务的服务消费方。</li>\n<li>Register：服务注册与发现的注册中心。</li>\n</ul>\n<p>服务提供者启动后想注册中心注册机器IP、Port以及提供服务列表；</p>\n<p>服务消费者启动时向注册中心获取服务提供方提供地址列表，可实现软负载均衡以及故障转移、</p>\n<h3 id=\"3-HTTP\"><a href=\"#3-HTTP\" class=\"headerlink\" title=\"3 HTTP\"></a>3 HTTP</h3><h4 id=\"3-1-什么是HTTP？\"><a href=\"#3-1-什么是HTTP？\" class=\"headerlink\" title=\"3.1 什么是HTTP？\"></a>3.1 什么是HTTP？</h4><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是一种应用协议，用于分布式、协作、超媒体信息系统。</p>\n<h3 id=\"4-RPC和HTTP的关系是什么\"><a href=\"#4-RPC和HTTP的关系是什么\" class=\"headerlink\" title=\"4 RPC和HTTP的关系是什么\"></a>4 RPC和HTTP的关系是什么</h3><p><strong>RPC是一种概念，HTTP是RPC实现的一种方式，至于为什么要这么用，因为业务场景不同。</strong></p>\n<ul>\n<li><p>对于HTTP：为应用层提供服务，需要支持web网页或其他请求的各种诉求，本身数据报文包含的内容较多，有很多的头信息。</p>\n</li>\n<li><p>对于RPC：可直接使用TCP、UDP等协议，在提供服务上更简洁，报文更小，性能更快，可专注于提高远程服务调用。</p>\n</li>\n</ul>\n<h3 id=\"5-对于微服务使用RPC调用的好处\"><a href=\"#5-对于微服务使用RPC调用的好处\" class=\"headerlink\" title=\"5 对于微服务使用RPC调用的好处\"></a>5 对于微服务使用RPC调用的好处</h3><ul>\n<li>调用简单，真正提供了类似于调用本地方方法一样调用接口的功能。</li>\n<li>参数返回值简单明了，自定义返回结果，无需二次解析。</li>\n<li>轻量，没有多余的信息</li>\n<li>便于管理，基于注册中心。</li>\n<li>解耦，通过RPC解耦服务，</li>\n</ul>\n<hr>\n<p>参考资料：</p>\n<p><a href=\"https://developer.51cto.com/art/201904/595840.htm\">微服务调用为啥用RPC框架，Http不更简单吗？</a><br><a href=\"http://blog.itpub.net/31559985/viewspace-2676573/\">服务之间的调用 HTTP代替RPC？</a><br><a href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\">Remote procedure call</a><br><a href=\"http://www.360doc.com/content/18/1116/23/99071_795390393.shtml\">RPC框架面试总结-RPC原理及实现</a><br><a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol\">Hypertext Transfer Protocol</a></p>"},{"title":"DesignPattern-Factory(工厂模式)","date":"2020-09-21T09:54:27.000Z","_content":"\n### 1 概述\n\n当使用＂`new`＂实例化一个具体类，将会导致代码更加脆弱，缺乏弹性．例如：当有很多相关的具体类时（如下代码所示），究竟要实例化哪个类，要在运行时由一些条件来决定．一旦有变化扩者扩展，就需要重新对这段代码进行检查和修改．可能造成部分系统维护和更新的困扰，也容易出错．\n\n<!--more-->\n\n```java\nDuck duck;\n\nif (picnic) {\n\tduck = new MallardDuck();\n} else if (hunting) {\n\tduck = new DecoyDuck();\n} else if(inBathTub) {\n\tduck = new RubberDuck();\n}\n```\n\n\n\n那么如何将实例化具体类的代码从应用总抽离，或者封装起来，使他们不会干扰应用的其他部分呢？\n\n- 识别变化的方面．\n- 封装创建对象的代码（该对象即为＂Factory，工厂＂）．\n\n\n\n### 2 Factory（工厂模式）\n\n根据应用场景和复杂度的不同，工厂模式可以分为以下三种：\n\n- 简单工厂模式；\n- 工厂方法模式；\n- 抽象工厂模式；\n\n\n\n#### 2.1 简单工厂模式\n\n简单工厂模式，准确点来说，并不算是一种设计模式，反而比较像一种编程习惯．\n\n实现方法：<u>新建一个工厂类，在工厂类内定义一个实例化各种对象的方法，将识别出来变化的部分移植到该方法中．</u>\n\n\n\n简单工厂模式看似只是把问题搬到一个对象中了，并没有进行实际的解决，`这样做的好处是什么`？\n\n- 将变化部分的代码封装起来，后续有改变时，只需要改动这一个类，避免对其他逻辑的影响．\n- 可以有多个调用方\n\n\n\nPHP示例：\n\n```php\n// 具体商品，白猫\nclass WhiteCat{\n    function voice() {\n        echo \"白猫喵喵..\";\n    }\n}\n\n// 具体商品，黑猫\nclass BlackCat{\n    function voice() {\n        echo \"黑猫喵喵..\";\n    }\n}\n\n// 工厂类，用于生产商品\nclass factory {\n    // 可以通过一个静态方法，通过参数来区分要实例化的类．\n    public static function create($color) {\n        switch ($color) {\n            case 'white':\n                return new WhiteCat();\n                break;\n            case 'black':\n                return new BlackCat();\n                break;\n        }\n    }\n}\n\n// 模拟客户端\nclass Client{\n    public static function main(){\n        $wCat = factory::create('white');\n        $wCat->voice();\n        $bCat = factory::create('black');\n        $bCat->voice();\n    }\n}\n\nClient::main();\n```\n\n\n\n#### 2.2 工厂方法模式（Factory Method Pattern）\n\n`工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个．工厂方法让类的实例化推迟到子类．`\n\n\n\n实现方法：<u>通过在抽象类（Creator）中定义抽象的工厂方法（factoryMethod），让其子类（ConcreteCreator）实现此方法以创建实例．（抽象类中通常会包含依赖子类实现的工厂方法，但无须知道是在创建哪种具体的对象．）</u>\n\n（注：Creator类并不是必须为抽象的，可实现其工厂方法作为默认方法，子类若有变化，则重写该方法）\n\n\n\n其类图如下：\n\n![FactoryMethodPattern](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/FactoryMethodPattern.png)\n\n\n\nPHP示例：\n\n```php\n// 商品基类\nabstract class Cat{\n    abstract protected function voice();\n}\n\n// 具体商品WhiteCat\nclass WhiteCat extends Cat{\n    function voice() {\n        echo \"白猫喵喵..\";\n    }\n}\n\n// 具体商品BlackCat\nclass BlackCat extends Cat{\n    function voice() {\n        echo \"黑猫喵喵..\";\n    }\n}\n\n// 工厂接口，用于实例化\ninterface factory{\n    // static主要是为了不实例子工厂类，直接调用create方法\n    public static function create();\n}\n\n// 白猫工厂，用于实例化白猫\nclass WhiteCatFactory implements factory{\n    public static function create() {\n        return new WhiteCat();\n    }\n}\n\n// 黑猫工厂，用于实例化黑猫\nclass BlackCatFactory implements factory{\n    public static function create() {\n        return new BlackCat();\n    }\n}\n\nclass Client{\n    public static function main(){\n        $wCat = WhiteCatFactory::create();\n        $wCat->voice();\n        $bCat = BlackCatFactory::create();\n        $bCat->voice();\n    }\n}\n\nClient::main();\n```\n\n\n\n\n\n`简单工厂和工厂方法之间的区别？`\n\n- 简单工厂将所有的逻辑，在一个地方处理完；它不具有工厂方法的弹性，因为简单工厂不能变更正在创建的对象．\n- 工厂方法是创建一个框架，让子类决定如何实现．\n\n\n\n`工厂方法的优点：`\n\n- 将创建对象的代码集中在一个对象或者方法中，可以避免代码的重复，并且更方便以后的维护．\n- 实例化对象时，只会依赖于接口，而不是具体类．使代码更具有弹性，方便未来扩展．\n\n\n\n#### 2.3 抽象工厂模式\n\n`抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类．`\n\n`实现方法`：\n\n- 抽象工厂定义了一个接口．所有的具体工厂都必须实现此接口，这个接口包含一组方法用来生产产品．\n- 所有具体工厂实现不同的产品家族．要创建一个产品，客户只要使用其中一个工厂而完全不需要实例化任何产品对象．\n\n\n\n其类图如下：\n\n![AbstractFactory](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AbstractFactory.png)\n\n\n\nPHP示例：\n\n```php\n// 商品基类，猫\nabstract class Cat{\n    abstract protected function voice();\n}\n\n// 具体商品WhiteCat\nclass WhiteCat extends Cat{\n    function voice() {\n        echo \"白猫喵喵..\";\n    }\n}\n\n// 具体商品BlackCat\nclass BlackCat extends Cat{\n    function voice() {\n        echo \"黑猫喵喵..\";\n    }\n}\n\n// 商品基类，狗\nabstract class Dog{\n    abstract protected function voice();\n}\n\n// 具体商品WhiteDog\nclass WhiteDog extends Dog{\n    function voice() {\n        echo \"白狗汪汪..\";\n    }\n}\n\n// 具体商品BlackDog\nclass BlackDog extends Dog{\n    function voice() {\n        echo \"黑狗汪汪..\";\n    }\n}\n\n// 工厂接口，用于实例化,提供一组商品．\ninterface factory{\n    public function createCat();\n    public function createDog();\n}\n\n// 白色动物工厂，用于实例化白猫，白狗\nclass WhiteAnimalFactory implements factory{\n    public function createCat() {\n        return new WhiteCat();\n    }\n    public function createDog() {\n        return new WhiteDog();\n    }\n}\n\n// 黑色动物工厂，用于实例化黑猫，黑狗\nclass BlackAnimalFactory implements factory{\n    public function createCat() {\n        return new BlackCat();\n    }\n    public function createDog() {\n        return new BlackDog();\n    }\n}\n\nclass Client{\n    public static function main() {  \n        self::run(new WhiteAnimalFactory());  \n        self::run(new BlackAnimalFactory());  \n    }  \n\n    public static function run(factory $AnimalFactory){  \n        $cat = $AnimalFactory->createCat();  \n        $cat->Voice();  \n\n        $dog = $AnimalFactory->createDog();  \n        $dog->Voice();  \n    }\n}\n\nClient::main();\n```\n\n\n\n`抽象工厂模式的优点`：\n\n- 将一群相关的产品集合起来．\n\n\n\n`抽象工厂模式的缺点`：\n\n- 扩展相关接口较难，例如新增一个接口．这就意味着需要深入改变每个子类的接口．\n\n\n\n### 3 工厂方法与抽象工厂的比较\n\n**关联点**：\n\n- `抽象工厂的方法经常以工厂方法的方式实现`．抽象工厂的任务是定义一个负责创建一组产品的接口．这个接口内的每个方法都则创建一个具体的产品，同时利用实现抽象工厂的子类类提供这些具体的做法．\n\n\n\n**相同点**：\n\n- 工厂方法和抽象方法都能将对象的创建封装起来，使应用程序解偶，降低其对特定实现的依赖．\n\n\n\n**不同点**：\n\n| 功能                               | 工厂方法               | 抽象工厂                                                     |\n| ---------------------------------- | ---------------------- | ------------------------------------------------------------ |\n| 创建对象的方法                     | 继承                   | 对象的组合                                                   |\n| 解偶方式（将客户从具体类型中解偶） | 通过子类来创建具体对象 | 提供一个用来创建产品家族的抽象类型，这个类型的子类定义了产品被生产的方法．要使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中． |\n\n\n\n### 4 总结\n\n- 所有的工厂都是用来封装对象的创建．通过减少应用程序和具体类之间的依赖促进松耦合．\n- 简单工厂，虽然不是真正的设计模式，但它是一种简单的可以将客户程序从具体类中解偶的方法．\n- 工厂方法通过使用继承，允许类将实例化延迟到子类，由子类实现工厂方法来创建对象．\n- 抽象工厂使用对象组合，对象的创建被是现在工厂接口所暴露出来的方法中．\n\n\n\n------\n\n### 参考资料：\n\nHead First设计模式 第五章（P109）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/DesignPattern-Factory.md","raw":"---\ntitle: DesignPattern-Factory(工厂模式)\ntags: [\"DesignPattern\",\"Factory\"]\ncategories: [\"DesignPattern\"]\ndate: 2020-09-21 17:54:27\n---\n\n### 1 概述\n\n当使用＂`new`＂实例化一个具体类，将会导致代码更加脆弱，缺乏弹性．例如：当有很多相关的具体类时（如下代码所示），究竟要实例化哪个类，要在运行时由一些条件来决定．一旦有变化扩者扩展，就需要重新对这段代码进行检查和修改．可能造成部分系统维护和更新的困扰，也容易出错．\n\n<!--more-->\n\n```java\nDuck duck;\n\nif (picnic) {\n\tduck = new MallardDuck();\n} else if (hunting) {\n\tduck = new DecoyDuck();\n} else if(inBathTub) {\n\tduck = new RubberDuck();\n}\n```\n\n\n\n那么如何将实例化具体类的代码从应用总抽离，或者封装起来，使他们不会干扰应用的其他部分呢？\n\n- 识别变化的方面．\n- 封装创建对象的代码（该对象即为＂Factory，工厂＂）．\n\n\n\n### 2 Factory（工厂模式）\n\n根据应用场景和复杂度的不同，工厂模式可以分为以下三种：\n\n- 简单工厂模式；\n- 工厂方法模式；\n- 抽象工厂模式；\n\n\n\n#### 2.1 简单工厂模式\n\n简单工厂模式，准确点来说，并不算是一种设计模式，反而比较像一种编程习惯．\n\n实现方法：<u>新建一个工厂类，在工厂类内定义一个实例化各种对象的方法，将识别出来变化的部分移植到该方法中．</u>\n\n\n\n简单工厂模式看似只是把问题搬到一个对象中了，并没有进行实际的解决，`这样做的好处是什么`？\n\n- 将变化部分的代码封装起来，后续有改变时，只需要改动这一个类，避免对其他逻辑的影响．\n- 可以有多个调用方\n\n\n\nPHP示例：\n\n```php\n// 具体商品，白猫\nclass WhiteCat{\n    function voice() {\n        echo \"白猫喵喵..\";\n    }\n}\n\n// 具体商品，黑猫\nclass BlackCat{\n    function voice() {\n        echo \"黑猫喵喵..\";\n    }\n}\n\n// 工厂类，用于生产商品\nclass factory {\n    // 可以通过一个静态方法，通过参数来区分要实例化的类．\n    public static function create($color) {\n        switch ($color) {\n            case 'white':\n                return new WhiteCat();\n                break;\n            case 'black':\n                return new BlackCat();\n                break;\n        }\n    }\n}\n\n// 模拟客户端\nclass Client{\n    public static function main(){\n        $wCat = factory::create('white');\n        $wCat->voice();\n        $bCat = factory::create('black');\n        $bCat->voice();\n    }\n}\n\nClient::main();\n```\n\n\n\n#### 2.2 工厂方法模式（Factory Method Pattern）\n\n`工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个．工厂方法让类的实例化推迟到子类．`\n\n\n\n实现方法：<u>通过在抽象类（Creator）中定义抽象的工厂方法（factoryMethod），让其子类（ConcreteCreator）实现此方法以创建实例．（抽象类中通常会包含依赖子类实现的工厂方法，但无须知道是在创建哪种具体的对象．）</u>\n\n（注：Creator类并不是必须为抽象的，可实现其工厂方法作为默认方法，子类若有变化，则重写该方法）\n\n\n\n其类图如下：\n\n![FactoryMethodPattern](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/FactoryMethodPattern.png)\n\n\n\nPHP示例：\n\n```php\n// 商品基类\nabstract class Cat{\n    abstract protected function voice();\n}\n\n// 具体商品WhiteCat\nclass WhiteCat extends Cat{\n    function voice() {\n        echo \"白猫喵喵..\";\n    }\n}\n\n// 具体商品BlackCat\nclass BlackCat extends Cat{\n    function voice() {\n        echo \"黑猫喵喵..\";\n    }\n}\n\n// 工厂接口，用于实例化\ninterface factory{\n    // static主要是为了不实例子工厂类，直接调用create方法\n    public static function create();\n}\n\n// 白猫工厂，用于实例化白猫\nclass WhiteCatFactory implements factory{\n    public static function create() {\n        return new WhiteCat();\n    }\n}\n\n// 黑猫工厂，用于实例化黑猫\nclass BlackCatFactory implements factory{\n    public static function create() {\n        return new BlackCat();\n    }\n}\n\nclass Client{\n    public static function main(){\n        $wCat = WhiteCatFactory::create();\n        $wCat->voice();\n        $bCat = BlackCatFactory::create();\n        $bCat->voice();\n    }\n}\n\nClient::main();\n```\n\n\n\n\n\n`简单工厂和工厂方法之间的区别？`\n\n- 简单工厂将所有的逻辑，在一个地方处理完；它不具有工厂方法的弹性，因为简单工厂不能变更正在创建的对象．\n- 工厂方法是创建一个框架，让子类决定如何实现．\n\n\n\n`工厂方法的优点：`\n\n- 将创建对象的代码集中在一个对象或者方法中，可以避免代码的重复，并且更方便以后的维护．\n- 实例化对象时，只会依赖于接口，而不是具体类．使代码更具有弹性，方便未来扩展．\n\n\n\n#### 2.3 抽象工厂模式\n\n`抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类．`\n\n`实现方法`：\n\n- 抽象工厂定义了一个接口．所有的具体工厂都必须实现此接口，这个接口包含一组方法用来生产产品．\n- 所有具体工厂实现不同的产品家族．要创建一个产品，客户只要使用其中一个工厂而完全不需要实例化任何产品对象．\n\n\n\n其类图如下：\n\n![AbstractFactory](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AbstractFactory.png)\n\n\n\nPHP示例：\n\n```php\n// 商品基类，猫\nabstract class Cat{\n    abstract protected function voice();\n}\n\n// 具体商品WhiteCat\nclass WhiteCat extends Cat{\n    function voice() {\n        echo \"白猫喵喵..\";\n    }\n}\n\n// 具体商品BlackCat\nclass BlackCat extends Cat{\n    function voice() {\n        echo \"黑猫喵喵..\";\n    }\n}\n\n// 商品基类，狗\nabstract class Dog{\n    abstract protected function voice();\n}\n\n// 具体商品WhiteDog\nclass WhiteDog extends Dog{\n    function voice() {\n        echo \"白狗汪汪..\";\n    }\n}\n\n// 具体商品BlackDog\nclass BlackDog extends Dog{\n    function voice() {\n        echo \"黑狗汪汪..\";\n    }\n}\n\n// 工厂接口，用于实例化,提供一组商品．\ninterface factory{\n    public function createCat();\n    public function createDog();\n}\n\n// 白色动物工厂，用于实例化白猫，白狗\nclass WhiteAnimalFactory implements factory{\n    public function createCat() {\n        return new WhiteCat();\n    }\n    public function createDog() {\n        return new WhiteDog();\n    }\n}\n\n// 黑色动物工厂，用于实例化黑猫，黑狗\nclass BlackAnimalFactory implements factory{\n    public function createCat() {\n        return new BlackCat();\n    }\n    public function createDog() {\n        return new BlackDog();\n    }\n}\n\nclass Client{\n    public static function main() {  \n        self::run(new WhiteAnimalFactory());  \n        self::run(new BlackAnimalFactory());  \n    }  \n\n    public static function run(factory $AnimalFactory){  \n        $cat = $AnimalFactory->createCat();  \n        $cat->Voice();  \n\n        $dog = $AnimalFactory->createDog();  \n        $dog->Voice();  \n    }\n}\n\nClient::main();\n```\n\n\n\n`抽象工厂模式的优点`：\n\n- 将一群相关的产品集合起来．\n\n\n\n`抽象工厂模式的缺点`：\n\n- 扩展相关接口较难，例如新增一个接口．这就意味着需要深入改变每个子类的接口．\n\n\n\n### 3 工厂方法与抽象工厂的比较\n\n**关联点**：\n\n- `抽象工厂的方法经常以工厂方法的方式实现`．抽象工厂的任务是定义一个负责创建一组产品的接口．这个接口内的每个方法都则创建一个具体的产品，同时利用实现抽象工厂的子类类提供这些具体的做法．\n\n\n\n**相同点**：\n\n- 工厂方法和抽象方法都能将对象的创建封装起来，使应用程序解偶，降低其对特定实现的依赖．\n\n\n\n**不同点**：\n\n| 功能                               | 工厂方法               | 抽象工厂                                                     |\n| ---------------------------------- | ---------------------- | ------------------------------------------------------------ |\n| 创建对象的方法                     | 继承                   | 对象的组合                                                   |\n| 解偶方式（将客户从具体类型中解偶） | 通过子类来创建具体对象 | 提供一个用来创建产品家族的抽象类型，这个类型的子类定义了产品被生产的方法．要使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中． |\n\n\n\n### 4 总结\n\n- 所有的工厂都是用来封装对象的创建．通过减少应用程序和具体类之间的依赖促进松耦合．\n- 简单工厂，虽然不是真正的设计模式，但它是一种简单的可以将客户程序从具体类中解偶的方法．\n- 工厂方法通过使用继承，允许类将实例化延迟到子类，由子类实现工厂方法来创建对象．\n- 抽象工厂使用对象组合，对象的创建被是现在工厂接口所暴露出来的方法中．\n\n\n\n------\n\n### 参考资料：\n\nHead First设计模式 第五章（P109）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"DesignPattern-Factory","published":1,"updated":"2020-09-29T02:19:16.973Z","_id":"ckfgoabiu000745g3hrype88h","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>当使用＂<code>new</code>＂实例化一个具体类，将会导致代码更加脆弱，缺乏弹性．例如：当有很多相关的具体类时（如下代码所示），究竟要实例化哪个类，要在运行时由一些条件来决定．一旦有变化扩者扩展，就需要重新对这段代码进行检查和修改．可能造成部分系统维护和更新的困扰，也容易出错．</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Duck duck;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (picnic) &#123;</span><br><span class=\"line\">\tduck = <span class=\"keyword\">new</span> MallardDuck();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hunting) &#123;</span><br><span class=\"line\">\tduck = <span class=\"keyword\">new</span> DecoyDuck();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(inBathTub) &#123;</span><br><span class=\"line\">\tduck = <span class=\"keyword\">new</span> RubberDuck();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>那么如何将实例化具体类的代码从应用总抽离，或者封装起来，使他们不会干扰应用的其他部分呢？</p>\n<ul>\n<li>识别变化的方面．</li>\n<li>封装创建对象的代码（该对象即为＂Factory，工厂＂）．</li>\n</ul>\n<h3 id=\"2-Factory（工厂模式）\"><a href=\"#2-Factory（工厂模式）\" class=\"headerlink\" title=\"2 Factory（工厂模式）\"></a>2 Factory（工厂模式）</h3><p>根据应用场景和复杂度的不同，工厂模式可以分为以下三种：</p>\n<ul>\n<li>简单工厂模式；</li>\n<li>工厂方法模式；</li>\n<li>抽象工厂模式；</li>\n</ul>\n<h4 id=\"2-1-简单工厂模式\"><a href=\"#2-1-简单工厂模式\" class=\"headerlink\" title=\"2.1 简单工厂模式\"></a>2.1 简单工厂模式</h4><p>简单工厂模式，准确点来说，并不算是一种设计模式，反而比较像一种编程习惯．</p>\n<p>实现方法：<u>新建一个工厂类，在工厂类内定义一个实例化各种对象的方法，将识别出来变化的部分移植到该方法中．</u></p>\n<p>简单工厂模式看似只是把问题搬到一个对象中了，并没有进行实际的解决，<code>这样做的好处是什么</code>？</p>\n<ul>\n<li>将变化部分的代码封装起来，后续有改变时，只需要改动这一个类，避免对其他逻辑的影响．</li>\n<li>可以有多个调用方</li>\n</ul>\n<p>PHP示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具体商品，白猫</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteCat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;白猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品，黑猫</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackCat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;黑猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂类，用于生产商品</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以通过一个静态方法，通过参数来区分要实例化的类．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">$color</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> ($color) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;white&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteCat();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;black&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlackCat();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟客户端</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        $wCat = factory::create(<span class=\"string\">&#x27;white&#x27;</span>);</span><br><span class=\"line\">        $wCat-&gt;voice();</span><br><span class=\"line\">        $bCat = factory::create(<span class=\"string\">&#x27;black&#x27;</span>);</span><br><span class=\"line\">        $bCat-&gt;voice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Client::main();</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-工厂方法模式（Factory-Method-Pattern）\"><a href=\"#2-2-工厂方法模式（Factory-Method-Pattern）\" class=\"headerlink\" title=\"2.2 工厂方法模式（Factory Method Pattern）\"></a>2.2 工厂方法模式（Factory Method Pattern）</h4><p><code>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个．工厂方法让类的实例化推迟到子类．</code></p>\n<p>实现方法：<u>通过在抽象类（Creator）中定义抽象的工厂方法（factoryMethod），让其子类（ConcreteCreator）实现此方法以创建实例．（抽象类中通常会包含依赖子类实现的工厂方法，但无须知道是在创建哪种具体的对象．）</u></p>\n<p>（注：Creator类并不是必须为抽象的，可实现其工厂方法作为默认方法，子类若有变化，则重写该方法）</p>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/FactoryMethodPattern.png\" alt=\"FactoryMethodPattern\"></p>\n<p>PHP示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 商品基类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品WhiteCat</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteCat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;白猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品BlackCat</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackCat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;黑猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂接口，用于实例化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// static主要是为了不实例子工厂类，直接调用create方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 白猫工厂，用于实例化白猫</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteCatFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteCat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 黑猫工厂，用于实例化黑猫</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackCatFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlackCat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        $wCat = WhiteCatFactory::create();</span><br><span class=\"line\">        $wCat-&gt;voice();</span><br><span class=\"line\">        $bCat = BlackCatFactory::create();</span><br><span class=\"line\">        $bCat-&gt;voice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Client::main();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><code>简单工厂和工厂方法之间的区别？</code></p>\n<ul>\n<li>简单工厂将所有的逻辑，在一个地方处理完；它不具有工厂方法的弹性，因为简单工厂不能变更正在创建的对象．</li>\n<li>工厂方法是创建一个框架，让子类决定如何实现．</li>\n</ul>\n<p><code>工厂方法的优点：</code></p>\n<ul>\n<li>将创建对象的代码集中在一个对象或者方法中，可以避免代码的重复，并且更方便以后的维护．</li>\n<li>实例化对象时，只会依赖于接口，而不是具体类．使代码更具有弹性，方便未来扩展．</li>\n</ul>\n<h4 id=\"2-3-抽象工厂模式\"><a href=\"#2-3-抽象工厂模式\" class=\"headerlink\" title=\"2.3 抽象工厂模式\"></a>2.3 抽象工厂模式</h4><p><code>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类．</code></p>\n<p><code>实现方法</code>：</p>\n<ul>\n<li>抽象工厂定义了一个接口．所有的具体工厂都必须实现此接口，这个接口包含一组方法用来生产产品．</li>\n<li>所有具体工厂实现不同的产品家族．要创建一个产品，客户只要使用其中一个工厂而完全不需要实例化任何产品对象．</li>\n</ul>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AbstractFactory.png\" alt=\"AbstractFactory\"></p>\n<p>PHP示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 商品基类，猫</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品WhiteCat</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteCat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;白猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品BlackCat</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackCat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;黑猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 商品基类，狗</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品WhiteDog</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteDog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;白狗汪汪..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品BlackDog</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackDog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;黑狗汪汪..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂接口，用于实例化,提供一组商品．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCat</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createDog</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 白色动物工厂，用于实例化白猫，白狗</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteAnimalFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCat</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteCat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createDog</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteDog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 黑色动物工厂，用于实例化黑猫，黑狗</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackAnimalFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCat</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlackCat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createDog</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlackDog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">        <span class=\"built_in\">self</span>::run(<span class=\"keyword\">new</span> WhiteAnimalFactory());  </span><br><span class=\"line\">        <span class=\"built_in\">self</span>::run(<span class=\"keyword\">new</span> BlackAnimalFactory());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">factory $AnimalFactory</span>)</span>&#123;  </span><br><span class=\"line\">        $cat = $AnimalFactory-&gt;createCat();  </span><br><span class=\"line\">        $cat-&gt;Voice();  </span><br><span class=\"line\"></span><br><span class=\"line\">        $dog = $AnimalFactory-&gt;createDog();  </span><br><span class=\"line\">        $dog-&gt;Voice();  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Client::main();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>抽象工厂模式的优点</code>：</p>\n<ul>\n<li>将一群相关的产品集合起来．</li>\n</ul>\n<p><code>抽象工厂模式的缺点</code>：</p>\n<ul>\n<li>扩展相关接口较难，例如新增一个接口．这就意味着需要深入改变每个子类的接口．</li>\n</ul>\n<h3 id=\"3-工厂方法与抽象工厂的比较\"><a href=\"#3-工厂方法与抽象工厂的比较\" class=\"headerlink\" title=\"3 工厂方法与抽象工厂的比较\"></a>3 工厂方法与抽象工厂的比较</h3><p><strong>关联点</strong>：</p>\n<ul>\n<li><code>抽象工厂的方法经常以工厂方法的方式实现</code>．抽象工厂的任务是定义一个负责创建一组产品的接口．这个接口内的每个方法都则创建一个具体的产品，同时利用实现抽象工厂的子类类提供这些具体的做法．</li>\n</ul>\n<p><strong>相同点</strong>：</p>\n<ul>\n<li>工厂方法和抽象方法都能将对象的创建封装起来，使应用程序解偶，降低其对特定实现的依赖．</li>\n</ul>\n<p><strong>不同点</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>工厂方法</th>\n<th>抽象工厂</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>创建对象的方法</td>\n<td>继承</td>\n<td>对象的组合</td>\n</tr>\n<tr>\n<td>解偶方式（将客户从具体类型中解偶）</td>\n<td>通过子类来创建具体对象</td>\n<td>提供一个用来创建产品家族的抽象类型，这个类型的子类定义了产品被生产的方法．要使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中．</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h3><ul>\n<li>所有的工厂都是用来封装对象的创建．通过减少应用程序和具体类之间的依赖促进松耦合．</li>\n<li>简单工厂，虽然不是真正的设计模式，但它是一种简单的可以将客户程序从具体类中解偶的方法．</li>\n<li>工厂方法通过使用继承，允许类将实例化延迟到子类，由子类实现工厂方法来创建对象．</li>\n<li>抽象工厂使用对象组合，对象的创建被是现在工厂接口所暴露出来的方法中．</li>\n</ul>\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>Head First设计模式 第五章（P109）</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>当使用＂<code>new</code>＂实例化一个具体类，将会导致代码更加脆弱，缺乏弹性．例如：当有很多相关的具体类时（如下代码所示），究竟要实例化哪个类，要在运行时由一些条件来决定．一旦有变化扩者扩展，就需要重新对这段代码进行检查和修改．可能造成部分系统维护和更新的困扰，也容易出错．</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Duck duck;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (picnic) &#123;</span><br><span class=\"line\">\tduck = <span class=\"keyword\">new</span> MallardDuck();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hunting) &#123;</span><br><span class=\"line\">\tduck = <span class=\"keyword\">new</span> DecoyDuck();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(inBathTub) &#123;</span><br><span class=\"line\">\tduck = <span class=\"keyword\">new</span> RubberDuck();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>那么如何将实例化具体类的代码从应用总抽离，或者封装起来，使他们不会干扰应用的其他部分呢？</p>\n<ul>\n<li>识别变化的方面．</li>\n<li>封装创建对象的代码（该对象即为＂Factory，工厂＂）．</li>\n</ul>\n<h3 id=\"2-Factory（工厂模式）\"><a href=\"#2-Factory（工厂模式）\" class=\"headerlink\" title=\"2 Factory（工厂模式）\"></a>2 Factory（工厂模式）</h3><p>根据应用场景和复杂度的不同，工厂模式可以分为以下三种：</p>\n<ul>\n<li>简单工厂模式；</li>\n<li>工厂方法模式；</li>\n<li>抽象工厂模式；</li>\n</ul>\n<h4 id=\"2-1-简单工厂模式\"><a href=\"#2-1-简单工厂模式\" class=\"headerlink\" title=\"2.1 简单工厂模式\"></a>2.1 简单工厂模式</h4><p>简单工厂模式，准确点来说，并不算是一种设计模式，反而比较像一种编程习惯．</p>\n<p>实现方法：<u>新建一个工厂类，在工厂类内定义一个实例化各种对象的方法，将识别出来变化的部分移植到该方法中．</u></p>\n<p>简单工厂模式看似只是把问题搬到一个对象中了，并没有进行实际的解决，<code>这样做的好处是什么</code>？</p>\n<ul>\n<li>将变化部分的代码封装起来，后续有改变时，只需要改动这一个类，避免对其他逻辑的影响．</li>\n<li>可以有多个调用方</li>\n</ul>\n<p>PHP示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具体商品，白猫</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteCat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;白猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品，黑猫</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackCat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;黑猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂类，用于生产商品</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以通过一个静态方法，通过参数来区分要实例化的类．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">$color</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> ($color) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;white&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteCat();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;black&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlackCat();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟客户端</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        $wCat = factory::create(<span class=\"string\">&#x27;white&#x27;</span>);</span><br><span class=\"line\">        $wCat-&gt;voice();</span><br><span class=\"line\">        $bCat = factory::create(<span class=\"string\">&#x27;black&#x27;</span>);</span><br><span class=\"line\">        $bCat-&gt;voice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Client::main();</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-工厂方法模式（Factory-Method-Pattern）\"><a href=\"#2-2-工厂方法模式（Factory-Method-Pattern）\" class=\"headerlink\" title=\"2.2 工厂方法模式（Factory Method Pattern）\"></a>2.2 工厂方法模式（Factory Method Pattern）</h4><p><code>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个．工厂方法让类的实例化推迟到子类．</code></p>\n<p>实现方法：<u>通过在抽象类（Creator）中定义抽象的工厂方法（factoryMethod），让其子类（ConcreteCreator）实现此方法以创建实例．（抽象类中通常会包含依赖子类实现的工厂方法，但无须知道是在创建哪种具体的对象．）</u></p>\n<p>（注：Creator类并不是必须为抽象的，可实现其工厂方法作为默认方法，子类若有变化，则重写该方法）</p>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/FactoryMethodPattern.png\" alt=\"FactoryMethodPattern\"></p>\n<p>PHP示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 商品基类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品WhiteCat</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteCat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;白猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品BlackCat</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackCat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;黑猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂接口，用于实例化</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// static主要是为了不实例子工厂类，直接调用create方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 白猫工厂，用于实例化白猫</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteCatFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteCat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 黑猫工厂，用于实例化黑猫</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackCatFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlackCat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        $wCat = WhiteCatFactory::create();</span><br><span class=\"line\">        $wCat-&gt;voice();</span><br><span class=\"line\">        $bCat = BlackCatFactory::create();</span><br><span class=\"line\">        $bCat-&gt;voice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Client::main();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><code>简单工厂和工厂方法之间的区别？</code></p>\n<ul>\n<li>简单工厂将所有的逻辑，在一个地方处理完；它不具有工厂方法的弹性，因为简单工厂不能变更正在创建的对象．</li>\n<li>工厂方法是创建一个框架，让子类决定如何实现．</li>\n</ul>\n<p><code>工厂方法的优点：</code></p>\n<ul>\n<li>将创建对象的代码集中在一个对象或者方法中，可以避免代码的重复，并且更方便以后的维护．</li>\n<li>实例化对象时，只会依赖于接口，而不是具体类．使代码更具有弹性，方便未来扩展．</li>\n</ul>\n<h4 id=\"2-3-抽象工厂模式\"><a href=\"#2-3-抽象工厂模式\" class=\"headerlink\" title=\"2.3 抽象工厂模式\"></a>2.3 抽象工厂模式</h4><p><code>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类．</code></p>\n<p><code>实现方法</code>：</p>\n<ul>\n<li>抽象工厂定义了一个接口．所有的具体工厂都必须实现此接口，这个接口包含一组方法用来生产产品．</li>\n<li>所有具体工厂实现不同的产品家族．要创建一个产品，客户只要使用其中一个工厂而完全不需要实例化任何产品对象．</li>\n</ul>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AbstractFactory.png\" alt=\"AbstractFactory\"></p>\n<p>PHP示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 商品基类，猫</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品WhiteCat</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteCat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;白猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品BlackCat</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackCat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Cat</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;黑猫喵喵..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 商品基类，狗</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品WhiteDog</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteDog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;白狗汪汪..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体商品BlackDog</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackDog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Dog</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">voice</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;黑狗汪汪..&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂接口，用于实例化,提供一组商品．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCat</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createDog</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 白色动物工厂，用于实例化白猫，白狗</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhiteAnimalFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCat</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteCat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createDog</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteDog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 黑色动物工厂，用于实例化黑猫，黑狗</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlackAnimalFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCat</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlackCat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createDog</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BlackDog();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">        <span class=\"built_in\">self</span>::run(<span class=\"keyword\">new</span> WhiteAnimalFactory());  </span><br><span class=\"line\">        <span class=\"built_in\">self</span>::run(<span class=\"keyword\">new</span> BlackAnimalFactory());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">factory $AnimalFactory</span>)</span>&#123;  </span><br><span class=\"line\">        $cat = $AnimalFactory-&gt;createCat();  </span><br><span class=\"line\">        $cat-&gt;Voice();  </span><br><span class=\"line\"></span><br><span class=\"line\">        $dog = $AnimalFactory-&gt;createDog();  </span><br><span class=\"line\">        $dog-&gt;Voice();  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Client::main();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>抽象工厂模式的优点</code>：</p>\n<ul>\n<li>将一群相关的产品集合起来．</li>\n</ul>\n<p><code>抽象工厂模式的缺点</code>：</p>\n<ul>\n<li>扩展相关接口较难，例如新增一个接口．这就意味着需要深入改变每个子类的接口．</li>\n</ul>\n<h3 id=\"3-工厂方法与抽象工厂的比较\"><a href=\"#3-工厂方法与抽象工厂的比较\" class=\"headerlink\" title=\"3 工厂方法与抽象工厂的比较\"></a>3 工厂方法与抽象工厂的比较</h3><p><strong>关联点</strong>：</p>\n<ul>\n<li><code>抽象工厂的方法经常以工厂方法的方式实现</code>．抽象工厂的任务是定义一个负责创建一组产品的接口．这个接口内的每个方法都则创建一个具体的产品，同时利用实现抽象工厂的子类类提供这些具体的做法．</li>\n</ul>\n<p><strong>相同点</strong>：</p>\n<ul>\n<li>工厂方法和抽象方法都能将对象的创建封装起来，使应用程序解偶，降低其对特定实现的依赖．</li>\n</ul>\n<p><strong>不同点</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>工厂方法</th>\n<th>抽象工厂</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>创建对象的方法</td>\n<td>继承</td>\n<td>对象的组合</td>\n</tr>\n<tr>\n<td>解偶方式（将客户从具体类型中解偶）</td>\n<td>通过子类来创建具体对象</td>\n<td>提供一个用来创建产品家族的抽象类型，这个类型的子类定义了产品被生产的方法．要使用这个工厂，必须先实例化它，然后将它传入一些针对抽象类型所写的代码中．</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h3><ul>\n<li>所有的工厂都是用来封装对象的创建．通过减少应用程序和具体类之间的依赖促进松耦合．</li>\n<li>简单工厂，虽然不是真正的设计模式，但它是一种简单的可以将客户程序从具体类中解偶的方法．</li>\n<li>工厂方法通过使用继承，允许类将实例化延迟到子类，由子类实现工厂方法来创建对象．</li>\n<li>抽象工厂使用对象组合，对象的创建被是现在工厂接口所暴露出来的方法中．</li>\n</ul>\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>Head First设计模式 第五章（P109）</p>"},{"title":"DesignPattern-Observer(观察者模式)","date":"2020-09-22T07:58:36.000Z","_content":"\n### 1 引入\n\n我们知道在报社订阅报纸的逻辑是：\n\n- ①、报社的业务就是出版报纸。\n- ②、向某家报社订阅报纸，只要他们有新报只出版，就会给你用来。只要你是他们的订阅用户，你就会一直收到报纸。\n\n<!--more-->\n\n- ③、当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。\n- ④、只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。\n\n\n\n<u>观察者模式就和订阅报纸类似，可以说`观察者模式=出版者+订阅者`，只是出版者改称为“`主题`”，订阅者改称为“`观察者`”</u>\n\n\n\n### 2 Observer（观察者模式）\n\n**观察者模式定义**了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有的依赖都会收到通知并自动更新。通过接口对观察者与被观察者进行逻辑解耦，降低二者的直接耦合。\n\n（观察者模式的实现方式不止一种，但是以包含`Subject`和`Observer`接口的做法最常见。 ）\n\n\n\n类图如下：\n\n![Observer_UML](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Observer_UML.png)\n\n\n\n------\n\n### 参考资料\n\nHead First设计模式 第五章（P37）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/DesignPattern-Observer.md","raw":"---\ntitle: DesignPattern-Observer(观察者模式)\ndate: 2020-09-22 15:58:36\ntags: [\"DesignPattern\",\"Observer\"]\ncategories: [\"DesignPattern\"]\n---\n\n### 1 引入\n\n我们知道在报社订阅报纸的逻辑是：\n\n- ①、报社的业务就是出版报纸。\n- ②、向某家报社订阅报纸，只要他们有新报只出版，就会给你用来。只要你是他们的订阅用户，你就会一直收到报纸。\n\n<!--more-->\n\n- ③、当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。\n- ④、只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。\n\n\n\n<u>观察者模式就和订阅报纸类似，可以说`观察者模式=出版者+订阅者`，只是出版者改称为“`主题`”，订阅者改称为“`观察者`”</u>\n\n\n\n### 2 Observer（观察者模式）\n\n**观察者模式定义**了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有的依赖都会收到通知并自动更新。通过接口对观察者与被观察者进行逻辑解耦，降低二者的直接耦合。\n\n（观察者模式的实现方式不止一种，但是以包含`Subject`和`Observer`接口的做法最常见。 ）\n\n\n\n类图如下：\n\n![Observer_UML](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Observer_UML.png)\n\n\n\n------\n\n### 参考资料\n\nHead First设计模式 第五章（P37）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"DesignPattern-Observer","published":1,"updated":"2020-09-25T03:19:11.424Z","_id":"ckfgoabiw000845g38c8ch3lo","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-引入\"><a href=\"#1-引入\" class=\"headerlink\" title=\"1 引入\"></a>1 引入</h3><p>我们知道在报社订阅报纸的逻辑是：</p>\n<ul>\n<li>①、报社的业务就是出版报纸。</li>\n<li>②、向某家报社订阅报纸，只要他们有新报只出版，就会给你用来。只要你是他们的订阅用户，你就会一直收到报纸。</li>\n</ul>\n<a id=\"more\"></a>\n\n<ul>\n<li>③、当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。</li>\n<li>④、只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。</li>\n</ul>\n<p><u>观察者模式就和订阅报纸类似，可以说<code>观察者模式=出版者+订阅者</code>，只是出版者改称为“<code>主题</code>”，订阅者改称为“<code>观察者</code>”</u></p>\n<h3 id=\"2-Observer（观察者模式）\"><a href=\"#2-Observer（观察者模式）\" class=\"headerlink\" title=\"2 Observer（观察者模式）\"></a>2 Observer（观察者模式）</h3><p><strong>观察者模式定义</strong>了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有的依赖都会收到通知并自动更新。通过接口对观察者与被观察者进行逻辑解耦，降低二者的直接耦合。</p>\n<p>（观察者模式的实现方式不止一种，但是以包含<code>Subject</code>和<code>Observer</code>接口的做法最常见。 ）</p>\n<p>类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Observer_UML.png\" alt=\"Observer_UML\"></p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>Head First设计模式 第五章（P37）</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-引入\"><a href=\"#1-引入\" class=\"headerlink\" title=\"1 引入\"></a>1 引入</h3><p>我们知道在报社订阅报纸的逻辑是：</p>\n<ul>\n<li>①、报社的业务就是出版报纸。</li>\n<li>②、向某家报社订阅报纸，只要他们有新报只出版，就会给你用来。只要你是他们的订阅用户，你就会一直收到报纸。</li>\n</ul>","more":"<ul>\n<li>③、当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。</li>\n<li>④、只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。</li>\n</ul>\n<p><u>观察者模式就和订阅报纸类似，可以说<code>观察者模式=出版者+订阅者</code>，只是出版者改称为“<code>主题</code>”，订阅者改称为“<code>观察者</code>”</u></p>\n<h3 id=\"2-Observer（观察者模式）\"><a href=\"#2-Observer（观察者模式）\" class=\"headerlink\" title=\"2 Observer（观察者模式）\"></a>2 Observer（观察者模式）</h3><p><strong>观察者模式定义</strong>了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有的依赖都会收到通知并自动更新。通过接口对观察者与被观察者进行逻辑解耦，降低二者的直接耦合。</p>\n<p>（观察者模式的实现方式不止一种，但是以包含<code>Subject</code>和<code>Observer</code>接口的做法最常见。 ）</p>\n<p>类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Observer_UML.png\" alt=\"Observer_UML\"></p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>Head First设计模式 第五章（P37）</p>"},{"title":"DesignPattern-Singleton(单例模式)","date":"2020-09-21T08:34:15.000Z","_content":"\n\n\n### 1 概述\n\n有一些对象其实我们只需要一个，比如说：线程池（threadpool）、缓存（cache）、对话框、处理器偏好设置和注册表的对象、日志对象、充当打印机、显卡等设备的驱动程序的对象。如果制造多个实例可能会出现许多问题，例如:程序行为异常、资源使用过量，或者不一致的结果．这就引入了单例模式．\n\n<!--more-->\n\n实际上，在不同通过单例模式实例化一个对象外，还可以有很多方式可以实现，例如：可以使用全局变量实现仅实例化一个对象（即在程序一开始就创建号该对象）．但是若该对象非常消耗资源，而程序有一直没有用到它，就形成了资源的浪费．而利用单例模式则可以在需要的时候才创建对象．\n\n\n\n### 2 Singleton（单例模式）\n\n`单例模式的定义`：确保一个类只有一个实例，并提供了一个全局访问点．\n\n`单例模式的实现原理`：\n\n- 利用一个静态变量来记录Singleton的唯一实例．\n- 将构造器声私有化，只有Singleton类内才可以调用构造器．\n- 提供一个静态的方法（eg：`getInstance()`）实例化对象，并返回这个实例．\n\n\n\n其类图如下：\n\n![Singleton_类图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Singleton_类图.png)\n\n\n\n### 3 单例模式实现方法\n\n#### 3.1 延迟实例化方法（饱汉模式）\n\n`延迟实例化方法`是最经典的实现方式，对静态变量的实例化赋值放在静态方法中实现．\n\n\n\nPHP实现示例：\n\n```php\nclass Singleton\n{\n    private static $instance; // 不进行赋值．\n    private function __construct(){}　//　私有化构造器．\n\n    public static function getInstance()　\n    {\n        if (static::$instance == null) {\n            static::$instance = new self();　// 需要使用该实例的时候，再进行赋值．\n        }\n        return static::$instance;\n    }\n}\n// 调用方法．\n$singleton = Singleton::getInstance();\n```\n\n\n\n`问题`：该方式在单进程模式下，可以有效确保一个类只有一个实例，但是在多进程并发的情况下，可能会导致多个实例产生．\n\n解决方法：\n\n- 使用同步的方法．但同步的方法可能会造成程序执行效率下降．\n  - 通过增加synchronized关键字到getInstance方法中，迫使每个线程在进入到这个放大之前，要先等待别的线程离开该方法．\n- 不采用延迟实例化方法（饿汉模式）．\n- 使用＂双重检测加锁＂.（使用 volatile实现）\n\n\n\n#### 3.2 饿汉模式\n\n顾名思义，即在静态初始化阶段中创建该示例，保证代码在调用getInstance时已经有实例了．\n\n\n\n`PHP实现示例`：\n\n```php\nclass Singleton\n{\n    private static $instance = new self();\n    private function __construct(){}\n\n    public static function getInstance()\n    {\n        return static::$instance;\n    }\n}\n\n$singleton = Singleton::getInstance();\n```\n\n\n\n------\n\n### 参考资料：\n\nHead First设计模式 第五章（P170）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/DesignPattern-Singleton.md","raw":"---\ntitle: DesignPattern-Singleton(单例模式)\ndate: 2020-09-21 16:34:15\ntags: [\"DesignPattern\",\"Singleton\"]\ncategories: [\"DesignPattern\"]\n---\n\n\n\n### 1 概述\n\n有一些对象其实我们只需要一个，比如说：线程池（threadpool）、缓存（cache）、对话框、处理器偏好设置和注册表的对象、日志对象、充当打印机、显卡等设备的驱动程序的对象。如果制造多个实例可能会出现许多问题，例如:程序行为异常、资源使用过量，或者不一致的结果．这就引入了单例模式．\n\n<!--more-->\n\n实际上，在不同通过单例模式实例化一个对象外，还可以有很多方式可以实现，例如：可以使用全局变量实现仅实例化一个对象（即在程序一开始就创建号该对象）．但是若该对象非常消耗资源，而程序有一直没有用到它，就形成了资源的浪费．而利用单例模式则可以在需要的时候才创建对象．\n\n\n\n### 2 Singleton（单例模式）\n\n`单例模式的定义`：确保一个类只有一个实例，并提供了一个全局访问点．\n\n`单例模式的实现原理`：\n\n- 利用一个静态变量来记录Singleton的唯一实例．\n- 将构造器声私有化，只有Singleton类内才可以调用构造器．\n- 提供一个静态的方法（eg：`getInstance()`）实例化对象，并返回这个实例．\n\n\n\n其类图如下：\n\n![Singleton_类图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Singleton_类图.png)\n\n\n\n### 3 单例模式实现方法\n\n#### 3.1 延迟实例化方法（饱汉模式）\n\n`延迟实例化方法`是最经典的实现方式，对静态变量的实例化赋值放在静态方法中实现．\n\n\n\nPHP实现示例：\n\n```php\nclass Singleton\n{\n    private static $instance; // 不进行赋值．\n    private function __construct(){}　//　私有化构造器．\n\n    public static function getInstance()　\n    {\n        if (static::$instance == null) {\n            static::$instance = new self();　// 需要使用该实例的时候，再进行赋值．\n        }\n        return static::$instance;\n    }\n}\n// 调用方法．\n$singleton = Singleton::getInstance();\n```\n\n\n\n`问题`：该方式在单进程模式下，可以有效确保一个类只有一个实例，但是在多进程并发的情况下，可能会导致多个实例产生．\n\n解决方法：\n\n- 使用同步的方法．但同步的方法可能会造成程序执行效率下降．\n  - 通过增加synchronized关键字到getInstance方法中，迫使每个线程在进入到这个放大之前，要先等待别的线程离开该方法．\n- 不采用延迟实例化方法（饿汉模式）．\n- 使用＂双重检测加锁＂.（使用 volatile实现）\n\n\n\n#### 3.2 饿汉模式\n\n顾名思义，即在静态初始化阶段中创建该示例，保证代码在调用getInstance时已经有实例了．\n\n\n\n`PHP实现示例`：\n\n```php\nclass Singleton\n{\n    private static $instance = new self();\n    private function __construct(){}\n\n    public static function getInstance()\n    {\n        return static::$instance;\n    }\n}\n\n$singleton = Singleton::getInstance();\n```\n\n\n\n------\n\n### 参考资料：\n\nHead First设计模式 第五章（P170）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"DesignPattern-Singleton","published":1,"updated":"2020-09-29T02:19:36.389Z","_id":"ckfgoabix000945g3godr1xz5","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>有一些对象其实我们只需要一个，比如说：线程池（threadpool）、缓存（cache）、对话框、处理器偏好设置和注册表的对象、日志对象、充当打印机、显卡等设备的驱动程序的对象。如果制造多个实例可能会出现许多问题，例如:程序行为异常、资源使用过量，或者不一致的结果．这就引入了单例模式．</p>\n<a id=\"more\"></a>\n\n<p>实际上，在不同通过单例模式实例化一个对象外，还可以有很多方式可以实现，例如：可以使用全局变量实现仅实例化一个对象（即在程序一开始就创建号该对象）．但是若该对象非常消耗资源，而程序有一直没有用到它，就形成了资源的浪费．而利用单例模式则可以在需要的时候才创建对象．</p>\n<h3 id=\"2-Singleton（单例模式）\"><a href=\"#2-Singleton（单例模式）\" class=\"headerlink\" title=\"2 Singleton（单例模式）\"></a>2 Singleton（单例模式）</h3><p><code>单例模式的定义</code>：确保一个类只有一个实例，并提供了一个全局访问点．</p>\n<p><code>单例模式的实现原理</code>：</p>\n<ul>\n<li>利用一个静态变量来记录Singleton的唯一实例．</li>\n<li>将构造器声私有化，只有Singleton类内才可以调用构造器．</li>\n<li>提供一个静态的方法（eg：<code>getInstance()</code>）实例化对象，并返回这个实例．</li>\n</ul>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Singleton_%E7%B1%BB%E5%9B%BE.png\" alt=\"Singleton_类图\"></p>\n<h3 id=\"3-单例模式实现方法\"><a href=\"#3-单例模式实现方法\" class=\"headerlink\" title=\"3 单例模式实现方法\"></a>3 单例模式实现方法</h3><h4 id=\"3-1-延迟实例化方法（饱汉模式）\"><a href=\"#3-1-延迟实例化方法（饱汉模式）\" class=\"headerlink\" title=\"3.1 延迟实例化方法（饱汉模式）\"></a>3.1 延迟实例化方法（饱汉模式）</h4><p><code>延迟实例化方法</code>是最经典的实现方式，对静态变量的实例化赋值放在静态方法中实现．</p>\n<p>PHP实现示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">static</span> $instance; <span class=\"comment\">// 不进行赋值．</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"></span>)</span>&#123;&#125;　<span class=\"comment\">//　私有化构造器．</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getInstance</span>(<span class=\"params\"></span>)　</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">static</span>::$instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static</span>::$instance = <span class=\"keyword\">new</span> <span class=\"built_in\">self</span>();　<span class=\"comment\">// 需要使用该实例的时候，再进行赋值．</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">static</span>::$instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用方法．</span></span><br><span class=\"line\">$singleton = Singleton::getInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>问题</code>：该方式在单进程模式下，可以有效确保一个类只有一个实例，但是在多进程并发的情况下，可能会导致多个实例产生．</p>\n<p>解决方法：</p>\n<ul>\n<li>使用同步的方法．但同步的方法可能会造成程序执行效率下降．<ul>\n<li>通过增加synchronized关键字到getInstance方法中，迫使每个线程在进入到这个放大之前，要先等待别的线程离开该方法．</li>\n</ul>\n</li>\n<li>不采用延迟实例化方法（饿汉模式）．</li>\n<li>使用＂双重检测加锁＂.（使用 volatile实现）</li>\n</ul>\n<h4 id=\"3-2-饿汉模式\"><a href=\"#3-2-饿汉模式\" class=\"headerlink\" title=\"3.2 饿汉模式\"></a>3.2 饿汉模式</h4><p>顾名思义，即在静态初始化阶段中创建该示例，保证代码在调用getInstance时已经有实例了．</p>\n<p><code>PHP实现示例</code>：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">static</span> $instance = <span class=\"keyword\">new</span> <span class=\"built_in\">self</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getInstance</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">static</span>::$instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$singleton = Singleton::getInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>Head First设计模式 第五章（P170）</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>有一些对象其实我们只需要一个，比如说：线程池（threadpool）、缓存（cache）、对话框、处理器偏好设置和注册表的对象、日志对象、充当打印机、显卡等设备的驱动程序的对象。如果制造多个实例可能会出现许多问题，例如:程序行为异常、资源使用过量，或者不一致的结果．这就引入了单例模式．</p>","more":"<p>实际上，在不同通过单例模式实例化一个对象外，还可以有很多方式可以实现，例如：可以使用全局变量实现仅实例化一个对象（即在程序一开始就创建号该对象）．但是若该对象非常消耗资源，而程序有一直没有用到它，就形成了资源的浪费．而利用单例模式则可以在需要的时候才创建对象．</p>\n<h3 id=\"2-Singleton（单例模式）\"><a href=\"#2-Singleton（单例模式）\" class=\"headerlink\" title=\"2 Singleton（单例模式）\"></a>2 Singleton（单例模式）</h3><p><code>单例模式的定义</code>：确保一个类只有一个实例，并提供了一个全局访问点．</p>\n<p><code>单例模式的实现原理</code>：</p>\n<ul>\n<li>利用一个静态变量来记录Singleton的唯一实例．</li>\n<li>将构造器声私有化，只有Singleton类内才可以调用构造器．</li>\n<li>提供一个静态的方法（eg：<code>getInstance()</code>）实例化对象，并返回这个实例．</li>\n</ul>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Singleton_%E7%B1%BB%E5%9B%BE.png\" alt=\"Singleton_类图\"></p>\n<h3 id=\"3-单例模式实现方法\"><a href=\"#3-单例模式实现方法\" class=\"headerlink\" title=\"3 单例模式实现方法\"></a>3 单例模式实现方法</h3><h4 id=\"3-1-延迟实例化方法（饱汉模式）\"><a href=\"#3-1-延迟实例化方法（饱汉模式）\" class=\"headerlink\" title=\"3.1 延迟实例化方法（饱汉模式）\"></a>3.1 延迟实例化方法（饱汉模式）</h4><p><code>延迟实例化方法</code>是最经典的实现方式，对静态变量的实例化赋值放在静态方法中实现．</p>\n<p>PHP实现示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">static</span> $instance; <span class=\"comment\">// 不进行赋值．</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"></span>)</span>&#123;&#125;　<span class=\"comment\">//　私有化构造器．</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getInstance</span>(<span class=\"params\"></span>)　</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">static</span>::$instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">static</span>::$instance = <span class=\"keyword\">new</span> <span class=\"built_in\">self</span>();　<span class=\"comment\">// 需要使用该实例的时候，再进行赋值．</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">static</span>::$instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用方法．</span></span><br><span class=\"line\">$singleton = Singleton::getInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>问题</code>：该方式在单进程模式下，可以有效确保一个类只有一个实例，但是在多进程并发的情况下，可能会导致多个实例产生．</p>\n<p>解决方法：</p>\n<ul>\n<li>使用同步的方法．但同步的方法可能会造成程序执行效率下降．<ul>\n<li>通过增加synchronized关键字到getInstance方法中，迫使每个线程在进入到这个放大之前，要先等待别的线程离开该方法．</li>\n</ul>\n</li>\n<li>不采用延迟实例化方法（饿汉模式）．</li>\n<li>使用＂双重检测加锁＂.（使用 volatile实现）</li>\n</ul>\n<h4 id=\"3-2-饿汉模式\"><a href=\"#3-2-饿汉模式\" class=\"headerlink\" title=\"3.2 饿汉模式\"></a>3.2 饿汉模式</h4><p>顾名思义，即在静态初始化阶段中创建该示例，保证代码在调用getInstance时已经有实例了．</p>\n<p><code>PHP实现示例</code>：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">static</span> $instance = <span class=\"keyword\">new</span> <span class=\"built_in\">self</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getInstance</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">static</span>::$instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$singleton = Singleton::getInstance();</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>Head First设计模式 第五章（P170）</p>"},{"title":"Docker-Dockerfile指令","date":"2020-09-17T08:18:16.000Z","_content":"\n\n\n## 1 概述\n\nDockerfile 是一个文本文件，其内包含了一条条的 `指令(Instruction)`，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n\n<!--more-->\n\nDockerfile功能很强大，它提供了十多个指令，如FROM, RUN, COPY等等．\n\n\n\n## 2 Dockerfile指令解析\n\n### 2.1 FROM指定基础镜像\n\n`FROM` 是指定 **基础镜像**，在 `Dockerfile` 中 `FROM` 是必备的指令，并且`必须是第一条指令`。\n\n\n\nDocker中有一个特殊的镜像，名为`scratch`。这个镜像是虚拟的概念，并不实际存在，他表示一个空白的镜像．若以scratch为基础镜像，以为这不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。\n\n\n\n### 2.2 RUN执行命令\n\n`RUN` 指令是用来执行命令行命令的。由于命令行的强大能力，`RUN` 指令在定制镜像时是最常用的指令之一。\n\n其格式有两种：\n\n- shell格式：`RUN <命令>`\n- exec格式：`RUN [\"可执行文件\", \"参数1\", \"参数2\"]`\n\n\n\n每一个 `RUN` 的行为，会新建立一层，在其上执行这些命令，执行结束后，`commit` 这一层的修改，构成新的镜像。因此`对于实现同一个目的的多条指令应该使用一个RUN指令，并使用&&将各个所需的命令串联起来`．\n\nDockerfile支持Shell类的行尾添加 `\\` 的命令换行方式，以及行首 `#` 进行注释的格式．\n\n\n\n注意：为了避免镜像过于臃肿，需要在每一层构建结束后清理掉无关的文件．\n\n\n\n### 2.3 COPY复制文件\n\n `COPY` 指令将从构建上下文目录中 `<源路径>` 的文件/目录复制到新的一层的镜像内的 `<目标路径>` 位置。\n\n- `<源路径>`可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [`filepath.Match`](https://golang.org/pkg/path/filepath/#Match) 规则．\n- `<目标路径>` 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 `WORKDIR` 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。\n\n\n\nCOPY指令格式有两种：\n\n- `COPY [--chown=<user>:<group>] <源路径>... <目标路径>`\n- `COPY [--chown=<user>:<group>] [\"<源路径1>\",... \"<目标路径>\"]`\n\n\n\n*注：使用 `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。*\n\n\n\n### 2.4 ADD高级复制文件\n\n `ADD` 指令和 `COPY` 的格式和性质基本一致，都是实现复制文件．ADD指令增加了一些功能：\n\n-  <源路径> 可以是一个 `URL`：这种情况下，Docker 引擎会试图去下载这个链接的文件放到 `<目标路径>` 去。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，那么还需要增加额外的一层 `RUN` 进行权限调整．（*若下载的是一个压缩包，需要使用一层RUN指令进行解压*）．（<u>此种情况并不推荐，不如直接使用RUN指令，用wget或curl工具下载，处理．</u>）\n-  <源路径> 为一个 `tar` 压缩文件`：压缩格式为 `gzip`, `bzip2` 以及 `xz` 的情况下，`ADD` 指令将会自动解压缩这个压缩文件到 `<目标路径>` 去。\n\n\n\n`ADD` 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 `ADD rootfs.tar.xz`。\n\n\n\n#### 2.4.1 不推荐使用ADD复制文件的原因\n\n- 因为`ADD` 语义不明。`COPY` 只支持简单将本地文件拷贝到容器中，而 `ADD` 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，`ADD` 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 `ADD rootfs.tar.xz`。\n- `ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。\n\n\n\n### 2.5 CMD容器启动命令\n\n `CMD` 指令就是用于指定默认的容器主进程的启动命令的。其格式有两种：\n\n- shell格式：`CMD <命令>`\n- exec 格式：`CMD [\"可执行文件\", \"参数1\", \"参数2\"...]`（<u>推荐，因为此类格式会被解析JSON数组，因此一定要使用双引号</u>）\n- 参数列表格式：`CMD [\"参数1\", \"参数2\"...]`。在指定了 `ENTRYPOINT` 指令后，用 `CMD` 指定具体的参数。\n\n\n\n注：在运行时可以指定新的命令来替代镜像设置中的这个默认命令．\n\n\n\n`示例`：Ubuntu镜像默认的CMD是`/bin/bash`， 如果直接 `docker run -it ubuntu` 的话，会直接进入 `bash`。我们也可以在运行时指定运行别的命令，如 `docker run -it ubuntu cat /etc/os-release`．\n\n\n\n### 2.6 ENTRYPOINT入口点\n\n`ENTRYPOINT`的目的与`CMD`一样，都是在指定容器启动程序及参数。`ENTRYPOINT`在运行时也可以替代，不过比`CMD`要稍微繁琐一些，需要通过docker run的参数`--entrypoint`来指定。\n\n\n\n当指定了ENTRYPOINT后，CMD的含义就变了，不再是直接的运行其命令，而是`将CMD的内容作为参数传给ENTRYPOINT指令`，即实际执行时，将变为：\n\n```\n<ENTRYPOINT> \"<CMD>\"\n```\n\n\n\n### 2.7 ENV设置环境变量\n\nENV指令用于设置环境变量，在后续的指令中，可以直接使用跟这里定义的环境变量。支持环境变量展开的指令包括：`ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。`\n\nENV指令格式有两种：\n\n- `ENV <key> <value>`\n- `ENV <key1>=<value1> <key2>=<value2>...`．eg：`ENV VERSION=1.0 DEBUG=on NAME=\"Happy Feet\"`\n\n注：*对于含有空格的值用双引号括起来*\n\n后续使用时，使用`$符号+key`进行使用，eg：$NAME\n\n\n\n### 2.8 AGR构建参数\n\n构建参数和ENV指令效果一样，都是设置环境变量。不同的是，A`RG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。`\n\n注：*不要使用ARG保存密码之类的，因为`docker history`还是可以看到所有值。*\n\n指令格式：\n\n```\nARG <参数名>[=<默认值>]\n```\n\n\n\nDockerfile中的ARG指令是定义参数名称及默认值，可以在构建命令`docker build`中使用以下参数来覆盖。\n\n```\n--build-arg <参数名>=<值>\n```\n\n\n\n注：*ARG 指令有生效范围，如果在 `FROM` 指令之前指定，那么只能用于 `FROM` 指令中。*\n\n\n\n### 2.9 VOLUME定义匿名卷\n\n`容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的饮用，其数据库文件应该保存于卷中（VOLUME）中。`\n\n为了防止运行时用户忘记将动态文件所保存目录挂在为卷，在Dockerfile中，可以事先指定某些目录挂在为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。\n\n\n\n指令格式为：\n\n- `VOLUME [\"<路径1>\", \"<路径2>\"...]`\n- `VOLUME <路径>`\n\n\n\n在运行时可以通过`-v`覆盖Dockerfile中设置的匿名卷．eg：`docker run -d -v mydata:/data xxxx`．\n\n\n\n### 2.10 EXPOSE暴露端口\n\n`EXPOSE`指令是声明运行时容器提供服务端口（注：<u>这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</u>）。\n\n\n\n指令格式为：\n\n```\nEXPOSE <端口1> [<端口2>...]\n```\n\n\n\n#### 2.10.1 使用EXPOSR声明的好处\n\n- ①、帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。\n- ②、运行时使用随机端口映射时，也就是`docker run -p`命令时，会自动随机映射EXPOSE端口。\n\n\n\n`EXPOSE`和`docker run -p <宿主端口>：<容器端口>的区别`？\n\n- -p：映射宿主端口和容器端口，即将容器对应端口服务公开给外界访问。\n- EXPOSE：仅仅是声明容器打算使用什么端口，并不会自动在宿主进行端口映射。\n\n\n\n### 2.11 WORKDIR指定工作目录\n\n使用`WORKDIR`指令可以指定工作目录（或当前目录），以后各层的当前目录就被改为指定的目录，若该目录不存在，WORKDIR会创建一个目录。\n\n\n\n指令格式为：\n\n```\nWORKDIR <工作目录路径>\n```\n\n注：若 `WORKDIR` 指令使用的相对路径，那么所切换的路径与之前的 `WORKDIR` 有关：\n\n```\nWORKDIR /a\nWORKDIR b\nWORKDIR c\n\nRUN pwd\n```\n\n结果为：`/a/b/c`\n\n\n\n### 2.12 USER指定当前用户\n\n`USER`指令和`WORKDIR`类似，都是改变环境状态并影响以后的层。WORKDIR是改变工作目录，USER则是改变之后层的适应`RUN`,`CMD`以及`ENTRYPOINT`这类命令的身份。\n\n（注：<u>USER只是切换指定用户，这个用户必须存在。</u>）\n\n\n\n指令格式：\n\n```\nUSER <用户名>[:<用户组>]\n```\n\n\n\n### 2.13 HEALTHCHECK健康检查\n\n`HEALTHCHECK`指令是告诉Docker应该如何进行判断容器的状态是否正常，这是Docker 1.12引入的新指令。\n\n\n\n指令格式为：\n\n- `HEALTHCHECK [选项] CMD <命令>`：设置检查容器健康状况的命令，支持的选项包括：\n  - `--interval=<间隔>`：两次健康检查的间隔，默认为 30 秒；\n  - `--timeout=<时长>`：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；\n  - `--retries=<次数>`：当连续失败指定次数后，则将容器状态视为 `unhealthy`，默认 3 次。\n- `HEALTHCHECK NONE`：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令\n\n\n\n### 2.14 ONBUILD 为他人作嫁衣裳\n\n`ONBUILD`是一个特殊的指令，他后面跟的是其他指令，比如RUN、COPY等，<u>在当前进项构建时并不会被执行，只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</u>\n\n\n\n指令格式：\n\n```\nONBUILD <其它指令>\n```\n\n\n\n### 2.15 SHELL 指令\n\nSHELL指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell，Linux 中默认为 `[\"/bin/sh\", \"-c\"]`.\n\n\n\n","source":"_posts/Docker-Dockerfile指令.md","raw":"---\ntitle: Docker-Dockerfile指令\ndate: 2020-09-17 16:18:16\ntags: [\"Docker\",\"Dockerfile\"]\ncategories: [\"Docker\",\"Dockerfile\"]\n---\n\n\n\n## 1 概述\n\nDockerfile 是一个文本文件，其内包含了一条条的 `指令(Instruction)`，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n\n<!--more-->\n\nDockerfile功能很强大，它提供了十多个指令，如FROM, RUN, COPY等等．\n\n\n\n## 2 Dockerfile指令解析\n\n### 2.1 FROM指定基础镜像\n\n`FROM` 是指定 **基础镜像**，在 `Dockerfile` 中 `FROM` 是必备的指令，并且`必须是第一条指令`。\n\n\n\nDocker中有一个特殊的镜像，名为`scratch`。这个镜像是虚拟的概念，并不实际存在，他表示一个空白的镜像．若以scratch为基础镜像，以为这不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。\n\n\n\n### 2.2 RUN执行命令\n\n`RUN` 指令是用来执行命令行命令的。由于命令行的强大能力，`RUN` 指令在定制镜像时是最常用的指令之一。\n\n其格式有两种：\n\n- shell格式：`RUN <命令>`\n- exec格式：`RUN [\"可执行文件\", \"参数1\", \"参数2\"]`\n\n\n\n每一个 `RUN` 的行为，会新建立一层，在其上执行这些命令，执行结束后，`commit` 这一层的修改，构成新的镜像。因此`对于实现同一个目的的多条指令应该使用一个RUN指令，并使用&&将各个所需的命令串联起来`．\n\nDockerfile支持Shell类的行尾添加 `\\` 的命令换行方式，以及行首 `#` 进行注释的格式．\n\n\n\n注意：为了避免镜像过于臃肿，需要在每一层构建结束后清理掉无关的文件．\n\n\n\n### 2.3 COPY复制文件\n\n `COPY` 指令将从构建上下文目录中 `<源路径>` 的文件/目录复制到新的一层的镜像内的 `<目标路径>` 位置。\n\n- `<源路径>`可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [`filepath.Match`](https://golang.org/pkg/path/filepath/#Match) 规则．\n- `<目标路径>` 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 `WORKDIR` 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。\n\n\n\nCOPY指令格式有两种：\n\n- `COPY [--chown=<user>:<group>] <源路径>... <目标路径>`\n- `COPY [--chown=<user>:<group>] [\"<源路径1>\",... \"<目标路径>\"]`\n\n\n\n*注：使用 `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。*\n\n\n\n### 2.4 ADD高级复制文件\n\n `ADD` 指令和 `COPY` 的格式和性质基本一致，都是实现复制文件．ADD指令增加了一些功能：\n\n-  <源路径> 可以是一个 `URL`：这种情况下，Docker 引擎会试图去下载这个链接的文件放到 `<目标路径>` 去。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，那么还需要增加额外的一层 `RUN` 进行权限调整．（*若下载的是一个压缩包，需要使用一层RUN指令进行解压*）．（<u>此种情况并不推荐，不如直接使用RUN指令，用wget或curl工具下载，处理．</u>）\n-  <源路径> 为一个 `tar` 压缩文件`：压缩格式为 `gzip`, `bzip2` 以及 `xz` 的情况下，`ADD` 指令将会自动解压缩这个压缩文件到 `<目标路径>` 去。\n\n\n\n`ADD` 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 `ADD rootfs.tar.xz`。\n\n\n\n#### 2.4.1 不推荐使用ADD复制文件的原因\n\n- 因为`ADD` 语义不明。`COPY` 只支持简单将本地文件拷贝到容器中，而 `ADD` 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，`ADD` 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 `ADD rootfs.tar.xz`。\n- `ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。\n\n\n\n### 2.5 CMD容器启动命令\n\n `CMD` 指令就是用于指定默认的容器主进程的启动命令的。其格式有两种：\n\n- shell格式：`CMD <命令>`\n- exec 格式：`CMD [\"可执行文件\", \"参数1\", \"参数2\"...]`（<u>推荐，因为此类格式会被解析JSON数组，因此一定要使用双引号</u>）\n- 参数列表格式：`CMD [\"参数1\", \"参数2\"...]`。在指定了 `ENTRYPOINT` 指令后，用 `CMD` 指定具体的参数。\n\n\n\n注：在运行时可以指定新的命令来替代镜像设置中的这个默认命令．\n\n\n\n`示例`：Ubuntu镜像默认的CMD是`/bin/bash`， 如果直接 `docker run -it ubuntu` 的话，会直接进入 `bash`。我们也可以在运行时指定运行别的命令，如 `docker run -it ubuntu cat /etc/os-release`．\n\n\n\n### 2.6 ENTRYPOINT入口点\n\n`ENTRYPOINT`的目的与`CMD`一样，都是在指定容器启动程序及参数。`ENTRYPOINT`在运行时也可以替代，不过比`CMD`要稍微繁琐一些，需要通过docker run的参数`--entrypoint`来指定。\n\n\n\n当指定了ENTRYPOINT后，CMD的含义就变了，不再是直接的运行其命令，而是`将CMD的内容作为参数传给ENTRYPOINT指令`，即实际执行时，将变为：\n\n```\n<ENTRYPOINT> \"<CMD>\"\n```\n\n\n\n### 2.7 ENV设置环境变量\n\nENV指令用于设置环境变量，在后续的指令中，可以直接使用跟这里定义的环境变量。支持环境变量展开的指令包括：`ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。`\n\nENV指令格式有两种：\n\n- `ENV <key> <value>`\n- `ENV <key1>=<value1> <key2>=<value2>...`．eg：`ENV VERSION=1.0 DEBUG=on NAME=\"Happy Feet\"`\n\n注：*对于含有空格的值用双引号括起来*\n\n后续使用时，使用`$符号+key`进行使用，eg：$NAME\n\n\n\n### 2.8 AGR构建参数\n\n构建参数和ENV指令效果一样，都是设置环境变量。不同的是，A`RG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。`\n\n注：*不要使用ARG保存密码之类的，因为`docker history`还是可以看到所有值。*\n\n指令格式：\n\n```\nARG <参数名>[=<默认值>]\n```\n\n\n\nDockerfile中的ARG指令是定义参数名称及默认值，可以在构建命令`docker build`中使用以下参数来覆盖。\n\n```\n--build-arg <参数名>=<值>\n```\n\n\n\n注：*ARG 指令有生效范围，如果在 `FROM` 指令之前指定，那么只能用于 `FROM` 指令中。*\n\n\n\n### 2.9 VOLUME定义匿名卷\n\n`容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的饮用，其数据库文件应该保存于卷中（VOLUME）中。`\n\n为了防止运行时用户忘记将动态文件所保存目录挂在为卷，在Dockerfile中，可以事先指定某些目录挂在为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。\n\n\n\n指令格式为：\n\n- `VOLUME [\"<路径1>\", \"<路径2>\"...]`\n- `VOLUME <路径>`\n\n\n\n在运行时可以通过`-v`覆盖Dockerfile中设置的匿名卷．eg：`docker run -d -v mydata:/data xxxx`．\n\n\n\n### 2.10 EXPOSE暴露端口\n\n`EXPOSE`指令是声明运行时容器提供服务端口（注：<u>这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</u>）。\n\n\n\n指令格式为：\n\n```\nEXPOSE <端口1> [<端口2>...]\n```\n\n\n\n#### 2.10.1 使用EXPOSR声明的好处\n\n- ①、帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。\n- ②、运行时使用随机端口映射时，也就是`docker run -p`命令时，会自动随机映射EXPOSE端口。\n\n\n\n`EXPOSE`和`docker run -p <宿主端口>：<容器端口>的区别`？\n\n- -p：映射宿主端口和容器端口，即将容器对应端口服务公开给外界访问。\n- EXPOSE：仅仅是声明容器打算使用什么端口，并不会自动在宿主进行端口映射。\n\n\n\n### 2.11 WORKDIR指定工作目录\n\n使用`WORKDIR`指令可以指定工作目录（或当前目录），以后各层的当前目录就被改为指定的目录，若该目录不存在，WORKDIR会创建一个目录。\n\n\n\n指令格式为：\n\n```\nWORKDIR <工作目录路径>\n```\n\n注：若 `WORKDIR` 指令使用的相对路径，那么所切换的路径与之前的 `WORKDIR` 有关：\n\n```\nWORKDIR /a\nWORKDIR b\nWORKDIR c\n\nRUN pwd\n```\n\n结果为：`/a/b/c`\n\n\n\n### 2.12 USER指定当前用户\n\n`USER`指令和`WORKDIR`类似，都是改变环境状态并影响以后的层。WORKDIR是改变工作目录，USER则是改变之后层的适应`RUN`,`CMD`以及`ENTRYPOINT`这类命令的身份。\n\n（注：<u>USER只是切换指定用户，这个用户必须存在。</u>）\n\n\n\n指令格式：\n\n```\nUSER <用户名>[:<用户组>]\n```\n\n\n\n### 2.13 HEALTHCHECK健康检查\n\n`HEALTHCHECK`指令是告诉Docker应该如何进行判断容器的状态是否正常，这是Docker 1.12引入的新指令。\n\n\n\n指令格式为：\n\n- `HEALTHCHECK [选项] CMD <命令>`：设置检查容器健康状况的命令，支持的选项包括：\n  - `--interval=<间隔>`：两次健康检查的间隔，默认为 30 秒；\n  - `--timeout=<时长>`：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；\n  - `--retries=<次数>`：当连续失败指定次数后，则将容器状态视为 `unhealthy`，默认 3 次。\n- `HEALTHCHECK NONE`：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令\n\n\n\n### 2.14 ONBUILD 为他人作嫁衣裳\n\n`ONBUILD`是一个特殊的指令，他后面跟的是其他指令，比如RUN、COPY等，<u>在当前进项构建时并不会被执行，只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</u>\n\n\n\n指令格式：\n\n```\nONBUILD <其它指令>\n```\n\n\n\n### 2.15 SHELL 指令\n\nSHELL指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell，Linux 中默认为 `[\"/bin/sh\", \"-c\"]`.\n\n\n\n","slug":"Docker-Dockerfile指令","published":1,"updated":"2020-09-18T01:58:45.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabj0000d45g30fk267j5","content":"<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的 <code>指令(Instruction)</code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>\n<a id=\"more\"></a>\n\n<p>Dockerfile功能很强大，它提供了十多个指令，如FROM, RUN, COPY等等．</p>\n<h2 id=\"2-Dockerfile指令解析\"><a href=\"#2-Dockerfile指令解析\" class=\"headerlink\" title=\"2 Dockerfile指令解析\"></a>2 Dockerfile指令解析</h2><h3 id=\"2-1-FROM指定基础镜像\"><a href=\"#2-1-FROM指定基础镜像\" class=\"headerlink\" title=\"2.1 FROM指定基础镜像\"></a>2.1 FROM指定基础镜像</h3><p><code>FROM</code> 是指定 <strong>基础镜像</strong>，在 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且<code>必须是第一条指令</code>。</p>\n<p>Docker中有一个特殊的镜像，名为<code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，他表示一个空白的镜像．若以scratch为基础镜像，以为这不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>\n<h3 id=\"2-2-RUN执行命令\"><a href=\"#2-2-RUN执行命令\" class=\"headerlink\" title=\"2.2 RUN执行命令\"></a>2.2 RUN执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。</p>\n<p>其格式有两种：</p>\n<ul>\n<li>shell格式：<code>RUN &lt;命令&gt;</code></li>\n<li>exec格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li>\n</ul>\n<p>每一个 <code>RUN</code> 的行为，会新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。因此<code>对于实现同一个目的的多条指令应该使用一个RUN指令，并使用&amp;&amp;将各个所需的命令串联起来</code>．</p>\n<p>Dockerfile支持Shell类的行尾添加 <code>\\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式．</p>\n<p>注意：为了避免镜像过于臃肿，需要在每一层构建结束后清理掉无关的文件．</p>\n<h3 id=\"2-3-COPY复制文件\"><a href=\"#2-3-COPY复制文件\" class=\"headerlink\" title=\"2.3 COPY复制文件\"></a>2.3 COPY复制文件</h3><p> <code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。</p>\n<ul>\n<li><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href=\"https://golang.org/pkg/path/filepath/#Match\"><code>filepath.Match</code></a> 规则．</li>\n<li><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li>\n</ul>\n<p>COPY指令格式有两种：</p>\n<ul>\n<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>\n<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>\n</ul>\n<p><em>注：使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</em></p>\n<h3 id=\"2-4-ADD高级复制文件\"><a href=\"#2-4-ADD高级复制文件\" class=\"headerlink\" title=\"2.4 ADD高级复制文件\"></a>2.4 ADD高级复制文件</h3><p> <code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致，都是实现复制文件．ADD指令增加了一些功能：</p>\n<ul>\n<li>&lt;源路径&gt; 可以是一个 <code>URL</code>：这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整．（<em>若下载的是一个压缩包，需要使用一层RUN指令进行解压</em>）．（<u>此种情况并不推荐，不如直接使用RUN指令，用wget或curl工具下载，处理．</u>）</li>\n<li>&lt;源路径&gt; 为一个 <code>tar</code> 压缩文件<code>：压缩格式为 </code>gzip<code>, </code>bzip2<code>以及</code>xz<code> 的情况下，</code>ADD<code>指令将会自动解压缩这个压缩文件到</code>&lt;目标路径&gt;` 去。</li>\n</ul>\n<p><code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p>\n<h4 id=\"2-4-1-不推荐使用ADD复制文件的原因\"><a href=\"#2-4-1-不推荐使用ADD复制文件的原因\" class=\"headerlink\" title=\"2.4.1 不推荐使用ADD复制文件的原因\"></a>2.4.1 不推荐使用ADD复制文件的原因</h4><ul>\n<li>因为<code>ADD</code> 语义不明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</li>\n<li><code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</li>\n</ul>\n<h3 id=\"2-5-CMD容器启动命令\"><a href=\"#2-5-CMD容器启动命令\" class=\"headerlink\" title=\"2.5 CMD容器启动命令\"></a>2.5 CMD容器启动命令</h3><p> <code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。其格式有两种：</p>\n<ul>\n<li>shell格式：<code>CMD &lt;命令&gt;</code></li>\n<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code>（<u>推荐，因为此类格式会被解析JSON数组，因此一定要使用双引号</u>）</li>\n<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>\n</ul>\n<p>注：在运行时可以指定新的命令来替代镜像设置中的这个默认命令．</p>\n<p><code>示例</code>：Ubuntu镜像默认的CMD是<code>/bin/bash</code>， 如果直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>．</p>\n<h3 id=\"2-6-ENTRYPOINT入口点\"><a href=\"#2-6-ENTRYPOINT入口点\" class=\"headerlink\" title=\"2.6 ENTRYPOINT入口点\"></a>2.6 ENTRYPOINT入口点</h3><p><code>ENTRYPOINT</code>的目的与<code>CMD</code>一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code>在运行时也可以替代，不过比<code>CMD</code>要稍微繁琐一些，需要通过docker run的参数<code>--entrypoint</code>来指定。</p>\n<p>当指定了ENTRYPOINT后，CMD的含义就变了，不再是直接的运行其命令，而是<code>将CMD的内容作为参数传给ENTRYPOINT指令</code>，即实际执行时，将变为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-7-ENV设置环境变量\"><a href=\"#2-7-ENV设置环境变量\" class=\"headerlink\" title=\"2.7 ENV设置环境变量\"></a>2.7 ENV设置环境变量</h3><p>ENV指令用于设置环境变量，在后续的指令中，可以直接使用跟这里定义的环境变量。支持环境变量展开的指令包括：<code>ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。</code></p>\n<p>ENV指令格式有两种：</p>\n<ul>\n<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>\n<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code>．eg：<code>ENV VERSION=1.0 DEBUG=on NAME=&quot;Happy Feet&quot;</code></li>\n</ul>\n<p>注：<em>对于含有空格的值用双引号括起来</em></p>\n<p>后续使用时，使用<code>$符号+key</code>进行使用，eg：$NAME</p>\n<h3 id=\"2-8-AGR构建参数\"><a href=\"#2-8-AGR构建参数\" class=\"headerlink\" title=\"2.8 AGR构建参数\"></a>2.8 AGR构建参数</h3><p>构建参数和ENV指令效果一样，都是设置环境变量。不同的是，A<code>RG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</code></p>\n<p>注：<em>不要使用ARG保存密码之类的，因为<code>docker history</code>还是可以看到所有值。</em></p>\n<p>指令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARG &lt;参数名&gt;[&#x3D;&lt;默认值&gt;]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Dockerfile中的ARG指令是定义参数名称及默认值，可以在构建命令<code>docker build</code>中使用以下参数来覆盖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--build-arg &lt;参数名&gt;&#x3D;&lt;值&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注：<em>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</em></p>\n<h3 id=\"2-9-VOLUME定义匿名卷\"><a href=\"#2-9-VOLUME定义匿名卷\" class=\"headerlink\" title=\"2.9 VOLUME定义匿名卷\"></a>2.9 VOLUME定义匿名卷</h3><p><code>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的饮用，其数据库文件应该保存于卷中（VOLUME）中。</code></p>\n<p>为了防止运行时用户忘记将动态文件所保存目录挂在为卷，在Dockerfile中，可以事先指定某些目录挂在为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>\n<p>指令格式为：</p>\n<ul>\n<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><code>VOLUME &lt;路径&gt;</code></li>\n</ul>\n<p>在运行时可以通过<code>-v</code>覆盖Dockerfile中设置的匿名卷．eg：<code>docker run -d -v mydata:/data xxxx</code>．</p>\n<h3 id=\"2-10-EXPOSE暴露端口\"><a href=\"#2-10-EXPOSE暴露端口\" class=\"headerlink\" title=\"2.10 EXPOSE暴露端口\"></a>2.10 EXPOSE暴露端口</h3><p><code>EXPOSE</code>指令是声明运行时容器提供服务端口（注：<u>这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</u>）。</p>\n<p>指令格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-10-1-使用EXPOSR声明的好处\"><a href=\"#2-10-1-使用EXPOSR声明的好处\" class=\"headerlink\" title=\"2.10.1 使用EXPOSR声明的好处\"></a>2.10.1 使用EXPOSR声明的好处</h4><ul>\n<li>①、帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>\n<li>②、运行时使用随机端口映射时，也就是<code>docker run -p</code>命令时，会自动随机映射EXPOSE端口。</li>\n</ul>\n<p><code>EXPOSE</code>和<code>docker run -p &lt;宿主端口&gt;：&lt;容器端口&gt;的区别</code>？</p>\n<ul>\n<li>-p：映射宿主端口和容器端口，即将容器对应端口服务公开给外界访问。</li>\n<li>EXPOSE：仅仅是声明容器打算使用什么端口，并不会自动在宿主进行端口映射。</li>\n</ul>\n<h3 id=\"2-11-WORKDIR指定工作目录\"><a href=\"#2-11-WORKDIR指定工作目录\" class=\"headerlink\" title=\"2.11 WORKDIR指定工作目录\"></a>2.11 WORKDIR指定工作目录</h3><p>使用<code>WORKDIR</code>指令可以指定工作目录（或当前目录），以后各层的当前目录就被改为指定的目录，若该目录不存在，WORKDIR会创建一个目录。</p>\n<p>指令格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR &lt;工作目录路径&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注：若 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR &#x2F;a</span><br><span class=\"line\">WORKDIR b</span><br><span class=\"line\">WORKDIR c</span><br><span class=\"line\"></span><br><span class=\"line\">RUN pwd</span><br></pre></td></tr></table></figure>\n\n<p>结果为：<code>/a/b/c</code></p>\n<h3 id=\"2-12-USER指定当前用户\"><a href=\"#2-12-USER指定当前用户\" class=\"headerlink\" title=\"2.12 USER指定当前用户\"></a>2.12 USER指定当前用户</h3><p><code>USER</code>指令和<code>WORKDIR</code>类似，都是改变环境状态并影响以后的层。WORKDIR是改变工作目录，USER则是改变之后层的适应<code>RUN</code>,<code>CMD</code>以及<code>ENTRYPOINT</code>这类命令的身份。</p>\n<p>（注：<u>USER只是切换指定用户，这个用户必须存在。</u>）</p>\n<p>指令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-13-HEALTHCHECK健康检查\"><a href=\"#2-13-HEALTHCHECK健康检查\" class=\"headerlink\" title=\"2.13 HEALTHCHECK健康检查\"></a>2.13 HEALTHCHECK健康检查</h3><p><code>HEALTHCHECK</code>指令是告诉Docker应该如何进行判断容器的状态是否正常，这是Docker 1.12引入的新指令。</p>\n<p>指令格式为：</p>\n<ul>\n<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令，支持的选项包括：<ul>\n<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>\n<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>\n<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>\n</ul>\n</li>\n<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>\n</ul>\n<h3 id=\"2-14-ONBUILD-为他人作嫁衣裳\"><a href=\"#2-14-ONBUILD-为他人作嫁衣裳\" class=\"headerlink\" title=\"2.14 ONBUILD 为他人作嫁衣裳\"></a>2.14 ONBUILD 为他人作嫁衣裳</h3><p><code>ONBUILD</code>是一个特殊的指令，他后面跟的是其他指令，比如RUN、COPY等，<u>在当前进项构建时并不会被执行，只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</u></p>\n<p>指令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ONBUILD &lt;其它指令&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-15-SHELL-指令\"><a href=\"#2-15-SHELL-指令\" class=\"headerlink\" title=\"2.15 SHELL 指令\"></a>2.15 SHELL 指令</h3><p>SHELL指令可以指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell，Linux 中默认为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的 <code>指令(Instruction)</code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>","more":"<p>Dockerfile功能很强大，它提供了十多个指令，如FROM, RUN, COPY等等．</p>\n<h2 id=\"2-Dockerfile指令解析\"><a href=\"#2-Dockerfile指令解析\" class=\"headerlink\" title=\"2 Dockerfile指令解析\"></a>2 Dockerfile指令解析</h2><h3 id=\"2-1-FROM指定基础镜像\"><a href=\"#2-1-FROM指定基础镜像\" class=\"headerlink\" title=\"2.1 FROM指定基础镜像\"></a>2.1 FROM指定基础镜像</h3><p><code>FROM</code> 是指定 <strong>基础镜像</strong>，在 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且<code>必须是第一条指令</code>。</p>\n<p>Docker中有一个特殊的镜像，名为<code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，他表示一个空白的镜像．若以scratch为基础镜像，以为这不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>\n<h3 id=\"2-2-RUN执行命令\"><a href=\"#2-2-RUN执行命令\" class=\"headerlink\" title=\"2.2 RUN执行命令\"></a>2.2 RUN执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。</p>\n<p>其格式有两种：</p>\n<ul>\n<li>shell格式：<code>RUN &lt;命令&gt;</code></li>\n<li>exec格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li>\n</ul>\n<p>每一个 <code>RUN</code> 的行为，会新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。因此<code>对于实现同一个目的的多条指令应该使用一个RUN指令，并使用&amp;&amp;将各个所需的命令串联起来</code>．</p>\n<p>Dockerfile支持Shell类的行尾添加 <code>\\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式．</p>\n<p>注意：为了避免镜像过于臃肿，需要在每一层构建结束后清理掉无关的文件．</p>\n<h3 id=\"2-3-COPY复制文件\"><a href=\"#2-3-COPY复制文件\" class=\"headerlink\" title=\"2.3 COPY复制文件\"></a>2.3 COPY复制文件</h3><p> <code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。</p>\n<ul>\n<li><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href=\"https://golang.org/pkg/path/filepath/#Match\"><code>filepath.Match</code></a> 规则．</li>\n<li><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li>\n</ul>\n<p>COPY指令格式有两种：</p>\n<ul>\n<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>\n<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>\n</ul>\n<p><em>注：使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</em></p>\n<h3 id=\"2-4-ADD高级复制文件\"><a href=\"#2-4-ADD高级复制文件\" class=\"headerlink\" title=\"2.4 ADD高级复制文件\"></a>2.4 ADD高级复制文件</h3><p> <code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致，都是实现复制文件．ADD指令增加了一些功能：</p>\n<ul>\n<li>&lt;源路径&gt; 可以是一个 <code>URL</code>：这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整．（<em>若下载的是一个压缩包，需要使用一层RUN指令进行解压</em>）．（<u>此种情况并不推荐，不如直接使用RUN指令，用wget或curl工具下载，处理．</u>）</li>\n<li>&lt;源路径&gt; 为一个 <code>tar</code> 压缩文件<code>：压缩格式为 </code>gzip<code>, </code>bzip2<code>以及</code>xz<code> 的情况下，</code>ADD<code>指令将会自动解压缩这个压缩文件到</code>&lt;目标路径&gt;` 去。</li>\n</ul>\n<p><code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p>\n<h4 id=\"2-4-1-不推荐使用ADD复制文件的原因\"><a href=\"#2-4-1-不推荐使用ADD复制文件的原因\" class=\"headerlink\" title=\"2.4.1 不推荐使用ADD复制文件的原因\"></a>2.4.1 不推荐使用ADD复制文件的原因</h4><ul>\n<li>因为<code>ADD</code> 语义不明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</li>\n<li><code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</li>\n</ul>\n<h3 id=\"2-5-CMD容器启动命令\"><a href=\"#2-5-CMD容器启动命令\" class=\"headerlink\" title=\"2.5 CMD容器启动命令\"></a>2.5 CMD容器启动命令</h3><p> <code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。其格式有两种：</p>\n<ul>\n<li>shell格式：<code>CMD &lt;命令&gt;</code></li>\n<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code>（<u>推荐，因为此类格式会被解析JSON数组，因此一定要使用双引号</u>）</li>\n<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>\n</ul>\n<p>注：在运行时可以指定新的命令来替代镜像设置中的这个默认命令．</p>\n<p><code>示例</code>：Ubuntu镜像默认的CMD是<code>/bin/bash</code>， 如果直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>．</p>\n<h3 id=\"2-6-ENTRYPOINT入口点\"><a href=\"#2-6-ENTRYPOINT入口点\" class=\"headerlink\" title=\"2.6 ENTRYPOINT入口点\"></a>2.6 ENTRYPOINT入口点</h3><p><code>ENTRYPOINT</code>的目的与<code>CMD</code>一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code>在运行时也可以替代，不过比<code>CMD</code>要稍微繁琐一些，需要通过docker run的参数<code>--entrypoint</code>来指定。</p>\n<p>当指定了ENTRYPOINT后，CMD的含义就变了，不再是直接的运行其命令，而是<code>将CMD的内容作为参数传给ENTRYPOINT指令</code>，即实际执行时，将变为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-7-ENV设置环境变量\"><a href=\"#2-7-ENV设置环境变量\" class=\"headerlink\" title=\"2.7 ENV设置环境变量\"></a>2.7 ENV设置环境变量</h3><p>ENV指令用于设置环境变量，在后续的指令中，可以直接使用跟这里定义的环境变量。支持环境变量展开的指令包括：<code>ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。</code></p>\n<p>ENV指令格式有两种：</p>\n<ul>\n<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>\n<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code>．eg：<code>ENV VERSION=1.0 DEBUG=on NAME=&quot;Happy Feet&quot;</code></li>\n</ul>\n<p>注：<em>对于含有空格的值用双引号括起来</em></p>\n<p>后续使用时，使用<code>$符号+key</code>进行使用，eg：$NAME</p>\n<h3 id=\"2-8-AGR构建参数\"><a href=\"#2-8-AGR构建参数\" class=\"headerlink\" title=\"2.8 AGR构建参数\"></a>2.8 AGR构建参数</h3><p>构建参数和ENV指令效果一样，都是设置环境变量。不同的是，A<code>RG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</code></p>\n<p>注：<em>不要使用ARG保存密码之类的，因为<code>docker history</code>还是可以看到所有值。</em></p>\n<p>指令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARG &lt;参数名&gt;[&#x3D;&lt;默认值&gt;]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Dockerfile中的ARG指令是定义参数名称及默认值，可以在构建命令<code>docker build</code>中使用以下参数来覆盖。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--build-arg &lt;参数名&gt;&#x3D;&lt;值&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注：<em>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</em></p>\n<h3 id=\"2-9-VOLUME定义匿名卷\"><a href=\"#2-9-VOLUME定义匿名卷\" class=\"headerlink\" title=\"2.9 VOLUME定义匿名卷\"></a>2.9 VOLUME定义匿名卷</h3><p><code>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的饮用，其数据库文件应该保存于卷中（VOLUME）中。</code></p>\n<p>为了防止运行时用户忘记将动态文件所保存目录挂在为卷，在Dockerfile中，可以事先指定某些目录挂在为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>\n<p>指令格式为：</p>\n<ul>\n<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><code>VOLUME &lt;路径&gt;</code></li>\n</ul>\n<p>在运行时可以通过<code>-v</code>覆盖Dockerfile中设置的匿名卷．eg：<code>docker run -d -v mydata:/data xxxx</code>．</p>\n<h3 id=\"2-10-EXPOSE暴露端口\"><a href=\"#2-10-EXPOSE暴露端口\" class=\"headerlink\" title=\"2.10 EXPOSE暴露端口\"></a>2.10 EXPOSE暴露端口</h3><p><code>EXPOSE</code>指令是声明运行时容器提供服务端口（注：<u>这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</u>）。</p>\n<p>指令格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-10-1-使用EXPOSR声明的好处\"><a href=\"#2-10-1-使用EXPOSR声明的好处\" class=\"headerlink\" title=\"2.10.1 使用EXPOSR声明的好处\"></a>2.10.1 使用EXPOSR声明的好处</h4><ul>\n<li>①、帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>\n<li>②、运行时使用随机端口映射时，也就是<code>docker run -p</code>命令时，会自动随机映射EXPOSE端口。</li>\n</ul>\n<p><code>EXPOSE</code>和<code>docker run -p &lt;宿主端口&gt;：&lt;容器端口&gt;的区别</code>？</p>\n<ul>\n<li>-p：映射宿主端口和容器端口，即将容器对应端口服务公开给外界访问。</li>\n<li>EXPOSE：仅仅是声明容器打算使用什么端口，并不会自动在宿主进行端口映射。</li>\n</ul>\n<h3 id=\"2-11-WORKDIR指定工作目录\"><a href=\"#2-11-WORKDIR指定工作目录\" class=\"headerlink\" title=\"2.11 WORKDIR指定工作目录\"></a>2.11 WORKDIR指定工作目录</h3><p>使用<code>WORKDIR</code>指令可以指定工作目录（或当前目录），以后各层的当前目录就被改为指定的目录，若该目录不存在，WORKDIR会创建一个目录。</p>\n<p>指令格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR &lt;工作目录路径&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注：若 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR &#x2F;a</span><br><span class=\"line\">WORKDIR b</span><br><span class=\"line\">WORKDIR c</span><br><span class=\"line\"></span><br><span class=\"line\">RUN pwd</span><br></pre></td></tr></table></figure>\n\n<p>结果为：<code>/a/b/c</code></p>\n<h3 id=\"2-12-USER指定当前用户\"><a href=\"#2-12-USER指定当前用户\" class=\"headerlink\" title=\"2.12 USER指定当前用户\"></a>2.12 USER指定当前用户</h3><p><code>USER</code>指令和<code>WORKDIR</code>类似，都是改变环境状态并影响以后的层。WORKDIR是改变工作目录，USER则是改变之后层的适应<code>RUN</code>,<code>CMD</code>以及<code>ENTRYPOINT</code>这类命令的身份。</p>\n<p>（注：<u>USER只是切换指定用户，这个用户必须存在。</u>）</p>\n<p>指令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-13-HEALTHCHECK健康检查\"><a href=\"#2-13-HEALTHCHECK健康检查\" class=\"headerlink\" title=\"2.13 HEALTHCHECK健康检查\"></a>2.13 HEALTHCHECK健康检查</h3><p><code>HEALTHCHECK</code>指令是告诉Docker应该如何进行判断容器的状态是否正常，这是Docker 1.12引入的新指令。</p>\n<p>指令格式为：</p>\n<ul>\n<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令，支持的选项包括：<ul>\n<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>\n<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>\n<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>\n</ul>\n</li>\n<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>\n</ul>\n<h3 id=\"2-14-ONBUILD-为他人作嫁衣裳\"><a href=\"#2-14-ONBUILD-为他人作嫁衣裳\" class=\"headerlink\" title=\"2.14 ONBUILD 为他人作嫁衣裳\"></a>2.14 ONBUILD 为他人作嫁衣裳</h3><p><code>ONBUILD</code>是一个特殊的指令，他后面跟的是其他指令，比如RUN、COPY等，<u>在当前进项构建时并不会被执行，只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</u></p>\n<p>指令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ONBUILD &lt;其它指令&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-15-SHELL-指令\"><a href=\"#2-15-SHELL-指令\" class=\"headerlink\" title=\"2.15 SHELL 指令\"></a>2.15 SHELL 指令</h3><p>SHELL指令可以指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell，Linux 中默认为 <code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>.</p>"},{"title":"Docker-容器","date":"2020-09-16T09:26:46.000Z","_content":"\n\n\n### 1 概述\n\n容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。\n\n<!--more-->\n\n\n\n### 2 启动容器\n\n`容器的启动有以下两种情况`：\n\n- ①、基于镜像新建一个容器并启动\n- ②、将在终止状态的容器重新启动\n\n\n\n#### 2.1 基于镜像新建容器并启动\n\n使用docker run命令新建并启动一个容器的，其语法格式为：\n\n```\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n```\n\n常用OPTIONS：\n\n- -t（--tty）：Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上．\n- -i（--interactive）：让容器的标准输入保持打开（交互模式）．eg：以交互式方式打开启动一个容器：`docker run -t -i ubuntu:18.04 /bin/bash`\n- -d（--detach）：后台运行容器，并返回容器ID．eg：`docker run -d ubuntu:18.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"`\n\n\n\n##### 2.1.1 Docker在后台运行的标准操作\n\n当利用 `docker run` 来创建容器时，Docker 在后台运行的标准操作包括：\n\n- 检查本地是否存在指定的镜像，不存在就从公有仓库下载\n- 利用镜像创建并启动一个容器\n- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层\n- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去\n- 从地址池配置一个 ip 地址给容器\n- 执行用户指定的应用程序\n- 执行完毕后容器被终止\n\n\n\n#### 2.2 启动已终止的容器\n\n使用 `docker container start` 命令，直接将一个已经终止的容器启动运行．其语法格式为：\n\n```\ndocker container start [OPTIONS] CONTAINER [CONTAINER...]\n```\n\n常用OPTIONS：\n\n- -a（--attach）：指定标准输入输出内容类型，可选 `STDOUT`/`STDERR` ；\n\n\n\n### 3 终止容器\n\n使用 `docker container stop` 来终止一个或多个运行中的容器，其语法格式为：\n\n```\ndocker container stop [OPTIONS] CONTAINER [CONTAINER...]\n```\n\nOPTIONS：\n\n- -t（--time）：终止容器前的等待时间，单位秒（默认10s）．\n\n\n\n### 4 重启一个容器\n\n使用 `docker container restart` 来重启一个或多个运行中的容器，其语法格式为：\n\n```\ndocker container restart [OPTIONS] CONTAINER [CONTAINER...]\n```\n\nOPTIONS：\n\n- -t（--time）：终止容器前的等待时间，单位秒（默认10s）．\n\n\n\n注： `docker container restart` 命令会将一个运行态的容器终止，然后再重新启动它。\n\n\n\n### 5 进入容器\n\n在使用 `-d` 参数启动容器后会进入后台。Docker提供了两种方式进入容器进行操作，分别是：\n\n- `docker attach`（不推荐）\n- `docker exec`\n\n#### 5.1 attach 命令\n\nattach命令的语法格式如下：\n\n```\ndocker attach [OPTIONS] CONTAINER\n```\n\n注：<u>如果从这个 stdin 中 exit，会导致容器的停止。</u>因此，不推荐使用attach命令．\n\n\n\n#### 5.2 exec命令\n\nexec命令的语法格式如下：\n\n```\ndocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n```\n\n常用OPTIONS：\n\n- -i（--interactive）：保持标准输入状态．\n- -t（--tty）：分配一个伪终端，与`-i`联合使用可实现交互式模式．eg：`docker exec -i 69d1 bash`\n\n\n\n### 6 删除容器\n\n使用 `docker container rm` 来删除一个或多个容器．其语法格式为：\n\n```\ndocker container rm [OPTIONS] CONTAINER [CONTAINER...]\n```\n\n常用OPTIONS：\n\n- -f（--force）：强制删除一个容器（删除一个运行中的容器）．\n\n\n\n#### 6.1 删除所有处于终止状态的容器\n\ndocker container prune用于删除所有处于终止状态的容器，其语法格式如下：\n\n```\ndocker container prune [OPTIONS]\n```\n\n常用OPTIONS:\n\n- --filter：提供过滤值．\n\n\n\n### 7 容器管理\n\n使用docker container对容器进行管理，其语法格式为：\n\n```\ndocker container COMMAND\n```\n\n常用的COMMAND：\n\n- start：启动一个或多个终止状态的容器．\n- stop：终止一个或多个运行中的容器．\n- restart：重启一个或多个运行中的容器．\n- rm：删除一个或多个容器．\n- prune：删除所有处于终止状态的容器．\n- ls：查看容器信息．\n- logs：获取容器的输出信息（获取后台运行的容器的输出信息）．格式：`docker container logs [OPTIONS] CONTAINER`\n\n","source":"_posts/Docker-容器.md","raw":"---\ntitle: Docker-容器\ndate: 2020-09-16 17:26:46\ntags: [\"Docker\"]\ncategories: [\"Docker\"]\n---\n\n\n\n### 1 概述\n\n容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。\n\n<!--more-->\n\n\n\n### 2 启动容器\n\n`容器的启动有以下两种情况`：\n\n- ①、基于镜像新建一个容器并启动\n- ②、将在终止状态的容器重新启动\n\n\n\n#### 2.1 基于镜像新建容器并启动\n\n使用docker run命令新建并启动一个容器的，其语法格式为：\n\n```\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n```\n\n常用OPTIONS：\n\n- -t（--tty）：Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上．\n- -i（--interactive）：让容器的标准输入保持打开（交互模式）．eg：以交互式方式打开启动一个容器：`docker run -t -i ubuntu:18.04 /bin/bash`\n- -d（--detach）：后台运行容器，并返回容器ID．eg：`docker run -d ubuntu:18.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"`\n\n\n\n##### 2.1.1 Docker在后台运行的标准操作\n\n当利用 `docker run` 来创建容器时，Docker 在后台运行的标准操作包括：\n\n- 检查本地是否存在指定的镜像，不存在就从公有仓库下载\n- 利用镜像创建并启动一个容器\n- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层\n- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去\n- 从地址池配置一个 ip 地址给容器\n- 执行用户指定的应用程序\n- 执行完毕后容器被终止\n\n\n\n#### 2.2 启动已终止的容器\n\n使用 `docker container start` 命令，直接将一个已经终止的容器启动运行．其语法格式为：\n\n```\ndocker container start [OPTIONS] CONTAINER [CONTAINER...]\n```\n\n常用OPTIONS：\n\n- -a（--attach）：指定标准输入输出内容类型，可选 `STDOUT`/`STDERR` ；\n\n\n\n### 3 终止容器\n\n使用 `docker container stop` 来终止一个或多个运行中的容器，其语法格式为：\n\n```\ndocker container stop [OPTIONS] CONTAINER [CONTAINER...]\n```\n\nOPTIONS：\n\n- -t（--time）：终止容器前的等待时间，单位秒（默认10s）．\n\n\n\n### 4 重启一个容器\n\n使用 `docker container restart` 来重启一个或多个运行中的容器，其语法格式为：\n\n```\ndocker container restart [OPTIONS] CONTAINER [CONTAINER...]\n```\n\nOPTIONS：\n\n- -t（--time）：终止容器前的等待时间，单位秒（默认10s）．\n\n\n\n注： `docker container restart` 命令会将一个运行态的容器终止，然后再重新启动它。\n\n\n\n### 5 进入容器\n\n在使用 `-d` 参数启动容器后会进入后台。Docker提供了两种方式进入容器进行操作，分别是：\n\n- `docker attach`（不推荐）\n- `docker exec`\n\n#### 5.1 attach 命令\n\nattach命令的语法格式如下：\n\n```\ndocker attach [OPTIONS] CONTAINER\n```\n\n注：<u>如果从这个 stdin 中 exit，会导致容器的停止。</u>因此，不推荐使用attach命令．\n\n\n\n#### 5.2 exec命令\n\nexec命令的语法格式如下：\n\n```\ndocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n```\n\n常用OPTIONS：\n\n- -i（--interactive）：保持标准输入状态．\n- -t（--tty）：分配一个伪终端，与`-i`联合使用可实现交互式模式．eg：`docker exec -i 69d1 bash`\n\n\n\n### 6 删除容器\n\n使用 `docker container rm` 来删除一个或多个容器．其语法格式为：\n\n```\ndocker container rm [OPTIONS] CONTAINER [CONTAINER...]\n```\n\n常用OPTIONS：\n\n- -f（--force）：强制删除一个容器（删除一个运行中的容器）．\n\n\n\n#### 6.1 删除所有处于终止状态的容器\n\ndocker container prune用于删除所有处于终止状态的容器，其语法格式如下：\n\n```\ndocker container prune [OPTIONS]\n```\n\n常用OPTIONS:\n\n- --filter：提供过滤值．\n\n\n\n### 7 容器管理\n\n使用docker container对容器进行管理，其语法格式为：\n\n```\ndocker container COMMAND\n```\n\n常用的COMMAND：\n\n- start：启动一个或多个终止状态的容器．\n- stop：终止一个或多个运行中的容器．\n- restart：重启一个或多个运行中的容器．\n- rm：删除一个或多个容器．\n- prune：删除所有处于终止状态的容器．\n- ls：查看容器信息．\n- logs：获取容器的输出信息（获取后台运行的容器的输出信息）．格式：`docker container logs [OPTIONS] CONTAINER`\n\n","slug":"Docker-容器","published":1,"updated":"2020-09-18T10:16:31.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabj1000e45g32q3fhgf6","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>\n<a id=\"more\"></a>\n\n\n\n<h3 id=\"2-启动容器\"><a href=\"#2-启动容器\" class=\"headerlink\" title=\"2 启动容器\"></a>2 启动容器</h3><p><code>容器的启动有以下两种情况</code>：</p>\n<ul>\n<li>①、基于镜像新建一个容器并启动</li>\n<li>②、将在终止状态的容器重新启动</li>\n</ul>\n<h4 id=\"2-1-基于镜像新建容器并启动\"><a href=\"#2-1-基于镜像新建容器并启动\" class=\"headerlink\" title=\"2.1 基于镜像新建容器并启动\"></a>2.1 基于镜像新建容器并启动</h4><p>使用docker run命令新建并启动一个容器的，其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li>-t（–tty）：Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上．</li>\n<li>-i（–interactive）：让容器的标准输入保持打开（交互模式）．eg：以交互式方式打开启动一个容器：<code>docker run -t -i ubuntu:18.04 /bin/bash</code></li>\n<li>-d（–detach）：后台运行容器，并返回容器ID．eg：<code>docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></li>\n</ul>\n<h5 id=\"2-1-1-Docker在后台运行的标准操作\"><a href=\"#2-1-1-Docker在后台运行的标准操作\" class=\"headerlink\" title=\"2.1.1 Docker在后台运行的标准操作\"></a>2.1.1 Docker在后台运行的标准操作</h5><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>\n<ul>\n<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>\n<li>利用镜像创建并启动一个容器</li>\n<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>\n<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>\n<li>从地址池配置一个 ip 地址给容器</li>\n<li>执行用户指定的应用程序</li>\n<li>执行完毕后容器被终止</li>\n</ul>\n<h4 id=\"2-2-启动已终止的容器\"><a href=\"#2-2-启动已终止的容器\" class=\"headerlink\" title=\"2.2 启动已终止的容器\"></a>2.2 启动已终止的容器</h4><p>使用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行．其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li>-a（–attach）：指定标准输入输出内容类型，可选 <code>STDOUT</code>/<code>STDERR</code> ；</li>\n</ul>\n<h3 id=\"3-终止容器\"><a href=\"#3-终止容器\" class=\"headerlink\" title=\"3 终止容器\"></a>3 终止容器</h3><p>使用 <code>docker container stop</code> 来终止一个或多个运行中的容器，其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>\n\n<p>OPTIONS：</p>\n<ul>\n<li>-t（–time）：终止容器前的等待时间，单位秒（默认10s）．</li>\n</ul>\n<h3 id=\"4-重启一个容器\"><a href=\"#4-重启一个容器\" class=\"headerlink\" title=\"4 重启一个容器\"></a>4 重启一个容器</h3><p>使用 <code>docker container restart</code> 来重启一个或多个运行中的容器，其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>\n\n<p>OPTIONS：</p>\n<ul>\n<li>-t（–time）：终止容器前的等待时间，单位秒（默认10s）．</li>\n</ul>\n<p>注： <code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>\n<h3 id=\"5-进入容器\"><a href=\"#5-进入容器\" class=\"headerlink\" title=\"5 进入容器\"></a>5 进入容器</h3><p>在使用 <code>-d</code> 参数启动容器后会进入后台。Docker提供了两种方式进入容器进行操作，分别是：</p>\n<ul>\n<li><code>docker attach</code>（不推荐）</li>\n<li><code>docker exec</code></li>\n</ul>\n<h4 id=\"5-1-attach-命令\"><a href=\"#5-1-attach-命令\" class=\"headerlink\" title=\"5.1 attach 命令\"></a>5.1 attach 命令</h4><p>attach命令的语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>\n\n<p>注：<u>如果从这个 stdin 中 exit，会导致容器的停止。</u>因此，不推荐使用attach命令．</p>\n<h4 id=\"5-2-exec命令\"><a href=\"#5-2-exec命令\" class=\"headerlink\" title=\"5.2 exec命令\"></a>5.2 exec命令</h4><p>exec命令的语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li>-i（–interactive）：保持标准输入状态．</li>\n<li>-t（–tty）：分配一个伪终端，与<code>-i</code>联合使用可实现交互式模式．eg：<code>docker exec -i 69d1 bash</code></li>\n</ul>\n<h3 id=\"6-删除容器\"><a href=\"#6-删除容器\" class=\"headerlink\" title=\"6 删除容器\"></a>6 删除容器</h3><p>使用 <code>docker container rm</code> 来删除一个或多个容器．其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li>-f（–force）：强制删除一个容器（删除一个运行中的容器）．</li>\n</ul>\n<h4 id=\"6-1-删除所有处于终止状态的容器\"><a href=\"#6-1-删除所有处于终止状态的容器\" class=\"headerlink\" title=\"6.1 删除所有处于终止状态的容器\"></a>6.1 删除所有处于终止状态的容器</h4><p>docker container prune用于删除所有处于终止状态的容器，其语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container prune [OPTIONS]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS:</p>\n<ul>\n<li>–filter：提供过滤值．</li>\n</ul>\n<h3 id=\"7-容器管理\"><a href=\"#7-容器管理\" class=\"headerlink\" title=\"7 容器管理\"></a>7 容器管理</h3><p>使用docker container对容器进行管理，其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container COMMAND</span><br></pre></td></tr></table></figure>\n\n<p>常用的COMMAND：</p>\n<ul>\n<li>start：启动一个或多个终止状态的容器．</li>\n<li>stop：终止一个或多个运行中的容器．</li>\n<li>restart：重启一个或多个运行中的容器．</li>\n<li>rm：删除一个或多个容器．</li>\n<li>prune：删除所有处于终止状态的容器．</li>\n<li>ls：查看容器信息．</li>\n<li>logs：获取容器的输出信息（获取后台运行的容器的输出信息）．格式：<code>docker container logs [OPTIONS] CONTAINER</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>","more":"<h3 id=\"2-启动容器\"><a href=\"#2-启动容器\" class=\"headerlink\" title=\"2 启动容器\"></a>2 启动容器</h3><p><code>容器的启动有以下两种情况</code>：</p>\n<ul>\n<li>①、基于镜像新建一个容器并启动</li>\n<li>②、将在终止状态的容器重新启动</li>\n</ul>\n<h4 id=\"2-1-基于镜像新建容器并启动\"><a href=\"#2-1-基于镜像新建容器并启动\" class=\"headerlink\" title=\"2.1 基于镜像新建容器并启动\"></a>2.1 基于镜像新建容器并启动</h4><p>使用docker run命令新建并启动一个容器的，其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li>-t（–tty）：Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上．</li>\n<li>-i（–interactive）：让容器的标准输入保持打开（交互模式）．eg：以交互式方式打开启动一个容器：<code>docker run -t -i ubuntu:18.04 /bin/bash</code></li>\n<li>-d（–detach）：后台运行容器，并返回容器ID．eg：<code>docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></li>\n</ul>\n<h5 id=\"2-1-1-Docker在后台运行的标准操作\"><a href=\"#2-1-1-Docker在后台运行的标准操作\" class=\"headerlink\" title=\"2.1.1 Docker在后台运行的标准操作\"></a>2.1.1 Docker在后台运行的标准操作</h5><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>\n<ul>\n<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>\n<li>利用镜像创建并启动一个容器</li>\n<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>\n<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>\n<li>从地址池配置一个 ip 地址给容器</li>\n<li>执行用户指定的应用程序</li>\n<li>执行完毕后容器被终止</li>\n</ul>\n<h4 id=\"2-2-启动已终止的容器\"><a href=\"#2-2-启动已终止的容器\" class=\"headerlink\" title=\"2.2 启动已终止的容器\"></a>2.2 启动已终止的容器</h4><p>使用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行．其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li>-a（–attach）：指定标准输入输出内容类型，可选 <code>STDOUT</code>/<code>STDERR</code> ；</li>\n</ul>\n<h3 id=\"3-终止容器\"><a href=\"#3-终止容器\" class=\"headerlink\" title=\"3 终止容器\"></a>3 终止容器</h3><p>使用 <code>docker container stop</code> 来终止一个或多个运行中的容器，其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>\n\n<p>OPTIONS：</p>\n<ul>\n<li>-t（–time）：终止容器前的等待时间，单位秒（默认10s）．</li>\n</ul>\n<h3 id=\"4-重启一个容器\"><a href=\"#4-重启一个容器\" class=\"headerlink\" title=\"4 重启一个容器\"></a>4 重启一个容器</h3><p>使用 <code>docker container restart</code> 来重启一个或多个运行中的容器，其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>\n\n<p>OPTIONS：</p>\n<ul>\n<li>-t（–time）：终止容器前的等待时间，单位秒（默认10s）．</li>\n</ul>\n<p>注： <code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>\n<h3 id=\"5-进入容器\"><a href=\"#5-进入容器\" class=\"headerlink\" title=\"5 进入容器\"></a>5 进入容器</h3><p>在使用 <code>-d</code> 参数启动容器后会进入后台。Docker提供了两种方式进入容器进行操作，分别是：</p>\n<ul>\n<li><code>docker attach</code>（不推荐）</li>\n<li><code>docker exec</code></li>\n</ul>\n<h4 id=\"5-1-attach-命令\"><a href=\"#5-1-attach-命令\" class=\"headerlink\" title=\"5.1 attach 命令\"></a>5.1 attach 命令</h4><p>attach命令的语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>\n\n<p>注：<u>如果从这个 stdin 中 exit，会导致容器的停止。</u>因此，不推荐使用attach命令．</p>\n<h4 id=\"5-2-exec命令\"><a href=\"#5-2-exec命令\" class=\"headerlink\" title=\"5.2 exec命令\"></a>5.2 exec命令</h4><p>exec命令的语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li>-i（–interactive）：保持标准输入状态．</li>\n<li>-t（–tty）：分配一个伪终端，与<code>-i</code>联合使用可实现交互式模式．eg：<code>docker exec -i 69d1 bash</code></li>\n</ul>\n<h3 id=\"6-删除容器\"><a href=\"#6-删除容器\" class=\"headerlink\" title=\"6 删除容器\"></a>6 删除容器</h3><p>使用 <code>docker container rm</code> 来删除一个或多个容器．其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li>-f（–force）：强制删除一个容器（删除一个运行中的容器）．</li>\n</ul>\n<h4 id=\"6-1-删除所有处于终止状态的容器\"><a href=\"#6-1-删除所有处于终止状态的容器\" class=\"headerlink\" title=\"6.1 删除所有处于终止状态的容器\"></a>6.1 删除所有处于终止状态的容器</h4><p>docker container prune用于删除所有处于终止状态的容器，其语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container prune [OPTIONS]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS:</p>\n<ul>\n<li>–filter：提供过滤值．</li>\n</ul>\n<h3 id=\"7-容器管理\"><a href=\"#7-容器管理\" class=\"headerlink\" title=\"7 容器管理\"></a>7 容器管理</h3><p>使用docker container对容器进行管理，其语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container COMMAND</span><br></pre></td></tr></table></figure>\n\n<p>常用的COMMAND：</p>\n<ul>\n<li>start：启动一个或多个终止状态的容器．</li>\n<li>stop：终止一个或多个运行中的容器．</li>\n<li>restart：重启一个或多个运行中的容器．</li>\n<li>rm：删除一个或多个容器．</li>\n<li>prune：删除所有处于终止状态的容器．</li>\n<li>ls：查看容器信息．</li>\n<li>logs：获取容器的输出信息（获取后台运行的容器的输出信息）．格式：<code>docker container logs [OPTIONS] CONTAINER</code></li>\n</ul>"},{"title":"Docker-是什么？","date":"2020-09-16T03:54:52.000Z","_content":"\n\n\n#### 1 Docker是什么\n\nDocker是使用Google推出的Go语言开发的，基于Linux内核的cgroup, namespace,OverlayFS类的Union FS等技术，对进程进行封装隔离的操作系统层面的虚拟化技术．\n\n<!--more-->\n\n由于隔离的进程独立于宿主和其他的隔离程序的进程，因此也称为`容器`．\n\n\n\n##### 1.1 Docker与传统虚拟化方式的不同点\n\n`Docker作为一种新兴的虚拟化技术，与传统的虚拟机技术相比有那些不同点呢？`\n\n- `传统虚拟机技术`是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上在运行所需应用进程。\n- `Docker`的应用进程直接运行在宿主的内核，容器内没有自己的内核，而且没有进行硬件虚拟，相比传统虚拟机更加轻便。\n\n\n\n##### 1.2 Docker相比虚拟机的优势\n\n- `更高效的利用系统资源`：容器不需要进行硬件虚拟及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。\n- `更快速的启动时间`：虚拟机启动应用服务往往需要数分钟；Docker容器应用，直接运行于宿主内核，无需启动完整的操作系统，启动时间可以做到秒或毫秒级。\n- `一致的运行环境`：Docker的镜像提供除了内核外完整的运行时环境，确保了应用运行环境一致性。\n- `持续交付和部署`：使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试；运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。\n- `更轻松的迁移`：Docker确保了执行环境的一致性，使得应用的迁移更加容易。\n- `更轻松的维护扩展`：Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更加容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单.\n\n\n\n#### ２ Docker的三大核心概念\n\n- `镜像（Image）`：Docker镜像是一个reshuffle的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包括了一些为运行时准备的一些配置参数（如：匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n- `容器（Container）`：容器的是指是进程，但与直接在宿主机执行的进程不同，容器进程运行于属于自己的独立的命名空间。容器拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主机运行更加安全。\n- `仓库（Repository）`：集中的存储、分发镜像的地方。\n\n\n\n\n\n------\n\n#### 参考资料：\n\n [Docker —— 从入门到实践](https://yeasy.gitbook.io/docker_practice/)\n\n[十分钟看懂Docker和K8S](https://zhuanlan.zhihu.com/p/185752438)","source":"_posts/Docker-是什么？.md","raw":"---\ntitle: Docker-是什么？\ndate: 2020-09-16 11:54:52\ntags: [\"Docker\"]\ncategories: [\"Docker\"]\n---\n\n\n\n#### 1 Docker是什么\n\nDocker是使用Google推出的Go语言开发的，基于Linux内核的cgroup, namespace,OverlayFS类的Union FS等技术，对进程进行封装隔离的操作系统层面的虚拟化技术．\n\n<!--more-->\n\n由于隔离的进程独立于宿主和其他的隔离程序的进程，因此也称为`容器`．\n\n\n\n##### 1.1 Docker与传统虚拟化方式的不同点\n\n`Docker作为一种新兴的虚拟化技术，与传统的虚拟机技术相比有那些不同点呢？`\n\n- `传统虚拟机技术`是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上在运行所需应用进程。\n- `Docker`的应用进程直接运行在宿主的内核，容器内没有自己的内核，而且没有进行硬件虚拟，相比传统虚拟机更加轻便。\n\n\n\n##### 1.2 Docker相比虚拟机的优势\n\n- `更高效的利用系统资源`：容器不需要进行硬件虚拟及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。\n- `更快速的启动时间`：虚拟机启动应用服务往往需要数分钟；Docker容器应用，直接运行于宿主内核，无需启动完整的操作系统，启动时间可以做到秒或毫秒级。\n- `一致的运行环境`：Docker的镜像提供除了内核外完整的运行时环境，确保了应用运行环境一致性。\n- `持续交付和部署`：使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试；运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。\n- `更轻松的迁移`：Docker确保了执行环境的一致性，使得应用的迁移更加容易。\n- `更轻松的维护扩展`：Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更加容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单.\n\n\n\n#### ２ Docker的三大核心概念\n\n- `镜像（Image）`：Docker镜像是一个reshuffle的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包括了一些为运行时准备的一些配置参数（如：匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n- `容器（Container）`：容器的是指是进程，但与直接在宿主机执行的进程不同，容器进程运行于属于自己的独立的命名空间。容器拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主机运行更加安全。\n- `仓库（Repository）`：集中的存储、分发镜像的地方。\n\n\n\n\n\n------\n\n#### 参考资料：\n\n [Docker —— 从入门到实践](https://yeasy.gitbook.io/docker_practice/)\n\n[十分钟看懂Docker和K8S](https://zhuanlan.zhihu.com/p/185752438)","slug":"Docker-是什么？","published":1,"updated":"2020-09-17T08:13:49.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkb001m45g37sq76vsx","content":"<h4 id=\"1-Docker是什么\"><a href=\"#1-Docker是什么\" class=\"headerlink\" title=\"1 Docker是什么\"></a>1 Docker是什么</h4><p>Docker是使用Google推出的Go语言开发的，基于Linux内核的cgroup, namespace,OverlayFS类的Union FS等技术，对进程进行封装隔离的操作系统层面的虚拟化技术．</p>\n<a id=\"more\"></a>\n\n<p>由于隔离的进程独立于宿主和其他的隔离程序的进程，因此也称为<code>容器</code>．</p>\n<h5 id=\"1-1-Docker与传统虚拟化方式的不同点\"><a href=\"#1-1-Docker与传统虚拟化方式的不同点\" class=\"headerlink\" title=\"1.1 Docker与传统虚拟化方式的不同点\"></a>1.1 Docker与传统虚拟化方式的不同点</h5><p><code>Docker作为一种新兴的虚拟化技术，与传统的虚拟机技术相比有那些不同点呢？</code></p>\n<ul>\n<li><code>传统虚拟机技术</code>是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上在运行所需应用进程。</li>\n<li><code>Docker</code>的应用进程直接运行在宿主的内核，容器内没有自己的内核，而且没有进行硬件虚拟，相比传统虚拟机更加轻便。</li>\n</ul>\n<h5 id=\"1-2-Docker相比虚拟机的优势\"><a href=\"#1-2-Docker相比虚拟机的优势\" class=\"headerlink\" title=\"1.2 Docker相比虚拟机的优势\"></a>1.2 Docker相比虚拟机的优势</h5><ul>\n<li><code>更高效的利用系统资源</code>：容器不需要进行硬件虚拟及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。</li>\n<li><code>更快速的启动时间</code>：虚拟机启动应用服务往往需要数分钟；Docker容器应用，直接运行于宿主内核，无需启动完整的操作系统，启动时间可以做到秒或毫秒级。</li>\n<li><code>一致的运行环境</code>：Docker的镜像提供除了内核外完整的运行时环境，确保了应用运行环境一致性。</li>\n<li><code>持续交付和部署</code>：使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试；运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。</li>\n<li><code>更轻松的迁移</code>：Docker确保了执行环境的一致性，使得应用的迁移更加容易。</li>\n<li><code>更轻松的维护扩展</code>：Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更加容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单.</li>\n</ul>\n<h4 id=\"２-Docker的三大核心概念\"><a href=\"#２-Docker的三大核心概念\" class=\"headerlink\" title=\"２ Docker的三大核心概念\"></a>２ Docker的三大核心概念</h4><ul>\n<li><code>镜像（Image）</code>：Docker镜像是一个reshuffle的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包括了一些为运行时准备的一些配置参数（如：匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li>\n<li><code>容器（Container）</code>：容器的是指是进程，但与直接在宿主机执行的进程不同，容器进程运行于属于自己的独立的命名空间。容器拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主机运行更加安全。</li>\n<li><code>仓库（Repository）</code>：集中的存储、分发镜像的地方。</li>\n</ul>\n<hr>\n<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p> <a href=\"https://yeasy.gitbook.io/docker_practice/\">Docker —— 从入门到实践</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/185752438\">十分钟看懂Docker和K8S</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-Docker是什么\"><a href=\"#1-Docker是什么\" class=\"headerlink\" title=\"1 Docker是什么\"></a>1 Docker是什么</h4><p>Docker是使用Google推出的Go语言开发的，基于Linux内核的cgroup, namespace,OverlayFS类的Union FS等技术，对进程进行封装隔离的操作系统层面的虚拟化技术．</p>","more":"<p>由于隔离的进程独立于宿主和其他的隔离程序的进程，因此也称为<code>容器</code>．</p>\n<h5 id=\"1-1-Docker与传统虚拟化方式的不同点\"><a href=\"#1-1-Docker与传统虚拟化方式的不同点\" class=\"headerlink\" title=\"1.1 Docker与传统虚拟化方式的不同点\"></a>1.1 Docker与传统虚拟化方式的不同点</h5><p><code>Docker作为一种新兴的虚拟化技术，与传统的虚拟机技术相比有那些不同点呢？</code></p>\n<ul>\n<li><code>传统虚拟机技术</code>是虚拟出一套硬件后，在其上运行一个完整的操作系统，在该系统上在运行所需应用进程。</li>\n<li><code>Docker</code>的应用进程直接运行在宿主的内核，容器内没有自己的内核，而且没有进行硬件虚拟，相比传统虚拟机更加轻便。</li>\n</ul>\n<h5 id=\"1-2-Docker相比虚拟机的优势\"><a href=\"#1-2-Docker相比虚拟机的优势\" class=\"headerlink\" title=\"1.2 Docker相比虚拟机的优势\"></a>1.2 Docker相比虚拟机的优势</h5><ul>\n<li><code>更高效的利用系统资源</code>：容器不需要进行硬件虚拟及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。</li>\n<li><code>更快速的启动时间</code>：虚拟机启动应用服务往往需要数分钟；Docker容器应用，直接运行于宿主内核，无需启动完整的操作系统，启动时间可以做到秒或毫秒级。</li>\n<li><code>一致的运行环境</code>：Docker的镜像提供除了内核外完整的运行时环境，确保了应用运行环境一致性。</li>\n<li><code>持续交付和部署</code>：使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试；运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。</li>\n<li><code>更轻松的迁移</code>：Docker确保了执行环境的一致性，使得应用的迁移更加容易。</li>\n<li><code>更轻松的维护扩展</code>：Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更加容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单.</li>\n</ul>\n<h4 id=\"２-Docker的三大核心概念\"><a href=\"#２-Docker的三大核心概念\" class=\"headerlink\" title=\"２ Docker的三大核心概念\"></a>２ Docker的三大核心概念</h4><ul>\n<li><code>镜像（Image）</code>：Docker镜像是一个reshuffle的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包括了一些为运行时准备的一些配置参数（如：匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li>\n<li><code>容器（Container）</code>：容器的是指是进程，但与直接在宿主机执行的进程不同，容器进程运行于属于自己的独立的命名空间。容器拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主机运行更加安全。</li>\n<li><code>仓库（Repository）</code>：集中的存储、分发镜像的地方。</li>\n</ul>\n<hr>\n<h4 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h4><p> <a href=\"https://yeasy.gitbook.io/docker_practice/\">Docker —— 从入门到实践</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/185752438\">十分钟看懂Docker和K8S</a></p>"},{"title":"Docker-错误处理","date":"2020-09-16T09:57:09.000Z","_content":"\n\n\n记录一些遇见的错误，及解决方法．\n\n<!--more-->\n\n#### 1 删除镜像错误\n\n##### 1.1 image is being used by stopped container <xxx>\n\n`报错信息`：\n\n```bash\n$ sudo docker image rm 1345a7ba5eb6\nError response from daemon: conflict: unable to delete 1345a7ba5eb6 (must be forced) - image is being used by stopped container 69bbed5c06aa\n```\n\n`报错原因`：要删除的镜像正在被容器使用．\n\n\n\n`解决方法`：删除正在使用镜像的容器，再进行镜像的删除．\n\n- 执行`docker ps -a`命令查看所有容器（包括未运行的容器），找到是哪个容器正在使用这个要删除的镜像(列出的第二列信息即为镜像名称)．\n- 执行`docker rm <容器id>`命令删除指定容器．\n\n\n\n##### 1.2 image is referenced in multiple repositories\n\n`报错信息`：\n\n```bash\n$ sudo docker image rm $(sudo docker image ls -q)\nError response from daemon: conflict: unable to delete 4e5021d210f6 (must be forced) - image is referenced in multiple repositories\n```\n\n\n\n`报错原因`：两个仓库指向了同一个镜像id，如下所示：\n\n```bash\n$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nubuntu              18.04               4e5021d210f6        6 months ago        64.2MB\nubuntu              latest              4e5021d210f6        6 months ago        64.2MB\n```\n\n\n\n`解决方法`：通过指定`仓库名：标签`的方式进行删除．\n\n```bash\n$ sudo docker image rm ubuntu:18.04\n```\n\n\n\n#### 2 拉取镜像错误\n\n##### 2.1 read: connection timed out\n\n`报错信息`：\n\n```bash\n$ sudo docker pull ubuntu:18.04\n18.04: Pulling from library/ubuntu\n5d9821c94847: Downloading  4.173MB/26.7MB\na610eae58dfc: Download complete \na40e0eb9f140: Download complete \nerror pulling image configuration: Get https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/c1/c14bccfdea1cc6aee142cd95f4069b6ada6b57e484e7886391816e1eba856950/data?verify=1600417610-ZVyDnSC2hWAtmSPbiNbhg4MHxGM%3D: read tcp 172.20.33.9:58120->104.18.124.25:443: read: connection timed out\n```\n\n`报错原因`：docker默认使用国外官方网站镜像，速度比较慢，甚至无法连接状态。\n\n\n\n`解决方法`：使用国内镜像源．\n\n- docker国内官方镜像地址：`https://registry.docker-cn.com`（貌似已经不能用了）\n- 网易：`https://hub-mirror.c.163.com`\n\n\n\n`配置方法`：\n\n- 修改 `/etc/docker/daemon.json`文件（<u>该文件默认不存在，需要手动编写</u>．但是注意不要与传递给命令行调用的选项冲突）\n\n```json /etc/docker/daemon.json\n{\n\"registry-mirrors\":[\"<镜像源地址>\"]\n}\n```\n\n- 重启docker生效：\n\n```\nsystemctl daemon-reload\nsystemctl restart docker\n```\n\n","source":"_posts/Docker-错误处理.md","raw":"---\ntitle: Docker-错误处理\ndate: 2020-09-16 17:57:09\ntags: [\"Docker\"]\ncategories: [\"Docker\"]\n---\n\n\n\n记录一些遇见的错误，及解决方法．\n\n<!--more-->\n\n#### 1 删除镜像错误\n\n##### 1.1 image is being used by stopped container <xxx>\n\n`报错信息`：\n\n```bash\n$ sudo docker image rm 1345a7ba5eb6\nError response from daemon: conflict: unable to delete 1345a7ba5eb6 (must be forced) - image is being used by stopped container 69bbed5c06aa\n```\n\n`报错原因`：要删除的镜像正在被容器使用．\n\n\n\n`解决方法`：删除正在使用镜像的容器，再进行镜像的删除．\n\n- 执行`docker ps -a`命令查看所有容器（包括未运行的容器），找到是哪个容器正在使用这个要删除的镜像(列出的第二列信息即为镜像名称)．\n- 执行`docker rm <容器id>`命令删除指定容器．\n\n\n\n##### 1.2 image is referenced in multiple repositories\n\n`报错信息`：\n\n```bash\n$ sudo docker image rm $(sudo docker image ls -q)\nError response from daemon: conflict: unable to delete 4e5021d210f6 (must be forced) - image is referenced in multiple repositories\n```\n\n\n\n`报错原因`：两个仓库指向了同一个镜像id，如下所示：\n\n```bash\n$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nubuntu              18.04               4e5021d210f6        6 months ago        64.2MB\nubuntu              latest              4e5021d210f6        6 months ago        64.2MB\n```\n\n\n\n`解决方法`：通过指定`仓库名：标签`的方式进行删除．\n\n```bash\n$ sudo docker image rm ubuntu:18.04\n```\n\n\n\n#### 2 拉取镜像错误\n\n##### 2.1 read: connection timed out\n\n`报错信息`：\n\n```bash\n$ sudo docker pull ubuntu:18.04\n18.04: Pulling from library/ubuntu\n5d9821c94847: Downloading  4.173MB/26.7MB\na610eae58dfc: Download complete \na40e0eb9f140: Download complete \nerror pulling image configuration: Get https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/c1/c14bccfdea1cc6aee142cd95f4069b6ada6b57e484e7886391816e1eba856950/data?verify=1600417610-ZVyDnSC2hWAtmSPbiNbhg4MHxGM%3D: read tcp 172.20.33.9:58120->104.18.124.25:443: read: connection timed out\n```\n\n`报错原因`：docker默认使用国外官方网站镜像，速度比较慢，甚至无法连接状态。\n\n\n\n`解决方法`：使用国内镜像源．\n\n- docker国内官方镜像地址：`https://registry.docker-cn.com`（貌似已经不能用了）\n- 网易：`https://hub-mirror.c.163.com`\n\n\n\n`配置方法`：\n\n- 修改 `/etc/docker/daemon.json`文件（<u>该文件默认不存在，需要手动编写</u>．但是注意不要与传递给命令行调用的选项冲突）\n\n```json /etc/docker/daemon.json\n{\n\"registry-mirrors\":[\"<镜像源地址>\"]\n}\n```\n\n- 重启docker生效：\n\n```\nsystemctl daemon-reload\nsystemctl restart docker\n```\n\n","slug":"Docker-错误处理","published":1,"updated":"2020-09-18T08:29:10.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkc001n45g3fzxgact4","content":"<p>记录一些遇见的错误，及解决方法．</p>\n<a id=\"more\"></a>\n\n<h4 id=\"1-删除镜像错误\"><a href=\"#1-删除镜像错误\" class=\"headerlink\" title=\"1 删除镜像错误\"></a>1 删除镜像错误</h4><h5 id=\"1-1-image-is-being-used-by-stopped-container\"><a href=\"#1-1-image-is-being-used-by-stopped-container\" class=\"headerlink\" title=\"1.1 image is being used by stopped container \"></a>1.1 image is being used by stopped container <xxx></h5><p><code>报错信息</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker image rm 1345a7ba5eb6</span><br><span class=\"line\">Error response from daemon: conflict: unable to delete 1345a7ba5eb6 (must be forced) - image is being used by stopped container 69bbed5c06aa</span><br></pre></td></tr></table></figure>\n\n<p><code>报错原因</code>：要删除的镜像正在被容器使用．</p>\n<p><code>解决方法</code>：删除正在使用镜像的容器，再进行镜像的删除．</p>\n<ul>\n<li>执行<code>docker ps -a</code>命令查看所有容器（包括未运行的容器），找到是哪个容器正在使用这个要删除的镜像(列出的第二列信息即为镜像名称)．</li>\n<li>执行<code>docker rm &lt;容器id&gt;</code>命令删除指定容器．</li>\n</ul>\n<h5 id=\"1-2-image-is-referenced-in-multiple-repositories\"><a href=\"#1-2-image-is-referenced-in-multiple-repositories\" class=\"headerlink\" title=\"1.2 image is referenced in multiple repositories\"></a>1.2 image is referenced in multiple repositories</h5><p><code>报错信息</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker image rm $(sudo docker image ls -q)</span><br><span class=\"line\">Error response from daemon: conflict: unable to delete 4e5021d210f6 (must be forced) - image is referenced <span class=\"keyword\">in</span> multiple repositories</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>报错原因</code>：两个仓库指向了同一个镜像id，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker image ls</span><br><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">ubuntu              18.04               4e5021d210f6        6 months ago        64.2MB</span><br><span class=\"line\">ubuntu              latest              4e5021d210f6        6 months ago        64.2MB</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>解决方法</code>：通过指定<code>仓库名：标签</code>的方式进行删除．</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker image rm ubuntu:18.04</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-拉取镜像错误\"><a href=\"#2-拉取镜像错误\" class=\"headerlink\" title=\"2 拉取镜像错误\"></a>2 拉取镜像错误</h4><h5 id=\"2-1-read-connection-timed-out\"><a href=\"#2-1-read-connection-timed-out\" class=\"headerlink\" title=\"2.1 read: connection timed out\"></a>2.1 read: connection timed out</h5><p><code>报错信息</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker pull ubuntu:18.04</span><br><span class=\"line\">18.04: Pulling from library/ubuntu</span><br><span class=\"line\">5d9821c94847: Downloading  4.173MB/26.7MB</span><br><span class=\"line\">a610eae58dfc: Download complete </span><br><span class=\"line\">a40e0eb9f140: Download complete </span><br><span class=\"line\">error pulling image configuration: Get https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/c1/c14bccfdea1cc6aee142cd95f4069b6ada6b57e484e7886391816e1eba856950/data?verify=1600417610-ZVyDnSC2hWAtmSPbiNbhg4MHxGM%3D: <span class=\"built_in\">read</span> tcp 172.20.33.9:58120-&gt;104.18.124.25:443: <span class=\"built_in\">read</span>: connection timed out</span><br></pre></td></tr></table></figure>\n\n<p><code>报错原因</code>：docker默认使用国外官方网站镜像，速度比较慢，甚至无法连接状态。</p>\n<p><code>解决方法</code>：使用国内镜像源．</p>\n<ul>\n<li>docker国内官方镜像地址：<code>https://registry.docker-cn.com</code>（貌似已经不能用了）</li>\n<li>网易：<code>https://hub-mirror.c.163.com</code></li>\n</ul>\n<p><code>配置方法</code>：</p>\n<ul>\n<li>修改 <code>/etc/docker/daemon.json</code>文件（<u>该文件默认不存在，需要手动编写</u>．但是注意不要与传递给命令行调用的选项冲突）</li>\n</ul>\n<figure class=\"highlight json\"><figcaption><span>/etc/docker/daemon.json</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"attr\">&quot;registry-mirrors&quot;</span>:[<span class=\"string\">&quot;&lt;镜像源地址&gt;&quot;</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重启docker生效：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>记录一些遇见的错误，及解决方法．</p>","more":"<h4 id=\"1-删除镜像错误\"><a href=\"#1-删除镜像错误\" class=\"headerlink\" title=\"1 删除镜像错误\"></a>1 删除镜像错误</h4><h5 id=\"1-1-image-is-being-used-by-stopped-container\"><a href=\"#1-1-image-is-being-used-by-stopped-container\" class=\"headerlink\" title=\"1.1 image is being used by stopped container \"></a>1.1 image is being used by stopped container <xxx></h5><p><code>报错信息</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker image rm 1345a7ba5eb6</span><br><span class=\"line\">Error response from daemon: conflict: unable to delete 1345a7ba5eb6 (must be forced) - image is being used by stopped container 69bbed5c06aa</span><br></pre></td></tr></table></figure>\n\n<p><code>报错原因</code>：要删除的镜像正在被容器使用．</p>\n<p><code>解决方法</code>：删除正在使用镜像的容器，再进行镜像的删除．</p>\n<ul>\n<li>执行<code>docker ps -a</code>命令查看所有容器（包括未运行的容器），找到是哪个容器正在使用这个要删除的镜像(列出的第二列信息即为镜像名称)．</li>\n<li>执行<code>docker rm &lt;容器id&gt;</code>命令删除指定容器．</li>\n</ul>\n<h5 id=\"1-2-image-is-referenced-in-multiple-repositories\"><a href=\"#1-2-image-is-referenced-in-multiple-repositories\" class=\"headerlink\" title=\"1.2 image is referenced in multiple repositories\"></a>1.2 image is referenced in multiple repositories</h5><p><code>报错信息</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker image rm $(sudo docker image ls -q)</span><br><span class=\"line\">Error response from daemon: conflict: unable to delete 4e5021d210f6 (must be forced) - image is referenced <span class=\"keyword\">in</span> multiple repositories</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>报错原因</code>：两个仓库指向了同一个镜像id，如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker image ls</span><br><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">ubuntu              18.04               4e5021d210f6        6 months ago        64.2MB</span><br><span class=\"line\">ubuntu              latest              4e5021d210f6        6 months ago        64.2MB</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>解决方法</code>：通过指定<code>仓库名：标签</code>的方式进行删除．</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker image rm ubuntu:18.04</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-拉取镜像错误\"><a href=\"#2-拉取镜像错误\" class=\"headerlink\" title=\"2 拉取镜像错误\"></a>2 拉取镜像错误</h4><h5 id=\"2-1-read-connection-timed-out\"><a href=\"#2-1-read-connection-timed-out\" class=\"headerlink\" title=\"2.1 read: connection timed out\"></a>2.1 read: connection timed out</h5><p><code>报错信息</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker pull ubuntu:18.04</span><br><span class=\"line\">18.04: Pulling from library/ubuntu</span><br><span class=\"line\">5d9821c94847: Downloading  4.173MB/26.7MB</span><br><span class=\"line\">a610eae58dfc: Download complete </span><br><span class=\"line\">a40e0eb9f140: Download complete </span><br><span class=\"line\">error pulling image configuration: Get https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/c1/c14bccfdea1cc6aee142cd95f4069b6ada6b57e484e7886391816e1eba856950/data?verify=1600417610-ZVyDnSC2hWAtmSPbiNbhg4MHxGM%3D: <span class=\"built_in\">read</span> tcp 172.20.33.9:58120-&gt;104.18.124.25:443: <span class=\"built_in\">read</span>: connection timed out</span><br></pre></td></tr></table></figure>\n\n<p><code>报错原因</code>：docker默认使用国外官方网站镜像，速度比较慢，甚至无法连接状态。</p>\n<p><code>解决方法</code>：使用国内镜像源．</p>\n<ul>\n<li>docker国内官方镜像地址：<code>https://registry.docker-cn.com</code>（貌似已经不能用了）</li>\n<li>网易：<code>https://hub-mirror.c.163.com</code></li>\n</ul>\n<p><code>配置方法</code>：</p>\n<ul>\n<li>修改 <code>/etc/docker/daemon.json</code>文件（<u>该文件默认不存在，需要手动编写</u>．但是注意不要与传递给命令行调用的选项冲突）</li>\n</ul>\n<figure class=\"highlight json\"><figcaption><span>/etc/docker/daemon.json</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"attr\">&quot;registry-mirrors&quot;</span>:[<span class=\"string\">&quot;&lt;镜像源地址&gt;&quot;</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重启docker生效：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure>"},{"title":"Docker-镜像的操作","date":"2020-09-16T09:30:51.000Z","_content":"\n\n\n#### 1 概述\n\n镜像是Docker的三大核心之一．Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。\n\n<!--more-->\n\n#### 2 获取镜像\n\n [Docker Hub](https://hub.docker.com/search?q=&type=image) 上有大量的高质量的镜像可以用，通过`docker pull`命令可以从中获取．\n\n命令格式：\n\n```\ndocker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n```\n\n- Docker 镜像仓库地址：地址的格式一般是 `<域名/IP>[:端口号]`。默认地址是 Docker Hub(docker.io)。\n- 仓库名：如之前所说，这里的仓库名是两段式名称，即 `<用户名>/<软件名>`。对于 Docker Hub，如果不给出用户名，则默认为 `library`，也就是官方镜像。\n\n\n\n示例：`sudo docker pull ubuntu:18.04`\n\n\n\n#### 3 列出镜像\n\n列出已经下载下来的镜像\n\n```\ndocker image ls [OPTIONS] [REPOSITORY[:TAG]]\n```\n\n常用OPTIONS：\n\n- `-a（--all）`：显示包括中间层镜像在内的所有镜像．\n- `-f（--filter）`：过滤出指定镜像．eg：`image ls -f since=ubuntu:18.04`\n  - `--format`：使用[Go模板语法](https://gohugo.io/templates/introduction/)列出指定内容的镜像．eg：`docker image ls --format \"{{.ID}}: {{.Repository}}\"`\n- `-q`：列出镜像ID．eg：`docker image ls -q`\n\n\n\n#### 4 查看镜像体积\n\n查看镜像、容器、数据卷所占用的空间命令：\n\n```\ndocker system df\n```\n\n注：*`docker image ls`列出的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。Docker使用Union FS，相同的层只需要保存一份即可，因此实际镜像磁盘占用空间很可能比这个列表镜像大小的总和要小很多。*\n\n\n\n#### 5 删除本地镜像\n\n删除本地镜像命令：\n\n```bash\ndocker image rm [OPTIONS] IMAGE [IMAGE...]\n```\n\n删除命令的别名还包括：`rm`，`rmi`，`remove`．\n\n其中镜像可以是：\n\n- 镜像短ID\n- 镜像长ID\n- 镜像名\n- 镜像摘要\n\n注：*`docker image ls`默认列出的就已经是短ID了，一般取前3个字符以上，就足够区分与别的镜像了。*\n\n\n\n常用OPTIONS:\n\n- `-f（--force）`：强制删除镜像．\n\n\n\n##### 5.1 批量删除镜像\n\n使用`docker image ls`命令配合使用`docker image rm`，实现成批删除镜像。\n\n\n\n示例：\n\n```\n1. 删除所有仓库名为redis的镜像\ndocker image rm $(docker image ls -q redis)\n\n2.删除所有在mongo:3.2之前的镜像\ndocker image rm $(docker image ls -q -f before=mongo:3.2)\n```\n\n\n\n#### 6 构建镜像\n\n使用docker build命令进行镜像构建．其格式为：\n\n```\ndocker build [OPTIONS] PATH | URL | -\n```\n\n常用OPTIONS:\n\n- -t：以name:tag格式对镜像命名．eg：`docker build -t nginx:v3 .`\n- -f：指定Dockerfile文件（默认为path/Dockerfile）\n- --build-arg：设置编译时的变量．eg：`docker build --build-arg name=\"Jovry\"`\n\n\n\n##### 6.1 docker build的工作原理\n\nDocker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具。Docker的引擎提供了一组REST API，被称为 [Docker Remote API](https://docs.docker.com/develop/sdk/)，而如 `docker` 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。\n\n因此，虽然表面上我们好像是在本机执行各种 `docker` 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。\n\n\n\n##### 6.2 构建上下文\n\n通过docker build的工作原理可知，docker运行是采用的C/S架构，为了解决让服务端获取本地文件的问题，因此引入了上下文的概念，在构建的时候，指定构建镜像的上下文的路径．\n\n`docker build` 命令拿到这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。\n\n\n\n在`docker build -t nginx:v3 .`示例中，`．`即表示上下文目录．  `docker build` 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。\n\n\n\n<u>推荐做法</u>：将 `Dockerfile` 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 `.gitignore` 一样的语法写一个 `.dockerignore`，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。\n\n\n\n##### 6.3 其他构建方式\n\n- 使用Git Repo进行构建：`docker build`支持从URL进行构建，比如可以直接从Git repo中构建．eg：`docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world`\n- 用给定的tar压缩包构建：Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。eg：`docker build http://server/context.tar.gz`\n- 从标准输入中读取Dockerfile进行构建： `docker build - < Dockerfile` 或 `cat Dockerfile | docker build -`\n- 从标准输入中读取上下文压缩包进行构建： `docker build - < context.tar.gz`              \n\n\n\n#### ７ 定制镜像\n\n`Docker镜像定制有哪些方式`？\n\n- ①、使用commit命令定制（不推荐）\n- ②、使用Dockerfile定制镜像\n\n\n\n##### 7.1 使用commit命令定制\n\n镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。\n\n当运行一个容器的时候（如果不使用卷的话），我们做的`任何文件修改都会被记录于容器存储层里`。而 Docker 提供了一个 `docker commit` 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。\n\n\n\n###### 7.1.1 查看容器改动\n\nDocker提供了一个命令查看修改的容器文件，如下：\n\n```\ndocker diff CONTAINER\n```\n\n\n\n###### 7.1.2 保存容器的修改\n\n`docker commit` 的语法格式为：\n\n```\ndocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n```\n\n\n\nOPTIONS：\n\n- -a（--author）：作者名\n- -c（ --change）使用Dockerfile结构创建镜像．\n- -m（--message） ：注释信息．\n- -p（--pause）：提交期间暂停容器（默认为true）\n\n\n\n###### 7.1.3 查看镜像内的历史记录\n\ndocker history的语法格式为：\n\n```\ndocker history [OPTIONS] IMAGE\n```\n\n\n\n###### 7.1.4 为什么不推荐使用docker commit定制镜像\n\n- 可能导致很多无关的文件被改动或者添加导致镜像变得非常臃肿．\n- 直接操作的镜像也被称为黑箱镜像，除了制作人知道修改过程，其他人无法得知，维护非常艰难．\n- 由于镜像为分层结构，每次修改都会让镜像更臃肿一次．\n\n\n\n##### 7.2　Dockerfile定制镜像\n\nDockerfile 是一个文本文件，其内包含了一条条的 `指令(Instruction)`，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n\n[Dockerfile相关指令](https://jovry-lee.github.io/2020/09/17/Docker-Dockerfile%E6%8C%87%E4%BB%A4)\n\n\n\n\n\n\n\n\n\n","source":"_posts/Docker-镜像.md","raw":"---\ntitle: Docker-镜像的操作\ndate: 2020-09-16 17:30:51\ntags: [\"Docker\"]\ncategories: [\"Docker\"]\n---\n\n\n\n#### 1 概述\n\n镜像是Docker的三大核心之一．Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。\n\n<!--more-->\n\n#### 2 获取镜像\n\n [Docker Hub](https://hub.docker.com/search?q=&type=image) 上有大量的高质量的镜像可以用，通过`docker pull`命令可以从中获取．\n\n命令格式：\n\n```\ndocker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n```\n\n- Docker 镜像仓库地址：地址的格式一般是 `<域名/IP>[:端口号]`。默认地址是 Docker Hub(docker.io)。\n- 仓库名：如之前所说，这里的仓库名是两段式名称，即 `<用户名>/<软件名>`。对于 Docker Hub，如果不给出用户名，则默认为 `library`，也就是官方镜像。\n\n\n\n示例：`sudo docker pull ubuntu:18.04`\n\n\n\n#### 3 列出镜像\n\n列出已经下载下来的镜像\n\n```\ndocker image ls [OPTIONS] [REPOSITORY[:TAG]]\n```\n\n常用OPTIONS：\n\n- `-a（--all）`：显示包括中间层镜像在内的所有镜像．\n- `-f（--filter）`：过滤出指定镜像．eg：`image ls -f since=ubuntu:18.04`\n  - `--format`：使用[Go模板语法](https://gohugo.io/templates/introduction/)列出指定内容的镜像．eg：`docker image ls --format \"{{.ID}}: {{.Repository}}\"`\n- `-q`：列出镜像ID．eg：`docker image ls -q`\n\n\n\n#### 4 查看镜像体积\n\n查看镜像、容器、数据卷所占用的空间命令：\n\n```\ndocker system df\n```\n\n注：*`docker image ls`列出的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。Docker使用Union FS，相同的层只需要保存一份即可，因此实际镜像磁盘占用空间很可能比这个列表镜像大小的总和要小很多。*\n\n\n\n#### 5 删除本地镜像\n\n删除本地镜像命令：\n\n```bash\ndocker image rm [OPTIONS] IMAGE [IMAGE...]\n```\n\n删除命令的别名还包括：`rm`，`rmi`，`remove`．\n\n其中镜像可以是：\n\n- 镜像短ID\n- 镜像长ID\n- 镜像名\n- 镜像摘要\n\n注：*`docker image ls`默认列出的就已经是短ID了，一般取前3个字符以上，就足够区分与别的镜像了。*\n\n\n\n常用OPTIONS:\n\n- `-f（--force）`：强制删除镜像．\n\n\n\n##### 5.1 批量删除镜像\n\n使用`docker image ls`命令配合使用`docker image rm`，实现成批删除镜像。\n\n\n\n示例：\n\n```\n1. 删除所有仓库名为redis的镜像\ndocker image rm $(docker image ls -q redis)\n\n2.删除所有在mongo:3.2之前的镜像\ndocker image rm $(docker image ls -q -f before=mongo:3.2)\n```\n\n\n\n#### 6 构建镜像\n\n使用docker build命令进行镜像构建．其格式为：\n\n```\ndocker build [OPTIONS] PATH | URL | -\n```\n\n常用OPTIONS:\n\n- -t：以name:tag格式对镜像命名．eg：`docker build -t nginx:v3 .`\n- -f：指定Dockerfile文件（默认为path/Dockerfile）\n- --build-arg：设置编译时的变量．eg：`docker build --build-arg name=\"Jovry\"`\n\n\n\n##### 6.1 docker build的工作原理\n\nDocker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具。Docker的引擎提供了一组REST API，被称为 [Docker Remote API](https://docs.docker.com/develop/sdk/)，而如 `docker` 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。\n\n因此，虽然表面上我们好像是在本机执行各种 `docker` 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。\n\n\n\n##### 6.2 构建上下文\n\n通过docker build的工作原理可知，docker运行是采用的C/S架构，为了解决让服务端获取本地文件的问题，因此引入了上下文的概念，在构建的时候，指定构建镜像的上下文的路径．\n\n`docker build` 命令拿到这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。\n\n\n\n在`docker build -t nginx:v3 .`示例中，`．`即表示上下文目录．  `docker build` 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。\n\n\n\n<u>推荐做法</u>：将 `Dockerfile` 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 `.gitignore` 一样的语法写一个 `.dockerignore`，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。\n\n\n\n##### 6.3 其他构建方式\n\n- 使用Git Repo进行构建：`docker build`支持从URL进行构建，比如可以直接从Git repo中构建．eg：`docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world`\n- 用给定的tar压缩包构建：Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。eg：`docker build http://server/context.tar.gz`\n- 从标准输入中读取Dockerfile进行构建： `docker build - < Dockerfile` 或 `cat Dockerfile | docker build -`\n- 从标准输入中读取上下文压缩包进行构建： `docker build - < context.tar.gz`              \n\n\n\n#### ７ 定制镜像\n\n`Docker镜像定制有哪些方式`？\n\n- ①、使用commit命令定制（不推荐）\n- ②、使用Dockerfile定制镜像\n\n\n\n##### 7.1 使用commit命令定制\n\n镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。\n\n当运行一个容器的时候（如果不使用卷的话），我们做的`任何文件修改都会被记录于容器存储层里`。而 Docker 提供了一个 `docker commit` 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。\n\n\n\n###### 7.1.1 查看容器改动\n\nDocker提供了一个命令查看修改的容器文件，如下：\n\n```\ndocker diff CONTAINER\n```\n\n\n\n###### 7.1.2 保存容器的修改\n\n`docker commit` 的语法格式为：\n\n```\ndocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n```\n\n\n\nOPTIONS：\n\n- -a（--author）：作者名\n- -c（ --change）使用Dockerfile结构创建镜像．\n- -m（--message） ：注释信息．\n- -p（--pause）：提交期间暂停容器（默认为true）\n\n\n\n###### 7.1.3 查看镜像内的历史记录\n\ndocker history的语法格式为：\n\n```\ndocker history [OPTIONS] IMAGE\n```\n\n\n\n###### 7.1.4 为什么不推荐使用docker commit定制镜像\n\n- 可能导致很多无关的文件被改动或者添加导致镜像变得非常臃肿．\n- 直接操作的镜像也被称为黑箱镜像，除了制作人知道修改过程，其他人无法得知，维护非常艰难．\n- 由于镜像为分层结构，每次修改都会让镜像更臃肿一次．\n\n\n\n##### 7.2　Dockerfile定制镜像\n\nDockerfile 是一个文本文件，其内包含了一条条的 `指令(Instruction)`，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n\n[Dockerfile相关指令](https://jovry-lee.github.io/2020/09/17/Docker-Dockerfile%E6%8C%87%E4%BB%A4)\n\n\n\n\n\n\n\n\n\n","slug":"Docker-镜像","published":1,"updated":"2020-09-18T01:58:45.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkd001p45g3hpq40qgo","content":"<h4 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h4><p>镜像是Docker的三大核心之一．Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"2-获取镜像\"><a href=\"#2-获取镜像\" class=\"headerlink\" title=\"2 获取镜像\"></a>2 获取镜像</h4><p> <a href=\"https://hub.docker.com/search?q=&type=image\">Docker Hub</a> 上有大量的高质量的镜像可以用，通过<code>docker pull</code>命令可以从中获取．</p>\n<p>命令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull [选项] [Docker Registry 地址[:端口号]&#x2F;]仓库名[:标签]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(docker.io)。</li>\n<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>\n</ul>\n<p>示例：<code>sudo docker pull ubuntu:18.04</code></p>\n<h4 id=\"3-列出镜像\"><a href=\"#3-列出镜像\" class=\"headerlink\" title=\"3 列出镜像\"></a>3 列出镜像</h4><p>列出已经下载下来的镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image ls [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li><code>-a（--all）</code>：显示包括中间层镜像在内的所有镜像．</li>\n<li><code>-f（--filter）</code>：过滤出指定镜像．eg：<code>image ls -f since=ubuntu:18.04</code><ul>\n<li><code>--format</code>：使用<a href=\"https://gohugo.io/templates/introduction/\">Go模板语法</a>列出指定内容的镜像．eg：<code>docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</code></li>\n</ul>\n</li>\n<li><code>-q</code>：列出镜像ID．eg：<code>docker image ls -q</code></li>\n</ul>\n<h4 id=\"4-查看镜像体积\"><a href=\"#4-查看镜像体积\" class=\"headerlink\" title=\"4 查看镜像体积\"></a>4 查看镜像体积</h4><p>查看镜像、容器、数据卷所占用的空间命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker system df</span><br></pre></td></tr></table></figure>\n\n<p>注：*<code>docker image ls</code>列出的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。Docker使用Union FS，相同的层只需要保存一份即可，因此实际镜像磁盘占用空间很可能比这个列表镜像大小的总和要小很多。*</p>\n<h4 id=\"5-删除本地镜像\"><a href=\"#5-删除本地镜像\" class=\"headerlink\" title=\"5 删除本地镜像\"></a>5 删除本地镜像</h4><p>删除本地镜像命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image rm [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>\n\n<p>删除命令的别名还包括：<code>rm</code>，<code>rmi</code>，<code>remove</code>．</p>\n<p>其中镜像可以是：</p>\n<ul>\n<li>镜像短ID</li>\n<li>镜像长ID</li>\n<li>镜像名</li>\n<li>镜像摘要</li>\n</ul>\n<p>注：*<code>docker image ls</code>默认列出的就已经是短ID了，一般取前3个字符以上，就足够区分与别的镜像了。*</p>\n<p>常用OPTIONS:</p>\n<ul>\n<li><code>-f（--force）</code>：强制删除镜像．</li>\n</ul>\n<h5 id=\"5-1-批量删除镜像\"><a href=\"#5-1-批量删除镜像\" class=\"headerlink\" title=\"5.1 批量删除镜像\"></a>5.1 批量删除镜像</h5><p>使用<code>docker image ls</code>命令配合使用<code>docker image rm</code>，实现成批删除镜像。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 删除所有仓库名为redis的镜像</span><br><span class=\"line\">docker image rm $(docker image ls -q redis)</span><br><span class=\"line\"></span><br><span class=\"line\">2.删除所有在mongo:3.2之前的镜像</span><br><span class=\"line\">docker image rm $(docker image ls -q -f before&#x3D;mongo:3.2)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"6-构建镜像\"><a href=\"#6-构建镜像\" class=\"headerlink\" title=\"6 构建镜像\"></a>6 构建镜像</h4><p>使用docker build命令进行镜像构建．其格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS:</p>\n<ul>\n<li>-t：以name:tag格式对镜像命名．eg：<code>docker build -t nginx:v3 .</code></li>\n<li>-f：指定Dockerfile文件（默认为path/Dockerfile）</li>\n<li>–build-arg：设置编译时的变量．eg：<code>docker build --build-arg name=&quot;Jovry&quot;</code></li>\n</ul>\n<h5 id=\"6-1-docker-build的工作原理\"><a href=\"#6-1-docker-build的工作原理\" class=\"headerlink\" title=\"6.1 docker build的工作原理\"></a>6.1 docker build的工作原理</h5><p>Docker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具。Docker的引擎提供了一组REST API，被称为 <a href=\"https://docs.docker.com/develop/sdk/\">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。</p>\n<p>因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。</p>\n<h5 id=\"6-2-构建上下文\"><a href=\"#6-2-构建上下文\" class=\"headerlink\" title=\"6.2 构建上下文\"></a>6.2 构建上下文</h5><p>通过docker build的工作原理可知，docker运行是采用的C/S架构，为了解决让服务端获取本地文件的问题，因此引入了上下文的概念，在构建的时候，指定构建镜像的上下文的路径．</p>\n<p><code>docker build</code> 命令拿到这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>\n<p>在<code>docker build -t nginx:v3 .</code>示例中，<code>．</code>即表示上下文目录．  <code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>\n<p><u>推荐做法</u>：将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>\n<h5 id=\"6-3-其他构建方式\"><a href=\"#6-3-其他构建方式\" class=\"headerlink\" title=\"6.3 其他构建方式\"></a>6.3 其他构建方式</h5><ul>\n<li>使用Git Repo进行构建：<code>docker build</code>支持从URL进行构建，比如可以直接从Git repo中构建．eg：<code>docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world</code></li>\n<li>用给定的tar压缩包构建：Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。eg：<code>docker build http://server/context.tar.gz</code></li>\n<li>从标准输入中读取Dockerfile进行构建： <code>docker build - &lt; Dockerfile</code> 或 <code>cat Dockerfile | docker build -</code></li>\n<li>从标准输入中读取上下文压缩包进行构建： <code>docker build - &lt; context.tar.gz</code>              </li>\n</ul>\n<h4 id=\"７-定制镜像\"><a href=\"#７-定制镜像\" class=\"headerlink\" title=\"７ 定制镜像\"></a>７ 定制镜像</h4><p><code>Docker镜像定制有哪些方式</code>？</p>\n<ul>\n<li>①、使用commit命令定制（不推荐）</li>\n<li>②、使用Dockerfile定制镜像</li>\n</ul>\n<h5 id=\"7-1-使用commit命令定制\"><a href=\"#7-1-使用commit命令定制\" class=\"headerlink\" title=\"7.1 使用commit命令定制\"></a>7.1 使用commit命令定制</h5><p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>\n<p>当运行一个容器的时候（如果不使用卷的话），我们做的<code>任何文件修改都会被记录于容器存储层里</code>。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>\n<h6 id=\"7-1-1-查看容器改动\"><a href=\"#7-1-1-查看容器改动\" class=\"headerlink\" title=\"7.1.1 查看容器改动\"></a>7.1.1 查看容器改动</h6><p>Docker提供了一个命令查看修改的容器文件，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker diff CONTAINER</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-1-2-保存容器的修改\"><a href=\"#7-1-2-保存容器的修改\" class=\"headerlink\" title=\"7.1.2 保存容器的修改\"></a>7.1.2 保存容器的修改</h6><p><code>docker commit</code> 的语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>OPTIONS：</p>\n<ul>\n<li>-a（–author）：作者名</li>\n<li>-c（ –change）使用Dockerfile结构创建镜像．</li>\n<li>-m（–message） ：注释信息．</li>\n<li>-p（–pause）：提交期间暂停容器（默认为true）</li>\n</ul>\n<h6 id=\"7-1-3-查看镜像内的历史记录\"><a href=\"#7-1-3-查看镜像内的历史记录\" class=\"headerlink\" title=\"7.1.3 查看镜像内的历史记录\"></a>7.1.3 查看镜像内的历史记录</h6><p>docker history的语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker history [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-1-4-为什么不推荐使用docker-commit定制镜像\"><a href=\"#7-1-4-为什么不推荐使用docker-commit定制镜像\" class=\"headerlink\" title=\"7.1.4 为什么不推荐使用docker commit定制镜像\"></a>7.1.4 为什么不推荐使用docker commit定制镜像</h6><ul>\n<li>可能导致很多无关的文件被改动或者添加导致镜像变得非常臃肿．</li>\n<li>直接操作的镜像也被称为黑箱镜像，除了制作人知道修改过程，其他人无法得知，维护非常艰难．</li>\n<li>由于镜像为分层结构，每次修改都会让镜像更臃肿一次．</li>\n</ul>\n<h5 id=\"7-2-Dockerfile定制镜像\"><a href=\"#7-2-Dockerfile定制镜像\" class=\"headerlink\" title=\"7.2　Dockerfile定制镜像\"></a>7.2　Dockerfile定制镜像</h5><p>Dockerfile 是一个文本文件，其内包含了一条条的 <code>指令(Instruction)</code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>\n<p><a href=\"https://jovry-lee.github.io/2020/09/17/Docker-Dockerfile%E6%8C%87%E4%BB%A4\">Dockerfile相关指令</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h4><p>镜像是Docker的三大核心之一．Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>","more":"<h4 id=\"2-获取镜像\"><a href=\"#2-获取镜像\" class=\"headerlink\" title=\"2 获取镜像\"></a>2 获取镜像</h4><p> <a href=\"https://hub.docker.com/search?q=&type=image\">Docker Hub</a> 上有大量的高质量的镜像可以用，通过<code>docker pull</code>命令可以从中获取．</p>\n<p>命令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull [选项] [Docker Registry 地址[:端口号]&#x2F;]仓库名[:标签]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(docker.io)。</li>\n<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>\n</ul>\n<p>示例：<code>sudo docker pull ubuntu:18.04</code></p>\n<h4 id=\"3-列出镜像\"><a href=\"#3-列出镜像\" class=\"headerlink\" title=\"3 列出镜像\"></a>3 列出镜像</h4><p>列出已经下载下来的镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image ls [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS：</p>\n<ul>\n<li><code>-a（--all）</code>：显示包括中间层镜像在内的所有镜像．</li>\n<li><code>-f（--filter）</code>：过滤出指定镜像．eg：<code>image ls -f since=ubuntu:18.04</code><ul>\n<li><code>--format</code>：使用<a href=\"https://gohugo.io/templates/introduction/\">Go模板语法</a>列出指定内容的镜像．eg：<code>docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</code></li>\n</ul>\n</li>\n<li><code>-q</code>：列出镜像ID．eg：<code>docker image ls -q</code></li>\n</ul>\n<h4 id=\"4-查看镜像体积\"><a href=\"#4-查看镜像体积\" class=\"headerlink\" title=\"4 查看镜像体积\"></a>4 查看镜像体积</h4><p>查看镜像、容器、数据卷所占用的空间命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker system df</span><br></pre></td></tr></table></figure>\n\n<p>注：*<code>docker image ls</code>列出的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。Docker使用Union FS，相同的层只需要保存一份即可，因此实际镜像磁盘占用空间很可能比这个列表镜像大小的总和要小很多。*</p>\n<h4 id=\"5-删除本地镜像\"><a href=\"#5-删除本地镜像\" class=\"headerlink\" title=\"5 删除本地镜像\"></a>5 删除本地镜像</h4><p>删除本地镜像命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image rm [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>\n\n<p>删除命令的别名还包括：<code>rm</code>，<code>rmi</code>，<code>remove</code>．</p>\n<p>其中镜像可以是：</p>\n<ul>\n<li>镜像短ID</li>\n<li>镜像长ID</li>\n<li>镜像名</li>\n<li>镜像摘要</li>\n</ul>\n<p>注：*<code>docker image ls</code>默认列出的就已经是短ID了，一般取前3个字符以上，就足够区分与别的镜像了。*</p>\n<p>常用OPTIONS:</p>\n<ul>\n<li><code>-f（--force）</code>：强制删除镜像．</li>\n</ul>\n<h5 id=\"5-1-批量删除镜像\"><a href=\"#5-1-批量删除镜像\" class=\"headerlink\" title=\"5.1 批量删除镜像\"></a>5.1 批量删除镜像</h5><p>使用<code>docker image ls</code>命令配合使用<code>docker image rm</code>，实现成批删除镜像。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 删除所有仓库名为redis的镜像</span><br><span class=\"line\">docker image rm $(docker image ls -q redis)</span><br><span class=\"line\"></span><br><span class=\"line\">2.删除所有在mongo:3.2之前的镜像</span><br><span class=\"line\">docker image rm $(docker image ls -q -f before&#x3D;mongo:3.2)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"6-构建镜像\"><a href=\"#6-构建镜像\" class=\"headerlink\" title=\"6 构建镜像\"></a>6 构建镜像</h4><p>使用docker build命令进行镜像构建．其格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>\n\n<p>常用OPTIONS:</p>\n<ul>\n<li>-t：以name:tag格式对镜像命名．eg：<code>docker build -t nginx:v3 .</code></li>\n<li>-f：指定Dockerfile文件（默认为path/Dockerfile）</li>\n<li>–build-arg：设置编译时的变量．eg：<code>docker build --build-arg name=&quot;Jovry&quot;</code></li>\n</ul>\n<h5 id=\"6-1-docker-build的工作原理\"><a href=\"#6-1-docker-build的工作原理\" class=\"headerlink\" title=\"6.1 docker build的工作原理\"></a>6.1 docker build的工作原理</h5><p>Docker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具。Docker的引擎提供了一组REST API，被称为 <a href=\"https://docs.docker.com/develop/sdk/\">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。</p>\n<p>因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。</p>\n<h5 id=\"6-2-构建上下文\"><a href=\"#6-2-构建上下文\" class=\"headerlink\" title=\"6.2 构建上下文\"></a>6.2 构建上下文</h5><p>通过docker build的工作原理可知，docker运行是采用的C/S架构，为了解决让服务端获取本地文件的问题，因此引入了上下文的概念，在构建的时候，指定构建镜像的上下文的路径．</p>\n<p><code>docker build</code> 命令拿到这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>\n<p>在<code>docker build -t nginx:v3 .</code>示例中，<code>．</code>即表示上下文目录．  <code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>\n<p><u>推荐做法</u>：将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>\n<h5 id=\"6-3-其他构建方式\"><a href=\"#6-3-其他构建方式\" class=\"headerlink\" title=\"6.3 其他构建方式\"></a>6.3 其他构建方式</h5><ul>\n<li>使用Git Repo进行构建：<code>docker build</code>支持从URL进行构建，比如可以直接从Git repo中构建．eg：<code>docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world</code></li>\n<li>用给定的tar压缩包构建：Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。eg：<code>docker build http://server/context.tar.gz</code></li>\n<li>从标准输入中读取Dockerfile进行构建： <code>docker build - &lt; Dockerfile</code> 或 <code>cat Dockerfile | docker build -</code></li>\n<li>从标准输入中读取上下文压缩包进行构建： <code>docker build - &lt; context.tar.gz</code>              </li>\n</ul>\n<h4 id=\"７-定制镜像\"><a href=\"#７-定制镜像\" class=\"headerlink\" title=\"７ 定制镜像\"></a>７ 定制镜像</h4><p><code>Docker镜像定制有哪些方式</code>？</p>\n<ul>\n<li>①、使用commit命令定制（不推荐）</li>\n<li>②、使用Dockerfile定制镜像</li>\n</ul>\n<h5 id=\"7-1-使用commit命令定制\"><a href=\"#7-1-使用commit命令定制\" class=\"headerlink\" title=\"7.1 使用commit命令定制\"></a>7.1 使用commit命令定制</h5><p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>\n<p>当运行一个容器的时候（如果不使用卷的话），我们做的<code>任何文件修改都会被记录于容器存储层里</code>。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>\n<h6 id=\"7-1-1-查看容器改动\"><a href=\"#7-1-1-查看容器改动\" class=\"headerlink\" title=\"7.1.1 查看容器改动\"></a>7.1.1 查看容器改动</h6><p>Docker提供了一个命令查看修改的容器文件，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker diff CONTAINER</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-1-2-保存容器的修改\"><a href=\"#7-1-2-保存容器的修改\" class=\"headerlink\" title=\"7.1.2 保存容器的修改\"></a>7.1.2 保存容器的修改</h6><p><code>docker commit</code> 的语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>OPTIONS：</p>\n<ul>\n<li>-a（–author）：作者名</li>\n<li>-c（ –change）使用Dockerfile结构创建镜像．</li>\n<li>-m（–message） ：注释信息．</li>\n<li>-p（–pause）：提交期间暂停容器（默认为true）</li>\n</ul>\n<h6 id=\"7-1-3-查看镜像内的历史记录\"><a href=\"#7-1-3-查看镜像内的历史记录\" class=\"headerlink\" title=\"7.1.3 查看镜像内的历史记录\"></a>7.1.3 查看镜像内的历史记录</h6><p>docker history的语法格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker history [OPTIONS] IMAGE</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-1-4-为什么不推荐使用docker-commit定制镜像\"><a href=\"#7-1-4-为什么不推荐使用docker-commit定制镜像\" class=\"headerlink\" title=\"7.1.4 为什么不推荐使用docker commit定制镜像\"></a>7.1.4 为什么不推荐使用docker commit定制镜像</h6><ul>\n<li>可能导致很多无关的文件被改动或者添加导致镜像变得非常臃肿．</li>\n<li>直接操作的镜像也被称为黑箱镜像，除了制作人知道修改过程，其他人无法得知，维护非常艰难．</li>\n<li>由于镜像为分层结构，每次修改都会让镜像更臃肿一次．</li>\n</ul>\n<h5 id=\"7-2-Dockerfile定制镜像\"><a href=\"#7-2-Dockerfile定制镜像\" class=\"headerlink\" title=\"7.2　Dockerfile定制镜像\"></a>7.2　Dockerfile定制镜像</h5><p>Dockerfile 是一个文本文件，其内包含了一条条的 <code>指令(Instruction)</code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>\n<p><a href=\"https://jovry-lee.github.io/2020/09/17/Docker-Dockerfile%E6%8C%87%E4%BB%A4\">Dockerfile相关指令</a></p>"},{"title":"FastCGI和PHP-FPM的关系","date":"2020-08-25T02:11:05.000Z","_content":"\n#### 1 相关概念\n\n##### 1.1 CGI\n\n`CGI`（Common Gateway Interface, 通用网关接口）是`WEB服务器`与`WEB Application`进行通信的工具，用于保证WEB Server传递的数据是标准格式的，是一种协议，其程序运行在服务器上，CGI可以用任何一种语言编写，只要该语言具有标准输入、输出和环境变量，如PHP、Perl等。\n\n<!--more-->\n\n<u>WEB Server只是内容的分发者</u>。CGI规定要传输哪些数据，以什么格式传递给后方处理。\n\n- 若客户端请求的是**静态数据**（如：`/index.html`），那么WEB Server会取文件系统中找到这个文件，并发送给浏览器，其流程如下所示：\n![客户端请求静态数据](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/客户端请求静态数据.png)\n\n- 若请求的是**非静态数据**（如：`/index.php`），根据配置文件，WEB Server（如：Nginx）知道这个不是静态文件，那么Nginx将会把该请求简单处理后交给PHP解析器。比如：URL、查询字符串、POST数据、HTTP Header等。PHP解析器收到数据首先会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程。WEB Server再把结果返回给浏览器。其流程如下所示：\n\n![客户端请求动态数据](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/客户端请求非静态数据.png)\n\n**缺陷**：<u>CGI只是个协议，与进程没有关系，PHP解析器在每次请求都会解析php.ini文件，初始化执行环境。所以处理时间耗时较长。</u>\n\n\n\n##### 1.2 FastCGI\n\n`FastCGI`（Fast Common Gateway Interface，快速通用网关接口）是一种让交互程序与WEB服务器通信的协议。FastCGI是CGI的增强版，通过常驻（Long-live）进程解决了CGI的Fork-Execute的缺点，减少Web服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。\n\n**FastCGI的实现**：FastCGI通过FastCGI进程管理器管理进程，在其自身初始化时，会fork多个FastCGI进程，并等待WEB服务器的连接。当一个请求来时，Web服务器将环境变量和页面请求通过socket或TCP连接传递给FastCGI进程。响应通过相同的连接从进程返回到WEB服务器，再传递给客户端。\n\n（*注：每次请求连接可能在相应结束时关闭，但WEB服务器和FastCGI服务进程都将持续，不会销毁。*）\n\n![FastCGI处理过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/FastCGI处理过程.png)\n\n**FastCGI优点**：\n\n- ①、每个单独的FastCGI进程在其生命周期内可以处理多个请求，从而避免每个请求进程创建和终止的开销。\n\n- ②、并发处理多个请求稳定性和可扩展性（配置多个FastCGI服务器）。\n\n\n\n**FastCGI的缺点**：\n\n- 由于FastCGI是多进程的，所以相比CGI多进程消耗更多服务器内存（如：PHP-CGI解释器每进程消耗7~25M内存，将这个数乘以50或100将是很大的内存数。）\n\n\n\n##### 1.3 PHP-CGI\n\n`php-cgi`是早期php官方出品的FastCGI管理器。\n\n缺点：\n\n①、PHP-CGI更改了php.ini配置后需要重启php-cgi才能让配置生效，不支持平滑重启。\n\n②、直接杀死PHP-CGI进程，PHP就不能运行了。而PHP-FPM和SPAWN-FCGI在杀掉进程后，守护进程会平滑重新生成子进程。\n\n③、不支持动态worker调度，只能一开始指定要起几个worker。\n\n\n\n##### 1.4 PHP-FPM\n\nPHP-CGI是使用PHP语言实现的了FastCGI的一个程序，后来被PHP官方收了。\n\nPHP-FPM加入了动态调度功能，可以根据请求来访压力变化动态增加worker进程数量来支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置\n\n\n\n#### 2 Web Server传递数据给Web Application（PHP应用）的方法\n\nPHP使用SAPI提供的2种连接方法与WEB Server通信：`mod_php`和`mod_fastcgi`。其中Apache通过mod_php来解析PHP，Nginx通过mod_fastcgi来解析。\n\n##### 2.1 Mod_php模式\n\nmod_php通过嵌入PHP解释器到Web Server进程中，只能与WEB Server配合使用。以Apache为例，其调用PHP执行过程如下：\n\n![Mod_php处理过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/Mod_php模式.png)\n\n`Apache->httpd->php5_module->sapi->php`\n\n**缺点**：\n\n- ①、该种模式下，WEB服务器每接收一个请求，都会产生一个进程通过sapi接连PHP完成请求，若用户过多，并发量大时，服务器会承受不住。\n\n- ②、内存占用大，无论是否用到PHP解释器都会将其加在到内存中，典型的就是处理CSS、JS之类的静态文件是完全没有必要加载解释器。\n\n- ③、把mod_php编进Web服务器时，出问题很难定位是php的问题还是WEB服务器的问题。\n\n\n\n**2.2 Mod_FastCGI模式**\n\n`mod_fastcgi`以独立的进程形式出现，只要对应的WEB Server（如：Nginx）实现了cgi/fastCgi协议，就能处理PHP请求。\n\n\n\n##### 2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】\n\n- ①、若仅在Web服务器上运行PHP，那么Apache相较Nginx有更高的性能，若看到明显的性能差异，则应检查AllowOverride是否打开（httpd.conf），然后重试。\n\n- ②、若运行混合内容（例如添加CSS,JS和图像），则Nginx将提供更好的总体性能，但不会更快地运行PHP。另外Nginx在拒绝服务攻击及减轻CDN风险做的更好。\n\n#### 3 总结\n\n简单的来说，`PHP-FPM`是实现了`FastCGI协议`的一个`进程管理器`。它通过常驻内存的方式解决了早期CGI实现每次都需要解析php.ini及初始化执行环境导致的耗时长的问题，支持平滑启动及动态Worker调度。\n\n\n\n#### 参考资料\n\n1. [搞不清FastCGI与PHP-FPM之间是个什么样的关系？](https://segmentfault.com/q/1010000000256516)\n\n2. [概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM](http://www.nowamagic.net/librarys/veda/detail/1319)\n3. [在Nginx中理解和实现FastCGI代理](https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx)\n\n4. [php中fastcgi和php-fpm是什么东西](https://zhuanlan.zhihu.com/p/101433025)\n\n5. [FastCGI](https://zh.wikipedia.org/wiki/FastCGI)\n6. [php-cgi和php-fpm有什么关系？](https://segmentfault.com/q/1010000008356979)\n\n7. [WHY IS FASTCGI /W NGINX SO MUCH FASTER THAN APACHE /W MOD_PHP?](https://www.eschrade.com/page/why-is-fastcgi-w-nginx-so-much-faster-than-apache-w-mod_php/)\n8. [CGI、FastCGI和PHP-FPM关系图解](https://www.awaimai.com/371.html)","source":"_posts/FastCGI和PHP-FPM的关系.md","raw":"---\ntitle: FastCGI和PHP-FPM的关系\ndate: 2020-08-25 10:11:05\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n#### 1 相关概念\n\n##### 1.1 CGI\n\n`CGI`（Common Gateway Interface, 通用网关接口）是`WEB服务器`与`WEB Application`进行通信的工具，用于保证WEB Server传递的数据是标准格式的，是一种协议，其程序运行在服务器上，CGI可以用任何一种语言编写，只要该语言具有标准输入、输出和环境变量，如PHP、Perl等。\n\n<!--more-->\n\n<u>WEB Server只是内容的分发者</u>。CGI规定要传输哪些数据，以什么格式传递给后方处理。\n\n- 若客户端请求的是**静态数据**（如：`/index.html`），那么WEB Server会取文件系统中找到这个文件，并发送给浏览器，其流程如下所示：\n![客户端请求静态数据](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/客户端请求静态数据.png)\n\n- 若请求的是**非静态数据**（如：`/index.php`），根据配置文件，WEB Server（如：Nginx）知道这个不是静态文件，那么Nginx将会把该请求简单处理后交给PHP解析器。比如：URL、查询字符串、POST数据、HTTP Header等。PHP解析器收到数据首先会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程。WEB Server再把结果返回给浏览器。其流程如下所示：\n\n![客户端请求动态数据](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/客户端请求非静态数据.png)\n\n**缺陷**：<u>CGI只是个协议，与进程没有关系，PHP解析器在每次请求都会解析php.ini文件，初始化执行环境。所以处理时间耗时较长。</u>\n\n\n\n##### 1.2 FastCGI\n\n`FastCGI`（Fast Common Gateway Interface，快速通用网关接口）是一种让交互程序与WEB服务器通信的协议。FastCGI是CGI的增强版，通过常驻（Long-live）进程解决了CGI的Fork-Execute的缺点，减少Web服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。\n\n**FastCGI的实现**：FastCGI通过FastCGI进程管理器管理进程，在其自身初始化时，会fork多个FastCGI进程，并等待WEB服务器的连接。当一个请求来时，Web服务器将环境变量和页面请求通过socket或TCP连接传递给FastCGI进程。响应通过相同的连接从进程返回到WEB服务器，再传递给客户端。\n\n（*注：每次请求连接可能在相应结束时关闭，但WEB服务器和FastCGI服务进程都将持续，不会销毁。*）\n\n![FastCGI处理过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/FastCGI处理过程.png)\n\n**FastCGI优点**：\n\n- ①、每个单独的FastCGI进程在其生命周期内可以处理多个请求，从而避免每个请求进程创建和终止的开销。\n\n- ②、并发处理多个请求稳定性和可扩展性（配置多个FastCGI服务器）。\n\n\n\n**FastCGI的缺点**：\n\n- 由于FastCGI是多进程的，所以相比CGI多进程消耗更多服务器内存（如：PHP-CGI解释器每进程消耗7~25M内存，将这个数乘以50或100将是很大的内存数。）\n\n\n\n##### 1.3 PHP-CGI\n\n`php-cgi`是早期php官方出品的FastCGI管理器。\n\n缺点：\n\n①、PHP-CGI更改了php.ini配置后需要重启php-cgi才能让配置生效，不支持平滑重启。\n\n②、直接杀死PHP-CGI进程，PHP就不能运行了。而PHP-FPM和SPAWN-FCGI在杀掉进程后，守护进程会平滑重新生成子进程。\n\n③、不支持动态worker调度，只能一开始指定要起几个worker。\n\n\n\n##### 1.4 PHP-FPM\n\nPHP-CGI是使用PHP语言实现的了FastCGI的一个程序，后来被PHP官方收了。\n\nPHP-FPM加入了动态调度功能，可以根据请求来访压力变化动态增加worker进程数量来支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置\n\n\n\n#### 2 Web Server传递数据给Web Application（PHP应用）的方法\n\nPHP使用SAPI提供的2种连接方法与WEB Server通信：`mod_php`和`mod_fastcgi`。其中Apache通过mod_php来解析PHP，Nginx通过mod_fastcgi来解析。\n\n##### 2.1 Mod_php模式\n\nmod_php通过嵌入PHP解释器到Web Server进程中，只能与WEB Server配合使用。以Apache为例，其调用PHP执行过程如下：\n\n![Mod_php处理过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI和PHP-FPM的关系/Mod_php模式.png)\n\n`Apache->httpd->php5_module->sapi->php`\n\n**缺点**：\n\n- ①、该种模式下，WEB服务器每接收一个请求，都会产生一个进程通过sapi接连PHP完成请求，若用户过多，并发量大时，服务器会承受不住。\n\n- ②、内存占用大，无论是否用到PHP解释器都会将其加在到内存中，典型的就是处理CSS、JS之类的静态文件是完全没有必要加载解释器。\n\n- ③、把mod_php编进Web服务器时，出问题很难定位是php的问题还是WEB服务器的问题。\n\n\n\n**2.2 Mod_FastCGI模式**\n\n`mod_fastcgi`以独立的进程形式出现，只要对应的WEB Server（如：Nginx）实现了cgi/fastCgi协议，就能处理PHP请求。\n\n\n\n##### 2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】\n\n- ①、若仅在Web服务器上运行PHP，那么Apache相较Nginx有更高的性能，若看到明显的性能差异，则应检查AllowOverride是否打开（httpd.conf），然后重试。\n\n- ②、若运行混合内容（例如添加CSS,JS和图像），则Nginx将提供更好的总体性能，但不会更快地运行PHP。另外Nginx在拒绝服务攻击及减轻CDN风险做的更好。\n\n#### 3 总结\n\n简单的来说，`PHP-FPM`是实现了`FastCGI协议`的一个`进程管理器`。它通过常驻内存的方式解决了早期CGI实现每次都需要解析php.ini及初始化执行环境导致的耗时长的问题，支持平滑启动及动态Worker调度。\n\n\n\n#### 参考资料\n\n1. [搞不清FastCGI与PHP-FPM之间是个什么样的关系？](https://segmentfault.com/q/1010000000256516)\n\n2. [概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM](http://www.nowamagic.net/librarys/veda/detail/1319)\n3. [在Nginx中理解和实现FastCGI代理](https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx)\n\n4. [php中fastcgi和php-fpm是什么东西](https://zhuanlan.zhihu.com/p/101433025)\n\n5. [FastCGI](https://zh.wikipedia.org/wiki/FastCGI)\n6. [php-cgi和php-fpm有什么关系？](https://segmentfault.com/q/1010000008356979)\n\n7. [WHY IS FASTCGI /W NGINX SO MUCH FASTER THAN APACHE /W MOD_PHP?](https://www.eschrade.com/page/why-is-fastcgi-w-nginx-so-much-faster-than-apache-w-mod_php/)\n8. [CGI、FastCGI和PHP-FPM关系图解](https://www.awaimai.com/371.html)","slug":"FastCGI和PHP-FPM的关系","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabke001r45g39y9s4gao","content":"<h4 id=\"1-相关概念\"><a href=\"#1-相关概念\" class=\"headerlink\" title=\"1 相关概念\"></a>1 相关概念</h4><h5 id=\"1-1-CGI\"><a href=\"#1-1-CGI\" class=\"headerlink\" title=\"1.1 CGI\"></a>1.1 CGI</h5><p><code>CGI</code>（Common Gateway Interface, 通用网关接口）是<code>WEB服务器</code>与<code>WEB Application</code>进行通信的工具，用于保证WEB Server传递的数据是标准格式的，是一种协议，其程序运行在服务器上，CGI可以用任何一种语言编写，只要该语言具有标准输入、输出和环境变量，如PHP、Perl等。</p>\n<a id=\"more\"></a>\n\n<p><u>WEB Server只是内容的分发者</u>。CGI规定要传输哪些数据，以什么格式传递给后方处理。</p>\n<ul>\n<li><p>若客户端请求的是<strong>静态数据</strong>（如：<code>/index.html</code>），那么WEB Server会取文件系统中找到这个文件，并发送给浏览器，其流程如下所示：<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE.png\" alt=\"客户端请求静态数据\"></p>\n</li>\n<li><p>若请求的是<strong>非静态数据</strong>（如：<code>/index.php</code>），根据配置文件，WEB Server（如：Nginx）知道这个不是静态文件，那么Nginx将会把该请求简单处理后交给PHP解析器。比如：URL、查询字符串、POST数据、HTTP Header等。PHP解析器收到数据首先会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程。WEB Server再把结果返回给浏览器。其流程如下所示：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E9%9D%9E%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE.png\" alt=\"客户端请求动态数据\"></p>\n<p><strong>缺陷</strong>：<u>CGI只是个协议，与进程没有关系，PHP解析器在每次请求都会解析php.ini文件，初始化执行环境。所以处理时间耗时较长。</u></p>\n<h5 id=\"1-2-FastCGI\"><a href=\"#1-2-FastCGI\" class=\"headerlink\" title=\"1.2 FastCGI\"></a>1.2 FastCGI</h5><p><code>FastCGI</code>（Fast Common Gateway Interface，快速通用网关接口）是一种让交互程序与WEB服务器通信的协议。FastCGI是CGI的增强版，通过常驻（Long-live）进程解决了CGI的Fork-Execute的缺点，减少Web服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。</p>\n<p><strong>FastCGI的实现</strong>：FastCGI通过FastCGI进程管理器管理进程，在其自身初始化时，会fork多个FastCGI进程，并等待WEB服务器的连接。当一个请求来时，Web服务器将环境变量和页面请求通过socket或TCP连接传递给FastCGI进程。响应通过相同的连接从进程返回到WEB服务器，再传递给客户端。</p>\n<p>（<em>注：每次请求连接可能在相应结束时关闭，但WEB服务器和FastCGI服务进程都将持续，不会销毁。</em>）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/FastCGI%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png\" alt=\"FastCGI处理过程\"></p>\n<p><strong>FastCGI优点</strong>：</p>\n<ul>\n<li><p>①、每个单独的FastCGI进程在其生命周期内可以处理多个请求，从而避免每个请求进程创建和终止的开销。</p>\n</li>\n<li><p>②、并发处理多个请求稳定性和可扩展性（配置多个FastCGI服务器）。</p>\n</li>\n</ul>\n<p><strong>FastCGI的缺点</strong>：</p>\n<ul>\n<li>由于FastCGI是多进程的，所以相比CGI多进程消耗更多服务器内存（如：PHP-CGI解释器每进程消耗7~25M内存，将这个数乘以50或100将是很大的内存数。）</li>\n</ul>\n<h5 id=\"1-3-PHP-CGI\"><a href=\"#1-3-PHP-CGI\" class=\"headerlink\" title=\"1.3 PHP-CGI\"></a>1.3 PHP-CGI</h5><p><code>php-cgi</code>是早期php官方出品的FastCGI管理器。</p>\n<p>缺点：</p>\n<p>①、PHP-CGI更改了php.ini配置后需要重启php-cgi才能让配置生效，不支持平滑重启。</p>\n<p>②、直接杀死PHP-CGI进程，PHP就不能运行了。而PHP-FPM和SPAWN-FCGI在杀掉进程后，守护进程会平滑重新生成子进程。</p>\n<p>③、不支持动态worker调度，只能一开始指定要起几个worker。</p>\n<h5 id=\"1-4-PHP-FPM\"><a href=\"#1-4-PHP-FPM\" class=\"headerlink\" title=\"1.4 PHP-FPM\"></a>1.4 PHP-FPM</h5><p>PHP-CGI是使用PHP语言实现的了FastCGI的一个程序，后来被PHP官方收了。</p>\n<p>PHP-FPM加入了动态调度功能，可以根据请求来访压力变化动态增加worker进程数量来支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置</p>\n<h4 id=\"2-Web-Server传递数据给Web-Application（PHP应用）的方法\"><a href=\"#2-Web-Server传递数据给Web-Application（PHP应用）的方法\" class=\"headerlink\" title=\"2 Web Server传递数据给Web Application（PHP应用）的方法\"></a>2 Web Server传递数据给Web Application（PHP应用）的方法</h4><p>PHP使用SAPI提供的2种连接方法与WEB Server通信：<code>mod_php</code>和<code>mod_fastcgi</code>。其中Apache通过mod_php来解析PHP，Nginx通过mod_fastcgi来解析。</p>\n<h5 id=\"2-1-Mod-php模式\"><a href=\"#2-1-Mod-php模式\" class=\"headerlink\" title=\"2.1 Mod_php模式\"></a>2.1 Mod_php模式</h5><p>mod_php通过嵌入PHP解释器到Web Server进程中，只能与WEB Server配合使用。以Apache为例，其调用PHP执行过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/Mod_php%E6%A8%A1%E5%BC%8F.png\" alt=\"Mod_php处理过程\"></p>\n<p><code>Apache-&gt;httpd-&gt;php5_module-&gt;sapi-&gt;php</code></p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><p>①、该种模式下，WEB服务器每接收一个请求，都会产生一个进程通过sapi接连PHP完成请求，若用户过多，并发量大时，服务器会承受不住。</p>\n</li>\n<li><p>②、内存占用大，无论是否用到PHP解释器都会将其加在到内存中，典型的就是处理CSS、JS之类的静态文件是完全没有必要加载解释器。</p>\n</li>\n<li><p>③、把mod_php编进Web服务器时，出问题很难定位是php的问题还是WEB服务器的问题。</p>\n</li>\n</ul>\n<p><strong>2.2 Mod_FastCGI模式</strong></p>\n<p><code>mod_fastcgi</code>以独立的进程形式出现，只要对应的WEB Server（如：Nginx）实现了cgi/fastCgi协议，就能处理PHP请求。</p>\n<h5 id=\"2-3-Apache（php-mod）与Nginx-性能对比【参考资料7】\"><a href=\"#2-3-Apache（php-mod）与Nginx-性能对比【参考资料7】\" class=\"headerlink\" title=\"2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】\"></a>2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】</h5><ul>\n<li><p>①、若仅在Web服务器上运行PHP，那么Apache相较Nginx有更高的性能，若看到明显的性能差异，则应检查AllowOverride是否打开（httpd.conf），然后重试。</p>\n</li>\n<li><p>②、若运行混合内容（例如添加CSS,JS和图像），则Nginx将提供更好的总体性能，但不会更快地运行PHP。另外Nginx在拒绝服务攻击及减轻CDN风险做的更好。</p>\n</li>\n</ul>\n<h4 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h4><p>简单的来说，<code>PHP-FPM</code>是实现了<code>FastCGI协议</code>的一个<code>进程管理器</code>。它通过常驻内存的方式解决了早期CGI实现每次都需要解析php.ini及初始化执行环境导致的耗时长的问题，支持平滑启动及动态Worker调度。</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><p><a href=\"https://segmentfault.com/q/1010000000256516\">搞不清FastCGI与PHP-FPM之间是个什么样的关系？</a></p>\n</li>\n<li><p><a href=\"http://www.nowamagic.net/librarys/veda/detail/1319\">概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM</a></p>\n</li>\n<li><p><a href=\"https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx\">在Nginx中理解和实现FastCGI代理</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/101433025\">php中fastcgi和php-fpm是什么东西</a></p>\n</li>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/FastCGI\">FastCGI</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/q/1010000008356979\">php-cgi和php-fpm有什么关系？</a></p>\n</li>\n<li><p><a href=\"https://www.eschrade.com/page/why-is-fastcgi-w-nginx-so-much-faster-than-apache-w-mod_php/\">WHY IS FASTCGI /W NGINX SO MUCH FASTER THAN APACHE /W MOD_PHP?</a></p>\n</li>\n<li><p><a href=\"https://www.awaimai.com/371.html\">CGI、FastCGI和PHP-FPM关系图解</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-相关概念\"><a href=\"#1-相关概念\" class=\"headerlink\" title=\"1 相关概念\"></a>1 相关概念</h4><h5 id=\"1-1-CGI\"><a href=\"#1-1-CGI\" class=\"headerlink\" title=\"1.1 CGI\"></a>1.1 CGI</h5><p><code>CGI</code>（Common Gateway Interface, 通用网关接口）是<code>WEB服务器</code>与<code>WEB Application</code>进行通信的工具，用于保证WEB Server传递的数据是标准格式的，是一种协议，其程序运行在服务器上，CGI可以用任何一种语言编写，只要该语言具有标准输入、输出和环境变量，如PHP、Perl等。</p>","more":"<p><u>WEB Server只是内容的分发者</u>。CGI规定要传输哪些数据，以什么格式传递给后方处理。</p>\n<ul>\n<li><p>若客户端请求的是<strong>静态数据</strong>（如：<code>/index.html</code>），那么WEB Server会取文件系统中找到这个文件，并发送给浏览器，其流程如下所示：<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE.png\" alt=\"客户端请求静态数据\"></p>\n</li>\n<li><p>若请求的是<strong>非静态数据</strong>（如：<code>/index.php</code>），根据配置文件，WEB Server（如：Nginx）知道这个不是静态文件，那么Nginx将会把该请求简单处理后交给PHP解析器。比如：URL、查询字符串、POST数据、HTTP Header等。PHP解析器收到数据首先会解析php.ini文件，初始化执行环境，然后处理请求，再以CGI规定的格式返回处理后的结果，退出进程。WEB Server再把结果返回给浏览器。其流程如下所示：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E9%9D%9E%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE.png\" alt=\"客户端请求动态数据\"></p>\n<p><strong>缺陷</strong>：<u>CGI只是个协议，与进程没有关系，PHP解析器在每次请求都会解析php.ini文件，初始化执行环境。所以处理时间耗时较长。</u></p>\n<h5 id=\"1-2-FastCGI\"><a href=\"#1-2-FastCGI\" class=\"headerlink\" title=\"1.2 FastCGI\"></a>1.2 FastCGI</h5><p><code>FastCGI</code>（Fast Common Gateway Interface，快速通用网关接口）是一种让交互程序与WEB服务器通信的协议。FastCGI是CGI的增强版，通过常驻（Long-live）进程解决了CGI的Fork-Execute的缺点，减少Web服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。</p>\n<p><strong>FastCGI的实现</strong>：FastCGI通过FastCGI进程管理器管理进程，在其自身初始化时，会fork多个FastCGI进程，并等待WEB服务器的连接。当一个请求来时，Web服务器将环境变量和页面请求通过socket或TCP连接传递给FastCGI进程。响应通过相同的连接从进程返回到WEB服务器，再传递给客户端。</p>\n<p>（<em>注：每次请求连接可能在相应结束时关闭，但WEB服务器和FastCGI服务进程都将持续，不会销毁。</em>）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/FastCGI%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png\" alt=\"FastCGI处理过程\"></p>\n<p><strong>FastCGI优点</strong>：</p>\n<ul>\n<li><p>①、每个单独的FastCGI进程在其生命周期内可以处理多个请求，从而避免每个请求进程创建和终止的开销。</p>\n</li>\n<li><p>②、并发处理多个请求稳定性和可扩展性（配置多个FastCGI服务器）。</p>\n</li>\n</ul>\n<p><strong>FastCGI的缺点</strong>：</p>\n<ul>\n<li>由于FastCGI是多进程的，所以相比CGI多进程消耗更多服务器内存（如：PHP-CGI解释器每进程消耗7~25M内存，将这个数乘以50或100将是很大的内存数。）</li>\n</ul>\n<h5 id=\"1-3-PHP-CGI\"><a href=\"#1-3-PHP-CGI\" class=\"headerlink\" title=\"1.3 PHP-CGI\"></a>1.3 PHP-CGI</h5><p><code>php-cgi</code>是早期php官方出品的FastCGI管理器。</p>\n<p>缺点：</p>\n<p>①、PHP-CGI更改了php.ini配置后需要重启php-cgi才能让配置生效，不支持平滑重启。</p>\n<p>②、直接杀死PHP-CGI进程，PHP就不能运行了。而PHP-FPM和SPAWN-FCGI在杀掉进程后，守护进程会平滑重新生成子进程。</p>\n<p>③、不支持动态worker调度，只能一开始指定要起几个worker。</p>\n<h5 id=\"1-4-PHP-FPM\"><a href=\"#1-4-PHP-FPM\" class=\"headerlink\" title=\"1.4 PHP-FPM\"></a>1.4 PHP-FPM</h5><p>PHP-CGI是使用PHP语言实现的了FastCGI的一个程序，后来被PHP官方收了。</p>\n<p>PHP-FPM加入了动态调度功能，可以根据请求来访压力变化动态增加worker进程数量来支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置</p>\n<h4 id=\"2-Web-Server传递数据给Web-Application（PHP应用）的方法\"><a href=\"#2-Web-Server传递数据给Web-Application（PHP应用）的方法\" class=\"headerlink\" title=\"2 Web Server传递数据给Web Application（PHP应用）的方法\"></a>2 Web Server传递数据给Web Application（PHP应用）的方法</h4><p>PHP使用SAPI提供的2种连接方法与WEB Server通信：<code>mod_php</code>和<code>mod_fastcgi</code>。其中Apache通过mod_php来解析PHP，Nginx通过mod_fastcgi来解析。</p>\n<h5 id=\"2-1-Mod-php模式\"><a href=\"#2-1-Mod-php模式\" class=\"headerlink\" title=\"2.1 Mod_php模式\"></a>2.1 Mod_php模式</h5><p>mod_php通过嵌入PHP解释器到Web Server进程中，只能与WEB Server配合使用。以Apache为例，其调用PHP执行过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/Mod_php%E6%A8%A1%E5%BC%8F.png\" alt=\"Mod_php处理过程\"></p>\n<p><code>Apache-&gt;httpd-&gt;php5_module-&gt;sapi-&gt;php</code></p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><p>①、该种模式下，WEB服务器每接收一个请求，都会产生一个进程通过sapi接连PHP完成请求，若用户过多，并发量大时，服务器会承受不住。</p>\n</li>\n<li><p>②、内存占用大，无论是否用到PHP解释器都会将其加在到内存中，典型的就是处理CSS、JS之类的静态文件是完全没有必要加载解释器。</p>\n</li>\n<li><p>③、把mod_php编进Web服务器时，出问题很难定位是php的问题还是WEB服务器的问题。</p>\n</li>\n</ul>\n<p><strong>2.2 Mod_FastCGI模式</strong></p>\n<p><code>mod_fastcgi</code>以独立的进程形式出现，只要对应的WEB Server（如：Nginx）实现了cgi/fastCgi协议，就能处理PHP请求。</p>\n<h5 id=\"2-3-Apache（php-mod）与Nginx-性能对比【参考资料7】\"><a href=\"#2-3-Apache（php-mod）与Nginx-性能对比【参考资料7】\" class=\"headerlink\" title=\"2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】\"></a>2.3 Apache（php_mod）与Nginx()性能对比【参考资料7】</h5><ul>\n<li><p>①、若仅在Web服务器上运行PHP，那么Apache相较Nginx有更高的性能，若看到明显的性能差异，则应检查AllowOverride是否打开（httpd.conf），然后重试。</p>\n</li>\n<li><p>②、若运行混合内容（例如添加CSS,JS和图像），则Nginx将提供更好的总体性能，但不会更快地运行PHP。另外Nginx在拒绝服务攻击及减轻CDN风险做的更好。</p>\n</li>\n</ul>\n<h4 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h4><p>简单的来说，<code>PHP-FPM</code>是实现了<code>FastCGI协议</code>的一个<code>进程管理器</code>。它通过常驻内存的方式解决了早期CGI实现每次都需要解析php.ini及初始化执行环境导致的耗时长的问题，支持平滑启动及动态Worker调度。</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><p><a href=\"https://segmentfault.com/q/1010000000256516\">搞不清FastCGI与PHP-FPM之间是个什么样的关系？</a></p>\n</li>\n<li><p><a href=\"http://www.nowamagic.net/librarys/veda/detail/1319\">概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM</a></p>\n</li>\n<li><p><a href=\"https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx\">在Nginx中理解和实现FastCGI代理</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/101433025\">php中fastcgi和php-fpm是什么东西</a></p>\n</li>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/FastCGI\">FastCGI</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/q/1010000008356979\">php-cgi和php-fpm有什么关系？</a></p>\n</li>\n<li><p><a href=\"https://www.eschrade.com/page/why-is-fastcgi-w-nginx-so-much-faster-than-apache-w-mod_php/\">WHY IS FASTCGI /W NGINX SO MUCH FASTER THAN APACHE /W MOD_PHP?</a></p>\n</li>\n<li><p><a href=\"https://www.awaimai.com/371.html\">CGI、FastCGI和PHP-FPM关系图解</a></p>\n</li>\n</ol>"},{"title":"HTTP-GET与POST的区别？","date":"2020-09-23T07:12:44.000Z","_content":"\n\n\nGET和POST都是HTTP协议中的两种发送请求的方法，由于HTTP是基于TCP/IP，所以GET和POST的底层也是基于TCP/IP。GET和POST能做的事是一样的，使用GET方法请求时，加上`Request body`，或者使用POST请求方法是带上Url参数，技术上是完全行得通的。也就是说GET和POST在本质上没有什么太大的区别。\n\n<!--more-->\n\n### 1 关于应用场景\n\nHTTP最早被用来做浏览器与服务器之间交互HTML和表单的通讯协议了后来又被被广泛的扩充到接口格式的定义上。所以在讨论GET和POST区别的时候，需要现确定下到底是浏览器使用的GET/POST还是用HTTP作为接口传输协议的场景。\n\n#### 1.1 浏览器场景\n\n（注：此处特指浏览器中非Ajax的HTTP请求。）\n\n##### 1.1.1 定义\n\n- GET：获取一个资源，比如：获取一个html页面/图片/css/js等。\n- POST：在页面里标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，不幂等的\n\n##### 1.1.2 能否缓存\n\n- GET：允许缓存\n    - 因为是获取资源，反复读取是不应该对数据有副作用的，比如：GET一下，用户就下单，返回订单已受理，这个是不能接收的。因为是获取资源，是可以对GET请求的数据进行缓存的，可由浏览器本身、代理（如Nginx）或服务端（Etag）缓存，减少带宽。\n- POST：不允许缓存\n    - 不幂等，意味着不能多次执行，也不能缓存。（比如：若下单请求成功页面被缓存了，POST请求不向服务器发送请求，直接返回成功，却没有真正创建订单。）在浏览器中刷新页面，也会有副作用，浏览器会弹出弹框，提示用户是否继续。\n\n##### 1.1.3 携带参数的格式\n\n- GET：Url上携带\n    - 当在浏览器发出一个GET请求时，就意味着要么用户自己在浏览器地址栏输入，要么就是点击了HTML中a标签的href中的Url。因此不是GET只能用Url，而是浏览器提供的发出GET只能由一个Url触发。\n（<u>注：HTTP本身是没有这个限制的！</u>）\n- POST：表单提交\n    - 浏览器的POST请求都来自表单提交，每次提交浏览器会将要提交的数据编码，并放在HTTP请求的body（请求主体）中。\n    - 浏览器发出的POST的body格式主要有两种：\n        - ①、application/x-www-form-urlencoded：传输简单数据，通常以key-value格式传输。\n        - ②、multipart/form-data：比如传输大文件，或json串等。\n\n（<u>注：当POST一个表单时，Url也可以带参数，只是的标签数据会存在body中</u>）\n\n##### 1.1.4 总结\n\n对于浏览器发请求的场景，可以泛概为：“**GET请求没有body，只有Url，请求数据放在Url的querystring中；POST请求的数据在body中**“。\n\n#### 1.2 接口场景\n\n接口场景包括：\n\n- ①、浏览器的Ajax api\n- ②、IOS/Android的App的Http Client\n- ③、Java的Commons-Httpclient/okhttp\n- ④、Curl\n- ⑤、Postman等工具\n\n\n\n**当使用HTTP实现接口发送请求时，就没有浏览器中那么多限制，只要符合HTTP协议格式的就可以发送。**\n\nHTTP请求包格式如下：\n\n​    ![HTTP请求包](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/HTTP请求包.png)\n\n（<u>请求行格式：请求方法 URI 协议版本</u>）\n\n从协议本身看，并没有限制GET不一定没有Body，POST就一定不能把参数放在URI的queryString上。\n\n\n\n### 2 关于安全性\n\n我们经常听到GET方法不如POST方法安全，因为GET使用Url传输，更加容易被看到。但其实从攻击的角度看，无论GET还是POST都不够安全，因为<u>HTTP本身是明文协议</u>。\n\n为了避免传输数据被窃取，必须做从客户端到服务端端加密。<u>通常使用https进行加密传输</u>。（银行、金融、军用等特殊机构，也可以使用其他的加密方式）\n\n\n\n相比之下GET有更多的机会被泄露，比如：\n- ①、携带私密信息的Url会展示在地址栏，还可以分享给他人，非常不安全。\n- ②、从客户端到服务器端，有大量的中间结点，包括网关、代理等，他们的access log通常会输出完整的Url，比如Nginx默认的Access log会打印Url（当然，通过设置，也可打印出body中的内容）。如果Url中携带了敏感数据，就会被记录下来。\n\n\n避免泄露的唯一手段，就是端端加密（HTTPS等实现）。推荐私密数据传输方法：用POST+body方式。\n\n\n\n### 3 关于编码\n\n有说法说GET的参数只支持ASCII，而POST能支持任意binary，包括中文。但其实<u>针对接口方式实现GET,POST方法实际都能用Url和Body。因此所谓编码确切的说应该是HTTP中Url和Body用什么编码。</u>\n\n#### 3.1 Url编码\n\n##### 3.1.1 字符集合[a-zA-Z0-9$-_.+!*'(),]\n\n[RFC1738](https://link.zhihu.com/?target=https%3A//www.ietf.org/rfc/rfc1738.txt)中规定了一个ASCII的子集[a-zA-Z0-9$-_.+!*'(),]，可以不经过编码在Url中使用（尽管空格也是ASCII字，但是不能直接用在Url中）。\n\n```\nThus, only alphanumerics, the special characters \"$-_.+!*'(),\", and\nreserved characters used for their reserved purposes may be used\nunencoded within a URL.      \n```\n\n##### 3.1.2 特殊字符和中文\n\n有一个编码方式`Percent encoding`，可以将特殊字符和中文编码，甚至binary data编码为Url支持的字符。\n（这个编码方式只管把字符转换成Url可用字符，并不管字符集编码）\n\n\n\n#### 3.2 Body编码\nBody中有一个`Content-Type`来明确定义格式，如：\n\n```\nPOST xxxxxx HTTP/1.1\n...\nContent-Type: application/x-www-form-urlencoded ; charset=UTF-8\n```\n\n​    \n\n#### 3.3 总结\n\nBody和Url都可以提交中文给后端，但是POST的规范好一些，比较不容易出错。\n\n\n\n### 4 请求次数\n\n上面的请求报文可大致分为“报文首部”和“报文主体”两个部分。\n\n使用HTTP时大家会有一个约定，即所有的“控制类”信息应该放在请求头，具体的数据放在请求体里。于是服务器端在解析时，总是先完全解析全部请求头，这样，服务器端总是希望能够了解请求的控制信息后，就能决定这个请求怎么进一步处理，是拒绝，还是根据Content-type去调用相应的解析器处理数据或是zero copy转发。\n\n客户端就能做一些优化，比如内部设定一次POST的数据超过1KB就先只发“请求头”，否则就一次性全发。客户端甚至还可以做一些Adaptive的策略，统计发送成功率，如果成功率很高，就总是全部发等等。不同浏览器，不同的客户端（curl，postman）可以有各自的不同的方案。不管怎样做，优化目的总是在提高数据吞吐和降低带宽浪费上做一个折衷。\n\n因此到底是发一次还是发N次，客户端可以很灵活的决定。因为不管怎么发都是符合HTTP协议的，因此我们应该视为这种优化是一种实现细节，而不用扯到GET和POST本身的区别上。更不要当个什么世纪大发现。\n\n\n\n### 5 关于Url的长度\n\n因为上面提到了不论是GET和POST都可以使用URL传递数据，所以我们常说的“GET数据有长度限制“其实是指”URL的长度限制“。HTTP协议本身对URL长度并没有做任何规定。实际限制是由客户端/浏览器以及服务器端决定的。\n\n#### 5.1 浏览器\n\n不同浏览器不一样，\n\n------\n\n### 参考资料：\n\n1、[99% 的人都理解错了 HTTP 中 GET 与 POST 的区别【面试必问】](https://zhuanlan.zhihu.com/p/54654014)\n2、[GET和POST到底有什么区别？](https://www.zhihu.com/question/28586791/answer/767316172)\n3、[Percent-encoding](https://en.wikipedia.org/wiki/Percent-encoding)","source":"_posts/HTTP-GET与POST的区别？.md","raw":"---\ntitle: HTTP-GET与POST的区别？\ndate: 2020-09-23 15:12:44\ntags: [\"HTTP\",\"Interview\"]\ncategories: [\"HTTP\"]\n---\n\n\n\nGET和POST都是HTTP协议中的两种发送请求的方法，由于HTTP是基于TCP/IP，所以GET和POST的底层也是基于TCP/IP。GET和POST能做的事是一样的，使用GET方法请求时，加上`Request body`，或者使用POST请求方法是带上Url参数，技术上是完全行得通的。也就是说GET和POST在本质上没有什么太大的区别。\n\n<!--more-->\n\n### 1 关于应用场景\n\nHTTP最早被用来做浏览器与服务器之间交互HTML和表单的通讯协议了后来又被被广泛的扩充到接口格式的定义上。所以在讨论GET和POST区别的时候，需要现确定下到底是浏览器使用的GET/POST还是用HTTP作为接口传输协议的场景。\n\n#### 1.1 浏览器场景\n\n（注：此处特指浏览器中非Ajax的HTTP请求。）\n\n##### 1.1.1 定义\n\n- GET：获取一个资源，比如：获取一个html页面/图片/css/js等。\n- POST：在页面里标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，不幂等的\n\n##### 1.1.2 能否缓存\n\n- GET：允许缓存\n    - 因为是获取资源，反复读取是不应该对数据有副作用的，比如：GET一下，用户就下单，返回订单已受理，这个是不能接收的。因为是获取资源，是可以对GET请求的数据进行缓存的，可由浏览器本身、代理（如Nginx）或服务端（Etag）缓存，减少带宽。\n- POST：不允许缓存\n    - 不幂等，意味着不能多次执行，也不能缓存。（比如：若下单请求成功页面被缓存了，POST请求不向服务器发送请求，直接返回成功，却没有真正创建订单。）在浏览器中刷新页面，也会有副作用，浏览器会弹出弹框，提示用户是否继续。\n\n##### 1.1.3 携带参数的格式\n\n- GET：Url上携带\n    - 当在浏览器发出一个GET请求时，就意味着要么用户自己在浏览器地址栏输入，要么就是点击了HTML中a标签的href中的Url。因此不是GET只能用Url，而是浏览器提供的发出GET只能由一个Url触发。\n（<u>注：HTTP本身是没有这个限制的！</u>）\n- POST：表单提交\n    - 浏览器的POST请求都来自表单提交，每次提交浏览器会将要提交的数据编码，并放在HTTP请求的body（请求主体）中。\n    - 浏览器发出的POST的body格式主要有两种：\n        - ①、application/x-www-form-urlencoded：传输简单数据，通常以key-value格式传输。\n        - ②、multipart/form-data：比如传输大文件，或json串等。\n\n（<u>注：当POST一个表单时，Url也可以带参数，只是的标签数据会存在body中</u>）\n\n##### 1.1.4 总结\n\n对于浏览器发请求的场景，可以泛概为：“**GET请求没有body，只有Url，请求数据放在Url的querystring中；POST请求的数据在body中**“。\n\n#### 1.2 接口场景\n\n接口场景包括：\n\n- ①、浏览器的Ajax api\n- ②、IOS/Android的App的Http Client\n- ③、Java的Commons-Httpclient/okhttp\n- ④、Curl\n- ⑤、Postman等工具\n\n\n\n**当使用HTTP实现接口发送请求时，就没有浏览器中那么多限制，只要符合HTTP协议格式的就可以发送。**\n\nHTTP请求包格式如下：\n\n​    ![HTTP请求包](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/HTTP请求包.png)\n\n（<u>请求行格式：请求方法 URI 协议版本</u>）\n\n从协议本身看，并没有限制GET不一定没有Body，POST就一定不能把参数放在URI的queryString上。\n\n\n\n### 2 关于安全性\n\n我们经常听到GET方法不如POST方法安全，因为GET使用Url传输，更加容易被看到。但其实从攻击的角度看，无论GET还是POST都不够安全，因为<u>HTTP本身是明文协议</u>。\n\n为了避免传输数据被窃取，必须做从客户端到服务端端加密。<u>通常使用https进行加密传输</u>。（银行、金融、军用等特殊机构，也可以使用其他的加密方式）\n\n\n\n相比之下GET有更多的机会被泄露，比如：\n- ①、携带私密信息的Url会展示在地址栏，还可以分享给他人，非常不安全。\n- ②、从客户端到服务器端，有大量的中间结点，包括网关、代理等，他们的access log通常会输出完整的Url，比如Nginx默认的Access log会打印Url（当然，通过设置，也可打印出body中的内容）。如果Url中携带了敏感数据，就会被记录下来。\n\n\n避免泄露的唯一手段，就是端端加密（HTTPS等实现）。推荐私密数据传输方法：用POST+body方式。\n\n\n\n### 3 关于编码\n\n有说法说GET的参数只支持ASCII，而POST能支持任意binary，包括中文。但其实<u>针对接口方式实现GET,POST方法实际都能用Url和Body。因此所谓编码确切的说应该是HTTP中Url和Body用什么编码。</u>\n\n#### 3.1 Url编码\n\n##### 3.1.1 字符集合[a-zA-Z0-9$-_.+!*'(),]\n\n[RFC1738](https://link.zhihu.com/?target=https%3A//www.ietf.org/rfc/rfc1738.txt)中规定了一个ASCII的子集[a-zA-Z0-9$-_.+!*'(),]，可以不经过编码在Url中使用（尽管空格也是ASCII字，但是不能直接用在Url中）。\n\n```\nThus, only alphanumerics, the special characters \"$-_.+!*'(),\", and\nreserved characters used for their reserved purposes may be used\nunencoded within a URL.      \n```\n\n##### 3.1.2 特殊字符和中文\n\n有一个编码方式`Percent encoding`，可以将特殊字符和中文编码，甚至binary data编码为Url支持的字符。\n（这个编码方式只管把字符转换成Url可用字符，并不管字符集编码）\n\n\n\n#### 3.2 Body编码\nBody中有一个`Content-Type`来明确定义格式，如：\n\n```\nPOST xxxxxx HTTP/1.1\n...\nContent-Type: application/x-www-form-urlencoded ; charset=UTF-8\n```\n\n​    \n\n#### 3.3 总结\n\nBody和Url都可以提交中文给后端，但是POST的规范好一些，比较不容易出错。\n\n\n\n### 4 请求次数\n\n上面的请求报文可大致分为“报文首部”和“报文主体”两个部分。\n\n使用HTTP时大家会有一个约定，即所有的“控制类”信息应该放在请求头，具体的数据放在请求体里。于是服务器端在解析时，总是先完全解析全部请求头，这样，服务器端总是希望能够了解请求的控制信息后，就能决定这个请求怎么进一步处理，是拒绝，还是根据Content-type去调用相应的解析器处理数据或是zero copy转发。\n\n客户端就能做一些优化，比如内部设定一次POST的数据超过1KB就先只发“请求头”，否则就一次性全发。客户端甚至还可以做一些Adaptive的策略，统计发送成功率，如果成功率很高，就总是全部发等等。不同浏览器，不同的客户端（curl，postman）可以有各自的不同的方案。不管怎样做，优化目的总是在提高数据吞吐和降低带宽浪费上做一个折衷。\n\n因此到底是发一次还是发N次，客户端可以很灵活的决定。因为不管怎么发都是符合HTTP协议的，因此我们应该视为这种优化是一种实现细节，而不用扯到GET和POST本身的区别上。更不要当个什么世纪大发现。\n\n\n\n### 5 关于Url的长度\n\n因为上面提到了不论是GET和POST都可以使用URL传递数据，所以我们常说的“GET数据有长度限制“其实是指”URL的长度限制“。HTTP协议本身对URL长度并没有做任何规定。实际限制是由客户端/浏览器以及服务器端决定的。\n\n#### 5.1 浏览器\n\n不同浏览器不一样，\n\n------\n\n### 参考资料：\n\n1、[99% 的人都理解错了 HTTP 中 GET 与 POST 的区别【面试必问】](https://zhuanlan.zhihu.com/p/54654014)\n2、[GET和POST到底有什么区别？](https://www.zhihu.com/question/28586791/answer/767316172)\n3、[Percent-encoding](https://en.wikipedia.org/wiki/Percent-encoding)","slug":"HTTP-GET与POST的区别？","published":1,"updated":"2020-09-23T10:00:47.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkh001u45g302329a65","content":"<p>GET和POST都是HTTP协议中的两种发送请求的方法，由于HTTP是基于TCP/IP，所以GET和POST的底层也是基于TCP/IP。GET和POST能做的事是一样的，使用GET方法请求时，加上<code>Request body</code>，或者使用POST请求方法是带上Url参数，技术上是完全行得通的。也就是说GET和POST在本质上没有什么太大的区别。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-关于应用场景\"><a href=\"#1-关于应用场景\" class=\"headerlink\" title=\"1 关于应用场景\"></a>1 关于应用场景</h3><p>HTTP最早被用来做浏览器与服务器之间交互HTML和表单的通讯协议了后来又被被广泛的扩充到接口格式的定义上。所以在讨论GET和POST区别的时候，需要现确定下到底是浏览器使用的GET/POST还是用HTTP作为接口传输协议的场景。</p>\n<h4 id=\"1-1-浏览器场景\"><a href=\"#1-1-浏览器场景\" class=\"headerlink\" title=\"1.1 浏览器场景\"></a>1.1 浏览器场景</h4><p>（注：此处特指浏览器中非Ajax的HTTP请求。）</p>\n<h5 id=\"1-1-1-定义\"><a href=\"#1-1-1-定义\" class=\"headerlink\" title=\"1.1.1 定义\"></a>1.1.1 定义</h5><ul>\n<li>GET：获取一个资源，比如：获取一个html页面/图片/css/js等。</li>\n<li>POST：在页面里标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，不幂等的</li>\n</ul>\n<h5 id=\"1-1-2-能否缓存\"><a href=\"#1-1-2-能否缓存\" class=\"headerlink\" title=\"1.1.2 能否缓存\"></a>1.1.2 能否缓存</h5><ul>\n<li>GET：允许缓存<ul>\n<li>因为是获取资源，反复读取是不应该对数据有副作用的，比如：GET一下，用户就下单，返回订单已受理，这个是不能接收的。因为是获取资源，是可以对GET请求的数据进行缓存的，可由浏览器本身、代理（如Nginx）或服务端（Etag）缓存，减少带宽。</li>\n</ul>\n</li>\n<li>POST：不允许缓存<ul>\n<li>不幂等，意味着不能多次执行，也不能缓存。（比如：若下单请求成功页面被缓存了，POST请求不向服务器发送请求，直接返回成功，却没有真正创建订单。）在浏览器中刷新页面，也会有副作用，浏览器会弹出弹框，提示用户是否继续。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"1-1-3-携带参数的格式\"><a href=\"#1-1-3-携带参数的格式\" class=\"headerlink\" title=\"1.1.3 携带参数的格式\"></a>1.1.3 携带参数的格式</h5><ul>\n<li>GET：Url上携带<ul>\n<li>当在浏览器发出一个GET请求时，就意味着要么用户自己在浏览器地址栏输入，要么就是点击了HTML中a标签的href中的Url。因此不是GET只能用Url，而是浏览器提供的发出GET只能由一个Url触发。<br>（<u>注：HTTP本身是没有这个限制的！</u>）</li>\n</ul>\n</li>\n<li>POST：表单提交<ul>\n<li>浏览器的POST请求都来自表单提交，每次提交浏览器会将要提交的数据编码，并放在HTTP请求的body（请求主体）中。</li>\n<li>浏览器发出的POST的body格式主要有两种：<ul>\n<li>①、application/x-www-form-urlencoded：传输简单数据，通常以key-value格式传输。</li>\n<li>②、multipart/form-data：比如传输大文件，或json串等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>（<u>注：当POST一个表单时，Url也可以带参数，只是的标签数据会存在body中</u>）</p>\n<h5 id=\"1-1-4-总结\"><a href=\"#1-1-4-总结\" class=\"headerlink\" title=\"1.1.4 总结\"></a>1.1.4 总结</h5><p>对于浏览器发请求的场景，可以泛概为：“<strong>GET请求没有body，只有Url，请求数据放在Url的querystring中；POST请求的数据在body中</strong>“。</p>\n<h4 id=\"1-2-接口场景\"><a href=\"#1-2-接口场景\" class=\"headerlink\" title=\"1.2 接口场景\"></a>1.2 接口场景</h4><p>接口场景包括：</p>\n<ul>\n<li>①、浏览器的Ajax api</li>\n<li>②、IOS/Android的App的Http Client</li>\n<li>③、Java的Commons-Httpclient/okhttp</li>\n<li>④、Curl</li>\n<li>⑤、Postman等工具</li>\n</ul>\n<p><strong>当使用HTTP实现接口发送请求时，就没有浏览器中那么多限制，只要符合HTTP协议格式的就可以发送。</strong></p>\n<p>HTTP请求包格式如下：</p>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/HTTP%E8%AF%B7%E6%B1%82%E5%8C%85.png\" alt=\"HTTP请求包\"></p>\n<p>（<u>请求行格式：请求方法 URI 协议版本</u>）</p>\n<p>从协议本身看，并没有限制GET不一定没有Body，POST就一定不能把参数放在URI的queryString上。</p>\n<h3 id=\"2-关于安全性\"><a href=\"#2-关于安全性\" class=\"headerlink\" title=\"2 关于安全性\"></a>2 关于安全性</h3><p>我们经常听到GET方法不如POST方法安全，因为GET使用Url传输，更加容易被看到。但其实从攻击的角度看，无论GET还是POST都不够安全，因为<u>HTTP本身是明文协议</u>。</p>\n<p>为了避免传输数据被窃取，必须做从客户端到服务端端加密。<u>通常使用https进行加密传输</u>。（银行、金融、军用等特殊机构，也可以使用其他的加密方式）</p>\n<p>相比之下GET有更多的机会被泄露，比如：</p>\n<ul>\n<li>①、携带私密信息的Url会展示在地址栏，还可以分享给他人，非常不安全。</li>\n<li>②、从客户端到服务器端，有大量的中间结点，包括网关、代理等，他们的access log通常会输出完整的Url，比如Nginx默认的Access log会打印Url（当然，通过设置，也可打印出body中的内容）。如果Url中携带了敏感数据，就会被记录下来。</li>\n</ul>\n<p>避免泄露的唯一手段，就是端端加密（HTTPS等实现）。推荐私密数据传输方法：用POST+body方式。</p>\n<h3 id=\"3-关于编码\"><a href=\"#3-关于编码\" class=\"headerlink\" title=\"3 关于编码\"></a>3 关于编码</h3><p>有说法说GET的参数只支持ASCII，而POST能支持任意binary，包括中文。但其实<u>针对接口方式实现GET,POST方法实际都能用Url和Body。因此所谓编码确切的说应该是HTTP中Url和Body用什么编码。</u></p>\n<h4 id=\"3-1-Url编码\"><a href=\"#3-1-Url编码\" class=\"headerlink\" title=\"3.1 Url编码\"></a>3.1 Url编码</h4><h5 id=\"3-1-1-字符集合-a-zA-Z0-9-’\"><a href=\"#3-1-1-字符集合-a-zA-Z0-9-’\" class=\"headerlink\" title=\"3.1.1 字符集合[a-zA-Z0-9$-_.+!*’(),]\"></a>3.1.1 字符集合[a-zA-Z0-9$-_.+!*’(),]</h5><p><a href=\"https://link.zhihu.com/?target=https://www.ietf.org/rfc/rfc1738.txt\">RFC1738</a>中规定了一个ASCII的子集[a-zA-Z0-9$-_.+!*’(),]，可以不经过编码在Url中使用（尽管空格也是ASCII字，但是不能直接用在Url中）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thus, only alphanumerics, the special characters &quot;$-_.+!*&#39;(),&quot;, and</span><br><span class=\"line\">reserved characters used for their reserved purposes may be used</span><br><span class=\"line\">unencoded within a URL.      </span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-1-2-特殊字符和中文\"><a href=\"#3-1-2-特殊字符和中文\" class=\"headerlink\" title=\"3.1.2 特殊字符和中文\"></a>3.1.2 特殊字符和中文</h5><p>有一个编码方式<code>Percent encoding</code>，可以将特殊字符和中文编码，甚至binary data编码为Url支持的字符。<br>（这个编码方式只管把字符转换成Url可用字符，并不管字符集编码）</p>\n<h4 id=\"3-2-Body编码\"><a href=\"#3-2-Body编码\" class=\"headerlink\" title=\"3.2 Body编码\"></a>3.2 Body编码</h4><p>Body中有一个<code>Content-Type</code>来明确定义格式，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST xxxxxx HTTP&#x2F;1.1</span><br><span class=\"line\">...</span><br><span class=\"line\">Content-Type: application&#x2F;x-www-form-urlencoded ; charset&#x3D;UTF-8</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<h4 id=\"3-3-总结\"><a href=\"#3-3-总结\" class=\"headerlink\" title=\"3.3 总结\"></a>3.3 总结</h4><p>Body和Url都可以提交中文给后端，但是POST的规范好一些，比较不容易出错。</p>\n<h3 id=\"4-请求次数\"><a href=\"#4-请求次数\" class=\"headerlink\" title=\"4 请求次数\"></a>4 请求次数</h3><p>上面的请求报文可大致分为“报文首部”和“报文主体”两个部分。</p>\n<p>使用HTTP时大家会有一个约定，即所有的“控制类”信息应该放在请求头，具体的数据放在请求体里。于是服务器端在解析时，总是先完全解析全部请求头，这样，服务器端总是希望能够了解请求的控制信息后，就能决定这个请求怎么进一步处理，是拒绝，还是根据Content-type去调用相应的解析器处理数据或是zero copy转发。</p>\n<p>客户端就能做一些优化，比如内部设定一次POST的数据超过1KB就先只发“请求头”，否则就一次性全发。客户端甚至还可以做一些Adaptive的策略，统计发送成功率，如果成功率很高，就总是全部发等等。不同浏览器，不同的客户端（curl，postman）可以有各自的不同的方案。不管怎样做，优化目的总是在提高数据吞吐和降低带宽浪费上做一个折衷。</p>\n<p>因此到底是发一次还是发N次，客户端可以很灵活的决定。因为不管怎么发都是符合HTTP协议的，因此我们应该视为这种优化是一种实现细节，而不用扯到GET和POST本身的区别上。更不要当个什么世纪大发现。</p>\n<h3 id=\"5-关于Url的长度\"><a href=\"#5-关于Url的长度\" class=\"headerlink\" title=\"5 关于Url的长度\"></a>5 关于Url的长度</h3><p>因为上面提到了不论是GET和POST都可以使用URL传递数据，所以我们常说的“GET数据有长度限制“其实是指”URL的长度限制“。HTTP协议本身对URL长度并没有做任何规定。实际限制是由客户端/浏览器以及服务器端决定的。</p>\n<h4 id=\"5-1-浏览器\"><a href=\"#5-1-浏览器\" class=\"headerlink\" title=\"5.1 浏览器\"></a>5.1 浏览器</h4><p>不同浏览器不一样，</p>\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>1、<a href=\"https://zhuanlan.zhihu.com/p/54654014\">99% 的人都理解错了 HTTP 中 GET 与 POST 的区别【面试必问】</a><br>2、<a href=\"https://www.zhihu.com/question/28586791/answer/767316172\">GET和POST到底有什么区别？</a><br>3、<a href=\"https://en.wikipedia.org/wiki/Percent-encoding\">Percent-encoding</a></p>\n","site":{"data":{}},"excerpt":"<p>GET和POST都是HTTP协议中的两种发送请求的方法，由于HTTP是基于TCP/IP，所以GET和POST的底层也是基于TCP/IP。GET和POST能做的事是一样的，使用GET方法请求时，加上<code>Request body</code>，或者使用POST请求方法是带上Url参数，技术上是完全行得通的。也就是说GET和POST在本质上没有什么太大的区别。</p>","more":"<h3 id=\"1-关于应用场景\"><a href=\"#1-关于应用场景\" class=\"headerlink\" title=\"1 关于应用场景\"></a>1 关于应用场景</h3><p>HTTP最早被用来做浏览器与服务器之间交互HTML和表单的通讯协议了后来又被被广泛的扩充到接口格式的定义上。所以在讨论GET和POST区别的时候，需要现确定下到底是浏览器使用的GET/POST还是用HTTP作为接口传输协议的场景。</p>\n<h4 id=\"1-1-浏览器场景\"><a href=\"#1-1-浏览器场景\" class=\"headerlink\" title=\"1.1 浏览器场景\"></a>1.1 浏览器场景</h4><p>（注：此处特指浏览器中非Ajax的HTTP请求。）</p>\n<h5 id=\"1-1-1-定义\"><a href=\"#1-1-1-定义\" class=\"headerlink\" title=\"1.1.1 定义\"></a>1.1.1 定义</h5><ul>\n<li>GET：获取一个资源，比如：获取一个html页面/图片/css/js等。</li>\n<li>POST：在页面里标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，不幂等的</li>\n</ul>\n<h5 id=\"1-1-2-能否缓存\"><a href=\"#1-1-2-能否缓存\" class=\"headerlink\" title=\"1.1.2 能否缓存\"></a>1.1.2 能否缓存</h5><ul>\n<li>GET：允许缓存<ul>\n<li>因为是获取资源，反复读取是不应该对数据有副作用的，比如：GET一下，用户就下单，返回订单已受理，这个是不能接收的。因为是获取资源，是可以对GET请求的数据进行缓存的，可由浏览器本身、代理（如Nginx）或服务端（Etag）缓存，减少带宽。</li>\n</ul>\n</li>\n<li>POST：不允许缓存<ul>\n<li>不幂等，意味着不能多次执行，也不能缓存。（比如：若下单请求成功页面被缓存了，POST请求不向服务器发送请求，直接返回成功，却没有真正创建订单。）在浏览器中刷新页面，也会有副作用，浏览器会弹出弹框，提示用户是否继续。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"1-1-3-携带参数的格式\"><a href=\"#1-1-3-携带参数的格式\" class=\"headerlink\" title=\"1.1.3 携带参数的格式\"></a>1.1.3 携带参数的格式</h5><ul>\n<li>GET：Url上携带<ul>\n<li>当在浏览器发出一个GET请求时，就意味着要么用户自己在浏览器地址栏输入，要么就是点击了HTML中a标签的href中的Url。因此不是GET只能用Url，而是浏览器提供的发出GET只能由一个Url触发。<br>（<u>注：HTTP本身是没有这个限制的！</u>）</li>\n</ul>\n</li>\n<li>POST：表单提交<ul>\n<li>浏览器的POST请求都来自表单提交，每次提交浏览器会将要提交的数据编码，并放在HTTP请求的body（请求主体）中。</li>\n<li>浏览器发出的POST的body格式主要有两种：<ul>\n<li>①、application/x-www-form-urlencoded：传输简单数据，通常以key-value格式传输。</li>\n<li>②、multipart/form-data：比如传输大文件，或json串等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>（<u>注：当POST一个表单时，Url也可以带参数，只是的标签数据会存在body中</u>）</p>\n<h5 id=\"1-1-4-总结\"><a href=\"#1-1-4-总结\" class=\"headerlink\" title=\"1.1.4 总结\"></a>1.1.4 总结</h5><p>对于浏览器发请求的场景，可以泛概为：“<strong>GET请求没有body，只有Url，请求数据放在Url的querystring中；POST请求的数据在body中</strong>“。</p>\n<h4 id=\"1-2-接口场景\"><a href=\"#1-2-接口场景\" class=\"headerlink\" title=\"1.2 接口场景\"></a>1.2 接口场景</h4><p>接口场景包括：</p>\n<ul>\n<li>①、浏览器的Ajax api</li>\n<li>②、IOS/Android的App的Http Client</li>\n<li>③、Java的Commons-Httpclient/okhttp</li>\n<li>④、Curl</li>\n<li>⑤、Postman等工具</li>\n</ul>\n<p><strong>当使用HTTP实现接口发送请求时，就没有浏览器中那么多限制，只要符合HTTP协议格式的就可以发送。</strong></p>\n<p>HTTP请求包格式如下：</p>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/HTTP%E8%AF%B7%E6%B1%82%E5%8C%85.png\" alt=\"HTTP请求包\"></p>\n<p>（<u>请求行格式：请求方法 URI 协议版本</u>）</p>\n<p>从协议本身看，并没有限制GET不一定没有Body，POST就一定不能把参数放在URI的queryString上。</p>\n<h3 id=\"2-关于安全性\"><a href=\"#2-关于安全性\" class=\"headerlink\" title=\"2 关于安全性\"></a>2 关于安全性</h3><p>我们经常听到GET方法不如POST方法安全，因为GET使用Url传输，更加容易被看到。但其实从攻击的角度看，无论GET还是POST都不够安全，因为<u>HTTP本身是明文协议</u>。</p>\n<p>为了避免传输数据被窃取，必须做从客户端到服务端端加密。<u>通常使用https进行加密传输</u>。（银行、金融、军用等特殊机构，也可以使用其他的加密方式）</p>\n<p>相比之下GET有更多的机会被泄露，比如：</p>\n<ul>\n<li>①、携带私密信息的Url会展示在地址栏，还可以分享给他人，非常不安全。</li>\n<li>②、从客户端到服务器端，有大量的中间结点，包括网关、代理等，他们的access log通常会输出完整的Url，比如Nginx默认的Access log会打印Url（当然，通过设置，也可打印出body中的内容）。如果Url中携带了敏感数据，就会被记录下来。</li>\n</ul>\n<p>避免泄露的唯一手段，就是端端加密（HTTPS等实现）。推荐私密数据传输方法：用POST+body方式。</p>\n<h3 id=\"3-关于编码\"><a href=\"#3-关于编码\" class=\"headerlink\" title=\"3 关于编码\"></a>3 关于编码</h3><p>有说法说GET的参数只支持ASCII，而POST能支持任意binary，包括中文。但其实<u>针对接口方式实现GET,POST方法实际都能用Url和Body。因此所谓编码确切的说应该是HTTP中Url和Body用什么编码。</u></p>\n<h4 id=\"3-1-Url编码\"><a href=\"#3-1-Url编码\" class=\"headerlink\" title=\"3.1 Url编码\"></a>3.1 Url编码</h4><h5 id=\"3-1-1-字符集合-a-zA-Z0-9-’\"><a href=\"#3-1-1-字符集合-a-zA-Z0-9-’\" class=\"headerlink\" title=\"3.1.1 字符集合[a-zA-Z0-9$-_.+!*’(),]\"></a>3.1.1 字符集合[a-zA-Z0-9$-_.+!*’(),]</h5><p><a href=\"https://link.zhihu.com/?target=https://www.ietf.org/rfc/rfc1738.txt\">RFC1738</a>中规定了一个ASCII的子集[a-zA-Z0-9$-_.+!*’(),]，可以不经过编码在Url中使用（尽管空格也是ASCII字，但是不能直接用在Url中）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thus, only alphanumerics, the special characters &quot;$-_.+!*&#39;(),&quot;, and</span><br><span class=\"line\">reserved characters used for their reserved purposes may be used</span><br><span class=\"line\">unencoded within a URL.      </span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-1-2-特殊字符和中文\"><a href=\"#3-1-2-特殊字符和中文\" class=\"headerlink\" title=\"3.1.2 特殊字符和中文\"></a>3.1.2 特殊字符和中文</h5><p>有一个编码方式<code>Percent encoding</code>，可以将特殊字符和中文编码，甚至binary data编码为Url支持的字符。<br>（这个编码方式只管把字符转换成Url可用字符，并不管字符集编码）</p>\n<h4 id=\"3-2-Body编码\"><a href=\"#3-2-Body编码\" class=\"headerlink\" title=\"3.2 Body编码\"></a>3.2 Body编码</h4><p>Body中有一个<code>Content-Type</code>来明确定义格式，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST xxxxxx HTTP&#x2F;1.1</span><br><span class=\"line\">...</span><br><span class=\"line\">Content-Type: application&#x2F;x-www-form-urlencoded ; charset&#x3D;UTF-8</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<h4 id=\"3-3-总结\"><a href=\"#3-3-总结\" class=\"headerlink\" title=\"3.3 总结\"></a>3.3 总结</h4><p>Body和Url都可以提交中文给后端，但是POST的规范好一些，比较不容易出错。</p>\n<h3 id=\"4-请求次数\"><a href=\"#4-请求次数\" class=\"headerlink\" title=\"4 请求次数\"></a>4 请求次数</h3><p>上面的请求报文可大致分为“报文首部”和“报文主体”两个部分。</p>\n<p>使用HTTP时大家会有一个约定，即所有的“控制类”信息应该放在请求头，具体的数据放在请求体里。于是服务器端在解析时，总是先完全解析全部请求头，这样，服务器端总是希望能够了解请求的控制信息后，就能决定这个请求怎么进一步处理，是拒绝，还是根据Content-type去调用相应的解析器处理数据或是zero copy转发。</p>\n<p>客户端就能做一些优化，比如内部设定一次POST的数据超过1KB就先只发“请求头”，否则就一次性全发。客户端甚至还可以做一些Adaptive的策略，统计发送成功率，如果成功率很高，就总是全部发等等。不同浏览器，不同的客户端（curl，postman）可以有各自的不同的方案。不管怎样做，优化目的总是在提高数据吞吐和降低带宽浪费上做一个折衷。</p>\n<p>因此到底是发一次还是发N次，客户端可以很灵活的决定。因为不管怎么发都是符合HTTP协议的，因此我们应该视为这种优化是一种实现细节，而不用扯到GET和POST本身的区别上。更不要当个什么世纪大发现。</p>\n<h3 id=\"5-关于Url的长度\"><a href=\"#5-关于Url的长度\" class=\"headerlink\" title=\"5 关于Url的长度\"></a>5 关于Url的长度</h3><p>因为上面提到了不论是GET和POST都可以使用URL传递数据，所以我们常说的“GET数据有长度限制“其实是指”URL的长度限制“。HTTP协议本身对URL长度并没有做任何规定。实际限制是由客户端/浏览器以及服务器端决定的。</p>\n<h4 id=\"5-1-浏览器\"><a href=\"#5-1-浏览器\" class=\"headerlink\" title=\"5.1 浏览器\"></a>5.1 浏览器</h4><p>不同浏览器不一样，</p>\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>1、<a href=\"https://zhuanlan.zhihu.com/p/54654014\">99% 的人都理解错了 HTTP 中 GET 与 POST 的区别【面试必问】</a><br>2、<a href=\"https://www.zhihu.com/question/28586791/answer/767316172\">GET和POST到底有什么区别？</a><br>3、<a href=\"https://en.wikipedia.org/wiki/Percent-encoding\">Percent-encoding</a></p>"},{"title":"MySQL-为什么使用B+树作为索引结构","date":"2020-09-07T09:03:33.000Z","_content":"\n### 1 概述\n\n首先，MySQL和B+树是没有直接关系的，真正与B+树有关系的是MySQL的默认存储引擎InnoDB，MySQL中存储引擎的主要作用是负责数据的存储和提取．除了InnoDB外，MySQL还支持另外一些存储引擎，例如，MyISAM．使用`show engines`命令可查看．\n\n<!--more-->\n\n```mysql\nmysql> show engines;\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |\n| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |\n| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |\n| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |\n| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |\n| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |\n| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |\n| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |\n| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n9 rows in set (0.24 sec)\n```\n\n\n\n对于InnoDB来说，所有数据都是以键值对的方式存储在Ｂ+树结构中，其中表中的数据（主键索引）以<id, row>的方式存储；而辅助索引以<index, id>的方式进行存储．\n\n- 在主键索引中，ｉｄ是主键，通过ｉｄ能找到该行的全部列．\n- 在辅助索引中，索引中的几个列构成了键，通过索引中的列找到ｉｄ，如果有需要的话，可以再通过ｉｄ找到当前数据行的全部内容．\n\n\n\n### 2 分析\n\nMySQL作为`OLTP(Online Tranaction Processing)`的数据库，不仅需要具备事务的处理能力，还要保证数据的持久化并且能够有一定的实时数据查询能力．\n\n一般来说索引文件本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上．这样的话，索引查找过程就会产生磁盘I/O消耗，相对于内存的存取，I/Ｏ存取的消耗要高几个数量级，所以评判一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂读．换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数．\n\n\n\n对于普通磁盘（非ＳＳＤ）加载数据需要经过队列，寻道，旋转以及传输这些过程，大约耗时为１０ｍｓ左右，如下图所示：\n\n![磁盘IO消耗](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-为什么使用B+树作为索引结构/磁盘IO消耗.png)\n\n\n\n对于InnoDB选择B+树索引结构原因可以从以下几个方面进行分析：\n\n- 考虑其支持的场景和功能需要在特定查询上拥有较强的性能；\n- CPU将磁盘上的数据加载到内存需要花费大量的时间，采用Ｂ+树将是非常好的选择；\n\n\n\n#### 2.1 读写性能分析\n\n这里选取哈希结构及Ｂ树结构进行对比分析．\n\n##### 2.1.1 与哈希结构进行比较\n\n- 若使用Ｂ+树作为底层的数据结构，其增删改查一条数据的ＳＱＬ的时间复杂度都是O(lg n)，即树的高度．\n\n- 若使用哈希作为底层的数据结构，其增删改查一条数据的ＳＱＬ的时间复杂度可能达到Ｏ(1)．\n\n- 对于单行数据的读写，哈希索引均比Tree型索引块，但是`对于某些特殊的查询SQL，例如分组、排序、比较等情况，哈希索引的时间复杂度会退化为O(n)，而Tree索引因为其有序的特性，能依旧保持O(lg(n))的高效率。`\n\n\n\n\n##### 2.1.2 与Ｂ树进行比较\n\nＢ树和Ｂ+树在数据结构上起始有一些相似的，都能按照某些顺序对索引中内容进行遍历，排序及范围查找，相比哈希结构来说，Ｂ树和Ｂ+树能带来更好的性能．\n\n\n\n#### 2.2 数据加载\n\n`哈希结构无法满足一些特殊的查询SQL，而Ｂ树和Ｂ+树均能相对高效的执行，那么为什么不选择Ｂ树呢？`\n\n`Ｂ树与Ｂ+树最大的区别就是，Ｂ树的非页结点中可以存储数据，但是Ｂ+树所有数据都是存储于叶子结点中．`\n\n\n\n##### 2.2.1 B树数据加载分析\n\n当一个表的底层数据结构是Ｂ树时，假设我们需要访问索引在［4, 9］区间的数据：\n\n![b-tree](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-为什么使用B+树作为索引结构/b-tree.png)\n\n在不考虑优化的情况下，在上面简单Ｂ树中需要进行４次磁盘的随机I/O访问才能找到所有满足条件的行：\n\n- 加载根结点所在的页，发现根结点的第一个元素是６，大于４；\n- 通过根节点的指针加载左字节点所在的页，遍历页面中的数据，找到５；\n- 重新加载根节点所在的页，发现根节点不包含第二个元素；\n- 通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到７，８；\n\n（*以上过程不考虑对过程进行优化，Ｂ树能做的优化Ｂ＋树都能做*）\n\n\n\n由上述过程可见，对于Ｂ树，由于所有结点都可能包含目标数据，总是需要从根结点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机I/O，这就是Ｂ树最大的性能问题．\n\n\n\n##### 2.2.2 B+树数据加载分析\n\n对于B+树，由于其数据行均存储在叶子结点中，而这些叶节点可以通过指针依次顺序连接，如下图所示．当需要遍历数据时，可以直接在多个子节点之间通过指针跳转，这样可以节省大量的磁盘I/O时间，也不需要在不同层级的节点之间对数据进行拼接和排序．通过一个 B+ 树最左侧的叶子节点，可以像链表一样遍历整个树中的全部数据，也可以引入双向链表保证倒序遍历时的性能。\n\n![mysql-innodb-b-plus-tree](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-为什么使用B+树作为索引结构/mysql-innodb-b-plus-tree.png)\n\n\n\n`Ｂ+树的所有数据仅存储于叶子节点中，会不会导致树的高度增加，从而影响耗时呢？`\n\n其实这个影响是可以忽略不计的，对于高度为３的Ｂ+树就能存储千万级别的数据量．可通过以下计算量化，并得出结论：\n\n- 根据局部性原理，将一个节点的大小设为一页，一页为４Ｋ，假设一个Key有８个字节，那么一个结点至少可以存储500个Key．\n- 根据Ｍ叉搜索树特性，非根节点包含的关键字个数需要满足[[m/2], m]区间，即Ｍ大约为1000叉．\n- 那么，可以知道：\n  - ​\t一层：１个节点，1 * 500个key，大小为４ｋ；\n  - ​\t二层：1000个节点，1000  * 500  = 50W个key，大小为1000 * 4k = 4M;\n  - ​\t三层：1000 * 1000个节点，1000 * 1000 * 500 = 5亿个key，大小为1000 * 4M = 4G\n\n即３层的Ｂ+树结构，可以存储的数据量大约在５亿左右，其中索引占据的内存大小为４Ｇ左右．\n\n\n\n### 3 总结\n\n任何不考虑应用场景的设计都不是好设计，在明确了解MySQL常见的应用场景之后，再对不同的数据结构进行选择就是理所当然的事了．当然Ｂ+树并不能对所有的OLTP场景下的查询都有着较好的性能，但是它能解决大部分的问题．\n\n- 与哈希结构做对比：哈希虽然能提供Ｏ(1)的单数据操作性能，但对于范围查询，分组，排序等功能却无法很好的支持，最终导致全表扫描；\n- 与Ｂ树结构作对比：Ｂ树能够在非叶子节点中存储数据，这将导致在查询连续数据时可能会带来更多的随机I/O，而Ｂ+树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机I/O；\n- 与红黑树结构作对比：红黑树结构的高明显要深很多，由于逻辑上很近的节点（父子结点）物理上可能很远，无法利用局部性原理，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比Ｂ树差很多．\n\n\n\nB+Tree相比B-Tree有的优势包括：\n\n- ①、范围查找，定位min和max之后，中间叶子节点，就是结果集，不需要中序回溯；\n- ②、叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储。\n- ③、非叶子节点，不存储实际记录，而只存储记录的Key的话，那么在相同内存的情况下，B+Tree能够存储更多的索引。\n\n\n\n数据库的索引最常用的是B+树的原因：\n\n- ①、很合适磁盘存储，能够充分利用局部性原理，磁盘预读；\n- ②、很低的树高度，能够存储大量数据；\n- ③、索引本身占用的内存很小；\n- ④、能够很好的支持单点查询、范围查询、有序性查询。\n\n\n\n------\n\n参考资料\n\n1 [为什么MySQL使用B+树](https://draveness.me/whys-the-design-mysql-b-plus-tree/)\n\n2 [数据库索引，到底是什么做的？](https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A)\n\n3 [为什么实用B-Tree（B+Tree）](https://www.kancloud.cn/kancloud/theory-of-mysql-index/41856)\n\n","source":"_posts/MySQL-为什么使用B-树作为索引结构.md","raw":"---\ntitle: MySQL-为什么使用B+树作为索引结构\ndate: 2020-09-07 17:03:33\ntags: [\"MySQL\",\"B+Tree\",\"Interview\"]\ncategories: [\"MySQL\"]\n---\n\n### 1 概述\n\n首先，MySQL和B+树是没有直接关系的，真正与B+树有关系的是MySQL的默认存储引擎InnoDB，MySQL中存储引擎的主要作用是负责数据的存储和提取．除了InnoDB外，MySQL还支持另外一些存储引擎，例如，MyISAM．使用`show engines`命令可查看．\n\n<!--more-->\n\n```mysql\nmysql> show engines;\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |\n| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |\n| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |\n| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |\n| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |\n| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |\n| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |\n| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |\n| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n9 rows in set (0.24 sec)\n```\n\n\n\n对于InnoDB来说，所有数据都是以键值对的方式存储在Ｂ+树结构中，其中表中的数据（主键索引）以<id, row>的方式存储；而辅助索引以<index, id>的方式进行存储．\n\n- 在主键索引中，ｉｄ是主键，通过ｉｄ能找到该行的全部列．\n- 在辅助索引中，索引中的几个列构成了键，通过索引中的列找到ｉｄ，如果有需要的话，可以再通过ｉｄ找到当前数据行的全部内容．\n\n\n\n### 2 分析\n\nMySQL作为`OLTP(Online Tranaction Processing)`的数据库，不仅需要具备事务的处理能力，还要保证数据的持久化并且能够有一定的实时数据查询能力．\n\n一般来说索引文件本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上．这样的话，索引查找过程就会产生磁盘I/O消耗，相对于内存的存取，I/Ｏ存取的消耗要高几个数量级，所以评判一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂读．换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数．\n\n\n\n对于普通磁盘（非ＳＳＤ）加载数据需要经过队列，寻道，旋转以及传输这些过程，大约耗时为１０ｍｓ左右，如下图所示：\n\n![磁盘IO消耗](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-为什么使用B+树作为索引结构/磁盘IO消耗.png)\n\n\n\n对于InnoDB选择B+树索引结构原因可以从以下几个方面进行分析：\n\n- 考虑其支持的场景和功能需要在特定查询上拥有较强的性能；\n- CPU将磁盘上的数据加载到内存需要花费大量的时间，采用Ｂ+树将是非常好的选择；\n\n\n\n#### 2.1 读写性能分析\n\n这里选取哈希结构及Ｂ树结构进行对比分析．\n\n##### 2.1.1 与哈希结构进行比较\n\n- 若使用Ｂ+树作为底层的数据结构，其增删改查一条数据的ＳＱＬ的时间复杂度都是O(lg n)，即树的高度．\n\n- 若使用哈希作为底层的数据结构，其增删改查一条数据的ＳＱＬ的时间复杂度可能达到Ｏ(1)．\n\n- 对于单行数据的读写，哈希索引均比Tree型索引块，但是`对于某些特殊的查询SQL，例如分组、排序、比较等情况，哈希索引的时间复杂度会退化为O(n)，而Tree索引因为其有序的特性，能依旧保持O(lg(n))的高效率。`\n\n\n\n\n##### 2.1.2 与Ｂ树进行比较\n\nＢ树和Ｂ+树在数据结构上起始有一些相似的，都能按照某些顺序对索引中内容进行遍历，排序及范围查找，相比哈希结构来说，Ｂ树和Ｂ+树能带来更好的性能．\n\n\n\n#### 2.2 数据加载\n\n`哈希结构无法满足一些特殊的查询SQL，而Ｂ树和Ｂ+树均能相对高效的执行，那么为什么不选择Ｂ树呢？`\n\n`Ｂ树与Ｂ+树最大的区别就是，Ｂ树的非页结点中可以存储数据，但是Ｂ+树所有数据都是存储于叶子结点中．`\n\n\n\n##### 2.2.1 B树数据加载分析\n\n当一个表的底层数据结构是Ｂ树时，假设我们需要访问索引在［4, 9］区间的数据：\n\n![b-tree](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-为什么使用B+树作为索引结构/b-tree.png)\n\n在不考虑优化的情况下，在上面简单Ｂ树中需要进行４次磁盘的随机I/O访问才能找到所有满足条件的行：\n\n- 加载根结点所在的页，发现根结点的第一个元素是６，大于４；\n- 通过根节点的指针加载左字节点所在的页，遍历页面中的数据，找到５；\n- 重新加载根节点所在的页，发现根节点不包含第二个元素；\n- 通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到７，８；\n\n（*以上过程不考虑对过程进行优化，Ｂ树能做的优化Ｂ＋树都能做*）\n\n\n\n由上述过程可见，对于Ｂ树，由于所有结点都可能包含目标数据，总是需要从根结点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机I/O，这就是Ｂ树最大的性能问题．\n\n\n\n##### 2.2.2 B+树数据加载分析\n\n对于B+树，由于其数据行均存储在叶子结点中，而这些叶节点可以通过指针依次顺序连接，如下图所示．当需要遍历数据时，可以直接在多个子节点之间通过指针跳转，这样可以节省大量的磁盘I/O时间，也不需要在不同层级的节点之间对数据进行拼接和排序．通过一个 B+ 树最左侧的叶子节点，可以像链表一样遍历整个树中的全部数据，也可以引入双向链表保证倒序遍历时的性能。\n\n![mysql-innodb-b-plus-tree](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-为什么使用B+树作为索引结构/mysql-innodb-b-plus-tree.png)\n\n\n\n`Ｂ+树的所有数据仅存储于叶子节点中，会不会导致树的高度增加，从而影响耗时呢？`\n\n其实这个影响是可以忽略不计的，对于高度为３的Ｂ+树就能存储千万级别的数据量．可通过以下计算量化，并得出结论：\n\n- 根据局部性原理，将一个节点的大小设为一页，一页为４Ｋ，假设一个Key有８个字节，那么一个结点至少可以存储500个Key．\n- 根据Ｍ叉搜索树特性，非根节点包含的关键字个数需要满足[[m/2], m]区间，即Ｍ大约为1000叉．\n- 那么，可以知道：\n  - ​\t一层：１个节点，1 * 500个key，大小为４ｋ；\n  - ​\t二层：1000个节点，1000  * 500  = 50W个key，大小为1000 * 4k = 4M;\n  - ​\t三层：1000 * 1000个节点，1000 * 1000 * 500 = 5亿个key，大小为1000 * 4M = 4G\n\n即３层的Ｂ+树结构，可以存储的数据量大约在５亿左右，其中索引占据的内存大小为４Ｇ左右．\n\n\n\n### 3 总结\n\n任何不考虑应用场景的设计都不是好设计，在明确了解MySQL常见的应用场景之后，再对不同的数据结构进行选择就是理所当然的事了．当然Ｂ+树并不能对所有的OLTP场景下的查询都有着较好的性能，但是它能解决大部分的问题．\n\n- 与哈希结构做对比：哈希虽然能提供Ｏ(1)的单数据操作性能，但对于范围查询，分组，排序等功能却无法很好的支持，最终导致全表扫描；\n- 与Ｂ树结构作对比：Ｂ树能够在非叶子节点中存储数据，这将导致在查询连续数据时可能会带来更多的随机I/O，而Ｂ+树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机I/O；\n- 与红黑树结构作对比：红黑树结构的高明显要深很多，由于逻辑上很近的节点（父子结点）物理上可能很远，无法利用局部性原理，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比Ｂ树差很多．\n\n\n\nB+Tree相比B-Tree有的优势包括：\n\n- ①、范围查找，定位min和max之后，中间叶子节点，就是结果集，不需要中序回溯；\n- ②、叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储。\n- ③、非叶子节点，不存储实际记录，而只存储记录的Key的话，那么在相同内存的情况下，B+Tree能够存储更多的索引。\n\n\n\n数据库的索引最常用的是B+树的原因：\n\n- ①、很合适磁盘存储，能够充分利用局部性原理，磁盘预读；\n- ②、很低的树高度，能够存储大量数据；\n- ③、索引本身占用的内存很小；\n- ④、能够很好的支持单点查询、范围查询、有序性查询。\n\n\n\n------\n\n参考资料\n\n1 [为什么MySQL使用B+树](https://draveness.me/whys-the-design-mysql-b-plus-tree/)\n\n2 [数据库索引，到底是什么做的？](https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A)\n\n3 [为什么实用B-Tree（B+Tree）](https://www.kancloud.cn/kancloud/theory-of-mysql-index/41856)\n\n","slug":"MySQL-为什么使用B-树作为索引结构","published":1,"updated":"2020-09-24T10:18:48.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabki001y45g3432v2g2q","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>首先，MySQL和B+树是没有直接关系的，真正与B+树有关系的是MySQL的默认存储引擎InnoDB，MySQL中存储引擎的主要作用是负责数据的存储和提取．除了InnoDB外，MySQL还支持另外一些存储引擎，例如，MyISAM．使用<code>show engines</code>命令可查看．</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engines;</span><br><span class=\"line\">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class=\"line\">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class=\"line\">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class=\"line\">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class=\"line\">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class=\"line\">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class=\"line\">| BLACKHOLE          | YES     | &#x2F;dev&#x2F;null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class=\"line\">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class=\"line\">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class=\"line\">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class=\"line\">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class=\"line\">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class=\"line\">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class=\"line\">9 rows in set (0.24 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对于InnoDB来说，所有数据都是以键值对的方式存储在Ｂ+树结构中，其中表中的数据（主键索引）以&lt;id, row&gt;的方式存储；而辅助索引以&lt;index, id&gt;的方式进行存储．</p>\n<ul>\n<li>在主键索引中，ｉｄ是主键，通过ｉｄ能找到该行的全部列．</li>\n<li>在辅助索引中，索引中的几个列构成了键，通过索引中的列找到ｉｄ，如果有需要的话，可以再通过ｉｄ找到当前数据行的全部内容．</li>\n</ul>\n<h3 id=\"2-分析\"><a href=\"#2-分析\" class=\"headerlink\" title=\"2 分析\"></a>2 分析</h3><p>MySQL作为<code>OLTP(Online Tranaction Processing)</code>的数据库，不仅需要具备事务的处理能力，还要保证数据的持久化并且能够有一定的实时数据查询能力．</p>\n<p>一般来说索引文件本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上．这样的话，索引查找过程就会产生磁盘I/O消耗，相对于内存的存取，I/Ｏ存取的消耗要高几个数量级，所以评判一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂读．换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数．</p>\n<p>对于普通磁盘（非ＳＳＤ）加载数据需要经过队列，寻道，旋转以及传输这些过程，大约耗时为１０ｍｓ左右，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/%E7%A3%81%E7%9B%98IO%E6%B6%88%E8%80%97.png\" alt=\"磁盘IO消耗\"></p>\n<p>对于InnoDB选择B+树索引结构原因可以从以下几个方面进行分析：</p>\n<ul>\n<li>考虑其支持的场景和功能需要在特定查询上拥有较强的性能；</li>\n<li>CPU将磁盘上的数据加载到内存需要花费大量的时间，采用Ｂ+树将是非常好的选择；</li>\n</ul>\n<h4 id=\"2-1-读写性能分析\"><a href=\"#2-1-读写性能分析\" class=\"headerlink\" title=\"2.1 读写性能分析\"></a>2.1 读写性能分析</h4><p>这里选取哈希结构及Ｂ树结构进行对比分析．</p>\n<h5 id=\"2-1-1-与哈希结构进行比较\"><a href=\"#2-1-1-与哈希结构进行比较\" class=\"headerlink\" title=\"2.1.1 与哈希结构进行比较\"></a>2.1.1 与哈希结构进行比较</h5><ul>\n<li><p>若使用Ｂ+树作为底层的数据结构，其增删改查一条数据的ＳＱＬ的时间复杂度都是O(lg n)，即树的高度．</p>\n</li>\n<li><p>若使用哈希作为底层的数据结构，其增删改查一条数据的ＳＱＬ的时间复杂度可能达到Ｏ(1)．</p>\n</li>\n<li><p>对于单行数据的读写，哈希索引均比Tree型索引块，但是<code>对于某些特殊的查询SQL，例如分组、排序、比较等情况，哈希索引的时间复杂度会退化为O(n)，而Tree索引因为其有序的特性，能依旧保持O(lg(n))的高效率。</code></p>\n</li>\n</ul>\n<h5 id=\"2-1-2-与B树进行比较\"><a href=\"#2-1-2-与B树进行比较\" class=\"headerlink\" title=\"2.1.2 与Ｂ树进行比较\"></a>2.1.2 与Ｂ树进行比较</h5><p>Ｂ树和Ｂ+树在数据结构上起始有一些相似的，都能按照某些顺序对索引中内容进行遍历，排序及范围查找，相比哈希结构来说，Ｂ树和Ｂ+树能带来更好的性能．</p>\n<h4 id=\"2-2-数据加载\"><a href=\"#2-2-数据加载\" class=\"headerlink\" title=\"2.2 数据加载\"></a>2.2 数据加载</h4><p><code>哈希结构无法满足一些特殊的查询SQL，而Ｂ树和Ｂ+树均能相对高效的执行，那么为什么不选择Ｂ树呢？</code></p>\n<p><code>Ｂ树与Ｂ+树最大的区别就是，Ｂ树的非页结点中可以存储数据，但是Ｂ+树所有数据都是存储于叶子结点中．</code></p>\n<h5 id=\"2-2-1-B树数据加载分析\"><a href=\"#2-2-1-B树数据加载分析\" class=\"headerlink\" title=\"2.2.1 B树数据加载分析\"></a>2.2.1 B树数据加载分析</h5><p>当一个表的底层数据结构是Ｂ树时，假设我们需要访问索引在［4, 9］区间的数据：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/b-tree.png\" alt=\"b-tree\"></p>\n<p>在不考虑优化的情况下，在上面简单Ｂ树中需要进行４次磁盘的随机I/O访问才能找到所有满足条件的行：</p>\n<ul>\n<li>加载根结点所在的页，发现根结点的第一个元素是６，大于４；</li>\n<li>通过根节点的指针加载左字节点所在的页，遍历页面中的数据，找到５；</li>\n<li>重新加载根节点所在的页，发现根节点不包含第二个元素；</li>\n<li>通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到７，８；</li>\n</ul>\n<p>（<em>以上过程不考虑对过程进行优化，Ｂ树能做的优化Ｂ＋树都能做</em>）</p>\n<p>由上述过程可见，对于Ｂ树，由于所有结点都可能包含目标数据，总是需要从根结点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机I/O，这就是Ｂ树最大的性能问题．</p>\n<h5 id=\"2-2-2-B-树数据加载分析\"><a href=\"#2-2-2-B-树数据加载分析\" class=\"headerlink\" title=\"2.2.2 B+树数据加载分析\"></a>2.2.2 B+树数据加载分析</h5><p>对于B+树，由于其数据行均存储在叶子结点中，而这些叶节点可以通过指针依次顺序连接，如下图所示．当需要遍历数据时，可以直接在多个子节点之间通过指针跳转，这样可以节省大量的磁盘I/O时间，也不需要在不同层级的节点之间对数据进行拼接和排序．通过一个 B+ 树最左侧的叶子节点，可以像链表一样遍历整个树中的全部数据，也可以引入双向链表保证倒序遍历时的性能。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/mysql-innodb-b-plus-tree.png\" alt=\"mysql-innodb-b-plus-tree\"></p>\n<p><code>Ｂ+树的所有数据仅存储于叶子节点中，会不会导致树的高度增加，从而影响耗时呢？</code></p>\n<p>其实这个影响是可以忽略不计的，对于高度为３的Ｂ+树就能存储千万级别的数据量．可通过以下计算量化，并得出结论：</p>\n<ul>\n<li>根据局部性原理，将一个节点的大小设为一页，一页为４Ｋ，假设一个Key有８个字节，那么一个结点至少可以存储500个Key．</li>\n<li>根据Ｍ叉搜索树特性，非根节点包含的关键字个数需要满足[[m/2], m]区间，即Ｍ大约为1000叉．</li>\n<li>那么，可以知道：<ul>\n<li>​    一层：１个节点，1 * 500个key，大小为４ｋ；</li>\n<li>​    二层：1000个节点，1000  * 500  = 50W个key，大小为1000 * 4k = 4M;</li>\n<li>​    三层：1000 * 1000个节点，1000 * 1000 * 500 = 5亿个key，大小为1000 * 4M = 4G</li>\n</ul>\n</li>\n</ul>\n<p>即３层的Ｂ+树结构，可以存储的数据量大约在５亿左右，其中索引占据的内存大小为４Ｇ左右．</p>\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h3><p>任何不考虑应用场景的设计都不是好设计，在明确了解MySQL常见的应用场景之后，再对不同的数据结构进行选择就是理所当然的事了．当然Ｂ+树并不能对所有的OLTP场景下的查询都有着较好的性能，但是它能解决大部分的问题．</p>\n<ul>\n<li>与哈希结构做对比：哈希虽然能提供Ｏ(1)的单数据操作性能，但对于范围查询，分组，排序等功能却无法很好的支持，最终导致全表扫描；</li>\n<li>与Ｂ树结构作对比：Ｂ树能够在非叶子节点中存储数据，这将导致在查询连续数据时可能会带来更多的随机I/O，而Ｂ+树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机I/O；</li>\n<li>与红黑树结构作对比：红黑树结构的高明显要深很多，由于逻辑上很近的节点（父子结点）物理上可能很远，无法利用局部性原理，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比Ｂ树差很多．</li>\n</ul>\n<p>B+Tree相比B-Tree有的优势包括：</p>\n<ul>\n<li>①、范围查找，定位min和max之后，中间叶子节点，就是结果集，不需要中序回溯；</li>\n<li>②、叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储。</li>\n<li>③、非叶子节点，不存储实际记录，而只存储记录的Key的话，那么在相同内存的情况下，B+Tree能够存储更多的索引。</li>\n</ul>\n<p>数据库的索引最常用的是B+树的原因：</p>\n<ul>\n<li>①、很合适磁盘存储，能够充分利用局部性原理，磁盘预读；</li>\n<li>②、很低的树高度，能够存储大量数据；</li>\n<li>③、索引本身占用的内存很小；</li>\n<li>④、能够很好的支持单点查询、范围查询、有序性查询。</li>\n</ul>\n<hr>\n<p>参考资料</p>\n<p>1 <a href=\"https://draveness.me/whys-the-design-mysql-b-plus-tree/\">为什么MySQL使用B+树</a></p>\n<p>2 <a href=\"https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A\">数据库索引，到底是什么做的？</a></p>\n<p>3 <a href=\"https://www.kancloud.cn/kancloud/theory-of-mysql-index/41856\">为什么实用B-Tree（B+Tree）</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>首先，MySQL和B+树是没有直接关系的，真正与B+树有关系的是MySQL的默认存储引擎InnoDB，MySQL中存储引擎的主要作用是负责数据的存储和提取．除了InnoDB外，MySQL还支持另外一些存储引擎，例如，MyISAM．使用<code>show engines</code>命令可查看．</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engines;</span><br><span class=\"line\">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class=\"line\">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class=\"line\">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class=\"line\">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class=\"line\">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class=\"line\">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class=\"line\">| BLACKHOLE          | YES     | &#x2F;dev&#x2F;null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class=\"line\">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class=\"line\">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class=\"line\">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class=\"line\">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class=\"line\">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class=\"line\">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class=\"line\">9 rows in set (0.24 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对于InnoDB来说，所有数据都是以键值对的方式存储在Ｂ+树结构中，其中表中的数据（主键索引）以&lt;id, row&gt;的方式存储；而辅助索引以&lt;index, id&gt;的方式进行存储．</p>\n<ul>\n<li>在主键索引中，ｉｄ是主键，通过ｉｄ能找到该行的全部列．</li>\n<li>在辅助索引中，索引中的几个列构成了键，通过索引中的列找到ｉｄ，如果有需要的话，可以再通过ｉｄ找到当前数据行的全部内容．</li>\n</ul>\n<h3 id=\"2-分析\"><a href=\"#2-分析\" class=\"headerlink\" title=\"2 分析\"></a>2 分析</h3><p>MySQL作为<code>OLTP(Online Tranaction Processing)</code>的数据库，不仅需要具备事务的处理能力，还要保证数据的持久化并且能够有一定的实时数据查询能力．</p>\n<p>一般来说索引文件本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上．这样的话，索引查找过程就会产生磁盘I/O消耗，相对于内存的存取，I/Ｏ存取的消耗要高几个数量级，所以评判一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂读．换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数．</p>\n<p>对于普通磁盘（非ＳＳＤ）加载数据需要经过队列，寻道，旋转以及传输这些过程，大约耗时为１０ｍｓ左右，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/%E7%A3%81%E7%9B%98IO%E6%B6%88%E8%80%97.png\" alt=\"磁盘IO消耗\"></p>\n<p>对于InnoDB选择B+树索引结构原因可以从以下几个方面进行分析：</p>\n<ul>\n<li>考虑其支持的场景和功能需要在特定查询上拥有较强的性能；</li>\n<li>CPU将磁盘上的数据加载到内存需要花费大量的时间，采用Ｂ+树将是非常好的选择；</li>\n</ul>\n<h4 id=\"2-1-读写性能分析\"><a href=\"#2-1-读写性能分析\" class=\"headerlink\" title=\"2.1 读写性能分析\"></a>2.1 读写性能分析</h4><p>这里选取哈希结构及Ｂ树结构进行对比分析．</p>\n<h5 id=\"2-1-1-与哈希结构进行比较\"><a href=\"#2-1-1-与哈希结构进行比较\" class=\"headerlink\" title=\"2.1.1 与哈希结构进行比较\"></a>2.1.1 与哈希结构进行比较</h5><ul>\n<li><p>若使用Ｂ+树作为底层的数据结构，其增删改查一条数据的ＳＱＬ的时间复杂度都是O(lg n)，即树的高度．</p>\n</li>\n<li><p>若使用哈希作为底层的数据结构，其增删改查一条数据的ＳＱＬ的时间复杂度可能达到Ｏ(1)．</p>\n</li>\n<li><p>对于单行数据的读写，哈希索引均比Tree型索引块，但是<code>对于某些特殊的查询SQL，例如分组、排序、比较等情况，哈希索引的时间复杂度会退化为O(n)，而Tree索引因为其有序的特性，能依旧保持O(lg(n))的高效率。</code></p>\n</li>\n</ul>\n<h5 id=\"2-1-2-与B树进行比较\"><a href=\"#2-1-2-与B树进行比较\" class=\"headerlink\" title=\"2.1.2 与Ｂ树进行比较\"></a>2.1.2 与Ｂ树进行比较</h5><p>Ｂ树和Ｂ+树在数据结构上起始有一些相似的，都能按照某些顺序对索引中内容进行遍历，排序及范围查找，相比哈希结构来说，Ｂ树和Ｂ+树能带来更好的性能．</p>\n<h4 id=\"2-2-数据加载\"><a href=\"#2-2-数据加载\" class=\"headerlink\" title=\"2.2 数据加载\"></a>2.2 数据加载</h4><p><code>哈希结构无法满足一些特殊的查询SQL，而Ｂ树和Ｂ+树均能相对高效的执行，那么为什么不选择Ｂ树呢？</code></p>\n<p><code>Ｂ树与Ｂ+树最大的区别就是，Ｂ树的非页结点中可以存储数据，但是Ｂ+树所有数据都是存储于叶子结点中．</code></p>\n<h5 id=\"2-2-1-B树数据加载分析\"><a href=\"#2-2-1-B树数据加载分析\" class=\"headerlink\" title=\"2.2.1 B树数据加载分析\"></a>2.2.1 B树数据加载分析</h5><p>当一个表的底层数据结构是Ｂ树时，假设我们需要访问索引在［4, 9］区间的数据：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/b-tree.png\" alt=\"b-tree\"></p>\n<p>在不考虑优化的情况下，在上面简单Ｂ树中需要进行４次磁盘的随机I/O访问才能找到所有满足条件的行：</p>\n<ul>\n<li>加载根结点所在的页，发现根结点的第一个元素是６，大于４；</li>\n<li>通过根节点的指针加载左字节点所在的页，遍历页面中的数据，找到５；</li>\n<li>重新加载根节点所在的页，发现根节点不包含第二个元素；</li>\n<li>通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到７，８；</li>\n</ul>\n<p>（<em>以上过程不考虑对过程进行优化，Ｂ树能做的优化Ｂ＋树都能做</em>）</p>\n<p>由上述过程可见，对于Ｂ树，由于所有结点都可能包含目标数据，总是需要从根结点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机I/O，这就是Ｂ树最大的性能问题．</p>\n<h5 id=\"2-2-2-B-树数据加载分析\"><a href=\"#2-2-2-B-树数据加载分析\" class=\"headerlink\" title=\"2.2.2 B+树数据加载分析\"></a>2.2.2 B+树数据加载分析</h5><p>对于B+树，由于其数据行均存储在叶子结点中，而这些叶节点可以通过指针依次顺序连接，如下图所示．当需要遍历数据时，可以直接在多个子节点之间通过指针跳转，这样可以节省大量的磁盘I/O时间，也不需要在不同层级的节点之间对数据进行拼接和排序．通过一个 B+ 树最左侧的叶子节点，可以像链表一样遍历整个树中的全部数据，也可以引入双向链表保证倒序遍历时的性能。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/mysql-innodb-b-plus-tree.png\" alt=\"mysql-innodb-b-plus-tree\"></p>\n<p><code>Ｂ+树的所有数据仅存储于叶子节点中，会不会导致树的高度增加，从而影响耗时呢？</code></p>\n<p>其实这个影响是可以忽略不计的，对于高度为３的Ｂ+树就能存储千万级别的数据量．可通过以下计算量化，并得出结论：</p>\n<ul>\n<li>根据局部性原理，将一个节点的大小设为一页，一页为４Ｋ，假设一个Key有８个字节，那么一个结点至少可以存储500个Key．</li>\n<li>根据Ｍ叉搜索树特性，非根节点包含的关键字个数需要满足[[m/2], m]区间，即Ｍ大约为1000叉．</li>\n<li>那么，可以知道：<ul>\n<li>​    一层：１个节点，1 * 500个key，大小为４ｋ；</li>\n<li>​    二层：1000个节点，1000  * 500  = 50W个key，大小为1000 * 4k = 4M;</li>\n<li>​    三层：1000 * 1000个节点，1000 * 1000 * 500 = 5亿个key，大小为1000 * 4M = 4G</li>\n</ul>\n</li>\n</ul>\n<p>即３层的Ｂ+树结构，可以存储的数据量大约在５亿左右，其中索引占据的内存大小为４Ｇ左右．</p>\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h3><p>任何不考虑应用场景的设计都不是好设计，在明确了解MySQL常见的应用场景之后，再对不同的数据结构进行选择就是理所当然的事了．当然Ｂ+树并不能对所有的OLTP场景下的查询都有着较好的性能，但是它能解决大部分的问题．</p>\n<ul>\n<li>与哈希结构做对比：哈希虽然能提供Ｏ(1)的单数据操作性能，但对于范围查询，分组，排序等功能却无法很好的支持，最终导致全表扫描；</li>\n<li>与Ｂ树结构作对比：Ｂ树能够在非叶子节点中存储数据，这将导致在查询连续数据时可能会带来更多的随机I/O，而Ｂ+树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机I/O；</li>\n<li>与红黑树结构作对比：红黑树结构的高明显要深很多，由于逻辑上很近的节点（父子结点）物理上可能很远，无法利用局部性原理，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比Ｂ树差很多．</li>\n</ul>\n<p>B+Tree相比B-Tree有的优势包括：</p>\n<ul>\n<li>①、范围查找，定位min和max之后，中间叶子节点，就是结果集，不需要中序回溯；</li>\n<li>②、叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储。</li>\n<li>③、非叶子节点，不存储实际记录，而只存储记录的Key的话，那么在相同内存的情况下，B+Tree能够存储更多的索引。</li>\n</ul>\n<p>数据库的索引最常用的是B+树的原因：</p>\n<ul>\n<li>①、很合适磁盘存储，能够充分利用局部性原理，磁盘预读；</li>\n<li>②、很低的树高度，能够存储大量数据；</li>\n<li>③、索引本身占用的内存很小；</li>\n<li>④、能够很好的支持单点查询、范围查询、有序性查询。</li>\n</ul>\n<hr>\n<p>参考资料</p>\n<p>1 <a href=\"https://draveness.me/whys-the-design-mysql-b-plus-tree/\">为什么MySQL使用B+树</a></p>\n<p>2 <a href=\"https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A\">数据库索引，到底是什么做的？</a></p>\n<p>3 <a href=\"https://www.kancloud.cn/kancloud/theory-of-mysql-index/41856\">为什么实用B-Tree（B+Tree）</a></p>"},{"title":"MySQL-命令/方法备忘录","date":"2020-09-11T03:52:09.000Z","_content":"\n\n\n记录一些常用或者不常用的命令或方法，方便后续直接查看．．．\n\n<!--more-->\n\n### 1 简单监控当前事务及分析锁问题\n\n从InnoDB1.0开始，在`INFORMATION_SCHEMA`架构下添加了表INNODB_TRX，INNODB_LOCKS, INNODB_LOCK_WAITS．`通过这三张表可以简单的监控当前事务并分析可能存在的锁问题`．\n\n示例：\n\n```mysql\n表结构：\nmysql> explain t_id_incr;\n+-------+------------------+------+-----+---------+----------------+\n| Field | Type             | Null | Key | Default | Extra          |\n+-------+------------------+------+-----+---------+----------------+\n| id    | int(10) unsigned | NO   | MUL | NULL    | auto_increment |\n| name  | varchar(10)      | NO   |     |         |                |\n+-------+------------------+------+-----+---------+----------------+\n2 rows in set (0.00 sec)\n\n表数据如下：\nmysql> select * from t_id_incr;\n+----+----------+\n| id | name     |\n+----+----------+\n|  1 | seven    |\n|  2 | zhangsan |\n|  3 | lisi     |\n+----+----------+\n\n\n按以下顺序执行，产生锁等待\nＡ：start transaction;\nＡ：update t_id_idcr set name='seven1' where id = 1;\n\tＢ：start transaction;\n\tＢ：update t_id_incr set name='zhangsan1' where id = 2;\nＡ：update t_id_incr set name='zhangsan2' where id = 2;\n\t\n此时由于事务Ｂ正在修改id=2的行，因此Ａ需等待事务Ｂ释放id=2的行锁．\n```\n\n\n\n#### 1.1 INNODB_TRX表\n\nINNODB_TRX表提供了当前INNODB引擎内每个事务的信息，包括事务是否在锁等待，正在执行的语句，隔离级别等等．\n\n详细信息可查看：[INNODB_TRX](https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-trx-table.html)\n\n\n\n查看innodb_trx表信息：\n\n```mysql\nmysql> select * from information_schema.INNODB_TRX\\G;\n*************************** 1. row ***************************\n                    trx_id: 101153\n                 trx_state: RUNNING\n               trx_started: 2020-09-11 16:43:15\n     trx_requested_lock_id: NULL\n          trx_wait_started: NULL\n                trx_weight: 5\n       trx_mysql_thread_id: 6\n                 trx_query: select * from information_schema.INNODB_TRX\n       trx_operation_state: NULL\n         trx_tables_in_use: 0\n         trx_tables_locked: 1\n          trx_lock_structs: 4\n     trx_lock_memory_bytes: 1136\n           trx_rows_locked: 3\n         trx_rows_modified: 1\n   trx_concurrency_tickets: 0\n       trx_isolation_level: REPEATABLE READ\n         trx_unique_checks: 1\n    trx_foreign_key_checks: 1\ntrx_last_foreign_key_error: NULL\n trx_adaptive_hash_latched: 0\n trx_adaptive_hash_timeout: 0\n          trx_is_read_only: 0\ntrx_autocommit_non_locking: 0\n*************************** 2. row ***************************\n                    trx_id: 101152\n                 trx_state: LOCK WAIT\n               trx_started: 2020-09-11 16:43:05\n     trx_requested_lock_id: 101152:444:4:3\n          trx_wait_started: 2020-09-11 16:43:22\n                trx_weight: 6\n       trx_mysql_thread_id: 5\n                 trx_query: update t_id_incr set name='zhangsan2' where id = 2\n       trx_operation_state: starting index read\n         trx_tables_in_use: 1\n         trx_tables_locked: 1\n          trx_lock_structs: 5\n     trx_lock_memory_bytes: 1136\n           trx_rows_locked: 4\n         trx_rows_modified: 1\n   trx_concurrency_tickets: 0\n       trx_isolation_level: REPEATABLE READ\n         trx_unique_checks: 1\n    trx_foreign_key_checks: 1\ntrx_last_foreign_key_error: NULL\n trx_adaptive_hash_latched: 0\n trx_adaptive_hash_timeout: 0\n          trx_is_read_only: 0\ntrx_autocommit_non_locking: 0\n2 rows in set (0.00 sec)\n```\n\n\n\n\n\n#### 1.2 INNODB_LOCKS表\n\nINNODB_LOCKS表提供关于InnoDB事务已请求但尚未获取的每个锁的信息，以及事务持有的阻止另一个事务的每个锁的信息．（ MySQL 8.0.1起不推荐使用该表，并删除了该表。改用性能架构[`data_locks`](https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-locks-table.html) 表）\n\n详细信息可查看：[INNODB_LOCKS](https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-locks-table.html)\n\n查看innodb_locks表：\n\n```mysql\nmysql> select * from information_schema.innodb_locks\\G;\n*************************** 1. row ***************************\n    lock_id: 101152:444:4:3\nlock_trx_id: 101152\n  lock_mode: X\n  lock_type: RECORD\n lock_table: `seven`.`t_id_incr`\n lock_index: idx_id\n lock_space: 444\n  lock_page: 4\n   lock_rec: 3\n  lock_data: 2, 0x000000000301\n*************************** 2. row ***************************\n    lock_id: 101153:444:4:3\nlock_trx_id: 101153\n  lock_mode: X\n  lock_type: RECORD\n lock_table: `seven`.`t_id_incr`\n lock_index: idx_id\n lock_space: 444\n  lock_page: 4\n   lock_rec: 3\n  lock_data: 2, 0x000000000301\n2 rows in set, 1 warning (0.02 sec)\n```\n\n\n\n#### 1.3 INNODB_LOCK_WAITS表\n\nINNODB_LOCK_WAITS表为每个被阻止的InnoDB事务包含一个或多个行，指示它已请求的锁以及正在阻止该请求的所有锁．（MySQL 8.0.1起不推荐使用该表，并删除了该表。改用性能架构 [`data_lock_waits`](https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-lock-waits-table.html)表。）\n\n详细信息可查看：[INNODB_LOCK_WAITS](https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-lock-waits-table.html)\n\n查看innodb_lock_waits表：\n\n```mysql\nmysql> select * from information_schema.INNODB_LOCK_WAITS\\G;\n*************************** 1. row ***************************\nrequesting_trx_id: 101152\nrequested_lock_id: 101152:444:4:3\n  blocking_trx_id: 101153\n blocking_lock_id: 101153:444:4:3\n1 row in set, 1 warning (0.00 sec)\n```\n\n\n\n### INNODB_LOCK_WAITS\n\n### 2 隔离级别\n\n不同事务的隔离级别，InnoDB的锁实现是不一样的．支持的隔离级别包括：\n\n- read uncommitted\n- read committed\n- repeatable read（默认）\n- serializable\n\n\n\n#### 2.1 查看隔离级别方法\n\n- 查看当前会话隔离级别\n\n```mysql\nshow variables like 'tx_isolation'\n或\nselect @@tx_isolation\n```\n\n- 查看系统隔离级别\n\n```mysql\nshow global variables like 'tx_isolation'\n或\nselect @@global.tx_isolation\n```\n\n\n\n#### 2.2 设置隔离级别\n\n- 设置当前会话隔离级别：\n\n```mysql\nset session transaction isolation level <隔离级别>';\n```\n\n- 设置系统隔离级别：\n\n```mysql\nset global transaction isolation level <隔离级别>';\n```\n\n\n\n### 3 事务自动提交\n\nMysql默认采用自动提交模式（即`autocommit=1`），即如果不是显式地开始一个事务，每个查询都被当做一个事务执行提交操作。\n\n#### 3.1 查看事务自动提交模式\n\n- 查看当前会话自动提交模式命令：\n\n```mysql\nshow variables like 'autocommit'\n```\n\n- 查看数据库系统自动提交模式命令：\n\n```mysql\nshow global variables like 'autocommit'\n```\n\n\n\n#### 3.2 设置事务自动提交模式\n\n- 设置当前会话自动提交模式命令：\n\n```mysql\nset autocommit = ０　// 0表示关闭，１表示开启\n```\n\n- 设置系统自动提交模式命令：\n\n```\nset global autocommit = 0;\n```\n\n\n\n### 4 数据库线程\n\n#### 4.1 查看数据库线程使用情况\n\n命令：\n\n```mysql\n show processlist\n```\n\n示例：\n\n```mysql\nmysql>  show processlist;\n+----+------+-----------+-------+---------+------+----------+------------------+\n| Id | User | Host      | db    | Command | Time | State    | Info             |\n+----+------+-----------+-------+---------+------+----------+------------------+\n|  3 | root | localhost | seven | Query   |    0 | starting | show processlist |\n|  4 | root | localhost | seven | Sleep   | 1450 |          | NULL             |\n+----+------+-----------+-------+---------+------+----------+------------------+\n2 rows in set (0.00 sec)\n```\n\n\n\n#### 4.2 杀掉线程\n\n命令：\n\n```mysql\nkill <id>\n```\n\n示例：\n\n```\nmysql> kill 4;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql>  show processlist;\n+----+------+-----------+-------+---------+------+----------+------------------+\n| Id | User | Host      | db    | Command | Time | State    | Info             |\n+----+------+-----------+-------+---------+------+----------+------------------+\n|  3 | root | localhost | seven | Query   |    0 | starting | show processlist |\n+----+------+-----------+-------+---------+------+----------+------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n### 5 查看表自增长计数器\n\n在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。\n\n通过以下命令查看表的自增长计数器的值：\n\n```mysql\nselect max(auto_inc_col) from <table_name> for update\n```\n\n\n\n### 6 显式关闭间隙锁的方法\n\n显式关闭间隙锁的方法：\n\n- 将事务的隔离级别设置为READ COMMITTED.\n- 将参数innodb_locks_unsafe_for_binlog设置为１．\n\n\n\n### 7 锁等待时间\n\n在InnoDB存储引擎中，参数`innodb_lock_wait_timeout`用来控制等待的时间（默认是50秒）,该参数是动态的，可以在MySQL运行时进行调整．\n\n- 查看锁等待时间．\n\n```mysql\nshow variables like 'innodb_lock_wait_timeout';\n```\n\n- 设置锁等待时间,单位秒．\n\n```mysql\nset @@innodb_lock_wait_timeout=<超时时间>;\n```\n\n\n\n### 8 超时回滚\n\n在InnoDB存储引擎中，参数innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作（默认是OFF，代表不回滚）．\n\n- 查看超时回滚．\n\n```mysql\nshow variables like 'innodb_rollback_on_timeout';\n```\n\n- 启用超时回滚．\n\n  innodb_rollback_on_timeout参数为只读参数，需要更改配置文件，并重启服务才会生效．\n\n  在mysqld.cnf文件(本机配置文件路径为：`/etc/mysql/mysql.conf.d/mysqld.cnf`)末尾添加以下内容：\n\n  ```tex mysqld.cnf\n  innodb_lock_wait_timeout=on\n  ```\n\n  \n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/MySQL-命令及方法备忘录.md","raw":"---\n\ntitle: MySQL-命令/方法备忘录\ndate: 2020-09-11 11:52:09\ntags: [\"MySQL\",\"InnoDB\"]\ncategories: [\"MySQL\",\"InnoDB\"]\n---\n\n\n\n记录一些常用或者不常用的命令或方法，方便后续直接查看．．．\n\n<!--more-->\n\n### 1 简单监控当前事务及分析锁问题\n\n从InnoDB1.0开始，在`INFORMATION_SCHEMA`架构下添加了表INNODB_TRX，INNODB_LOCKS, INNODB_LOCK_WAITS．`通过这三张表可以简单的监控当前事务并分析可能存在的锁问题`．\n\n示例：\n\n```mysql\n表结构：\nmysql> explain t_id_incr;\n+-------+------------------+------+-----+---------+----------------+\n| Field | Type             | Null | Key | Default | Extra          |\n+-------+------------------+------+-----+---------+----------------+\n| id    | int(10) unsigned | NO   | MUL | NULL    | auto_increment |\n| name  | varchar(10)      | NO   |     |         |                |\n+-------+------------------+------+-----+---------+----------------+\n2 rows in set (0.00 sec)\n\n表数据如下：\nmysql> select * from t_id_incr;\n+----+----------+\n| id | name     |\n+----+----------+\n|  1 | seven    |\n|  2 | zhangsan |\n|  3 | lisi     |\n+----+----------+\n\n\n按以下顺序执行，产生锁等待\nＡ：start transaction;\nＡ：update t_id_idcr set name='seven1' where id = 1;\n\tＢ：start transaction;\n\tＢ：update t_id_incr set name='zhangsan1' where id = 2;\nＡ：update t_id_incr set name='zhangsan2' where id = 2;\n\t\n此时由于事务Ｂ正在修改id=2的行，因此Ａ需等待事务Ｂ释放id=2的行锁．\n```\n\n\n\n#### 1.1 INNODB_TRX表\n\nINNODB_TRX表提供了当前INNODB引擎内每个事务的信息，包括事务是否在锁等待，正在执行的语句，隔离级别等等．\n\n详细信息可查看：[INNODB_TRX](https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-trx-table.html)\n\n\n\n查看innodb_trx表信息：\n\n```mysql\nmysql> select * from information_schema.INNODB_TRX\\G;\n*************************** 1. row ***************************\n                    trx_id: 101153\n                 trx_state: RUNNING\n               trx_started: 2020-09-11 16:43:15\n     trx_requested_lock_id: NULL\n          trx_wait_started: NULL\n                trx_weight: 5\n       trx_mysql_thread_id: 6\n                 trx_query: select * from information_schema.INNODB_TRX\n       trx_operation_state: NULL\n         trx_tables_in_use: 0\n         trx_tables_locked: 1\n          trx_lock_structs: 4\n     trx_lock_memory_bytes: 1136\n           trx_rows_locked: 3\n         trx_rows_modified: 1\n   trx_concurrency_tickets: 0\n       trx_isolation_level: REPEATABLE READ\n         trx_unique_checks: 1\n    trx_foreign_key_checks: 1\ntrx_last_foreign_key_error: NULL\n trx_adaptive_hash_latched: 0\n trx_adaptive_hash_timeout: 0\n          trx_is_read_only: 0\ntrx_autocommit_non_locking: 0\n*************************** 2. row ***************************\n                    trx_id: 101152\n                 trx_state: LOCK WAIT\n               trx_started: 2020-09-11 16:43:05\n     trx_requested_lock_id: 101152:444:4:3\n          trx_wait_started: 2020-09-11 16:43:22\n                trx_weight: 6\n       trx_mysql_thread_id: 5\n                 trx_query: update t_id_incr set name='zhangsan2' where id = 2\n       trx_operation_state: starting index read\n         trx_tables_in_use: 1\n         trx_tables_locked: 1\n          trx_lock_structs: 5\n     trx_lock_memory_bytes: 1136\n           trx_rows_locked: 4\n         trx_rows_modified: 1\n   trx_concurrency_tickets: 0\n       trx_isolation_level: REPEATABLE READ\n         trx_unique_checks: 1\n    trx_foreign_key_checks: 1\ntrx_last_foreign_key_error: NULL\n trx_adaptive_hash_latched: 0\n trx_adaptive_hash_timeout: 0\n          trx_is_read_only: 0\ntrx_autocommit_non_locking: 0\n2 rows in set (0.00 sec)\n```\n\n\n\n\n\n#### 1.2 INNODB_LOCKS表\n\nINNODB_LOCKS表提供关于InnoDB事务已请求但尚未获取的每个锁的信息，以及事务持有的阻止另一个事务的每个锁的信息．（ MySQL 8.0.1起不推荐使用该表，并删除了该表。改用性能架构[`data_locks`](https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-locks-table.html) 表）\n\n详细信息可查看：[INNODB_LOCKS](https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-locks-table.html)\n\n查看innodb_locks表：\n\n```mysql\nmysql> select * from information_schema.innodb_locks\\G;\n*************************** 1. row ***************************\n    lock_id: 101152:444:4:3\nlock_trx_id: 101152\n  lock_mode: X\n  lock_type: RECORD\n lock_table: `seven`.`t_id_incr`\n lock_index: idx_id\n lock_space: 444\n  lock_page: 4\n   lock_rec: 3\n  lock_data: 2, 0x000000000301\n*************************** 2. row ***************************\n    lock_id: 101153:444:4:3\nlock_trx_id: 101153\n  lock_mode: X\n  lock_type: RECORD\n lock_table: `seven`.`t_id_incr`\n lock_index: idx_id\n lock_space: 444\n  lock_page: 4\n   lock_rec: 3\n  lock_data: 2, 0x000000000301\n2 rows in set, 1 warning (0.02 sec)\n```\n\n\n\n#### 1.3 INNODB_LOCK_WAITS表\n\nINNODB_LOCK_WAITS表为每个被阻止的InnoDB事务包含一个或多个行，指示它已请求的锁以及正在阻止该请求的所有锁．（MySQL 8.0.1起不推荐使用该表，并删除了该表。改用性能架构 [`data_lock_waits`](https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-lock-waits-table.html)表。）\n\n详细信息可查看：[INNODB_LOCK_WAITS](https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-lock-waits-table.html)\n\n查看innodb_lock_waits表：\n\n```mysql\nmysql> select * from information_schema.INNODB_LOCK_WAITS\\G;\n*************************** 1. row ***************************\nrequesting_trx_id: 101152\nrequested_lock_id: 101152:444:4:3\n  blocking_trx_id: 101153\n blocking_lock_id: 101153:444:4:3\n1 row in set, 1 warning (0.00 sec)\n```\n\n\n\n### INNODB_LOCK_WAITS\n\n### 2 隔离级别\n\n不同事务的隔离级别，InnoDB的锁实现是不一样的．支持的隔离级别包括：\n\n- read uncommitted\n- read committed\n- repeatable read（默认）\n- serializable\n\n\n\n#### 2.1 查看隔离级别方法\n\n- 查看当前会话隔离级别\n\n```mysql\nshow variables like 'tx_isolation'\n或\nselect @@tx_isolation\n```\n\n- 查看系统隔离级别\n\n```mysql\nshow global variables like 'tx_isolation'\n或\nselect @@global.tx_isolation\n```\n\n\n\n#### 2.2 设置隔离级别\n\n- 设置当前会话隔离级别：\n\n```mysql\nset session transaction isolation level <隔离级别>';\n```\n\n- 设置系统隔离级别：\n\n```mysql\nset global transaction isolation level <隔离级别>';\n```\n\n\n\n### 3 事务自动提交\n\nMysql默认采用自动提交模式（即`autocommit=1`），即如果不是显式地开始一个事务，每个查询都被当做一个事务执行提交操作。\n\n#### 3.1 查看事务自动提交模式\n\n- 查看当前会话自动提交模式命令：\n\n```mysql\nshow variables like 'autocommit'\n```\n\n- 查看数据库系统自动提交模式命令：\n\n```mysql\nshow global variables like 'autocommit'\n```\n\n\n\n#### 3.2 设置事务自动提交模式\n\n- 设置当前会话自动提交模式命令：\n\n```mysql\nset autocommit = ０　// 0表示关闭，１表示开启\n```\n\n- 设置系统自动提交模式命令：\n\n```\nset global autocommit = 0;\n```\n\n\n\n### 4 数据库线程\n\n#### 4.1 查看数据库线程使用情况\n\n命令：\n\n```mysql\n show processlist\n```\n\n示例：\n\n```mysql\nmysql>  show processlist;\n+----+------+-----------+-------+---------+------+----------+------------------+\n| Id | User | Host      | db    | Command | Time | State    | Info             |\n+----+------+-----------+-------+---------+------+----------+------------------+\n|  3 | root | localhost | seven | Query   |    0 | starting | show processlist |\n|  4 | root | localhost | seven | Sleep   | 1450 |          | NULL             |\n+----+------+-----------+-------+---------+------+----------+------------------+\n2 rows in set (0.00 sec)\n```\n\n\n\n#### 4.2 杀掉线程\n\n命令：\n\n```mysql\nkill <id>\n```\n\n示例：\n\n```\nmysql> kill 4;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql>  show processlist;\n+----+------+-----------+-------+---------+------+----------+------------------+\n| Id | User | Host      | db    | Command | Time | State    | Info             |\n+----+------+-----------+-------+---------+------+----------+------------------+\n|  3 | root | localhost | seven | Query   |    0 | starting | show processlist |\n+----+------+-----------+-------+---------+------+----------+------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n### 5 查看表自增长计数器\n\n在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。\n\n通过以下命令查看表的自增长计数器的值：\n\n```mysql\nselect max(auto_inc_col) from <table_name> for update\n```\n\n\n\n### 6 显式关闭间隙锁的方法\n\n显式关闭间隙锁的方法：\n\n- 将事务的隔离级别设置为READ COMMITTED.\n- 将参数innodb_locks_unsafe_for_binlog设置为１．\n\n\n\n### 7 锁等待时间\n\n在InnoDB存储引擎中，参数`innodb_lock_wait_timeout`用来控制等待的时间（默认是50秒）,该参数是动态的，可以在MySQL运行时进行调整．\n\n- 查看锁等待时间．\n\n```mysql\nshow variables like 'innodb_lock_wait_timeout';\n```\n\n- 设置锁等待时间,单位秒．\n\n```mysql\nset @@innodb_lock_wait_timeout=<超时时间>;\n```\n\n\n\n### 8 超时回滚\n\n在InnoDB存储引擎中，参数innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作（默认是OFF，代表不回滚）．\n\n- 查看超时回滚．\n\n```mysql\nshow variables like 'innodb_rollback_on_timeout';\n```\n\n- 启用超时回滚．\n\n  innodb_rollback_on_timeout参数为只读参数，需要更改配置文件，并重启服务才会生效．\n\n  在mysqld.cnf文件(本机配置文件路径为：`/etc/mysql/mysql.conf.d/mysqld.cnf`)末尾添加以下内容：\n\n  ```tex mysqld.cnf\n  innodb_lock_wait_timeout=on\n  ```\n\n  \n\n\n\n\n\n\n\n\n\n\n\n","slug":"MySQL-命令及方法备忘录","published":1,"updated":"2020-09-15T03:11:47.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkk002045g3hjoleh4l","content":"<p>记录一些常用或者不常用的命令或方法，方便后续直接查看．．．</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-简单监控当前事务及分析锁问题\"><a href=\"#1-简单监控当前事务及分析锁问题\" class=\"headerlink\" title=\"1 简单监控当前事务及分析锁问题\"></a>1 简单监控当前事务及分析锁问题</h3><p>从InnoDB1.0开始，在<code>INFORMATION_SCHEMA</code>架构下添加了表INNODB_TRX，INNODB_LOCKS, INNODB_LOCK_WAITS．<code>通过这三张表可以简单的监控当前事务并分析可能存在的锁问题</code>．</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表结构：</span><br><span class=\"line\">mysql&gt; explain t_id_incr;</span><br><span class=\"line\">+-------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">| Field | Type             | Null | Key | Default | Extra          |</span><br><span class=\"line\">+-------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">| id    | int(10) unsigned | NO   | MUL | NULL    | auto_increment |</span><br><span class=\"line\">| name  | varchar(10)      | NO   |     |         |                |</span><br><span class=\"line\">+-------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">表数据如下：</span><br><span class=\"line\">mysql&gt; select * from t_id_incr;</span><br><span class=\"line\">+----+----------+</span><br><span class=\"line\">| id | name     |</span><br><span class=\"line\">+----+----------+</span><br><span class=\"line\">|  1 | seven    |</span><br><span class=\"line\">|  2 | zhangsan |</span><br><span class=\"line\">|  3 | lisi     |</span><br><span class=\"line\">+----+----------+</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">按以下顺序执行，产生锁等待</span><br><span class=\"line\">Ａ：start transaction;</span><br><span class=\"line\">Ａ：update t_id_idcr set name&#x3D;&#39;seven1&#39; where id &#x3D; 1;</span><br><span class=\"line\">\tＢ：start transaction;</span><br><span class=\"line\">\tＢ：update t_id_incr set name&#x3D;&#39;zhangsan1&#39; where id &#x3D; 2;</span><br><span class=\"line\">Ａ：update t_id_incr set name&#x3D;&#39;zhangsan2&#39; where id &#x3D; 2;</span><br><span class=\"line\">\t</span><br><span class=\"line\">此时由于事务Ｂ正在修改id&#x3D;2的行，因此Ａ需等待事务Ｂ释放id&#x3D;2的行锁．</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-1-INNODB-TRX表\"><a href=\"#1-1-INNODB-TRX表\" class=\"headerlink\" title=\"1.1 INNODB_TRX表\"></a>1.1 INNODB_TRX表</h4><p>INNODB_TRX表提供了当前INNODB引擎内每个事务的信息，包括事务是否在锁等待，正在执行的语句，隔离级别等等．</p>\n<p>详细信息可查看：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-trx-table.html\">INNODB_TRX</a></p>\n<p>查看innodb_trx表信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from information_schema.INNODB_TRX\\G;</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">                    trx_id: 101153</span><br><span class=\"line\">                 trx_state: RUNNING</span><br><span class=\"line\">               trx_started: 2020-09-11 16:43:15</span><br><span class=\"line\">     trx_requested_lock_id: NULL</span><br><span class=\"line\">          trx_wait_started: NULL</span><br><span class=\"line\">                trx_weight: 5</span><br><span class=\"line\">       trx_mysql_thread_id: 6</span><br><span class=\"line\">                 trx_query: select * from information_schema.INNODB_TRX</span><br><span class=\"line\">       trx_operation_state: NULL</span><br><span class=\"line\">         trx_tables_in_use: 0</span><br><span class=\"line\">         trx_tables_locked: 1</span><br><span class=\"line\">          trx_lock_structs: 4</span><br><span class=\"line\">     trx_lock_memory_bytes: 1136</span><br><span class=\"line\">           trx_rows_locked: 3</span><br><span class=\"line\">         trx_rows_modified: 1</span><br><span class=\"line\">   trx_concurrency_tickets: 0</span><br><span class=\"line\">       trx_isolation_level: REPEATABLE READ</span><br><span class=\"line\">         trx_unique_checks: 1</span><br><span class=\"line\">    trx_foreign_key_checks: 1</span><br><span class=\"line\">trx_last_foreign_key_error: NULL</span><br><span class=\"line\"> trx_adaptive_hash_latched: 0</span><br><span class=\"line\"> trx_adaptive_hash_timeout: 0</span><br><span class=\"line\">          trx_is_read_only: 0</span><br><span class=\"line\">trx_autocommit_non_locking: 0</span><br><span class=\"line\">*************************** 2. row ***************************</span><br><span class=\"line\">                    trx_id: 101152</span><br><span class=\"line\">                 trx_state: LOCK WAIT</span><br><span class=\"line\">               trx_started: 2020-09-11 16:43:05</span><br><span class=\"line\">     trx_requested_lock_id: 101152:444:4:3</span><br><span class=\"line\">          trx_wait_started: 2020-09-11 16:43:22</span><br><span class=\"line\">                trx_weight: 6</span><br><span class=\"line\">       trx_mysql_thread_id: 5</span><br><span class=\"line\">                 trx_query: update t_id_incr set name&#x3D;&#39;zhangsan2&#39; where id &#x3D; 2</span><br><span class=\"line\">       trx_operation_state: starting index read</span><br><span class=\"line\">         trx_tables_in_use: 1</span><br><span class=\"line\">         trx_tables_locked: 1</span><br><span class=\"line\">          trx_lock_structs: 5</span><br><span class=\"line\">     trx_lock_memory_bytes: 1136</span><br><span class=\"line\">           trx_rows_locked: 4</span><br><span class=\"line\">         trx_rows_modified: 1</span><br><span class=\"line\">   trx_concurrency_tickets: 0</span><br><span class=\"line\">       trx_isolation_level: REPEATABLE READ</span><br><span class=\"line\">         trx_unique_checks: 1</span><br><span class=\"line\">    trx_foreign_key_checks: 1</span><br><span class=\"line\">trx_last_foreign_key_error: NULL</span><br><span class=\"line\"> trx_adaptive_hash_latched: 0</span><br><span class=\"line\"> trx_adaptive_hash_timeout: 0</span><br><span class=\"line\">          trx_is_read_only: 0</span><br><span class=\"line\">trx_autocommit_non_locking: 0</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"1-2-INNODB-LOCKS表\"><a href=\"#1-2-INNODB-LOCKS表\" class=\"headerlink\" title=\"1.2 INNODB_LOCKS表\"></a>1.2 INNODB_LOCKS表</h4><p>INNODB_LOCKS表提供关于InnoDB事务已请求但尚未获取的每个锁的信息，以及事务持有的阻止另一个事务的每个锁的信息．（ MySQL 8.0.1起不推荐使用该表，并删除了该表。改用性能架构<a href=\"https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-locks-table.html\"><code>data_locks</code></a> 表）</p>\n<p>详细信息可查看：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-locks-table.html\">INNODB_LOCKS</a></p>\n<p>查看innodb_locks表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from information_schema.innodb_locks\\G;</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">    lock_id: 101152:444:4:3</span><br><span class=\"line\">lock_trx_id: 101152</span><br><span class=\"line\">  lock_mode: X</span><br><span class=\"line\">  lock_type: RECORD</span><br><span class=\"line\"> lock_table: &#96;seven&#96;.&#96;t_id_incr&#96;</span><br><span class=\"line\"> lock_index: idx_id</span><br><span class=\"line\"> lock_space: 444</span><br><span class=\"line\">  lock_page: 4</span><br><span class=\"line\">   lock_rec: 3</span><br><span class=\"line\">  lock_data: 2, 0x000000000301</span><br><span class=\"line\">*************************** 2. row ***************************</span><br><span class=\"line\">    lock_id: 101153:444:4:3</span><br><span class=\"line\">lock_trx_id: 101153</span><br><span class=\"line\">  lock_mode: X</span><br><span class=\"line\">  lock_type: RECORD</span><br><span class=\"line\"> lock_table: &#96;seven&#96;.&#96;t_id_incr&#96;</span><br><span class=\"line\"> lock_index: idx_id</span><br><span class=\"line\"> lock_space: 444</span><br><span class=\"line\">  lock_page: 4</span><br><span class=\"line\">   lock_rec: 3</span><br><span class=\"line\">  lock_data: 2, 0x000000000301</span><br><span class=\"line\">2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-3-INNODB-LOCK-WAITS表\"><a href=\"#1-3-INNODB-LOCK-WAITS表\" class=\"headerlink\" title=\"1.3 INNODB_LOCK_WAITS表\"></a>1.3 INNODB_LOCK_WAITS表</h4><p>INNODB_LOCK_WAITS表为每个被阻止的InnoDB事务包含一个或多个行，指示它已请求的锁以及正在阻止该请求的所有锁．（MySQL 8.0.1起不推荐使用该表，并删除了该表。改用性能架构 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-lock-waits-table.html\"><code>data_lock_waits</code></a>表。）</p>\n<p>详细信息可查看：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-lock-waits-table.html\">INNODB_LOCK_WAITS</a></p>\n<p>查看innodb_lock_waits表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from information_schema.INNODB_LOCK_WAITS\\G;</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">requesting_trx_id: 101152</span><br><span class=\"line\">requested_lock_id: 101152:444:4:3</span><br><span class=\"line\">  blocking_trx_id: 101153</span><br><span class=\"line\"> blocking_lock_id: 101153:444:4:3</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"INNODB-LOCK-WAITS\"><a href=\"#INNODB-LOCK-WAITS\" class=\"headerlink\" title=\"INNODB_LOCK_WAITS\"></a>INNODB_LOCK_WAITS</h3><h3 id=\"2-隔离级别\"><a href=\"#2-隔离级别\" class=\"headerlink\" title=\"2 隔离级别\"></a>2 隔离级别</h3><p>不同事务的隔离级别，InnoDB的锁实现是不一样的．支持的隔离级别包括：</p>\n<ul>\n<li>read uncommitted</li>\n<li>read committed</li>\n<li>repeatable read（默认）</li>\n<li>serializable</li>\n</ul>\n<h4 id=\"2-1-查看隔离级别方法\"><a href=\"#2-1-查看隔离级别方法\" class=\"headerlink\" title=\"2.1 查看隔离级别方法\"></a>2.1 查看隔离级别方法</h4><ul>\n<li>查看当前会话隔离级别</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#39;tx_isolation&#39;</span><br><span class=\"line\">或</span><br><span class=\"line\">select @@tx_isolation</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查看系统隔离级别</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show global variables like &#39;tx_isolation&#39;</span><br><span class=\"line\">或</span><br><span class=\"line\">select @@global.tx_isolation</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-设置隔离级别\"><a href=\"#2-2-设置隔离级别\" class=\"headerlink\" title=\"2.2 设置隔离级别\"></a>2.2 设置隔离级别</h4><ul>\n<li>设置当前会话隔离级别：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set session transaction isolation level &lt;隔离级别&gt;&#39;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置系统隔离级别：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global transaction isolation level &lt;隔离级别&gt;&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-事务自动提交\"><a href=\"#3-事务自动提交\" class=\"headerlink\" title=\"3 事务自动提交\"></a>3 事务自动提交</h3><p>Mysql默认采用自动提交模式（即<code>autocommit=1</code>），即如果不是显式地开始一个事务，每个查询都被当做一个事务执行提交操作。</p>\n<h4 id=\"3-1-查看事务自动提交模式\"><a href=\"#3-1-查看事务自动提交模式\" class=\"headerlink\" title=\"3.1 查看事务自动提交模式\"></a>3.1 查看事务自动提交模式</h4><ul>\n<li>查看当前会话自动提交模式命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#39;autocommit&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查看数据库系统自动提交模式命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show global variables like &#39;autocommit&#39;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-设置事务自动提交模式\"><a href=\"#3-2-设置事务自动提交模式\" class=\"headerlink\" title=\"3.2 设置事务自动提交模式\"></a>3.2 设置事务自动提交模式</h4><ul>\n<li>设置当前会话自动提交模式命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set autocommit &#x3D; ０　&#x2F;&#x2F; 0表示关闭，１表示开启</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置系统自动提交模式命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-数据库线程\"><a href=\"#4-数据库线程\" class=\"headerlink\" title=\"4 数据库线程\"></a>4 数据库线程</h3><h4 id=\"4-1-查看数据库线程使用情况\"><a href=\"#4-1-查看数据库线程使用情况\" class=\"headerlink\" title=\"4.1 查看数据库线程使用情况\"></a>4.1 查看数据库线程使用情况</h4><p>命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show processlist</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt;  show processlist;</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">| Id | User | Host      | db    | Command | Time | State    | Info             |</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">|  3 | root | localhost | seven | Query   |    0 | starting | show processlist |</span><br><span class=\"line\">|  4 | root | localhost | seven | Sleep   | 1450 |          | NULL             |</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-2-杀掉线程\"><a href=\"#4-2-杀掉线程\" class=\"headerlink\" title=\"4.2 杀掉线程\"></a>4.2 杀掉线程</h4><p>命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill &lt;id&gt;</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; kill 4;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt;  show processlist;</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">| Id | User | Host      | db    | Command | Time | State    | Info             |</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">|  3 | root | localhost | seven | Query   |    0 | starting | show processlist |</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-查看表自增长计数器\"><a href=\"#5-查看表自增长计数器\" class=\"headerlink\" title=\"5 查看表自增长计数器\"></a>5 查看表自增长计数器</h3><p>在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。</p>\n<p>通过以下命令查看表的自增长计数器的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select max(auto_inc_col) from &lt;table_name&gt; for update</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-显式关闭间隙锁的方法\"><a href=\"#6-显式关闭间隙锁的方法\" class=\"headerlink\" title=\"6 显式关闭间隙锁的方法\"></a>6 显式关闭间隙锁的方法</h3><p>显式关闭间隙锁的方法：</p>\n<ul>\n<li>将事务的隔离级别设置为READ COMMITTED.</li>\n<li>将参数innodb_locks_unsafe_for_binlog设置为１．</li>\n</ul>\n<h3 id=\"7-锁等待时间\"><a href=\"#7-锁等待时间\" class=\"headerlink\" title=\"7 锁等待时间\"></a>7 锁等待时间</h3><p>在InnoDB存储引擎中，参数<code>innodb_lock_wait_timeout</code>用来控制等待的时间（默认是50秒）,该参数是动态的，可以在MySQL运行时进行调整．</p>\n<ul>\n<li>查看锁等待时间．</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#39;innodb_lock_wait_timeout&#39;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置锁等待时间,单位秒．</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set @@innodb_lock_wait_timeout&#x3D;&lt;超时时间&gt;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"8-超时回滚\"><a href=\"#8-超时回滚\" class=\"headerlink\" title=\"8 超时回滚\"></a>8 超时回滚</h3><p>在InnoDB存储引擎中，参数innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作（默认是OFF，代表不回滚）．</p>\n<ul>\n<li>查看超时回滚．</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#39;innodb_rollback_on_timeout&#39;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>启用超时回滚．</p>\n<p>innodb_rollback_on_timeout参数为只读参数，需要更改配置文件，并重启服务才会生效．</p>\n<p>在mysqld.cnf文件(本机配置文件路径为：<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>)末尾添加以下内容：</p>\n<figure class=\"highlight tex\"><figcaption><span>mysqld.cnf</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_lock_wait_timeout=on</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>记录一些常用或者不常用的命令或方法，方便后续直接查看．．．</p>","more":"<h3 id=\"1-简单监控当前事务及分析锁问题\"><a href=\"#1-简单监控当前事务及分析锁问题\" class=\"headerlink\" title=\"1 简单监控当前事务及分析锁问题\"></a>1 简单监控当前事务及分析锁问题</h3><p>从InnoDB1.0开始，在<code>INFORMATION_SCHEMA</code>架构下添加了表INNODB_TRX，INNODB_LOCKS, INNODB_LOCK_WAITS．<code>通过这三张表可以简单的监控当前事务并分析可能存在的锁问题</code>．</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">表结构：</span><br><span class=\"line\">mysql&gt; explain t_id_incr;</span><br><span class=\"line\">+-------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">| Field | Type             | Null | Key | Default | Extra          |</span><br><span class=\"line\">+-------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">| id    | int(10) unsigned | NO   | MUL | NULL    | auto_increment |</span><br><span class=\"line\">| name  | varchar(10)      | NO   |     |         |                |</span><br><span class=\"line\">+-------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">表数据如下：</span><br><span class=\"line\">mysql&gt; select * from t_id_incr;</span><br><span class=\"line\">+----+----------+</span><br><span class=\"line\">| id | name     |</span><br><span class=\"line\">+----+----------+</span><br><span class=\"line\">|  1 | seven    |</span><br><span class=\"line\">|  2 | zhangsan |</span><br><span class=\"line\">|  3 | lisi     |</span><br><span class=\"line\">+----+----------+</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">按以下顺序执行，产生锁等待</span><br><span class=\"line\">Ａ：start transaction;</span><br><span class=\"line\">Ａ：update t_id_idcr set name&#x3D;&#39;seven1&#39; where id &#x3D; 1;</span><br><span class=\"line\">\tＢ：start transaction;</span><br><span class=\"line\">\tＢ：update t_id_incr set name&#x3D;&#39;zhangsan1&#39; where id &#x3D; 2;</span><br><span class=\"line\">Ａ：update t_id_incr set name&#x3D;&#39;zhangsan2&#39; where id &#x3D; 2;</span><br><span class=\"line\">\t</span><br><span class=\"line\">此时由于事务Ｂ正在修改id&#x3D;2的行，因此Ａ需等待事务Ｂ释放id&#x3D;2的行锁．</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-1-INNODB-TRX表\"><a href=\"#1-1-INNODB-TRX表\" class=\"headerlink\" title=\"1.1 INNODB_TRX表\"></a>1.1 INNODB_TRX表</h4><p>INNODB_TRX表提供了当前INNODB引擎内每个事务的信息，包括事务是否在锁等待，正在执行的语句，隔离级别等等．</p>\n<p>详细信息可查看：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-trx-table.html\">INNODB_TRX</a></p>\n<p>查看innodb_trx表信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from information_schema.INNODB_TRX\\G;</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">                    trx_id: 101153</span><br><span class=\"line\">                 trx_state: RUNNING</span><br><span class=\"line\">               trx_started: 2020-09-11 16:43:15</span><br><span class=\"line\">     trx_requested_lock_id: NULL</span><br><span class=\"line\">          trx_wait_started: NULL</span><br><span class=\"line\">                trx_weight: 5</span><br><span class=\"line\">       trx_mysql_thread_id: 6</span><br><span class=\"line\">                 trx_query: select * from information_schema.INNODB_TRX</span><br><span class=\"line\">       trx_operation_state: NULL</span><br><span class=\"line\">         trx_tables_in_use: 0</span><br><span class=\"line\">         trx_tables_locked: 1</span><br><span class=\"line\">          trx_lock_structs: 4</span><br><span class=\"line\">     trx_lock_memory_bytes: 1136</span><br><span class=\"line\">           trx_rows_locked: 3</span><br><span class=\"line\">         trx_rows_modified: 1</span><br><span class=\"line\">   trx_concurrency_tickets: 0</span><br><span class=\"line\">       trx_isolation_level: REPEATABLE READ</span><br><span class=\"line\">         trx_unique_checks: 1</span><br><span class=\"line\">    trx_foreign_key_checks: 1</span><br><span class=\"line\">trx_last_foreign_key_error: NULL</span><br><span class=\"line\"> trx_adaptive_hash_latched: 0</span><br><span class=\"line\"> trx_adaptive_hash_timeout: 0</span><br><span class=\"line\">          trx_is_read_only: 0</span><br><span class=\"line\">trx_autocommit_non_locking: 0</span><br><span class=\"line\">*************************** 2. row ***************************</span><br><span class=\"line\">                    trx_id: 101152</span><br><span class=\"line\">                 trx_state: LOCK WAIT</span><br><span class=\"line\">               trx_started: 2020-09-11 16:43:05</span><br><span class=\"line\">     trx_requested_lock_id: 101152:444:4:3</span><br><span class=\"line\">          trx_wait_started: 2020-09-11 16:43:22</span><br><span class=\"line\">                trx_weight: 6</span><br><span class=\"line\">       trx_mysql_thread_id: 5</span><br><span class=\"line\">                 trx_query: update t_id_incr set name&#x3D;&#39;zhangsan2&#39; where id &#x3D; 2</span><br><span class=\"line\">       trx_operation_state: starting index read</span><br><span class=\"line\">         trx_tables_in_use: 1</span><br><span class=\"line\">         trx_tables_locked: 1</span><br><span class=\"line\">          trx_lock_structs: 5</span><br><span class=\"line\">     trx_lock_memory_bytes: 1136</span><br><span class=\"line\">           trx_rows_locked: 4</span><br><span class=\"line\">         trx_rows_modified: 1</span><br><span class=\"line\">   trx_concurrency_tickets: 0</span><br><span class=\"line\">       trx_isolation_level: REPEATABLE READ</span><br><span class=\"line\">         trx_unique_checks: 1</span><br><span class=\"line\">    trx_foreign_key_checks: 1</span><br><span class=\"line\">trx_last_foreign_key_error: NULL</span><br><span class=\"line\"> trx_adaptive_hash_latched: 0</span><br><span class=\"line\"> trx_adaptive_hash_timeout: 0</span><br><span class=\"line\">          trx_is_read_only: 0</span><br><span class=\"line\">trx_autocommit_non_locking: 0</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"1-2-INNODB-LOCKS表\"><a href=\"#1-2-INNODB-LOCKS表\" class=\"headerlink\" title=\"1.2 INNODB_LOCKS表\"></a>1.2 INNODB_LOCKS表</h4><p>INNODB_LOCKS表提供关于InnoDB事务已请求但尚未获取的每个锁的信息，以及事务持有的阻止另一个事务的每个锁的信息．（ MySQL 8.0.1起不推荐使用该表，并删除了该表。改用性能架构<a href=\"https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-locks-table.html\"><code>data_locks</code></a> 表）</p>\n<p>详细信息可查看：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-locks-table.html\">INNODB_LOCKS</a></p>\n<p>查看innodb_locks表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from information_schema.innodb_locks\\G;</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">    lock_id: 101152:444:4:3</span><br><span class=\"line\">lock_trx_id: 101152</span><br><span class=\"line\">  lock_mode: X</span><br><span class=\"line\">  lock_type: RECORD</span><br><span class=\"line\"> lock_table: &#96;seven&#96;.&#96;t_id_incr&#96;</span><br><span class=\"line\"> lock_index: idx_id</span><br><span class=\"line\"> lock_space: 444</span><br><span class=\"line\">  lock_page: 4</span><br><span class=\"line\">   lock_rec: 3</span><br><span class=\"line\">  lock_data: 2, 0x000000000301</span><br><span class=\"line\">*************************** 2. row ***************************</span><br><span class=\"line\">    lock_id: 101153:444:4:3</span><br><span class=\"line\">lock_trx_id: 101153</span><br><span class=\"line\">  lock_mode: X</span><br><span class=\"line\">  lock_type: RECORD</span><br><span class=\"line\"> lock_table: &#96;seven&#96;.&#96;t_id_incr&#96;</span><br><span class=\"line\"> lock_index: idx_id</span><br><span class=\"line\"> lock_space: 444</span><br><span class=\"line\">  lock_page: 4</span><br><span class=\"line\">   lock_rec: 3</span><br><span class=\"line\">  lock_data: 2, 0x000000000301</span><br><span class=\"line\">2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-3-INNODB-LOCK-WAITS表\"><a href=\"#1-3-INNODB-LOCK-WAITS表\" class=\"headerlink\" title=\"1.3 INNODB_LOCK_WAITS表\"></a>1.3 INNODB_LOCK_WAITS表</h4><p>INNODB_LOCK_WAITS表为每个被阻止的InnoDB事务包含一个或多个行，指示它已请求的锁以及正在阻止该请求的所有锁．（MySQL 8.0.1起不推荐使用该表，并删除了该表。改用性能架构 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-lock-waits-table.html\"><code>data_lock_waits</code></a>表。）</p>\n<p>详细信息可查看：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-lock-waits-table.html\">INNODB_LOCK_WAITS</a></p>\n<p>查看innodb_lock_waits表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from information_schema.INNODB_LOCK_WAITS\\G;</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">requesting_trx_id: 101152</span><br><span class=\"line\">requested_lock_id: 101152:444:4:3</span><br><span class=\"line\">  blocking_trx_id: 101153</span><br><span class=\"line\"> blocking_lock_id: 101153:444:4:3</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"INNODB-LOCK-WAITS\"><a href=\"#INNODB-LOCK-WAITS\" class=\"headerlink\" title=\"INNODB_LOCK_WAITS\"></a>INNODB_LOCK_WAITS</h3><h3 id=\"2-隔离级别\"><a href=\"#2-隔离级别\" class=\"headerlink\" title=\"2 隔离级别\"></a>2 隔离级别</h3><p>不同事务的隔离级别，InnoDB的锁实现是不一样的．支持的隔离级别包括：</p>\n<ul>\n<li>read uncommitted</li>\n<li>read committed</li>\n<li>repeatable read（默认）</li>\n<li>serializable</li>\n</ul>\n<h4 id=\"2-1-查看隔离级别方法\"><a href=\"#2-1-查看隔离级别方法\" class=\"headerlink\" title=\"2.1 查看隔离级别方法\"></a>2.1 查看隔离级别方法</h4><ul>\n<li>查看当前会话隔离级别</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#39;tx_isolation&#39;</span><br><span class=\"line\">或</span><br><span class=\"line\">select @@tx_isolation</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查看系统隔离级别</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show global variables like &#39;tx_isolation&#39;</span><br><span class=\"line\">或</span><br><span class=\"line\">select @@global.tx_isolation</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-设置隔离级别\"><a href=\"#2-2-设置隔离级别\" class=\"headerlink\" title=\"2.2 设置隔离级别\"></a>2.2 设置隔离级别</h4><ul>\n<li>设置当前会话隔离级别：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set session transaction isolation level &lt;隔离级别&gt;&#39;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置系统隔离级别：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global transaction isolation level &lt;隔离级别&gt;&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-事务自动提交\"><a href=\"#3-事务自动提交\" class=\"headerlink\" title=\"3 事务自动提交\"></a>3 事务自动提交</h3><p>Mysql默认采用自动提交模式（即<code>autocommit=1</code>），即如果不是显式地开始一个事务，每个查询都被当做一个事务执行提交操作。</p>\n<h4 id=\"3-1-查看事务自动提交模式\"><a href=\"#3-1-查看事务自动提交模式\" class=\"headerlink\" title=\"3.1 查看事务自动提交模式\"></a>3.1 查看事务自动提交模式</h4><ul>\n<li>查看当前会话自动提交模式命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#39;autocommit&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查看数据库系统自动提交模式命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show global variables like &#39;autocommit&#39;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-设置事务自动提交模式\"><a href=\"#3-2-设置事务自动提交模式\" class=\"headerlink\" title=\"3.2 设置事务自动提交模式\"></a>3.2 设置事务自动提交模式</h4><ul>\n<li>设置当前会话自动提交模式命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set autocommit &#x3D; ０　&#x2F;&#x2F; 0表示关闭，１表示开启</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置系统自动提交模式命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-数据库线程\"><a href=\"#4-数据库线程\" class=\"headerlink\" title=\"4 数据库线程\"></a>4 数据库线程</h3><h4 id=\"4-1-查看数据库线程使用情况\"><a href=\"#4-1-查看数据库线程使用情况\" class=\"headerlink\" title=\"4.1 查看数据库线程使用情况\"></a>4.1 查看数据库线程使用情况</h4><p>命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show processlist</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt;  show processlist;</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">| Id | User | Host      | db    | Command | Time | State    | Info             |</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">|  3 | root | localhost | seven | Query   |    0 | starting | show processlist |</span><br><span class=\"line\">|  4 | root | localhost | seven | Sleep   | 1450 |          | NULL             |</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-2-杀掉线程\"><a href=\"#4-2-杀掉线程\" class=\"headerlink\" title=\"4.2 杀掉线程\"></a>4.2 杀掉线程</h4><p>命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill &lt;id&gt;</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; kill 4;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt;  show processlist;</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">| Id | User | Host      | db    | Command | Time | State    | Info             |</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">|  3 | root | localhost | seven | Query   |    0 | starting | show processlist |</span><br><span class=\"line\">+----+------+-----------+-------+---------+------+----------+------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-查看表自增长计数器\"><a href=\"#5-查看表自增长计数器\" class=\"headerlink\" title=\"5 查看表自增长计数器\"></a>5 查看表自增长计数器</h3><p>在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。</p>\n<p>通过以下命令查看表的自增长计数器的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select max(auto_inc_col) from &lt;table_name&gt; for update</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-显式关闭间隙锁的方法\"><a href=\"#6-显式关闭间隙锁的方法\" class=\"headerlink\" title=\"6 显式关闭间隙锁的方法\"></a>6 显式关闭间隙锁的方法</h3><p>显式关闭间隙锁的方法：</p>\n<ul>\n<li>将事务的隔离级别设置为READ COMMITTED.</li>\n<li>将参数innodb_locks_unsafe_for_binlog设置为１．</li>\n</ul>\n<h3 id=\"7-锁等待时间\"><a href=\"#7-锁等待时间\" class=\"headerlink\" title=\"7 锁等待时间\"></a>7 锁等待时间</h3><p>在InnoDB存储引擎中，参数<code>innodb_lock_wait_timeout</code>用来控制等待的时间（默认是50秒）,该参数是动态的，可以在MySQL运行时进行调整．</p>\n<ul>\n<li>查看锁等待时间．</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#39;innodb_lock_wait_timeout&#39;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>设置锁等待时间,单位秒．</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set @@innodb_lock_wait_timeout&#x3D;&lt;超时时间&gt;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"8-超时回滚\"><a href=\"#8-超时回滚\" class=\"headerlink\" title=\"8 超时回滚\"></a>8 超时回滚</h3><p>在InnoDB存储引擎中，参数innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作（默认是OFF，代表不回滚）．</p>\n<ul>\n<li>查看超时回滚．</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#39;innodb_rollback_on_timeout&#39;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>启用超时回滚．</p>\n<p>innodb_rollback_on_timeout参数为只读参数，需要更改配置文件，并重启服务才会生效．</p>\n<p>在mysqld.cnf文件(本机配置文件路径为：<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>)末尾添加以下内容：</p>\n<figure class=\"highlight tex\"><figcaption><span>mysqld.cnf</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_lock_wait_timeout=on</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n</li>\n</ul>"},{"title":"MySQL-索引分类","date":"2020-09-05T17:04:57.000Z","_content":"\n### 1 从逻辑角度划分类\n\n索引本质上是表字段的有序子集，其每个记录项指向相应的表记录。MySQL共有4类索引：\n\n<!--more-->\n\n- 主键索引\n- 唯一索引\n- 常规索引\n- 全文索引\n\n\n\n#### 1.1 主键索引\n\n`主键索引用于根据主键自身的唯一性来唯一标识每条记录。`因此，该键必须是该记录所表示实体唯一拥有的值，或者是数据库生成的唯一值，例如，自增整数。\n\n\n\n示例: 设置id作为自增主键索引.\n\n```mysql\ncreate table `bookmarks` (\n    `id` int unsigned not null auto_increment comment '主键id',\n    `name` varchar(75) not null default '' comment '名称',\n    `url` varchar(200) not null default '' comment 'URL',\n    `description` mediumtext not null comment '描述',\n    primary key(`id`)\n) engine=InnoDB default charset=utf8mb4 comment='书签表';\n```\n\n注：<u>每个表只能有一个自增字段,且该字段必须为主键,为主键的字段不能包含null值,即使没有显式申明为not null, MySQL也会自动赋予此特性.</u>\n\n\n\n#### 1.2 唯一索引\n\n与主键索引一样，唯一索引可以预防哪个创建重复的值。但是，<u>与之不同之处在于每个表只能有一个主键索引,但可以有多个唯一索引.可以为null值.</u>\n\n\n\n示例:设置name和url作为唯一联合索引\n\n```mysql\ncreate table `bookmarks_v1` (\n    `id` int unsigned not null auto_increment comment '主键id',\n    `name` varchar(75) not null default '' comment '名称',\n    `url` varchar(200) not null default '' comment 'URL',\n    `description` mediumtext not null comment '描述',\n    primary key (`id`),\n    unique key `name_url` (`name`,`url`)\n) engine=InnoDB default charset=utf8mb4 comment='书签表';\n```\n\n\n\n#### 1.3 普通索引\n\n普通索引可以分为`单列普通索引`和`联合普通索引`.\n\n##### 1.3.1 单列普通索引\n\n若表中的某个列将成为大量选择查询的焦点，就应当使用单列普通索引。\n\n示例：设置email为唯一索引，姓氏为单例普通索引。\n\n```mysql\ncreate table employees(\n    `id` int unsigned not null auto_increment comment '主键id',\n    `firstname` varchar(100) not null default '' comment '名称',\n    `lastname` varchar(100) not null default '' comment '姓氏',\n    `email` varchar(100) not null default '' comment '电子邮箱',\n    primary key (`id`),\n    unique key `idx_email` (`email`),\n    key `idx_lastname` (`lastname`)\n) engine=InnoDB default charset=utf8mb4 comment='员工信息表';\n```\n\n##### 1.3.2 多列普通索引(联合索引)\n\n若在查询中，经常会使用多列一起使用，则可使用联合索引，MySQL的联合索引方法基于最左前缀的策略.\n\n\n\n假设为列A、B、C添加联合索引，则使用下列组合可以提高涉及的查询性能：\n\n```\nA,B,C\nA,B\nA\n```\n\n\n\n示例:\n\n```mysql\ncreate table employees_v1(\n    `id` int unsigned not null auto_increment comment '主键id',\n    `firstname` varchar(100) not null default '' comment '名称',\n    `lastname` varchar(100) not null default '' comment '姓氏',\n    `email` varchar(100) not null default '' comment '电子邮箱',\n    primary key (`id`),\n    unique key `idx_email` (`email`),\n    key `idx_lastname_firstname` (`lastname`, `firstname`)\n) engine=InnoDB default charset=utf8mb4 comment='员工信息表';\n```\n\n\n\n#### 1.4 全文索引\n\n全文索引提供了一种高效的方法来搜索存储为`char`，`varchar`或者`text`数据类型的文本。\n\n\n\n示例：在`description`字段上添加全文索引。\n\n```mysql\ncreate table `bookmarks_v2` (\n    `id` int unsigned not null auto_increment comment '主键id',\n    `name` varchar(75) not null default '' comment '名称',\n    `url` varchar(200) not null default '' comment 'URL',\n    `description` mediumtext not null comment '描述',\n    primary key(`id`),\n    fulltext key `idx_description`(`description`)\n) engine=InnoDB default charset=utf8mb4 comment='书签表';\n```\n\n基于全文索引获取数据时，select查询使用两个特殊的MySQL函数`MATCH()`和`AGAINST()`。利用这两个函数，可以针对全文索引执行自然语言搜索，如下所示：\n\n- 添加数据\n\n\n```mysql\ninsert into bookmarks_v2 (name,url,description) \n    values \n    (\"Python\", \"www.python.org\", \"The official Python Web site\"),\n    (\"MySQL manuel\", \"http://dev.mysql.com/doc\", \"The MySQL reference manual\"),\n    (\"Apache site\", \"http://httpd.apache.org\", \"Includes Apache 2 manual\"),\n    (\"PHP Hypertext\", \"www.php.net\", \"The official PHP Web site\"),\n    (\"Apache Week\", \"www.apacheweek.com\", \"Offers a dedicated Apache 2 section\");\n```\n\n\n\n- 根据全文索引查询\n\n```mysql\nmysql> select name,url FROM bookmarks_v2 where match(description) against('Apache 2');\n+-------------+-------------------------+\n| name        | url                     |\n+-------------+-------------------------+\n| Apache site | http://httpd.apache.org |\n| Apache Week | www.apacheweek.com      |\n+-------------+-------------------------+\n2 rows in set (0.07 sec)\n\nmysql> select match(description) against('Apache 2') from bookmarks_v2;\n+----------------------------------------+\n| match(description) against('Apache 2') |\n+----------------------------------------+\n|                                      0 |\n|                                      0 |\n|                    0.15835624933242798 |\n|                                      0 |\n|                    0.15835624933242798 |\n+----------------------------------------+\n5 rows in set (0.05 sec)\n```\n\n该查询列出在description中出现了\"Apache\"的记录，以相关性从高到底的顺序排序。(其中\"2\"由于长度过短,因此被忽略了).\n\n\n\n当`MATCH()`用于`WHERE`子句时，相关性按照返回的记录与搜索的字符串的匹配程度来定义。\n\n<u>MATCH和AGAINST函数也可以放在查询体中,返回匹配记录的加权列表,分数越高,相关性就越大</u>.\n\n\n\n### 2 索引的创建方式\n\n创建索引的方式有两种: \n\n- **alter table**\n- **create table**\n\n\n\n#### 2.1 alter table方式创建索引\n\n```mysql\n# 添加主键索引\nalter table `table_name` add primary key(`column`)\n# 添加唯一索引\nalter table `table_name` add unique key (`column`)\n# 添加普通单列索引\nalter table `table_name` add key index_name (`column`)\n# 添加普通联合索引\nalter table `table_name` add key index_name(`column1`, `column2`,...)\n# 添加全文索引\nalter table `table_name` add fulltext (`column`)\n```\n\n\n\n#### 2.2 create table方式创建索引\n\n见本文第一小结.\n\n\n\n### 3 索引的触发\n\nMysql只会对`<、<=、 =、 >=、 >、 between、in`以及`不以通配符%和_开头的like`有效。\n\n\n\n示例：\n\n```mysql\n# 不会用到索引\nselect * from bookmarks where description like '%The';\n# 会用到索引\nselect * from bookmarks where description like 'The%';\n```\n\n\n\n### 4 索引的优缺点\n\n**优点**：提高查询的效率.\n\n**缺点**：\n\n- 降低更新表的速度，比如对表进行INSERT， UPDATE，DELETE。因为在更新表时，MYSQL不仅要保存数据。还要保存一些索引文件。\n- 建立索引会占用磁盘空间，若在一个很大的表上创建了多种组合的索引，索引文件将膨胀得很快。\n\n\n\n### 5 按物理存储角度分类\n\n从物理存储角度划分,索引可以分为：\n\n- 聚簇索引\n- 非聚簇索引\n\n\n\n### 6 按数据结构的角度划分\n\n从数据结构角度划分,索引可分为以下几种：\n\n- B+树索引\n- Hash索引\n- Fulltext索引\n- R-Tree索引\n\n可参考另一片笔记:[【索引】高性能MySQL_第三版-创建高性能索引.note](note://2FB3314BE14A4D2CACB7FB44F8B07C31)\n\n\n\n------\n\n### 参考资料\n\nPHP与MySQL程序设计 第四版 P532\n\n[MYSQL的索引类型：PRIMARY, INDEX,UNIQUE,FULLTEXT,SPAIAL 有什么区别？各适用于什么场合？](https://blog.csdn.net/u014745069/article/details/80466917)\n\n[面试官:谈谈你对mysql索引的认识？](https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=2247484720&idx=1&sn=7bd7774058e7886eeb3dedb38aa8657a&chksm=96f66759a181ee4f4c177a755c3ac6b6e97fef148bbf4afea8616f4edec33bf6d4f18cda9f69&scene=21#wechat_redirect)           \n\n","source":"_posts/MySQL-索引分类.md","raw":"---\ntitle: MySQL-索引分类\ndate: 2020-09-06 01:04:57\ntags: [\"MySQL\",\"索引\"]\ncategories: [\"MySQL\"]\n---\n\n### 1 从逻辑角度划分类\n\n索引本质上是表字段的有序子集，其每个记录项指向相应的表记录。MySQL共有4类索引：\n\n<!--more-->\n\n- 主键索引\n- 唯一索引\n- 常规索引\n- 全文索引\n\n\n\n#### 1.1 主键索引\n\n`主键索引用于根据主键自身的唯一性来唯一标识每条记录。`因此，该键必须是该记录所表示实体唯一拥有的值，或者是数据库生成的唯一值，例如，自增整数。\n\n\n\n示例: 设置id作为自增主键索引.\n\n```mysql\ncreate table `bookmarks` (\n    `id` int unsigned not null auto_increment comment '主键id',\n    `name` varchar(75) not null default '' comment '名称',\n    `url` varchar(200) not null default '' comment 'URL',\n    `description` mediumtext not null comment '描述',\n    primary key(`id`)\n) engine=InnoDB default charset=utf8mb4 comment='书签表';\n```\n\n注：<u>每个表只能有一个自增字段,且该字段必须为主键,为主键的字段不能包含null值,即使没有显式申明为not null, MySQL也会自动赋予此特性.</u>\n\n\n\n#### 1.2 唯一索引\n\n与主键索引一样，唯一索引可以预防哪个创建重复的值。但是，<u>与之不同之处在于每个表只能有一个主键索引,但可以有多个唯一索引.可以为null值.</u>\n\n\n\n示例:设置name和url作为唯一联合索引\n\n```mysql\ncreate table `bookmarks_v1` (\n    `id` int unsigned not null auto_increment comment '主键id',\n    `name` varchar(75) not null default '' comment '名称',\n    `url` varchar(200) not null default '' comment 'URL',\n    `description` mediumtext not null comment '描述',\n    primary key (`id`),\n    unique key `name_url` (`name`,`url`)\n) engine=InnoDB default charset=utf8mb4 comment='书签表';\n```\n\n\n\n#### 1.3 普通索引\n\n普通索引可以分为`单列普通索引`和`联合普通索引`.\n\n##### 1.3.1 单列普通索引\n\n若表中的某个列将成为大量选择查询的焦点，就应当使用单列普通索引。\n\n示例：设置email为唯一索引，姓氏为单例普通索引。\n\n```mysql\ncreate table employees(\n    `id` int unsigned not null auto_increment comment '主键id',\n    `firstname` varchar(100) not null default '' comment '名称',\n    `lastname` varchar(100) not null default '' comment '姓氏',\n    `email` varchar(100) not null default '' comment '电子邮箱',\n    primary key (`id`),\n    unique key `idx_email` (`email`),\n    key `idx_lastname` (`lastname`)\n) engine=InnoDB default charset=utf8mb4 comment='员工信息表';\n```\n\n##### 1.3.2 多列普通索引(联合索引)\n\n若在查询中，经常会使用多列一起使用，则可使用联合索引，MySQL的联合索引方法基于最左前缀的策略.\n\n\n\n假设为列A、B、C添加联合索引，则使用下列组合可以提高涉及的查询性能：\n\n```\nA,B,C\nA,B\nA\n```\n\n\n\n示例:\n\n```mysql\ncreate table employees_v1(\n    `id` int unsigned not null auto_increment comment '主键id',\n    `firstname` varchar(100) not null default '' comment '名称',\n    `lastname` varchar(100) not null default '' comment '姓氏',\n    `email` varchar(100) not null default '' comment '电子邮箱',\n    primary key (`id`),\n    unique key `idx_email` (`email`),\n    key `idx_lastname_firstname` (`lastname`, `firstname`)\n) engine=InnoDB default charset=utf8mb4 comment='员工信息表';\n```\n\n\n\n#### 1.4 全文索引\n\n全文索引提供了一种高效的方法来搜索存储为`char`，`varchar`或者`text`数据类型的文本。\n\n\n\n示例：在`description`字段上添加全文索引。\n\n```mysql\ncreate table `bookmarks_v2` (\n    `id` int unsigned not null auto_increment comment '主键id',\n    `name` varchar(75) not null default '' comment '名称',\n    `url` varchar(200) not null default '' comment 'URL',\n    `description` mediumtext not null comment '描述',\n    primary key(`id`),\n    fulltext key `idx_description`(`description`)\n) engine=InnoDB default charset=utf8mb4 comment='书签表';\n```\n\n基于全文索引获取数据时，select查询使用两个特殊的MySQL函数`MATCH()`和`AGAINST()`。利用这两个函数，可以针对全文索引执行自然语言搜索，如下所示：\n\n- 添加数据\n\n\n```mysql\ninsert into bookmarks_v2 (name,url,description) \n    values \n    (\"Python\", \"www.python.org\", \"The official Python Web site\"),\n    (\"MySQL manuel\", \"http://dev.mysql.com/doc\", \"The MySQL reference manual\"),\n    (\"Apache site\", \"http://httpd.apache.org\", \"Includes Apache 2 manual\"),\n    (\"PHP Hypertext\", \"www.php.net\", \"The official PHP Web site\"),\n    (\"Apache Week\", \"www.apacheweek.com\", \"Offers a dedicated Apache 2 section\");\n```\n\n\n\n- 根据全文索引查询\n\n```mysql\nmysql> select name,url FROM bookmarks_v2 where match(description) against('Apache 2');\n+-------------+-------------------------+\n| name        | url                     |\n+-------------+-------------------------+\n| Apache site | http://httpd.apache.org |\n| Apache Week | www.apacheweek.com      |\n+-------------+-------------------------+\n2 rows in set (0.07 sec)\n\nmysql> select match(description) against('Apache 2') from bookmarks_v2;\n+----------------------------------------+\n| match(description) against('Apache 2') |\n+----------------------------------------+\n|                                      0 |\n|                                      0 |\n|                    0.15835624933242798 |\n|                                      0 |\n|                    0.15835624933242798 |\n+----------------------------------------+\n5 rows in set (0.05 sec)\n```\n\n该查询列出在description中出现了\"Apache\"的记录，以相关性从高到底的顺序排序。(其中\"2\"由于长度过短,因此被忽略了).\n\n\n\n当`MATCH()`用于`WHERE`子句时，相关性按照返回的记录与搜索的字符串的匹配程度来定义。\n\n<u>MATCH和AGAINST函数也可以放在查询体中,返回匹配记录的加权列表,分数越高,相关性就越大</u>.\n\n\n\n### 2 索引的创建方式\n\n创建索引的方式有两种: \n\n- **alter table**\n- **create table**\n\n\n\n#### 2.1 alter table方式创建索引\n\n```mysql\n# 添加主键索引\nalter table `table_name` add primary key(`column`)\n# 添加唯一索引\nalter table `table_name` add unique key (`column`)\n# 添加普通单列索引\nalter table `table_name` add key index_name (`column`)\n# 添加普通联合索引\nalter table `table_name` add key index_name(`column1`, `column2`,...)\n# 添加全文索引\nalter table `table_name` add fulltext (`column`)\n```\n\n\n\n#### 2.2 create table方式创建索引\n\n见本文第一小结.\n\n\n\n### 3 索引的触发\n\nMysql只会对`<、<=、 =、 >=、 >、 between、in`以及`不以通配符%和_开头的like`有效。\n\n\n\n示例：\n\n```mysql\n# 不会用到索引\nselect * from bookmarks where description like '%The';\n# 会用到索引\nselect * from bookmarks where description like 'The%';\n```\n\n\n\n### 4 索引的优缺点\n\n**优点**：提高查询的效率.\n\n**缺点**：\n\n- 降低更新表的速度，比如对表进行INSERT， UPDATE，DELETE。因为在更新表时，MYSQL不仅要保存数据。还要保存一些索引文件。\n- 建立索引会占用磁盘空间，若在一个很大的表上创建了多种组合的索引，索引文件将膨胀得很快。\n\n\n\n### 5 按物理存储角度分类\n\n从物理存储角度划分,索引可以分为：\n\n- 聚簇索引\n- 非聚簇索引\n\n\n\n### 6 按数据结构的角度划分\n\n从数据结构角度划分,索引可分为以下几种：\n\n- B+树索引\n- Hash索引\n- Fulltext索引\n- R-Tree索引\n\n可参考另一片笔记:[【索引】高性能MySQL_第三版-创建高性能索引.note](note://2FB3314BE14A4D2CACB7FB44F8B07C31)\n\n\n\n------\n\n### 参考资料\n\nPHP与MySQL程序设计 第四版 P532\n\n[MYSQL的索引类型：PRIMARY, INDEX,UNIQUE,FULLTEXT,SPAIAL 有什么区别？各适用于什么场合？](https://blog.csdn.net/u014745069/article/details/80466917)\n\n[面试官:谈谈你对mysql索引的认识？](https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=2247484720&idx=1&sn=7bd7774058e7886eeb3dedb38aa8657a&chksm=96f66759a181ee4f4c177a755c3ac6b6e97fef148bbf4afea8616f4edec33bf6d4f18cda9f69&scene=21#wechat_redirect)           \n\n","slug":"MySQL-索引分类","published":1,"updated":"2020-09-24T10:19:07.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkl002145g3cgjkcsyb","content":"<h3 id=\"1-从逻辑角度划分类\"><a href=\"#1-从逻辑角度划分类\" class=\"headerlink\" title=\"1 从逻辑角度划分类\"></a>1 从逻辑角度划分类</h3><p>索引本质上是表字段的有序子集，其每个记录项指向相应的表记录。MySQL共有4类索引：</p>\n<a id=\"more\"></a>\n\n<ul>\n<li>主键索引</li>\n<li>唯一索引</li>\n<li>常规索引</li>\n<li>全文索引</li>\n</ul>\n<h4 id=\"1-1-主键索引\"><a href=\"#1-1-主键索引\" class=\"headerlink\" title=\"1.1 主键索引\"></a>1.1 主键索引</h4><p><code>主键索引用于根据主键自身的唯一性来唯一标识每条记录。</code>因此，该键必须是该记录所表示实体唯一拥有的值，或者是数据库生成的唯一值，例如，自增整数。</p>\n<p>示例: 设置id作为自增主键索引.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table &#96;bookmarks&#96; (</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;name&#96; varchar(75) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;url&#96; varchar(200) not null default &#39;&#39; comment &#39;URL&#39;,</span><br><span class=\"line\">    &#96;description&#96; mediumtext not null comment &#39;描述&#39;,</span><br><span class=\"line\">    primary key(&#96;id&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;书签表&#39;;</span><br></pre></td></tr></table></figure>\n\n<p>注：<u>每个表只能有一个自增字段,且该字段必须为主键,为主键的字段不能包含null值,即使没有显式申明为not null, MySQL也会自动赋予此特性.</u></p>\n<h4 id=\"1-2-唯一索引\"><a href=\"#1-2-唯一索引\" class=\"headerlink\" title=\"1.2 唯一索引\"></a>1.2 唯一索引</h4><p>与主键索引一样，唯一索引可以预防哪个创建重复的值。但是，<u>与之不同之处在于每个表只能有一个主键索引,但可以有多个唯一索引.可以为null值.</u></p>\n<p>示例:设置name和url作为唯一联合索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table &#96;bookmarks_v1&#96; (</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;name&#96; varchar(75) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;url&#96; varchar(200) not null default &#39;&#39; comment &#39;URL&#39;,</span><br><span class=\"line\">    &#96;description&#96; mediumtext not null comment &#39;描述&#39;,</span><br><span class=\"line\">    primary key (&#96;id&#96;),</span><br><span class=\"line\">    unique key &#96;name_url&#96; (&#96;name&#96;,&#96;url&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;书签表&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-3-普通索引\"><a href=\"#1-3-普通索引\" class=\"headerlink\" title=\"1.3 普通索引\"></a>1.3 普通索引</h4><p>普通索引可以分为<code>单列普通索引</code>和<code>联合普通索引</code>.</p>\n<h5 id=\"1-3-1-单列普通索引\"><a href=\"#1-3-1-单列普通索引\" class=\"headerlink\" title=\"1.3.1 单列普通索引\"></a>1.3.1 单列普通索引</h5><p>若表中的某个列将成为大量选择查询的焦点，就应当使用单列普通索引。</p>\n<p>示例：设置email为唯一索引，姓氏为单例普通索引。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table employees(</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;firstname&#96; varchar(100) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;lastname&#96; varchar(100) not null default &#39;&#39; comment &#39;姓氏&#39;,</span><br><span class=\"line\">    &#96;email&#96; varchar(100) not null default &#39;&#39; comment &#39;电子邮箱&#39;,</span><br><span class=\"line\">    primary key (&#96;id&#96;),</span><br><span class=\"line\">    unique key &#96;idx_email&#96; (&#96;email&#96;),</span><br><span class=\"line\">    key &#96;idx_lastname&#96; (&#96;lastname&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;员工信息表&#39;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-3-2-多列普通索引-联合索引\"><a href=\"#1-3-2-多列普通索引-联合索引\" class=\"headerlink\" title=\"1.3.2 多列普通索引(联合索引)\"></a>1.3.2 多列普通索引(联合索引)</h5><p>若在查询中，经常会使用多列一起使用，则可使用联合索引，MySQL的联合索引方法基于最左前缀的策略.</p>\n<p>假设为列A、B、C添加联合索引，则使用下列组合可以提高涉及的查询性能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A,B,C</span><br><span class=\"line\">A,B</span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table employees_v1(</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;firstname&#96; varchar(100) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;lastname&#96; varchar(100) not null default &#39;&#39; comment &#39;姓氏&#39;,</span><br><span class=\"line\">    &#96;email&#96; varchar(100) not null default &#39;&#39; comment &#39;电子邮箱&#39;,</span><br><span class=\"line\">    primary key (&#96;id&#96;),</span><br><span class=\"line\">    unique key &#96;idx_email&#96; (&#96;email&#96;),</span><br><span class=\"line\">    key &#96;idx_lastname_firstname&#96; (&#96;lastname&#96;, &#96;firstname&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;员工信息表&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-4-全文索引\"><a href=\"#1-4-全文索引\" class=\"headerlink\" title=\"1.4 全文索引\"></a>1.4 全文索引</h4><p>全文索引提供了一种高效的方法来搜索存储为<code>char</code>，<code>varchar</code>或者<code>text</code>数据类型的文本。</p>\n<p>示例：在<code>description</code>字段上添加全文索引。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table &#96;bookmarks_v2&#96; (</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;name&#96; varchar(75) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;url&#96; varchar(200) not null default &#39;&#39; comment &#39;URL&#39;,</span><br><span class=\"line\">    &#96;description&#96; mediumtext not null comment &#39;描述&#39;,</span><br><span class=\"line\">    primary key(&#96;id&#96;),</span><br><span class=\"line\">    fulltext key &#96;idx_description&#96;(&#96;description&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;书签表&#39;;</span><br></pre></td></tr></table></figure>\n\n<p>基于全文索引获取数据时，select查询使用两个特殊的MySQL函数<code>MATCH()</code>和<code>AGAINST()</code>。利用这两个函数，可以针对全文索引执行自然语言搜索，如下所示：</p>\n<ul>\n<li>添加数据</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into bookmarks_v2 (name,url,description) </span><br><span class=\"line\">    values </span><br><span class=\"line\">    (&quot;Python&quot;, &quot;www.python.org&quot;, &quot;The official Python Web site&quot;),</span><br><span class=\"line\">    (&quot;MySQL manuel&quot;, &quot;http:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&quot;, &quot;The MySQL reference manual&quot;),</span><br><span class=\"line\">    (&quot;Apache site&quot;, &quot;http:&#x2F;&#x2F;httpd.apache.org&quot;, &quot;Includes Apache 2 manual&quot;),</span><br><span class=\"line\">    (&quot;PHP Hypertext&quot;, &quot;www.php.net&quot;, &quot;The official PHP Web site&quot;),</span><br><span class=\"line\">    (&quot;Apache Week&quot;, &quot;www.apacheweek.com&quot;, &quot;Offers a dedicated Apache 2 section&quot;);</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>根据全文索引查询</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select name,url FROM bookmarks_v2 where match(description) against(&#39;Apache 2&#39;);</span><br><span class=\"line\">+-------------+-------------------------+</span><br><span class=\"line\">| name        | url                     |</span><br><span class=\"line\">+-------------+-------------------------+</span><br><span class=\"line\">| Apache site | http:&#x2F;&#x2F;httpd.apache.org |</span><br><span class=\"line\">| Apache Week | www.apacheweek.com      |</span><br><span class=\"line\">+-------------+-------------------------+</span><br><span class=\"line\">2 rows in set (0.07 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select match(description) against(&#39;Apache 2&#39;) from bookmarks_v2;</span><br><span class=\"line\">+----------------------------------------+</span><br><span class=\"line\">| match(description) against(&#39;Apache 2&#39;) |</span><br><span class=\"line\">+----------------------------------------+</span><br><span class=\"line\">|                                      0 |</span><br><span class=\"line\">|                                      0 |</span><br><span class=\"line\">|                    0.15835624933242798 |</span><br><span class=\"line\">|                                      0 |</span><br><span class=\"line\">|                    0.15835624933242798 |</span><br><span class=\"line\">+----------------------------------------+</span><br><span class=\"line\">5 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure>\n\n<p>该查询列出在description中出现了”Apache”的记录，以相关性从高到底的顺序排序。(其中”2”由于长度过短,因此被忽略了).</p>\n<p>当<code>MATCH()</code>用于<code>WHERE</code>子句时，相关性按照返回的记录与搜索的字符串的匹配程度来定义。</p>\n<p><u>MATCH和AGAINST函数也可以放在查询体中,返回匹配记录的加权列表,分数越高,相关性就越大</u>.</p>\n<h3 id=\"2-索引的创建方式\"><a href=\"#2-索引的创建方式\" class=\"headerlink\" title=\"2 索引的创建方式\"></a>2 索引的创建方式</h3><p>创建索引的方式有两种: </p>\n<ul>\n<li><strong>alter table</strong></li>\n<li><strong>create table</strong></li>\n</ul>\n<h4 id=\"2-1-alter-table方式创建索引\"><a href=\"#2-1-alter-table方式创建索引\" class=\"headerlink\" title=\"2.1 alter table方式创建索引\"></a>2.1 alter table方式创建索引</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 添加主键索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add primary key(&#96;column&#96;)</span><br><span class=\"line\"># 添加唯一索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add unique key (&#96;column&#96;)</span><br><span class=\"line\"># 添加普通单列索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add key index_name (&#96;column&#96;)</span><br><span class=\"line\"># 添加普通联合索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add key index_name(&#96;column1&#96;, &#96;column2&#96;,...)</span><br><span class=\"line\"># 添加全文索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add fulltext (&#96;column&#96;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-create-table方式创建索引\"><a href=\"#2-2-create-table方式创建索引\" class=\"headerlink\" title=\"2.2 create table方式创建索引\"></a>2.2 create table方式创建索引</h4><p>见本文第一小结.</p>\n<h3 id=\"3-索引的触发\"><a href=\"#3-索引的触发\" class=\"headerlink\" title=\"3 索引的触发\"></a>3 索引的触发</h3><p>Mysql只会对<code>&lt;、&lt;=、 =、 &gt;=、 &gt;、 between、in</code>以及<code>不以通配符%和_开头的like</code>有效。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 不会用到索引</span><br><span class=\"line\">select * from bookmarks where description like &#39;%The&#39;;</span><br><span class=\"line\"># 会用到索引</span><br><span class=\"line\">select * from bookmarks where description like &#39;The%&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-索引的优缺点\"><a href=\"#4-索引的优缺点\" class=\"headerlink\" title=\"4 索引的优缺点\"></a>4 索引的优缺点</h3><p><strong>优点</strong>：提高查询的效率.</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>降低更新表的速度，比如对表进行INSERT， UPDATE，DELETE。因为在更新表时，MYSQL不仅要保存数据。还要保存一些索引文件。</li>\n<li>建立索引会占用磁盘空间，若在一个很大的表上创建了多种组合的索引，索引文件将膨胀得很快。</li>\n</ul>\n<h3 id=\"5-按物理存储角度分类\"><a href=\"#5-按物理存储角度分类\" class=\"headerlink\" title=\"5 按物理存储角度分类\"></a>5 按物理存储角度分类</h3><p>从物理存储角度划分,索引可以分为：</p>\n<ul>\n<li>聚簇索引</li>\n<li>非聚簇索引</li>\n</ul>\n<h3 id=\"6-按数据结构的角度划分\"><a href=\"#6-按数据结构的角度划分\" class=\"headerlink\" title=\"6 按数据结构的角度划分\"></a>6 按数据结构的角度划分</h3><p>从数据结构角度划分,索引可分为以下几种：</p>\n<ul>\n<li>B+树索引</li>\n<li>Hash索引</li>\n<li>Fulltext索引</li>\n<li>R-Tree索引</li>\n</ul>\n<p>可参考另一片笔记:<a href=\"note://2FB3314BE14A4D2CACB7FB44F8B07C31\">【索引】高性能MySQL_第三版-创建高性能索引.note</a></p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>PHP与MySQL程序设计 第四版 P532</p>\n<p><a href=\"https://blog.csdn.net/u014745069/article/details/80466917\">MYSQL的索引类型：PRIMARY, INDEX,UNIQUE,FULLTEXT,SPAIAL 有什么区别？各适用于什么场合？</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=2247484720&idx=1&sn=7bd7774058e7886eeb3dedb38aa8657a&chksm=96f66759a181ee4f4c177a755c3ac6b6e97fef148bbf4afea8616f4edec33bf6d4f18cda9f69&scene=21#wechat_redirect\">面试官:谈谈你对mysql索引的认识？</a>           </p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-从逻辑角度划分类\"><a href=\"#1-从逻辑角度划分类\" class=\"headerlink\" title=\"1 从逻辑角度划分类\"></a>1 从逻辑角度划分类</h3><p>索引本质上是表字段的有序子集，其每个记录项指向相应的表记录。MySQL共有4类索引：</p>","more":"<ul>\n<li>主键索引</li>\n<li>唯一索引</li>\n<li>常规索引</li>\n<li>全文索引</li>\n</ul>\n<h4 id=\"1-1-主键索引\"><a href=\"#1-1-主键索引\" class=\"headerlink\" title=\"1.1 主键索引\"></a>1.1 主键索引</h4><p><code>主键索引用于根据主键自身的唯一性来唯一标识每条记录。</code>因此，该键必须是该记录所表示实体唯一拥有的值，或者是数据库生成的唯一值，例如，自增整数。</p>\n<p>示例: 设置id作为自增主键索引.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table &#96;bookmarks&#96; (</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;name&#96; varchar(75) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;url&#96; varchar(200) not null default &#39;&#39; comment &#39;URL&#39;,</span><br><span class=\"line\">    &#96;description&#96; mediumtext not null comment &#39;描述&#39;,</span><br><span class=\"line\">    primary key(&#96;id&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;书签表&#39;;</span><br></pre></td></tr></table></figure>\n\n<p>注：<u>每个表只能有一个自增字段,且该字段必须为主键,为主键的字段不能包含null值,即使没有显式申明为not null, MySQL也会自动赋予此特性.</u></p>\n<h4 id=\"1-2-唯一索引\"><a href=\"#1-2-唯一索引\" class=\"headerlink\" title=\"1.2 唯一索引\"></a>1.2 唯一索引</h4><p>与主键索引一样，唯一索引可以预防哪个创建重复的值。但是，<u>与之不同之处在于每个表只能有一个主键索引,但可以有多个唯一索引.可以为null值.</u></p>\n<p>示例:设置name和url作为唯一联合索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table &#96;bookmarks_v1&#96; (</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;name&#96; varchar(75) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;url&#96; varchar(200) not null default &#39;&#39; comment &#39;URL&#39;,</span><br><span class=\"line\">    &#96;description&#96; mediumtext not null comment &#39;描述&#39;,</span><br><span class=\"line\">    primary key (&#96;id&#96;),</span><br><span class=\"line\">    unique key &#96;name_url&#96; (&#96;name&#96;,&#96;url&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;书签表&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-3-普通索引\"><a href=\"#1-3-普通索引\" class=\"headerlink\" title=\"1.3 普通索引\"></a>1.3 普通索引</h4><p>普通索引可以分为<code>单列普通索引</code>和<code>联合普通索引</code>.</p>\n<h5 id=\"1-3-1-单列普通索引\"><a href=\"#1-3-1-单列普通索引\" class=\"headerlink\" title=\"1.3.1 单列普通索引\"></a>1.3.1 单列普通索引</h5><p>若表中的某个列将成为大量选择查询的焦点，就应当使用单列普通索引。</p>\n<p>示例：设置email为唯一索引，姓氏为单例普通索引。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table employees(</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;firstname&#96; varchar(100) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;lastname&#96; varchar(100) not null default &#39;&#39; comment &#39;姓氏&#39;,</span><br><span class=\"line\">    &#96;email&#96; varchar(100) not null default &#39;&#39; comment &#39;电子邮箱&#39;,</span><br><span class=\"line\">    primary key (&#96;id&#96;),</span><br><span class=\"line\">    unique key &#96;idx_email&#96; (&#96;email&#96;),</span><br><span class=\"line\">    key &#96;idx_lastname&#96; (&#96;lastname&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;员工信息表&#39;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-3-2-多列普通索引-联合索引\"><a href=\"#1-3-2-多列普通索引-联合索引\" class=\"headerlink\" title=\"1.3.2 多列普通索引(联合索引)\"></a>1.3.2 多列普通索引(联合索引)</h5><p>若在查询中，经常会使用多列一起使用，则可使用联合索引，MySQL的联合索引方法基于最左前缀的策略.</p>\n<p>假设为列A、B、C添加联合索引，则使用下列组合可以提高涉及的查询性能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A,B,C</span><br><span class=\"line\">A,B</span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table employees_v1(</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;firstname&#96; varchar(100) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;lastname&#96; varchar(100) not null default &#39;&#39; comment &#39;姓氏&#39;,</span><br><span class=\"line\">    &#96;email&#96; varchar(100) not null default &#39;&#39; comment &#39;电子邮箱&#39;,</span><br><span class=\"line\">    primary key (&#96;id&#96;),</span><br><span class=\"line\">    unique key &#96;idx_email&#96; (&#96;email&#96;),</span><br><span class=\"line\">    key &#96;idx_lastname_firstname&#96; (&#96;lastname&#96;, &#96;firstname&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;员工信息表&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-4-全文索引\"><a href=\"#1-4-全文索引\" class=\"headerlink\" title=\"1.4 全文索引\"></a>1.4 全文索引</h4><p>全文索引提供了一种高效的方法来搜索存储为<code>char</code>，<code>varchar</code>或者<code>text</code>数据类型的文本。</p>\n<p>示例：在<code>description</code>字段上添加全文索引。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table &#96;bookmarks_v2&#96; (</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;name&#96; varchar(75) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;url&#96; varchar(200) not null default &#39;&#39; comment &#39;URL&#39;,</span><br><span class=\"line\">    &#96;description&#96; mediumtext not null comment &#39;描述&#39;,</span><br><span class=\"line\">    primary key(&#96;id&#96;),</span><br><span class=\"line\">    fulltext key &#96;idx_description&#96;(&#96;description&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;书签表&#39;;</span><br></pre></td></tr></table></figure>\n\n<p>基于全文索引获取数据时，select查询使用两个特殊的MySQL函数<code>MATCH()</code>和<code>AGAINST()</code>。利用这两个函数，可以针对全文索引执行自然语言搜索，如下所示：</p>\n<ul>\n<li>添加数据</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into bookmarks_v2 (name,url,description) </span><br><span class=\"line\">    values </span><br><span class=\"line\">    (&quot;Python&quot;, &quot;www.python.org&quot;, &quot;The official Python Web site&quot;),</span><br><span class=\"line\">    (&quot;MySQL manuel&quot;, &quot;http:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&quot;, &quot;The MySQL reference manual&quot;),</span><br><span class=\"line\">    (&quot;Apache site&quot;, &quot;http:&#x2F;&#x2F;httpd.apache.org&quot;, &quot;Includes Apache 2 manual&quot;),</span><br><span class=\"line\">    (&quot;PHP Hypertext&quot;, &quot;www.php.net&quot;, &quot;The official PHP Web site&quot;),</span><br><span class=\"line\">    (&quot;Apache Week&quot;, &quot;www.apacheweek.com&quot;, &quot;Offers a dedicated Apache 2 section&quot;);</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>根据全文索引查询</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select name,url FROM bookmarks_v2 where match(description) against(&#39;Apache 2&#39;);</span><br><span class=\"line\">+-------------+-------------------------+</span><br><span class=\"line\">| name        | url                     |</span><br><span class=\"line\">+-------------+-------------------------+</span><br><span class=\"line\">| Apache site | http:&#x2F;&#x2F;httpd.apache.org |</span><br><span class=\"line\">| Apache Week | www.apacheweek.com      |</span><br><span class=\"line\">+-------------+-------------------------+</span><br><span class=\"line\">2 rows in set (0.07 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select match(description) against(&#39;Apache 2&#39;) from bookmarks_v2;</span><br><span class=\"line\">+----------------------------------------+</span><br><span class=\"line\">| match(description) against(&#39;Apache 2&#39;) |</span><br><span class=\"line\">+----------------------------------------+</span><br><span class=\"line\">|                                      0 |</span><br><span class=\"line\">|                                      0 |</span><br><span class=\"line\">|                    0.15835624933242798 |</span><br><span class=\"line\">|                                      0 |</span><br><span class=\"line\">|                    0.15835624933242798 |</span><br><span class=\"line\">+----------------------------------------+</span><br><span class=\"line\">5 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure>\n\n<p>该查询列出在description中出现了”Apache”的记录，以相关性从高到底的顺序排序。(其中”2”由于长度过短,因此被忽略了).</p>\n<p>当<code>MATCH()</code>用于<code>WHERE</code>子句时，相关性按照返回的记录与搜索的字符串的匹配程度来定义。</p>\n<p><u>MATCH和AGAINST函数也可以放在查询体中,返回匹配记录的加权列表,分数越高,相关性就越大</u>.</p>\n<h3 id=\"2-索引的创建方式\"><a href=\"#2-索引的创建方式\" class=\"headerlink\" title=\"2 索引的创建方式\"></a>2 索引的创建方式</h3><p>创建索引的方式有两种: </p>\n<ul>\n<li><strong>alter table</strong></li>\n<li><strong>create table</strong></li>\n</ul>\n<h4 id=\"2-1-alter-table方式创建索引\"><a href=\"#2-1-alter-table方式创建索引\" class=\"headerlink\" title=\"2.1 alter table方式创建索引\"></a>2.1 alter table方式创建索引</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 添加主键索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add primary key(&#96;column&#96;)</span><br><span class=\"line\"># 添加唯一索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add unique key (&#96;column&#96;)</span><br><span class=\"line\"># 添加普通单列索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add key index_name (&#96;column&#96;)</span><br><span class=\"line\"># 添加普通联合索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add key index_name(&#96;column1&#96;, &#96;column2&#96;,...)</span><br><span class=\"line\"># 添加全文索引</span><br><span class=\"line\">alter table &#96;table_name&#96; add fulltext (&#96;column&#96;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-create-table方式创建索引\"><a href=\"#2-2-create-table方式创建索引\" class=\"headerlink\" title=\"2.2 create table方式创建索引\"></a>2.2 create table方式创建索引</h4><p>见本文第一小结.</p>\n<h3 id=\"3-索引的触发\"><a href=\"#3-索引的触发\" class=\"headerlink\" title=\"3 索引的触发\"></a>3 索引的触发</h3><p>Mysql只会对<code>&lt;、&lt;=、 =、 &gt;=、 &gt;、 between、in</code>以及<code>不以通配符%和_开头的like</code>有效。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 不会用到索引</span><br><span class=\"line\">select * from bookmarks where description like &#39;%The&#39;;</span><br><span class=\"line\"># 会用到索引</span><br><span class=\"line\">select * from bookmarks where description like &#39;The%&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-索引的优缺点\"><a href=\"#4-索引的优缺点\" class=\"headerlink\" title=\"4 索引的优缺点\"></a>4 索引的优缺点</h3><p><strong>优点</strong>：提高查询的效率.</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>降低更新表的速度，比如对表进行INSERT， UPDATE，DELETE。因为在更新表时，MYSQL不仅要保存数据。还要保存一些索引文件。</li>\n<li>建立索引会占用磁盘空间，若在一个很大的表上创建了多种组合的索引，索引文件将膨胀得很快。</li>\n</ul>\n<h3 id=\"5-按物理存储角度分类\"><a href=\"#5-按物理存储角度分类\" class=\"headerlink\" title=\"5 按物理存储角度分类\"></a>5 按物理存储角度分类</h3><p>从物理存储角度划分,索引可以分为：</p>\n<ul>\n<li>聚簇索引</li>\n<li>非聚簇索引</li>\n</ul>\n<h3 id=\"6-按数据结构的角度划分\"><a href=\"#6-按数据结构的角度划分\" class=\"headerlink\" title=\"6 按数据结构的角度划分\"></a>6 按数据结构的角度划分</h3><p>从数据结构角度划分,索引可分为以下几种：</p>\n<ul>\n<li>B+树索引</li>\n<li>Hash索引</li>\n<li>Fulltext索引</li>\n<li>R-Tree索引</li>\n</ul>\n<p>可参考另一片笔记:<a href=\"note://2FB3314BE14A4D2CACB7FB44F8B07C31\">【索引】高性能MySQL_第三版-创建高性能索引.note</a></p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>PHP与MySQL程序设计 第四版 P532</p>\n<p><a href=\"https://blog.csdn.net/u014745069/article/details/80466917\">MYSQL的索引类型：PRIMARY, INDEX,UNIQUE,FULLTEXT,SPAIAL 有什么区别？各适用于什么场合？</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=2247484720&idx=1&sn=7bd7774058e7886eeb3dedb38aa8657a&chksm=96f66759a181ee4f4c177a755c3ac6b6e97fef148bbf4afea8616f4edec33bf6d4f18cda9f69&scene=21#wechat_redirect\">面试官:谈谈你对mysql索引的认识？</a>           </p>"},{"title":"MySQL-脏读,不可重复读,幻读","date":"2020-09-14T09:05:55.000Z","_content":"\n\n\n### 1 概述\n\n通过锁机制可以实现事务的隔离性要求，使得事务可以并发的工作．锁提高了并发，却会带来潜在问题呢，例如脏读，幻读等．\n\n<!--more-->\n\n后续示例均在以下user表的基础上进行操作．\n\n```mysql\n# 1.　表信息．\nCREATE TABLE `users` (\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',\n  `user_name` varchar(10) NOT NULL DEFAULT '' COMMENT '用户名',\n  `age` tinyint(2) NOT NULL DEFAULT '0' COMMENT '年龄',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COMMENT='用户信息'\n\n\n# 2. 准备测试数据．\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  6 | Gordon    |  20 |\n| 11 | Natasha   |  23 |\n| 12 | sam       |  28 |\n+----+-----------+-----+\n```\n\n\n\n### 2 脏读\n\n脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据．\n\n`脏读发生的条件`：事务的隔离级别为READ UNCOMMITTED．\n\n`脏读的适用场景`：在一些特殊特殊情况下，可以将事务的隔离级别设置为READ UNCOMMITTED，例如replication环境中的slave节点，并在该slave上的查询并不需要特别精确的返回值．\n\n\n\n示例：\n\n```mysql\nA: set session transaction isolation level read uncommitted;\nA: begin\nA: select * from users where id>11;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n| 12 | sam       |  28 |\n+----+-----------+-----+\n1 row in set (0.01 sec)\n\tB: set session transaction isolation level read uncommitted;\n\tB: begin\n\tB: insert into users(user_name,age)values('Jovry-Lee',18); # 未提交．\nA: select * from users where id > 11; # 此时事务Ａ读取到事务Ｂ尚未提交的数据，属于脏读．\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n| 12 | sam       |  28 |\n| 13 | Jovry-Lee |  18 |\n+----+-----------+-----+\n2 rows in set (0.00 sec)\n```\n\n\n\n\n\n### 3 不可重复读\n\nSQL92中对不可重复读的定义如下：\n\n> **不可重复读(nonrepeatable read)**：SQL-transaction T1 reads a row. SQL-transaction T2 then modifies or deletes that row and performs a COMMIT. If T1 then attempts to reread the row, it may receive the modified value or discover that the row has been deleted.\n\n即，**不可重复读**是指在一个事务中多次读取同一数据行，在这个事务还没结束时，另一个事务也访问了该数据行，并做了DML操作，导致第一个事务多次读取到的数据不一样．\n\n（注：<u>不可重复读是针对单行数据</u>）\n\n\n\n`不可重复读允许发生的隔离级别`：READ COMMITTED\n\n\n\n示例：\n\n```mysql\nA: set session transaction isolation level read committed;\nA: begin\nA: select * from users where id>11;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n| 12 | sam       |  28 |\n+----+-----------+-----+\n1 row in set (0.01 sec)\n\tB: set session transaction isolation level read committed;\n\tB: begin\n\tB: insert into users(user_name,age)values('Jovry-Lee',18);\n\tB: commit;\nA: select * from users where id > 11; # 此时事务Ａ两次读取到不同的结果，属于不可重复读．\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n| 12 | sam       |  28 |\n| 13 | Jovry-Lee |  18 |\n+----+-----------+-----+\n2 rows in set (0.00 sec)\n```\n\n\n\n`脏读与不可重复读的区别`：脏读时读到未提交的数据，而不可重复读独到的是已经提交的数据，但时其违反了数据库事务一致性要求．\n\n一般来说不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来太大的问题．因此，很多数据库的默认隔离级别是`READ COMMITTED`，如：Ｏracle, SQL Server.\n\n\n\nMySQL官方文档中`将不可重复读的问题定义为Phantom Problem，即幻象问题`．InnoDB存储引擎的默认事务隔离级别READ REPEATABLE采用<u>Next-Key Lock算法</u>，避免了不可重复读．\n\n\n\n### 4 幻读\n\nSQL92中对幻读的定义如下：\n\n> **幻读(phantom read)**：SQL-transaction T1 reads the set of rows N that satisfy some <search condition>. SQL-transaction T2 then executes SQL-statements that generate one or more rows that satisfy the <search condition> used by SQL-transaction T1. If SQL-transaction T1 then repeats the initial read with the same <search condition>, it obtains a different collection of rows.\n\n即，**幻读**指事务T1根据一定的查询条件读取一定的数据集，在这个事务还没有结束时，另一个事务T2执行SQL生成一条或多条满足事务T1查询条件的数据行．此时事务T1再次进行相同的查询时，其结果包含不同的数据集．\n\n（注：<u>幻读是针对一个结果集，不是单行数据</u>）\n\n\n\n对于MySQL的默认存储引擎InnoDB在RR隔离级别下通过MVCC机制避免了幻读问题．<u>严格的来说是解决了部分幻读的问题</u>[*参考资料2*]\n\n\n\n示例（*针对尚未解决的幻读问题*）：\n\n```mysql\n# 1. 建表\nCREATE TABLE `t` (\n  `a` int(11) NOT NULL,\n  PRIMARY KEY (`a`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n\n# 2. 数据\nmysql> select * from t;\n+----+\n| a  |\n+----+\n|  1 |\n|  2 |\n|  3 |\n+----+\n\n# 3. 按以下顺序分别执行Ａ，Ｂ两个事务．\nA: begin;\nA: select * from t where a>3; # 没有大于３的结果集．\nEmpty set (0.00 sec)\n\tB: insert into t select 4;　# 另一个事务插入了一条满足a>3条件的数据．\n\tQuery OK, 1 row affected (0.02 sec)\n\tRecords: 1  Duplicates: 0  Warnings: 0\nA: insert into t select 4; # 执行插入a=4的数据行．\nERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY'　# 对于事务Ａ在查询到a>3条件下没有结果集，写入一条数据，但是却出现了主键冲突的异常．\n```\n\n\n---\n### 参考资料\n\n1 MySQL技术内幕+InnoDB存储引擎第2版(7.2节)\n2 [搞懂不可重复读和幻读](https://segmentfault.com/a/1190000012669504)","source":"_posts/MySQL-脏读-不可重复读-幻读.md","raw":"---\ntitle: 'MySQL-脏读,不可重复读,幻读'\ndate: 2020-09-14 17:05:55\ntags: [\"MySQL\",\"事务\",\"锁\"]\ncategories: [\"MySQL\"]\n---\n\n\n\n### 1 概述\n\n通过锁机制可以实现事务的隔离性要求，使得事务可以并发的工作．锁提高了并发，却会带来潜在问题呢，例如脏读，幻读等．\n\n<!--more-->\n\n后续示例均在以下user表的基础上进行操作．\n\n```mysql\n# 1.　表信息．\nCREATE TABLE `users` (\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',\n  `user_name` varchar(10) NOT NULL DEFAULT '' COMMENT '用户名',\n  `age` tinyint(2) NOT NULL DEFAULT '0' COMMENT '年龄',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COMMENT='用户信息'\n\n\n# 2. 准备测试数据．\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  6 | Gordon    |  20 |\n| 11 | Natasha   |  23 |\n| 12 | sam       |  28 |\n+----+-----------+-----+\n```\n\n\n\n### 2 脏读\n\n脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据．\n\n`脏读发生的条件`：事务的隔离级别为READ UNCOMMITTED．\n\n`脏读的适用场景`：在一些特殊特殊情况下，可以将事务的隔离级别设置为READ UNCOMMITTED，例如replication环境中的slave节点，并在该slave上的查询并不需要特别精确的返回值．\n\n\n\n示例：\n\n```mysql\nA: set session transaction isolation level read uncommitted;\nA: begin\nA: select * from users where id>11;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n| 12 | sam       |  28 |\n+----+-----------+-----+\n1 row in set (0.01 sec)\n\tB: set session transaction isolation level read uncommitted;\n\tB: begin\n\tB: insert into users(user_name,age)values('Jovry-Lee',18); # 未提交．\nA: select * from users where id > 11; # 此时事务Ａ读取到事务Ｂ尚未提交的数据，属于脏读．\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n| 12 | sam       |  28 |\n| 13 | Jovry-Lee |  18 |\n+----+-----------+-----+\n2 rows in set (0.00 sec)\n```\n\n\n\n\n\n### 3 不可重复读\n\nSQL92中对不可重复读的定义如下：\n\n> **不可重复读(nonrepeatable read)**：SQL-transaction T1 reads a row. SQL-transaction T2 then modifies or deletes that row and performs a COMMIT. If T1 then attempts to reread the row, it may receive the modified value or discover that the row has been deleted.\n\n即，**不可重复读**是指在一个事务中多次读取同一数据行，在这个事务还没结束时，另一个事务也访问了该数据行，并做了DML操作，导致第一个事务多次读取到的数据不一样．\n\n（注：<u>不可重复读是针对单行数据</u>）\n\n\n\n`不可重复读允许发生的隔离级别`：READ COMMITTED\n\n\n\n示例：\n\n```mysql\nA: set session transaction isolation level read committed;\nA: begin\nA: select * from users where id>11;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n| 12 | sam       |  28 |\n+----+-----------+-----+\n1 row in set (0.01 sec)\n\tB: set session transaction isolation level read committed;\n\tB: begin\n\tB: insert into users(user_name,age)values('Jovry-Lee',18);\n\tB: commit;\nA: select * from users where id > 11; # 此时事务Ａ两次读取到不同的结果，属于不可重复读．\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n| 12 | sam       |  28 |\n| 13 | Jovry-Lee |  18 |\n+----+-----------+-----+\n2 rows in set (0.00 sec)\n```\n\n\n\n`脏读与不可重复读的区别`：脏读时读到未提交的数据，而不可重复读独到的是已经提交的数据，但时其违反了数据库事务一致性要求．\n\n一般来说不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来太大的问题．因此，很多数据库的默认隔离级别是`READ COMMITTED`，如：Ｏracle, SQL Server.\n\n\n\nMySQL官方文档中`将不可重复读的问题定义为Phantom Problem，即幻象问题`．InnoDB存储引擎的默认事务隔离级别READ REPEATABLE采用<u>Next-Key Lock算法</u>，避免了不可重复读．\n\n\n\n### 4 幻读\n\nSQL92中对幻读的定义如下：\n\n> **幻读(phantom read)**：SQL-transaction T1 reads the set of rows N that satisfy some <search condition>. SQL-transaction T2 then executes SQL-statements that generate one or more rows that satisfy the <search condition> used by SQL-transaction T1. If SQL-transaction T1 then repeats the initial read with the same <search condition>, it obtains a different collection of rows.\n\n即，**幻读**指事务T1根据一定的查询条件读取一定的数据集，在这个事务还没有结束时，另一个事务T2执行SQL生成一条或多条满足事务T1查询条件的数据行．此时事务T1再次进行相同的查询时，其结果包含不同的数据集．\n\n（注：<u>幻读是针对一个结果集，不是单行数据</u>）\n\n\n\n对于MySQL的默认存储引擎InnoDB在RR隔离级别下通过MVCC机制避免了幻读问题．<u>严格的来说是解决了部分幻读的问题</u>[*参考资料2*]\n\n\n\n示例（*针对尚未解决的幻读问题*）：\n\n```mysql\n# 1. 建表\nCREATE TABLE `t` (\n  `a` int(11) NOT NULL,\n  PRIMARY KEY (`a`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n\n# 2. 数据\nmysql> select * from t;\n+----+\n| a  |\n+----+\n|  1 |\n|  2 |\n|  3 |\n+----+\n\n# 3. 按以下顺序分别执行Ａ，Ｂ两个事务．\nA: begin;\nA: select * from t where a>3; # 没有大于３的结果集．\nEmpty set (0.00 sec)\n\tB: insert into t select 4;　# 另一个事务插入了一条满足a>3条件的数据．\n\tQuery OK, 1 row affected (0.02 sec)\n\tRecords: 1  Duplicates: 0  Warnings: 0\nA: insert into t select 4; # 执行插入a=4的数据行．\nERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY'　# 对于事务Ａ在查询到a>3条件下没有结果集，写入一条数据，但是却出现了主键冲突的异常．\n```\n\n\n---\n### 参考资料\n\n1 MySQL技术内幕+InnoDB存储引擎第2版(7.2节)\n2 [搞懂不可重复读和幻读](https://segmentfault.com/a/1190000012669504)","slug":"MySQL-脏读-不可重复读-幻读","published":1,"updated":"2020-09-24T08:29:00.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkm002545g3gle12rfq","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>通过锁机制可以实现事务的隔离性要求，使得事务可以并发的工作．锁提高了并发，却会带来潜在问题呢，例如脏读，幻读等．</p>\n<a id=\"more\"></a>\n\n<p>后续示例均在以下user表的基础上进行操作．</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1.　表信息．</span><br><span class=\"line\">CREATE TABLE &#96;users&#96; (</span><br><span class=\"line\">  &#96;id&#96; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,</span><br><span class=\"line\">  &#96;user_name&#96; varchar(10) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户名&#39;,</span><br><span class=\"line\">  &#96;age&#96; tinyint(2) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;年龄&#39;,</span><br><span class=\"line\">  PRIMARY KEY (&#96;id&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;13 DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;用户信息&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 准备测试数据．</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">| 11 | Natasha   |  23 |</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">+----+-----------+-----+</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-脏读\"><a href=\"#2-脏读\" class=\"headerlink\" title=\"2 脏读\"></a>2 脏读</h3><p>脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据．</p>\n<p><code>脏读发生的条件</code>：事务的隔离级别为READ UNCOMMITTED．</p>\n<p><code>脏读的适用场景</code>：在一些特殊特殊情况下，可以将事务的隔离级别设置为READ UNCOMMITTED，例如replication环境中的slave节点，并在该slave上的查询并不需要特别精确的返回值．</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: set session transaction isolation level read uncommitted;</span><br><span class=\"line\">A: begin</span><br><span class=\"line\">A: select * from users where id&gt;11;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">1 row in set (0.01 sec)</span><br><span class=\"line\">\tB: set session transaction isolation level read uncommitted;</span><br><span class=\"line\">\tB: begin</span><br><span class=\"line\">\tB: insert into users(user_name,age)values(&#39;Jovry-Lee&#39;,18); # 未提交．</span><br><span class=\"line\">A: select * from users where id &gt; 11; # 此时事务Ａ读取到事务Ｂ尚未提交的数据，属于脏读．</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">| 13 | Jovry-Lee |  18 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"3-不可重复读\"><a href=\"#3-不可重复读\" class=\"headerlink\" title=\"3 不可重复读\"></a>3 不可重复读</h3><p>SQL92中对不可重复读的定义如下：</p>\n<blockquote>\n<p>**不可重复读(nonrepeatable read)**：SQL-transaction T1 reads a row. SQL-transaction T2 then modifies or deletes that row and performs a COMMIT. If T1 then attempts to reread the row, it may receive the modified value or discover that the row has been deleted.</p>\n</blockquote>\n<p>即，<strong>不可重复读</strong>是指在一个事务中多次读取同一数据行，在这个事务还没结束时，另一个事务也访问了该数据行，并做了DML操作，导致第一个事务多次读取到的数据不一样．</p>\n<p>（注：<u>不可重复读是针对单行数据</u>）</p>\n<p><code>不可重复读允许发生的隔离级别</code>：READ COMMITTED</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: set session transaction isolation level read committed;</span><br><span class=\"line\">A: begin</span><br><span class=\"line\">A: select * from users where id&gt;11;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">1 row in set (0.01 sec)</span><br><span class=\"line\">\tB: set session transaction isolation level read committed;</span><br><span class=\"line\">\tB: begin</span><br><span class=\"line\">\tB: insert into users(user_name,age)values(&#39;Jovry-Lee&#39;,18);</span><br><span class=\"line\">\tB: commit;</span><br><span class=\"line\">A: select * from users where id &gt; 11; # 此时事务Ａ两次读取到不同的结果，属于不可重复读．</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">| 13 | Jovry-Lee |  18 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>脏读与不可重复读的区别</code>：脏读时读到未提交的数据，而不可重复读独到的是已经提交的数据，但时其违反了数据库事务一致性要求．</p>\n<p>一般来说不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来太大的问题．因此，很多数据库的默认隔离级别是<code>READ COMMITTED</code>，如：Ｏracle, SQL Server.</p>\n<p>MySQL官方文档中<code>将不可重复读的问题定义为Phantom Problem，即幻象问题</code>．InnoDB存储引擎的默认事务隔离级别READ REPEATABLE采用<u>Next-Key Lock算法</u>，避免了不可重复读．</p>\n<h3 id=\"4-幻读\"><a href=\"#4-幻读\" class=\"headerlink\" title=\"4 幻读\"></a>4 幻读</h3><p>SQL92中对幻读的定义如下：</p>\n<blockquote>\n<p>**幻读(phantom read)**：SQL-transaction T1 reads the set of rows N that satisfy some <search condition>. SQL-transaction T2 then executes SQL-statements that generate one or more rows that satisfy the <search condition> used by SQL-transaction T1. If SQL-transaction T1 then repeats the initial read with the same <search condition>, it obtains a different collection of rows.</p>\n</blockquote>\n<p>即，<strong>幻读</strong>指事务T1根据一定的查询条件读取一定的数据集，在这个事务还没有结束时，另一个事务T2执行SQL生成一条或多条满足事务T1查询条件的数据行．此时事务T1再次进行相同的查询时，其结果包含不同的数据集．</p>\n<p>（注：<u>幻读是针对一个结果集，不是单行数据</u>）</p>\n<p>对于MySQL的默认存储引擎InnoDB在RR隔离级别下通过MVCC机制避免了幻读问题．<u>严格的来说是解决了部分幻读的问题</u>[<em>参考资料2</em>]</p>\n<p>示例（<em>针对尚未解决的幻读问题</em>）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1. 建表</span><br><span class=\"line\">CREATE TABLE &#96;t&#96; (</span><br><span class=\"line\">  &#96;a&#96; int(11) NOT NULL,</span><br><span class=\"line\">  PRIMARY KEY (&#96;a&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 数据</span><br><span class=\"line\">mysql&gt; select * from t;</span><br><span class=\"line\">+----+</span><br><span class=\"line\">| a  |</span><br><span class=\"line\">+----+</span><br><span class=\"line\">|  1 |</span><br><span class=\"line\">|  2 |</span><br><span class=\"line\">|  3 |</span><br><span class=\"line\">+----+</span><br><span class=\"line\"></span><br><span class=\"line\"># 3. 按以下顺序分别执行Ａ，Ｂ两个事务．</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: select * from t where a&gt;3; # 没有大于３的结果集．</span><br><span class=\"line\">Empty set (0.00 sec)</span><br><span class=\"line\">\tB: insert into t select 4;　# 另一个事务插入了一条满足a&gt;3条件的数据．</span><br><span class=\"line\">\tQuery OK, 1 row affected (0.02 sec)</span><br><span class=\"line\">\tRecords: 1  Duplicates: 0  Warnings: 0</span><br><span class=\"line\">A: insert into t select 4; # 执行插入a&#x3D;4的数据行．</span><br><span class=\"line\">ERROR 1062 (23000): Duplicate entry &#39;4&#39; for key &#39;PRIMARY&#39;　# 对于事务Ａ在查询到a&gt;3条件下没有结果集，写入一条数据，但是却出现了主键冲突的异常．</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>1 MySQL技术内幕+InnoDB存储引擎第2版(7.2节)<br>2 <a href=\"https://segmentfault.com/a/1190000012669504\">搞懂不可重复读和幻读</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>通过锁机制可以实现事务的隔离性要求，使得事务可以并发的工作．锁提高了并发，却会带来潜在问题呢，例如脏读，幻读等．</p>","more":"<p>后续示例均在以下user表的基础上进行操作．</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1.　表信息．</span><br><span class=\"line\">CREATE TABLE &#96;users&#96; (</span><br><span class=\"line\">  &#96;id&#96; int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,</span><br><span class=\"line\">  &#96;user_name&#96; varchar(10) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户名&#39;,</span><br><span class=\"line\">  &#96;age&#96; tinyint(2) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;年龄&#39;,</span><br><span class=\"line\">  PRIMARY KEY (&#96;id&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;13 DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;用户信息&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 准备测试数据．</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">| 11 | Natasha   |  23 |</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">+----+-----------+-----+</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-脏读\"><a href=\"#2-脏读\" class=\"headerlink\" title=\"2 脏读\"></a>2 脏读</h3><p>脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据．</p>\n<p><code>脏读发生的条件</code>：事务的隔离级别为READ UNCOMMITTED．</p>\n<p><code>脏读的适用场景</code>：在一些特殊特殊情况下，可以将事务的隔离级别设置为READ UNCOMMITTED，例如replication环境中的slave节点，并在该slave上的查询并不需要特别精确的返回值．</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: set session transaction isolation level read uncommitted;</span><br><span class=\"line\">A: begin</span><br><span class=\"line\">A: select * from users where id&gt;11;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">1 row in set (0.01 sec)</span><br><span class=\"line\">\tB: set session transaction isolation level read uncommitted;</span><br><span class=\"line\">\tB: begin</span><br><span class=\"line\">\tB: insert into users(user_name,age)values(&#39;Jovry-Lee&#39;,18); # 未提交．</span><br><span class=\"line\">A: select * from users where id &gt; 11; # 此时事务Ａ读取到事务Ｂ尚未提交的数据，属于脏读．</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">| 13 | Jovry-Lee |  18 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"3-不可重复读\"><a href=\"#3-不可重复读\" class=\"headerlink\" title=\"3 不可重复读\"></a>3 不可重复读</h3><p>SQL92中对不可重复读的定义如下：</p>\n<blockquote>\n<p>**不可重复读(nonrepeatable read)**：SQL-transaction T1 reads a row. SQL-transaction T2 then modifies or deletes that row and performs a COMMIT. If T1 then attempts to reread the row, it may receive the modified value or discover that the row has been deleted.</p>\n</blockquote>\n<p>即，<strong>不可重复读</strong>是指在一个事务中多次读取同一数据行，在这个事务还没结束时，另一个事务也访问了该数据行，并做了DML操作，导致第一个事务多次读取到的数据不一样．</p>\n<p>（注：<u>不可重复读是针对单行数据</u>）</p>\n<p><code>不可重复读允许发生的隔离级别</code>：READ COMMITTED</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: set session transaction isolation level read committed;</span><br><span class=\"line\">A: begin</span><br><span class=\"line\">A: select * from users where id&gt;11;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">1 row in set (0.01 sec)</span><br><span class=\"line\">\tB: set session transaction isolation level read committed;</span><br><span class=\"line\">\tB: begin</span><br><span class=\"line\">\tB: insert into users(user_name,age)values(&#39;Jovry-Lee&#39;,18);</span><br><span class=\"line\">\tB: commit;</span><br><span class=\"line\">A: select * from users where id &gt; 11; # 此时事务Ａ两次读取到不同的结果，属于不可重复读．</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| 12 | sam       |  28 |</span><br><span class=\"line\">| 13 | Jovry-Lee |  18 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>脏读与不可重复读的区别</code>：脏读时读到未提交的数据，而不可重复读独到的是已经提交的数据，但时其违反了数据库事务一致性要求．</p>\n<p>一般来说不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来太大的问题．因此，很多数据库的默认隔离级别是<code>READ COMMITTED</code>，如：Ｏracle, SQL Server.</p>\n<p>MySQL官方文档中<code>将不可重复读的问题定义为Phantom Problem，即幻象问题</code>．InnoDB存储引擎的默认事务隔离级别READ REPEATABLE采用<u>Next-Key Lock算法</u>，避免了不可重复读．</p>\n<h3 id=\"4-幻读\"><a href=\"#4-幻读\" class=\"headerlink\" title=\"4 幻读\"></a>4 幻读</h3><p>SQL92中对幻读的定义如下：</p>\n<blockquote>\n<p>**幻读(phantom read)**：SQL-transaction T1 reads the set of rows N that satisfy some <search condition>. SQL-transaction T2 then executes SQL-statements that generate one or more rows that satisfy the <search condition> used by SQL-transaction T1. If SQL-transaction T1 then repeats the initial read with the same <search condition>, it obtains a different collection of rows.</p>\n</blockquote>\n<p>即，<strong>幻读</strong>指事务T1根据一定的查询条件读取一定的数据集，在这个事务还没有结束时，另一个事务T2执行SQL生成一条或多条满足事务T1查询条件的数据行．此时事务T1再次进行相同的查询时，其结果包含不同的数据集．</p>\n<p>（注：<u>幻读是针对一个结果集，不是单行数据</u>）</p>\n<p>对于MySQL的默认存储引擎InnoDB在RR隔离级别下通过MVCC机制避免了幻读问题．<u>严格的来说是解决了部分幻读的问题</u>[<em>参考资料2</em>]</p>\n<p>示例（<em>针对尚未解决的幻读问题</em>）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1. 建表</span><br><span class=\"line\">CREATE TABLE &#96;t&#96; (</span><br><span class=\"line\">  &#96;a&#96; int(11) NOT NULL,</span><br><span class=\"line\">  PRIMARY KEY (&#96;a&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 数据</span><br><span class=\"line\">mysql&gt; select * from t;</span><br><span class=\"line\">+----+</span><br><span class=\"line\">| a  |</span><br><span class=\"line\">+----+</span><br><span class=\"line\">|  1 |</span><br><span class=\"line\">|  2 |</span><br><span class=\"line\">|  3 |</span><br><span class=\"line\">+----+</span><br><span class=\"line\"></span><br><span class=\"line\"># 3. 按以下顺序分别执行Ａ，Ｂ两个事务．</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: select * from t where a&gt;3; # 没有大于３的结果集．</span><br><span class=\"line\">Empty set (0.00 sec)</span><br><span class=\"line\">\tB: insert into t select 4;　# 另一个事务插入了一条满足a&gt;3条件的数据．</span><br><span class=\"line\">\tQuery OK, 1 row affected (0.02 sec)</span><br><span class=\"line\">\tRecords: 1  Duplicates: 0  Warnings: 0</span><br><span class=\"line\">A: insert into t select 4; # 执行插入a&#x3D;4的数据行．</span><br><span class=\"line\">ERROR 1062 (23000): Duplicate entry &#39;4&#39; for key &#39;PRIMARY&#39;　# 对于事务Ａ在查询到a&gt;3条件下没有结果集，写入一条数据，但是却出现了主键冲突的异常．</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>1 MySQL技术内幕+InnoDB存储引擎第2版(7.2节)<br>2 <a href=\"https://segmentfault.com/a/1190000012669504\">搞懂不可重复读和幻读</a></p>"},{"title":"PHP-使用PDO访问数据库","date":"2020-09-22T10:21:31.000Z","_content":"\n\n\n### 1 前言\n\n一直时用的框架操作数据库，还没有仔细研究过PHP原生的接口，记录一下．\n\n<!--more-->\n\nPDO，PHP Data Objects的简称，是PHP访问数据库的抽象层，可以看作是一个连接数据库的接口，是PHP5之后推荐使用的连接数据库的方式。\n\n\n\n### 2.正文\n不管是哪种数据库，都可以通过这个接口来连接和操作数据，更换时只需要更换DSN（Data Source Name）即可（有点适配器模式那个意思）；可以有效防止SQL注入（预编译模式）；\n\n\n\n### 3 测试数据库\n\n- 连接本地数据库\n```bash\n$ mysql -uroot -p\nEnter password:123456\n```\n- 数据库: seven\n```mysql\n# 建库.\ncreate databases seven;\n```\n- 数据表: users\n```mysql\n# 建表.\nCREATE TABLE `users` (\n    `id` int(10) unsigned not null auto_increment COMMENT '自增主键',\n    `user_name` varchar(10) not null default '' COMMENT '用户名',\n    `age` tinyint(2) not null default 0 COMMENT '年龄',\n    PRIMARY KEY (`id`)\n) ENGINE InnoDB CHARSET = utf8mb4 COMMENT '用户信息'\n```\n- 数据：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  5 | Jovry     |  19 |\n|  6 | Gordon    |  20 |\n+----+-----------+-----+\n\n```\n\n### 4 基本操作\n#### 4.1 连接数据库\n```php\n// 连接数据库.\n$dsn = 'mysql:host=127.0.0.1;dbname=seven';\n$user = 'root';\n$pass = '123456';\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass);\n} catch (PDOException $e) {\n    echo \"Connection failed: \" . $e->getMessage();\n    die;\n}\n```\n\n#### 4.2 查询操作\n查询操作有两种方式:\n- query(直接查询方式)： 快捷方便,但存在Sql注入的风险.\n- prepare + execute(预编译和参数绑定方式)：防止SQL注入,并在插入或修改大量数据时,因为相关sql已经被执行过,所以直接读取即可,速度快.\n\n##### 4.2.1 query方式.\n```php\n$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // setAttribute用于设置数据库句柄属性,如错误模式等;\n$name = 'Seven';\n$sql = \"select * from users where user_name = \" . $dbh->quote($name); // quote是对参数(一般为用户输入)进行转义,防止Sql注入.\nforeach ($dbh->query($sql) as $row) {\n    echo $row['id'],\"\\t\",$row['user_name'],\"\\t\",$row['age'],\"\\n\";\n}\n```\n执行结果：\n```\n4       Seven   18\n```\n\n##### 4.2.2 prepare + execute方式.\n```php\n$name = 'Seven';\n$sql = 'select * from users where user_name =:name';\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->execute();\nwhile($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    echo $row['id'],\"\\t\",$row['user_name'],\"\\t\",$row['age'],\"\\n\";\n}\n```\n执行结果：\n```\n4       Seven   18\n```\n\n在SQL语句中,通过:name占位符来代替实际变量,然后在bindParam时将该占位符替换成实际的值,通过种种方式避免SQL注入.\n$dbh->prepare($sql)返回一个PDOStatement对象,之后都是通过这个对象来进行操作.\nPDO::FETCH_ASSOC指定获取方式,将对应结果集中的每一行作为一个由列名索引的数组返回.如果想返回对象，可以使用PDO::FETCH_LAZY或者调用fetchObject方法。\n\n\n#### 4.3 插入数据\n##### 4.3.1 prepare + execute的方式\n插入数据也是采用prepare + execute的方式，如果有多个参数，需要进行多次参数绑定。\n```php\n$name = 'Logan';\n$age = 10;\n$sql = \"insert into users (user_name, age) value (:name, :age)\";\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->bindParam(':age', $age, PDO::PARAM_INT);\n$stmt->execute();\n```\n\n执行后数据库中的数据如下：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  5 | Jovry     |  19 |\n|  6 | Gordon    |  20 |\n| 10 | Logan     |  10 |\n+----+-----------+-----+\n4 rows in set (0.00 sec)\n```\n\n#### 4.4 修改数据\n##### 4.4.1 prepare + execute方式\nprepare + execute方式. 修改或删除数据，如果有多个参数,需要进行多次数据绑定.\n```php\n$name = 'Logan';\n$age = 15;\n$sql = \"update users set age = :age where user_name = :name\";\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->bindParam(':age', $age, PDO::PARAM_INT);\n$stmt->execute();\n```\n执行后数据库中的数据如下：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  5 | Jovry     |  19 |\n|  6 | Gordon    |  20 |\n| 10 | Logan     |  15 |\n+----+-----------+-----+\n4 rows in set (0.00 sec)\n```\n\n#### 4.5 删除数据\n##### 4.5.1 prepare + execute方式\nprepare + execute方式. 修改或删除数据，如果有多个参数,需要进行多次数据绑定.\n```php\n$name = 'Logan';\n$sql = \"delete from users where user_name = :name\";\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->execute();\n```\n执行后数据库中的数据如下：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  5 | Jovry     |  19 |\n|  6 | Gordon    |  20 |\n+----+-----------+-----+\n3 rows in set (0.00 sec)\n```\n\n**其实，通过预编译加上参数绑定方式进行增删改查，就是SQL语句不同，其余的都一样。**\n\n#### 4.6 受影响的行 \n通过Statement的rowCount方法可以返回上一次操作影响到行数。\n```php\n$age = 15;\n$sql = \"select * from users where age > :age\";\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':age', $age, PDO::PARAM_INT);\n$stmt->execute();\necho $stmt->rowCount();\n```\n执行脚本输出如下：\n```\n3\n```\n\n### 5 事务支持\nPDO也支持MySQL事务（transaction），包括start、commit和rollback等。\n```php\ntry {\n    $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n    $dbh->beginTransaction();  // 开始事务.\n    $sql  = \"insert into users (user_name, age) values (:name, :age)\";\n    $stmt = $dbh->prepare($sql);\n    $stmt->execute(array(':name' => 'Natasha', ':age' => 23));\n    $id = 1;\n    $sql = 'delete from users where id = :id';\n    $stmt = $dbh->prepare($sql);\n    $stmt->bindParam(':id', $id, PDO::PARAM_INT);\n    $stmt->execute();\n    $dbh->commit(); // 提交事务.\n} catch(PDOException $e) {\n    $dbh->rollBack(); // 回滚事务.\n    echo \"Error occurred when execute SQL: \", $sql, \"<br>\";\n    echo \"Error info:<br>\", $e->getMessage();\n}\n```\n执行后数据库中的数据如下：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  6 | Gordon    |  20 |\n| 11 | Natasha   |  23 |\n+----+-----------+-----+\n3 rows in set (0.00 sec)\n```\n\n### 6 错误处理\nPDO有3个错误提示等级，分别为`POD::ERRMODE_SILENT`（默认）、`POD::ERRMODE_WARNING`和`POD::ERRMODE_EXCEPTION`。\n\n#### 6.1 POD::ERRMODE_SILENT\n不显示错误信息，会设置一个错误码，需要检查错误码来判断是否发生错误。\n```php\n$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT); // 问题：默认为POD::ERRMODE_SILENT，但是当未设置错误级别时，php抛出了Fatal error？？？？\n$name = 'Seven';\n$sql = 'SELECT * FROM user WHERE user_name =:name';   // 数据表名有误\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->execute();\n$code = $stmt->errorCode();\n//var_dump($code);echo '<br>';   // 输出错误码，string(5) \"42S02\"\nif (empty($code)) {\n    while ($row = $stmt->fetchObject()) {\n        echo $row['id'],\"\\t\",$row['name'],\"\\t\",$row['score'],\"<br>\";\n    }\n}else{\n    echo 'Error occurred when execut SQL ', $sql, '<br>';\n    echo 'ErrorInfo:<br><pre>';\n    var_dump($stmt->errorInfo());\n}\n```\n执行脚本结果：\n```\nError occurred when execut SQL SELECT * FROM user WHERE user_name =:name<br>ErrorInfo:<br><pre>array(3) {\n  [0]=>\n  string(5) \"42S02\"\n  [1]=>\n  int(1146)\n  [2]=>\n  string(32) \"Table 'seven.user' doesn't exist\"\n}\n```\n当未设置错误级别时，输出结果为：\n```\nPHP Fatal error:  Uncaught exception 'PDOException' with message 'SQLSTATE[42S02]: Base table or view not found: 1146 Table 'seven.user' doesn't exist' in /home/cdyf/tutorial/PDO/Pdo_test.php:119\nStack trace:\n#0 /home/cdyf/tutorial/PDO/Pdo_test.php(119): PDOStatement->execute()\n#1 {main}\n  thrown in /home/cdyf/tutorial/PDO/Pdo_test.php on line 119\n```\n\n注意:**这里的错误是Statement级别的,不是PHP级别,所以需要使用$stmt->errorInfo()来获取错误信息**.\n\n#### 6.2 PDO::ERRMODE_WARNING\n该模式下,出错会产生一个PHP的警告(warning), 同时会设置Statement级别和errorinfo.\n```php\n$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);\n$name = \"Seven\";\n$sql = 'SELECT * FROM user WHERE user_name =:name';\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->execute();\n$code = $stmt->errorCode();\n// var_dump($code);echo '<br>';\nif (empty($code)) {\n    while ($row = $stmt->fetchObject()) {\n        echo $row['id'],\"\\t\",$row['name'],\"\\t\",$row['score'],\"<br>\";\n    }\n}else{\n    echo 'Error occurred when execut SQL ', $sql, '<br>';\n    echo 'ErrorInfo:<br><pre>';\n    var_dump($stmt->errorInfo());\n}\n```\n执行脚本结果：\n```\nPHP Warning:  PDOStatement::execute(): SQLSTATE[42S02]: Base table or view not found: 1146 Table 'seven.user' doesn't exist in /home/cdyf/tutorial/PDO/Pdo_test.php on line 157\nError occurred when execut SQL SELECT * FROM user WHERE user_name =:name<br>ErrorInfo:<br><pre>array(3) {\n  [0]=>\n  string(5) \"42S02\"\n  [1]=>\n  int(1146)\n  [2]=>\n  string(32) \"Table 'seven.user' doesn't exist\"\n}\n```\n**与SILENT模式相比，多了一个Warning.**\n\n#### 6.3 PDO:: ERRMODE_EXCEPTION\n在这个模式下，出错会产生一个PHP的错误（PDOException），同时也会设置Statement级别的errorinfo。不过这个时候，我们就可以通过try{...}catch{...}的方式来捕获产生的异常。\n```php\n$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n$name = 'Seven';\ntry {\n    $sql = 'SELECT * FROM user WHERE user_name =:name';\n    $stmt = $dbh->prepare($sql);\n    $stmt->bindParam(':name', $name, PDO::PARAM_STR);\n    $stmt->execute();\n    while ($row = $stmt->fetchObject()) {\n        echo $row['id'],\"\\t\",$row['name'],\"\\t\",$row['score'],\"<br>\";\n    }\n}catch(PDOException $e) {\n    echo 'PDO Exception Caught.' . \"\\n\";\n    echo 'Error occurred with executed SQL: '.$sql.\"\\n\";\n    echo 'Error: ' . $e->getMessage(). \"\\n\";\n    echo 'Code: '. $e->getCode(). \"\\n\";\n    echo 'File: '. $e->getFile(). \"\\n\";\n    echo 'Line: '. $e->getLine(). \"\\n\";\n    echo 'Trace: '. $e->getTraceAsString(). \"\\n\";\n}\n```\n执行脚本结果：\n```\nPDO Exception Caught.\nError occurred with executed SQL: SELECT * FROM user WHERE user_name =:name\nError: SQLSTATE[42S02]: Base table or view not found: 1146 Table 'seven.user' doesn't exist\nCode: 42S02\nFile: /home/cdyf/tutorial/PDO/Pdo_test.php\nLine: 196\nTrace: #0 /home/cdyf/tutorial/PDO/Pdo_test.php(196): PDOStatement->execute()\n#1 {main}\n```\n通过try{...}catch{...}的方式，可以捕获execute时产生的异常，可以跟踪到文件和行数级别。\n\n### 7 防止SQL注入\n- SQL注入就是攻击者在用户输入的地方输入sql语句从而导致该语句在数据库中执行.\n- 避免SQL注入的准则: 在外部署据到达数据库之前线对他进行转义.\n\n#### 7.1 query方式防止sql注入方法\nquery方式不能自动转义,需要手动调用$hdb->quote方法来转.\n\n#### 7.2 预编译方法避免sql注入原理\n- 其原理如下:   \n当调用prepare()时，查询语句已经发送给了数据库服务器，此时只有占位符 发送过去，没有用户提交的数据；当调用到execute()时，用户提交过来的值才会传送给数据库，它们是分开传送的，所以不会产生SQL注入的风险。","source":"_posts/PHP-使用PDO访问数据库.md","raw":"---\ntitle: PHP-使用PDO访问数据库\ndate: 2020-09-22 18:21:31\ntags: [\"PHP\",\"PDO\"]\ncategories: [\"PHP\",\"PDO\"]\n---\n\n\n\n### 1 前言\n\n一直时用的框架操作数据库，还没有仔细研究过PHP原生的接口，记录一下．\n\n<!--more-->\n\nPDO，PHP Data Objects的简称，是PHP访问数据库的抽象层，可以看作是一个连接数据库的接口，是PHP5之后推荐使用的连接数据库的方式。\n\n\n\n### 2.正文\n不管是哪种数据库，都可以通过这个接口来连接和操作数据，更换时只需要更换DSN（Data Source Name）即可（有点适配器模式那个意思）；可以有效防止SQL注入（预编译模式）；\n\n\n\n### 3 测试数据库\n\n- 连接本地数据库\n```bash\n$ mysql -uroot -p\nEnter password:123456\n```\n- 数据库: seven\n```mysql\n# 建库.\ncreate databases seven;\n```\n- 数据表: users\n```mysql\n# 建表.\nCREATE TABLE `users` (\n    `id` int(10) unsigned not null auto_increment COMMENT '自增主键',\n    `user_name` varchar(10) not null default '' COMMENT '用户名',\n    `age` tinyint(2) not null default 0 COMMENT '年龄',\n    PRIMARY KEY (`id`)\n) ENGINE InnoDB CHARSET = utf8mb4 COMMENT '用户信息'\n```\n- 数据：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  5 | Jovry     |  19 |\n|  6 | Gordon    |  20 |\n+----+-----------+-----+\n\n```\n\n### 4 基本操作\n#### 4.1 连接数据库\n```php\n// 连接数据库.\n$dsn = 'mysql:host=127.0.0.1;dbname=seven';\n$user = 'root';\n$pass = '123456';\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass);\n} catch (PDOException $e) {\n    echo \"Connection failed: \" . $e->getMessage();\n    die;\n}\n```\n\n#### 4.2 查询操作\n查询操作有两种方式:\n- query(直接查询方式)： 快捷方便,但存在Sql注入的风险.\n- prepare + execute(预编译和参数绑定方式)：防止SQL注入,并在插入或修改大量数据时,因为相关sql已经被执行过,所以直接读取即可,速度快.\n\n##### 4.2.1 query方式.\n```php\n$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // setAttribute用于设置数据库句柄属性,如错误模式等;\n$name = 'Seven';\n$sql = \"select * from users where user_name = \" . $dbh->quote($name); // quote是对参数(一般为用户输入)进行转义,防止Sql注入.\nforeach ($dbh->query($sql) as $row) {\n    echo $row['id'],\"\\t\",$row['user_name'],\"\\t\",$row['age'],\"\\n\";\n}\n```\n执行结果：\n```\n4       Seven   18\n```\n\n##### 4.2.2 prepare + execute方式.\n```php\n$name = 'Seven';\n$sql = 'select * from users where user_name =:name';\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->execute();\nwhile($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    echo $row['id'],\"\\t\",$row['user_name'],\"\\t\",$row['age'],\"\\n\";\n}\n```\n执行结果：\n```\n4       Seven   18\n```\n\n在SQL语句中,通过:name占位符来代替实际变量,然后在bindParam时将该占位符替换成实际的值,通过种种方式避免SQL注入.\n$dbh->prepare($sql)返回一个PDOStatement对象,之后都是通过这个对象来进行操作.\nPDO::FETCH_ASSOC指定获取方式,将对应结果集中的每一行作为一个由列名索引的数组返回.如果想返回对象，可以使用PDO::FETCH_LAZY或者调用fetchObject方法。\n\n\n#### 4.3 插入数据\n##### 4.3.1 prepare + execute的方式\n插入数据也是采用prepare + execute的方式，如果有多个参数，需要进行多次参数绑定。\n```php\n$name = 'Logan';\n$age = 10;\n$sql = \"insert into users (user_name, age) value (:name, :age)\";\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->bindParam(':age', $age, PDO::PARAM_INT);\n$stmt->execute();\n```\n\n执行后数据库中的数据如下：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  5 | Jovry     |  19 |\n|  6 | Gordon    |  20 |\n| 10 | Logan     |  10 |\n+----+-----------+-----+\n4 rows in set (0.00 sec)\n```\n\n#### 4.4 修改数据\n##### 4.4.1 prepare + execute方式\nprepare + execute方式. 修改或删除数据，如果有多个参数,需要进行多次数据绑定.\n```php\n$name = 'Logan';\n$age = 15;\n$sql = \"update users set age = :age where user_name = :name\";\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->bindParam(':age', $age, PDO::PARAM_INT);\n$stmt->execute();\n```\n执行后数据库中的数据如下：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  5 | Jovry     |  19 |\n|  6 | Gordon    |  20 |\n| 10 | Logan     |  15 |\n+----+-----------+-----+\n4 rows in set (0.00 sec)\n```\n\n#### 4.5 删除数据\n##### 4.5.1 prepare + execute方式\nprepare + execute方式. 修改或删除数据，如果有多个参数,需要进行多次数据绑定.\n```php\n$name = 'Logan';\n$sql = \"delete from users where user_name = :name\";\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->execute();\n```\n执行后数据库中的数据如下：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  5 | Jovry     |  19 |\n|  6 | Gordon    |  20 |\n+----+-----------+-----+\n3 rows in set (0.00 sec)\n```\n\n**其实，通过预编译加上参数绑定方式进行增删改查，就是SQL语句不同，其余的都一样。**\n\n#### 4.6 受影响的行 \n通过Statement的rowCount方法可以返回上一次操作影响到行数。\n```php\n$age = 15;\n$sql = \"select * from users where age > :age\";\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':age', $age, PDO::PARAM_INT);\n$stmt->execute();\necho $stmt->rowCount();\n```\n执行脚本输出如下：\n```\n3\n```\n\n### 5 事务支持\nPDO也支持MySQL事务（transaction），包括start、commit和rollback等。\n```php\ntry {\n    $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n    $dbh->beginTransaction();  // 开始事务.\n    $sql  = \"insert into users (user_name, age) values (:name, :age)\";\n    $stmt = $dbh->prepare($sql);\n    $stmt->execute(array(':name' => 'Natasha', ':age' => 23));\n    $id = 1;\n    $sql = 'delete from users where id = :id';\n    $stmt = $dbh->prepare($sql);\n    $stmt->bindParam(':id', $id, PDO::PARAM_INT);\n    $stmt->execute();\n    $dbh->commit(); // 提交事务.\n} catch(PDOException $e) {\n    $dbh->rollBack(); // 回滚事务.\n    echo \"Error occurred when execute SQL: \", $sql, \"<br>\";\n    echo \"Error info:<br>\", $e->getMessage();\n}\n```\n执行后数据库中的数据如下：\n```mysql\nmysql> select * from users;\n+----+-----------+-----+\n| id | user_name | age |\n+----+-----------+-----+\n|  4 | Seven     |  18 |\n|  6 | Gordon    |  20 |\n| 11 | Natasha   |  23 |\n+----+-----------+-----+\n3 rows in set (0.00 sec)\n```\n\n### 6 错误处理\nPDO有3个错误提示等级，分别为`POD::ERRMODE_SILENT`（默认）、`POD::ERRMODE_WARNING`和`POD::ERRMODE_EXCEPTION`。\n\n#### 6.1 POD::ERRMODE_SILENT\n不显示错误信息，会设置一个错误码，需要检查错误码来判断是否发生错误。\n```php\n$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT); // 问题：默认为POD::ERRMODE_SILENT，但是当未设置错误级别时，php抛出了Fatal error？？？？\n$name = 'Seven';\n$sql = 'SELECT * FROM user WHERE user_name =:name';   // 数据表名有误\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->execute();\n$code = $stmt->errorCode();\n//var_dump($code);echo '<br>';   // 输出错误码，string(5) \"42S02\"\nif (empty($code)) {\n    while ($row = $stmt->fetchObject()) {\n        echo $row['id'],\"\\t\",$row['name'],\"\\t\",$row['score'],\"<br>\";\n    }\n}else{\n    echo 'Error occurred when execut SQL ', $sql, '<br>';\n    echo 'ErrorInfo:<br><pre>';\n    var_dump($stmt->errorInfo());\n}\n```\n执行脚本结果：\n```\nError occurred when execut SQL SELECT * FROM user WHERE user_name =:name<br>ErrorInfo:<br><pre>array(3) {\n  [0]=>\n  string(5) \"42S02\"\n  [1]=>\n  int(1146)\n  [2]=>\n  string(32) \"Table 'seven.user' doesn't exist\"\n}\n```\n当未设置错误级别时，输出结果为：\n```\nPHP Fatal error:  Uncaught exception 'PDOException' with message 'SQLSTATE[42S02]: Base table or view not found: 1146 Table 'seven.user' doesn't exist' in /home/cdyf/tutorial/PDO/Pdo_test.php:119\nStack trace:\n#0 /home/cdyf/tutorial/PDO/Pdo_test.php(119): PDOStatement->execute()\n#1 {main}\n  thrown in /home/cdyf/tutorial/PDO/Pdo_test.php on line 119\n```\n\n注意:**这里的错误是Statement级别的,不是PHP级别,所以需要使用$stmt->errorInfo()来获取错误信息**.\n\n#### 6.2 PDO::ERRMODE_WARNING\n该模式下,出错会产生一个PHP的警告(warning), 同时会设置Statement级别和errorinfo.\n```php\n$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);\n$name = \"Seven\";\n$sql = 'SELECT * FROM user WHERE user_name =:name';\n$stmt = $dbh->prepare($sql);\n$stmt->bindParam(':name', $name, PDO::PARAM_STR);\n$stmt->execute();\n$code = $stmt->errorCode();\n// var_dump($code);echo '<br>';\nif (empty($code)) {\n    while ($row = $stmt->fetchObject()) {\n        echo $row['id'],\"\\t\",$row['name'],\"\\t\",$row['score'],\"<br>\";\n    }\n}else{\n    echo 'Error occurred when execut SQL ', $sql, '<br>';\n    echo 'ErrorInfo:<br><pre>';\n    var_dump($stmt->errorInfo());\n}\n```\n执行脚本结果：\n```\nPHP Warning:  PDOStatement::execute(): SQLSTATE[42S02]: Base table or view not found: 1146 Table 'seven.user' doesn't exist in /home/cdyf/tutorial/PDO/Pdo_test.php on line 157\nError occurred when execut SQL SELECT * FROM user WHERE user_name =:name<br>ErrorInfo:<br><pre>array(3) {\n  [0]=>\n  string(5) \"42S02\"\n  [1]=>\n  int(1146)\n  [2]=>\n  string(32) \"Table 'seven.user' doesn't exist\"\n}\n```\n**与SILENT模式相比，多了一个Warning.**\n\n#### 6.3 PDO:: ERRMODE_EXCEPTION\n在这个模式下，出错会产生一个PHP的错误（PDOException），同时也会设置Statement级别的errorinfo。不过这个时候，我们就可以通过try{...}catch{...}的方式来捕获产生的异常。\n```php\n$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n$name = 'Seven';\ntry {\n    $sql = 'SELECT * FROM user WHERE user_name =:name';\n    $stmt = $dbh->prepare($sql);\n    $stmt->bindParam(':name', $name, PDO::PARAM_STR);\n    $stmt->execute();\n    while ($row = $stmt->fetchObject()) {\n        echo $row['id'],\"\\t\",$row['name'],\"\\t\",$row['score'],\"<br>\";\n    }\n}catch(PDOException $e) {\n    echo 'PDO Exception Caught.' . \"\\n\";\n    echo 'Error occurred with executed SQL: '.$sql.\"\\n\";\n    echo 'Error: ' . $e->getMessage(). \"\\n\";\n    echo 'Code: '. $e->getCode(). \"\\n\";\n    echo 'File: '. $e->getFile(). \"\\n\";\n    echo 'Line: '. $e->getLine(). \"\\n\";\n    echo 'Trace: '. $e->getTraceAsString(). \"\\n\";\n}\n```\n执行脚本结果：\n```\nPDO Exception Caught.\nError occurred with executed SQL: SELECT * FROM user WHERE user_name =:name\nError: SQLSTATE[42S02]: Base table or view not found: 1146 Table 'seven.user' doesn't exist\nCode: 42S02\nFile: /home/cdyf/tutorial/PDO/Pdo_test.php\nLine: 196\nTrace: #0 /home/cdyf/tutorial/PDO/Pdo_test.php(196): PDOStatement->execute()\n#1 {main}\n```\n通过try{...}catch{...}的方式，可以捕获execute时产生的异常，可以跟踪到文件和行数级别。\n\n### 7 防止SQL注入\n- SQL注入就是攻击者在用户输入的地方输入sql语句从而导致该语句在数据库中执行.\n- 避免SQL注入的准则: 在外部署据到达数据库之前线对他进行转义.\n\n#### 7.1 query方式防止sql注入方法\nquery方式不能自动转义,需要手动调用$hdb->quote方法来转.\n\n#### 7.2 预编译方法避免sql注入原理\n- 其原理如下:   \n当调用prepare()时，查询语句已经发送给了数据库服务器，此时只有占位符 发送过去，没有用户提交的数据；当调用到execute()时，用户提交过来的值才会传送给数据库，它们是分开传送的，所以不会产生SQL注入的风险。","slug":"PHP-使用PDO访问数据库","published":1,"updated":"2020-09-22T10:28:40.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkn002645g301gyg9ep","content":"<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1 前言\"></a>1 前言</h3><p>一直时用的框架操作数据库，还没有仔细研究过PHP原生的接口，记录一下．</p>\n<a id=\"more\"></a>\n\n<p>PDO，PHP Data Objects的简称，是PHP访问数据库的抽象层，可以看作是一个连接数据库的接口，是PHP5之后推荐使用的连接数据库的方式。</p>\n<h3 id=\"2-正文\"><a href=\"#2-正文\" class=\"headerlink\" title=\"2.正文\"></a>2.正文</h3><p>不管是哪种数据库，都可以通过这个接口来连接和操作数据，更换时只需要更换DSN（Data Source Name）即可（有点适配器模式那个意思）；可以有效防止SQL注入（预编译模式）；</p>\n<h3 id=\"3-测试数据库\"><a href=\"#3-测试数据库\" class=\"headerlink\" title=\"3 测试数据库\"></a>3 测试数据库</h3><ul>\n<li>连接本地数据库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mysql -uroot -p</span><br><span class=\"line\">Enter password:123456</span><br></pre></td></tr></table></figure></li>\n<li>数据库: seven<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建库.</span><br><span class=\"line\">create databases seven;</span><br></pre></td></tr></table></figure></li>\n<li>数据表: users<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建表.</span><br><span class=\"line\">CREATE TABLE &#96;users&#96; (</span><br><span class=\"line\">    &#96;id&#96; int(10) unsigned not null auto_increment COMMENT &#39;自增主键&#39;,</span><br><span class=\"line\">    &#96;user_name&#96; varchar(10) not null default &#39;&#39; COMMENT &#39;用户名&#39;,</span><br><span class=\"line\">    &#96;age&#96; tinyint(2) not null default 0 COMMENT &#39;年龄&#39;,</span><br><span class=\"line\">    PRIMARY KEY (&#96;id&#96;)</span><br><span class=\"line\">) ENGINE InnoDB CHARSET &#x3D; utf8mb4 COMMENT &#39;用户信息&#39;</span><br></pre></td></tr></table></figure></li>\n<li>数据：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  5 | Jovry     |  19 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"4-基本操作\"><a href=\"#4-基本操作\" class=\"headerlink\" title=\"4 基本操作\"></a>4 基本操作</h3><h4 id=\"4-1-连接数据库\"><a href=\"#4-1-连接数据库\" class=\"headerlink\" title=\"4.1 连接数据库\"></a>4.1 连接数据库</h4><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 连接数据库.</span></span><br><span class=\"line\">$dsn = <span class=\"string\">&#x27;mysql:host=127.0.0.1;dbname=seven&#x27;</span>;</span><br><span class=\"line\">$user = <span class=\"string\">&#x27;root&#x27;</span>;</span><br><span class=\"line\">$pass = <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    $dbh = <span class=\"keyword\">new</span> PDO($dsn, $user, $pass);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (PDOException $e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Connection failed: &quot;</span> . $e-&gt;getMessage();</span><br><span class=\"line\">    <span class=\"keyword\">die</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-查询操作\"><a href=\"#4-2-查询操作\" class=\"headerlink\" title=\"4.2 查询操作\"></a>4.2 查询操作</h4><p>查询操作有两种方式:</p>\n<ul>\n<li>query(直接查询方式)： 快捷方便,但存在Sql注入的风险.</li>\n<li>prepare + execute(预编译和参数绑定方式)：防止SQL注入,并在插入或修改大量数据时,因为相关sql已经被执行过,所以直接读取即可,速度快.</li>\n</ul>\n<h5 id=\"4-2-1-query方式\"><a href=\"#4-2-1-query方式\" class=\"headerlink\" title=\"4.2.1 query方式.\"></a>4.2.1 query方式.</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); <span class=\"comment\">// setAttribute用于设置数据库句柄属性,如错误模式等;</span></span><br><span class=\"line\">$name = <span class=\"string\">&#x27;Seven&#x27;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;select * from users where user_name = &quot;</span> . $dbh-&gt;quote($name); <span class=\"comment\">// quote是对参数(一般为用户输入)进行转义,防止Sql注入.</span></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> ($dbh-&gt;query($sql) <span class=\"keyword\">as</span> $row) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;user_name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;age&#x27;</span>],<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4       Seven   18</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-2-prepare-execute方式\"><a href=\"#4-2-2-prepare-execute方式\" class=\"headerlink\" title=\"4.2.2 prepare + execute方式.\"></a>4.2.2 prepare + execute方式.</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$name = <span class=\"string\">&#x27;Seven&#x27;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&#x27;select * from users where user_name =:name&#x27;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br><span class=\"line\"><span class=\"keyword\">while</span>($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;user_name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;age&#x27;</span>],<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4       Seven   18</span><br></pre></td></tr></table></figure>\n\n<p>在SQL语句中,通过:name占位符来代替实际变量,然后在bindParam时将该占位符替换成实际的值,通过种种方式避免SQL注入.<br>$dbh-&gt;prepare($sql)返回一个PDOStatement对象,之后都是通过这个对象来进行操作.<br>PDO::FETCH_ASSOC指定获取方式,将对应结果集中的每一行作为一个由列名索引的数组返回.如果想返回对象，可以使用PDO::FETCH_LAZY或者调用fetchObject方法。</p>\n<h4 id=\"4-3-插入数据\"><a href=\"#4-3-插入数据\" class=\"headerlink\" title=\"4.3 插入数据\"></a>4.3 插入数据</h4><h5 id=\"4-3-1-prepare-execute的方式\"><a href=\"#4-3-1-prepare-execute的方式\" class=\"headerlink\" title=\"4.3.1 prepare + execute的方式\"></a>4.3.1 prepare + execute的方式</h5><p>插入数据也是采用prepare + execute的方式，如果有多个参数，需要进行多次参数绑定。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$name = <span class=\"string\">&#x27;Logan&#x27;</span>;</span><br><span class=\"line\">$age = <span class=\"number\">10</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;insert into users (user_name, age) value (:name, :age)&quot;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:age&#x27;</span>, $age, PDO::PARAM_INT);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br></pre></td></tr></table></figure>\n\n<p>执行后数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  5 | Jovry     |  19 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">| 10 | Logan     |  10 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-修改数据\"><a href=\"#4-4-修改数据\" class=\"headerlink\" title=\"4.4 修改数据\"></a>4.4 修改数据</h4><h5 id=\"4-4-1-prepare-execute方式\"><a href=\"#4-4-1-prepare-execute方式\" class=\"headerlink\" title=\"4.4.1 prepare + execute方式\"></a>4.4.1 prepare + execute方式</h5><p>prepare + execute方式. 修改或删除数据，如果有多个参数,需要进行多次数据绑定.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$name = <span class=\"string\">&#x27;Logan&#x27;</span>;</span><br><span class=\"line\">$age = <span class=\"number\">15</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;update users set age = :age where user_name = :name&quot;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:age&#x27;</span>, $age, PDO::PARAM_INT);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br></pre></td></tr></table></figure>\n<p>执行后数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  5 | Jovry     |  19 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">| 10 | Logan     |  15 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-5-删除数据\"><a href=\"#4-5-删除数据\" class=\"headerlink\" title=\"4.5 删除数据\"></a>4.5 删除数据</h4><h5 id=\"4-5-1-prepare-execute方式\"><a href=\"#4-5-1-prepare-execute方式\" class=\"headerlink\" title=\"4.5.1 prepare + execute方式\"></a>4.5.1 prepare + execute方式</h5><p>prepare + execute方式. 修改或删除数据，如果有多个参数,需要进行多次数据绑定.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$name = <span class=\"string\">&#x27;Logan&#x27;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;delete from users where user_name = :name&quot;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br></pre></td></tr></table></figure>\n<p>执行后数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  5 | Jovry     |  19 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p><strong>其实，通过预编译加上参数绑定方式进行增删改查，就是SQL语句不同，其余的都一样。</strong></p>\n<h4 id=\"4-6-受影响的行\"><a href=\"#4-6-受影响的行\" class=\"headerlink\" title=\"4.6 受影响的行\"></a>4.6 受影响的行</h4><p>通过Statement的rowCount方法可以返回上一次操作影响到行数。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$age = <span class=\"number\">15</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;select * from users where age &gt; :age&quot;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:age&#x27;</span>, $age, PDO::PARAM_INT);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $stmt-&gt;rowCount();</span><br></pre></td></tr></table></figure>\n<p>执行脚本输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-事务支持\"><a href=\"#5-事务支持\" class=\"headerlink\" title=\"5 事务支持\"></a>5 事务支持</h3><p>PDO也支持MySQL事务（transaction），包括start、commit和rollback等。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    $dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class=\"line\">    $dbh-&gt;beginTransaction();  <span class=\"comment\">// 开始事务.</span></span><br><span class=\"line\">    $sql  = <span class=\"string\">&quot;insert into users (user_name, age) values (:name, :age)&quot;</span>;</span><br><span class=\"line\">    $stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">    $stmt-&gt;execute(<span class=\"keyword\">array</span>(<span class=\"string\">&#x27;:name&#x27;</span> =&gt; <span class=\"string\">&#x27;Natasha&#x27;</span>, <span class=\"string\">&#x27;:age&#x27;</span> =&gt; <span class=\"number\">23</span>));</span><br><span class=\"line\">    $id = <span class=\"number\">1</span>;</span><br><span class=\"line\">    $sql = <span class=\"string\">&#x27;delete from users where id = :id&#x27;</span>;</span><br><span class=\"line\">    $stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">    $stmt-&gt;bindParam(<span class=\"string\">&#x27;:id&#x27;</span>, $id, PDO::PARAM_INT);</span><br><span class=\"line\">    $stmt-&gt;execute();</span><br><span class=\"line\">    $dbh-&gt;commit(); <span class=\"comment\">// 提交事务.</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(PDOException $e) &#123;</span><br><span class=\"line\">    $dbh-&gt;rollBack(); <span class=\"comment\">// 回滚事务.</span></span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Error occurred when execute SQL: &quot;</span>, $sql, <span class=\"string\">&quot;&lt;br&gt;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Error info:&lt;br&gt;&quot;</span>, $e-&gt;getMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行后数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">| 11 | Natasha   |  23 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-错误处理\"><a href=\"#6-错误处理\" class=\"headerlink\" title=\"6 错误处理\"></a>6 错误处理</h3><p>PDO有3个错误提示等级，分别为<code>POD::ERRMODE_SILENT</code>（默认）、<code>POD::ERRMODE_WARNING</code>和<code>POD::ERRMODE_EXCEPTION</code>。</p>\n<h4 id=\"6-1-POD-ERRMODE-SILENT\"><a href=\"#6-1-POD-ERRMODE-SILENT\" class=\"headerlink\" title=\"6.1 POD::ERRMODE_SILENT\"></a>6.1 POD::ERRMODE_SILENT</h4><p>不显示错误信息，会设置一个错误码，需要检查错误码来判断是否发生错误。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT); <span class=\"comment\">// 问题：默认为POD::ERRMODE_SILENT，但是当未设置错误级别时，php抛出了Fatal error？？？？</span></span><br><span class=\"line\">$name = <span class=\"string\">&#x27;Seven&#x27;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&#x27;SELECT * FROM user WHERE user_name =:name&#x27;</span>;   <span class=\"comment\">// 数据表名有误</span></span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br><span class=\"line\">$code = $stmt-&gt;errorCode();</span><br><span class=\"line\"><span class=\"comment\">//var_dump($code);echo &#x27;&lt;br&gt;&#x27;;   // 输出错误码，string(5) &quot;42S02&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">empty</span>($code)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ($row = $stmt-&gt;fetchObject()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;score&#x27;</span>],<span class=\"string\">&quot;&lt;br&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Error occurred when execut SQL &#x27;</span>, $sql, <span class=\"string\">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;ErrorInfo:&lt;br&gt;&lt;pre&gt;&#x27;</span>;</span><br><span class=\"line\">    var_dump($stmt-&gt;errorInfo());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行脚本结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error occurred when execut SQL SELECT * FROM user WHERE user_name &#x3D;:name&lt;br&gt;ErrorInfo:&lt;br&gt;&lt;pre&gt;array(3) &#123;</span><br><span class=\"line\">  [0]&#x3D;&gt;</span><br><span class=\"line\">  string(5) &quot;42S02&quot;</span><br><span class=\"line\">  [1]&#x3D;&gt;</span><br><span class=\"line\">  int(1146)</span><br><span class=\"line\">  [2]&#x3D;&gt;</span><br><span class=\"line\">  string(32) &quot;Table &#39;seven.user&#39; doesn&#39;t exist&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当未设置错误级别时，输出结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PHP Fatal error:  Uncaught exception &#39;PDOException&#39; with message &#39;SQLSTATE[42S02]: Base table or view not found: 1146 Table &#39;seven.user&#39; doesn&#39;t exist&#39; in &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php:119</span><br><span class=\"line\">Stack trace:</span><br><span class=\"line\">#0 &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php(119): PDOStatement-&gt;execute()</span><br><span class=\"line\">#1 &#123;main&#125;</span><br><span class=\"line\">  thrown in &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php on line 119</span><br></pre></td></tr></table></figure>\n\n<p>注意:<strong>这里的错误是Statement级别的,不是PHP级别,所以需要使用$stmt-&gt;errorInfo()来获取错误信息</strong>.</p>\n<h4 id=\"6-2-PDO-ERRMODE-WARNING\"><a href=\"#6-2-PDO-ERRMODE-WARNING\" class=\"headerlink\" title=\"6.2 PDO::ERRMODE_WARNING\"></a>6.2 PDO::ERRMODE_WARNING</h4><p>该模式下,出错会产生一个PHP的警告(warning), 同时会设置Statement级别和errorinfo.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);</span><br><span class=\"line\">$name = <span class=\"string\">&quot;Seven&quot;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&#x27;SELECT * FROM user WHERE user_name =:name&#x27;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br><span class=\"line\">$code = $stmt-&gt;errorCode();</span><br><span class=\"line\"><span class=\"comment\">// var_dump($code);echo &#x27;&lt;br&gt;&#x27;;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">empty</span>($code)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ($row = $stmt-&gt;fetchObject()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;score&#x27;</span>],<span class=\"string\">&quot;&lt;br&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Error occurred when execut SQL &#x27;</span>, $sql, <span class=\"string\">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;ErrorInfo:&lt;br&gt;&lt;pre&gt;&#x27;</span>;</span><br><span class=\"line\">    var_dump($stmt-&gt;errorInfo());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行脚本结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PHP Warning:  PDOStatement::execute(): SQLSTATE[42S02]: Base table or view not found: 1146 Table &#39;seven.user&#39; doesn&#39;t exist in &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php on line 157</span><br><span class=\"line\">Error occurred when execut SQL SELECT * FROM user WHERE user_name &#x3D;:name&lt;br&gt;ErrorInfo:&lt;br&gt;&lt;pre&gt;array(3) &#123;</span><br><span class=\"line\">  [0]&#x3D;&gt;</span><br><span class=\"line\">  string(5) &quot;42S02&quot;</span><br><span class=\"line\">  [1]&#x3D;&gt;</span><br><span class=\"line\">  int(1146)</span><br><span class=\"line\">  [2]&#x3D;&gt;</span><br><span class=\"line\">  string(32) &quot;Table &#39;seven.user&#39; doesn&#39;t exist&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>与SILENT模式相比，多了一个Warning.</strong></p>\n<h4 id=\"6-3-PDO-ERRMODE-EXCEPTION\"><a href=\"#6-3-PDO-ERRMODE-EXCEPTION\" class=\"headerlink\" title=\"6.3 PDO:: ERRMODE_EXCEPTION\"></a>6.3 PDO:: ERRMODE_EXCEPTION</h4><p>在这个模式下，出错会产生一个PHP的错误（PDOException），同时也会设置Statement级别的errorinfo。不过这个时候，我们就可以通过try{…}catch{…}的方式来捕获产生的异常。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class=\"line\">$name = <span class=\"string\">&#x27;Seven&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    $sql = <span class=\"string\">&#x27;SELECT * FROM user WHERE user_name =:name&#x27;</span>;</span><br><span class=\"line\">    $stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">    $stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">    $stmt-&gt;execute();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ($row = $stmt-&gt;fetchObject()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;score&#x27;</span>],<span class=\"string\">&quot;&lt;br&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(PDOException $e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;PDO Exception Caught.&#x27;</span> . <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Error occurred with executed SQL: &#x27;</span>.$sql.<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Error: &#x27;</span> . $e-&gt;getMessage(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Code: &#x27;</span>. $e-&gt;getCode(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;File: &#x27;</span>. $e-&gt;getFile(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Line: &#x27;</span>. $e-&gt;getLine(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Trace: &#x27;</span>. $e-&gt;getTraceAsString(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行脚本结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PDO Exception Caught.</span><br><span class=\"line\">Error occurred with executed SQL: SELECT * FROM user WHERE user_name &#x3D;:name</span><br><span class=\"line\">Error: SQLSTATE[42S02]: Base table or view not found: 1146 Table &#39;seven.user&#39; doesn&#39;t exist</span><br><span class=\"line\">Code: 42S02</span><br><span class=\"line\">File: &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php</span><br><span class=\"line\">Line: 196</span><br><span class=\"line\">Trace: #0 &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php(196): PDOStatement-&gt;execute()</span><br><span class=\"line\">#1 &#123;main&#125;</span><br></pre></td></tr></table></figure>\n<p>通过try{…}catch{…}的方式，可以捕获execute时产生的异常，可以跟踪到文件和行数级别。</p>\n<h3 id=\"7-防止SQL注入\"><a href=\"#7-防止SQL注入\" class=\"headerlink\" title=\"7 防止SQL注入\"></a>7 防止SQL注入</h3><ul>\n<li>SQL注入就是攻击者在用户输入的地方输入sql语句从而导致该语句在数据库中执行.</li>\n<li>避免SQL注入的准则: 在外部署据到达数据库之前线对他进行转义.</li>\n</ul>\n<h4 id=\"7-1-query方式防止sql注入方法\"><a href=\"#7-1-query方式防止sql注入方法\" class=\"headerlink\" title=\"7.1 query方式防止sql注入方法\"></a>7.1 query方式防止sql注入方法</h4><p>query方式不能自动转义,需要手动调用$hdb-&gt;quote方法来转.</p>\n<h4 id=\"7-2-预编译方法避免sql注入原理\"><a href=\"#7-2-预编译方法避免sql注入原理\" class=\"headerlink\" title=\"7.2 预编译方法避免sql注入原理\"></a>7.2 预编译方法避免sql注入原理</h4><ul>\n<li>其原理如下:<br>当调用prepare()时，查询语句已经发送给了数据库服务器，此时只有占位符 发送过去，没有用户提交的数据；当调用到execute()时，用户提交过来的值才会传送给数据库，它们是分开传送的，所以不会产生SQL注入的风险。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1 前言\"></a>1 前言</h3><p>一直时用的框架操作数据库，还没有仔细研究过PHP原生的接口，记录一下．</p>","more":"<p>PDO，PHP Data Objects的简称，是PHP访问数据库的抽象层，可以看作是一个连接数据库的接口，是PHP5之后推荐使用的连接数据库的方式。</p>\n<h3 id=\"2-正文\"><a href=\"#2-正文\" class=\"headerlink\" title=\"2.正文\"></a>2.正文</h3><p>不管是哪种数据库，都可以通过这个接口来连接和操作数据，更换时只需要更换DSN（Data Source Name）即可（有点适配器模式那个意思）；可以有效防止SQL注入（预编译模式）；</p>\n<h3 id=\"3-测试数据库\"><a href=\"#3-测试数据库\" class=\"headerlink\" title=\"3 测试数据库\"></a>3 测试数据库</h3><ul>\n<li>连接本地数据库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mysql -uroot -p</span><br><span class=\"line\">Enter password:123456</span><br></pre></td></tr></table></figure></li>\n<li>数据库: seven<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建库.</span><br><span class=\"line\">create databases seven;</span><br></pre></td></tr></table></figure></li>\n<li>数据表: users<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建表.</span><br><span class=\"line\">CREATE TABLE &#96;users&#96; (</span><br><span class=\"line\">    &#96;id&#96; int(10) unsigned not null auto_increment COMMENT &#39;自增主键&#39;,</span><br><span class=\"line\">    &#96;user_name&#96; varchar(10) not null default &#39;&#39; COMMENT &#39;用户名&#39;,</span><br><span class=\"line\">    &#96;age&#96; tinyint(2) not null default 0 COMMENT &#39;年龄&#39;,</span><br><span class=\"line\">    PRIMARY KEY (&#96;id&#96;)</span><br><span class=\"line\">) ENGINE InnoDB CHARSET &#x3D; utf8mb4 COMMENT &#39;用户信息&#39;</span><br></pre></td></tr></table></figure></li>\n<li>数据：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  5 | Jovry     |  19 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"4-基本操作\"><a href=\"#4-基本操作\" class=\"headerlink\" title=\"4 基本操作\"></a>4 基本操作</h3><h4 id=\"4-1-连接数据库\"><a href=\"#4-1-连接数据库\" class=\"headerlink\" title=\"4.1 连接数据库\"></a>4.1 连接数据库</h4><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 连接数据库.</span></span><br><span class=\"line\">$dsn = <span class=\"string\">&#x27;mysql:host=127.0.0.1;dbname=seven&#x27;</span>;</span><br><span class=\"line\">$user = <span class=\"string\">&#x27;root&#x27;</span>;</span><br><span class=\"line\">$pass = <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    $dbh = <span class=\"keyword\">new</span> PDO($dsn, $user, $pass);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (PDOException $e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Connection failed: &quot;</span> . $e-&gt;getMessage();</span><br><span class=\"line\">    <span class=\"keyword\">die</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-查询操作\"><a href=\"#4-2-查询操作\" class=\"headerlink\" title=\"4.2 查询操作\"></a>4.2 查询操作</h4><p>查询操作有两种方式:</p>\n<ul>\n<li>query(直接查询方式)： 快捷方便,但存在Sql注入的风险.</li>\n<li>prepare + execute(预编译和参数绑定方式)：防止SQL注入,并在插入或修改大量数据时,因为相关sql已经被执行过,所以直接读取即可,速度快.</li>\n</ul>\n<h5 id=\"4-2-1-query方式\"><a href=\"#4-2-1-query方式\" class=\"headerlink\" title=\"4.2.1 query方式.\"></a>4.2.1 query方式.</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); <span class=\"comment\">// setAttribute用于设置数据库句柄属性,如错误模式等;</span></span><br><span class=\"line\">$name = <span class=\"string\">&#x27;Seven&#x27;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;select * from users where user_name = &quot;</span> . $dbh-&gt;quote($name); <span class=\"comment\">// quote是对参数(一般为用户输入)进行转义,防止Sql注入.</span></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> ($dbh-&gt;query($sql) <span class=\"keyword\">as</span> $row) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;user_name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;age&#x27;</span>],<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4       Seven   18</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-2-prepare-execute方式\"><a href=\"#4-2-2-prepare-execute方式\" class=\"headerlink\" title=\"4.2.2 prepare + execute方式.\"></a>4.2.2 prepare + execute方式.</h5><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$name = <span class=\"string\">&#x27;Seven&#x27;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&#x27;select * from users where user_name =:name&#x27;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br><span class=\"line\"><span class=\"keyword\">while</span>($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;user_name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;age&#x27;</span>],<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4       Seven   18</span><br></pre></td></tr></table></figure>\n\n<p>在SQL语句中,通过:name占位符来代替实际变量,然后在bindParam时将该占位符替换成实际的值,通过种种方式避免SQL注入.<br>$dbh-&gt;prepare($sql)返回一个PDOStatement对象,之后都是通过这个对象来进行操作.<br>PDO::FETCH_ASSOC指定获取方式,将对应结果集中的每一行作为一个由列名索引的数组返回.如果想返回对象，可以使用PDO::FETCH_LAZY或者调用fetchObject方法。</p>\n<h4 id=\"4-3-插入数据\"><a href=\"#4-3-插入数据\" class=\"headerlink\" title=\"4.3 插入数据\"></a>4.3 插入数据</h4><h5 id=\"4-3-1-prepare-execute的方式\"><a href=\"#4-3-1-prepare-execute的方式\" class=\"headerlink\" title=\"4.3.1 prepare + execute的方式\"></a>4.3.1 prepare + execute的方式</h5><p>插入数据也是采用prepare + execute的方式，如果有多个参数，需要进行多次参数绑定。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$name = <span class=\"string\">&#x27;Logan&#x27;</span>;</span><br><span class=\"line\">$age = <span class=\"number\">10</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;insert into users (user_name, age) value (:name, :age)&quot;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:age&#x27;</span>, $age, PDO::PARAM_INT);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br></pre></td></tr></table></figure>\n\n<p>执行后数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  5 | Jovry     |  19 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">| 10 | Logan     |  10 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-修改数据\"><a href=\"#4-4-修改数据\" class=\"headerlink\" title=\"4.4 修改数据\"></a>4.4 修改数据</h4><h5 id=\"4-4-1-prepare-execute方式\"><a href=\"#4-4-1-prepare-execute方式\" class=\"headerlink\" title=\"4.4.1 prepare + execute方式\"></a>4.4.1 prepare + execute方式</h5><p>prepare + execute方式. 修改或删除数据，如果有多个参数,需要进行多次数据绑定.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$name = <span class=\"string\">&#x27;Logan&#x27;</span>;</span><br><span class=\"line\">$age = <span class=\"number\">15</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;update users set age = :age where user_name = :name&quot;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:age&#x27;</span>, $age, PDO::PARAM_INT);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br></pre></td></tr></table></figure>\n<p>执行后数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  5 | Jovry     |  19 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">| 10 | Logan     |  15 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-5-删除数据\"><a href=\"#4-5-删除数据\" class=\"headerlink\" title=\"4.5 删除数据\"></a>4.5 删除数据</h4><h5 id=\"4-5-1-prepare-execute方式\"><a href=\"#4-5-1-prepare-execute方式\" class=\"headerlink\" title=\"4.5.1 prepare + execute方式\"></a>4.5.1 prepare + execute方式</h5><p>prepare + execute方式. 修改或删除数据，如果有多个参数,需要进行多次数据绑定.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$name = <span class=\"string\">&#x27;Logan&#x27;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;delete from users where user_name = :name&quot;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br></pre></td></tr></table></figure>\n<p>执行后数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  5 | Jovry     |  19 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p><strong>其实，通过预编译加上参数绑定方式进行增删改查，就是SQL语句不同，其余的都一样。</strong></p>\n<h4 id=\"4-6-受影响的行\"><a href=\"#4-6-受影响的行\" class=\"headerlink\" title=\"4.6 受影响的行\"></a>4.6 受影响的行</h4><p>通过Statement的rowCount方法可以返回上一次操作影响到行数。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$age = <span class=\"number\">15</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&quot;select * from users where age &gt; :age&quot;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:age&#x27;</span>, $age, PDO::PARAM_INT);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $stmt-&gt;rowCount();</span><br></pre></td></tr></table></figure>\n<p>执行脚本输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-事务支持\"><a href=\"#5-事务支持\" class=\"headerlink\" title=\"5 事务支持\"></a>5 事务支持</h3><p>PDO也支持MySQL事务（transaction），包括start、commit和rollback等。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    $dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class=\"line\">    $dbh-&gt;beginTransaction();  <span class=\"comment\">// 开始事务.</span></span><br><span class=\"line\">    $sql  = <span class=\"string\">&quot;insert into users (user_name, age) values (:name, :age)&quot;</span>;</span><br><span class=\"line\">    $stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">    $stmt-&gt;execute(<span class=\"keyword\">array</span>(<span class=\"string\">&#x27;:name&#x27;</span> =&gt; <span class=\"string\">&#x27;Natasha&#x27;</span>, <span class=\"string\">&#x27;:age&#x27;</span> =&gt; <span class=\"number\">23</span>));</span><br><span class=\"line\">    $id = <span class=\"number\">1</span>;</span><br><span class=\"line\">    $sql = <span class=\"string\">&#x27;delete from users where id = :id&#x27;</span>;</span><br><span class=\"line\">    $stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">    $stmt-&gt;bindParam(<span class=\"string\">&#x27;:id&#x27;</span>, $id, PDO::PARAM_INT);</span><br><span class=\"line\">    $stmt-&gt;execute();</span><br><span class=\"line\">    $dbh-&gt;commit(); <span class=\"comment\">// 提交事务.</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(PDOException $e) &#123;</span><br><span class=\"line\">    $dbh-&gt;rollBack(); <span class=\"comment\">// 回滚事务.</span></span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Error occurred when execute SQL: &quot;</span>, $sql, <span class=\"string\">&quot;&lt;br&gt;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Error info:&lt;br&gt;&quot;</span>, $e-&gt;getMessage();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行后数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from users;</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">| id | user_name | age |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">|  4 | Seven     |  18 |</span><br><span class=\"line\">|  6 | Gordon    |  20 |</span><br><span class=\"line\">| 11 | Natasha   |  23 |</span><br><span class=\"line\">+----+-----------+-----+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-错误处理\"><a href=\"#6-错误处理\" class=\"headerlink\" title=\"6 错误处理\"></a>6 错误处理</h3><p>PDO有3个错误提示等级，分别为<code>POD::ERRMODE_SILENT</code>（默认）、<code>POD::ERRMODE_WARNING</code>和<code>POD::ERRMODE_EXCEPTION</code>。</p>\n<h4 id=\"6-1-POD-ERRMODE-SILENT\"><a href=\"#6-1-POD-ERRMODE-SILENT\" class=\"headerlink\" title=\"6.1 POD::ERRMODE_SILENT\"></a>6.1 POD::ERRMODE_SILENT</h4><p>不显示错误信息，会设置一个错误码，需要检查错误码来判断是否发生错误。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT); <span class=\"comment\">// 问题：默认为POD::ERRMODE_SILENT，但是当未设置错误级别时，php抛出了Fatal error？？？？</span></span><br><span class=\"line\">$name = <span class=\"string\">&#x27;Seven&#x27;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&#x27;SELECT * FROM user WHERE user_name =:name&#x27;</span>;   <span class=\"comment\">// 数据表名有误</span></span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br><span class=\"line\">$code = $stmt-&gt;errorCode();</span><br><span class=\"line\"><span class=\"comment\">//var_dump($code);echo &#x27;&lt;br&gt;&#x27;;   // 输出错误码，string(5) &quot;42S02&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">empty</span>($code)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ($row = $stmt-&gt;fetchObject()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;score&#x27;</span>],<span class=\"string\">&quot;&lt;br&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Error occurred when execut SQL &#x27;</span>, $sql, <span class=\"string\">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;ErrorInfo:&lt;br&gt;&lt;pre&gt;&#x27;</span>;</span><br><span class=\"line\">    var_dump($stmt-&gt;errorInfo());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行脚本结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error occurred when execut SQL SELECT * FROM user WHERE user_name &#x3D;:name&lt;br&gt;ErrorInfo:&lt;br&gt;&lt;pre&gt;array(3) &#123;</span><br><span class=\"line\">  [0]&#x3D;&gt;</span><br><span class=\"line\">  string(5) &quot;42S02&quot;</span><br><span class=\"line\">  [1]&#x3D;&gt;</span><br><span class=\"line\">  int(1146)</span><br><span class=\"line\">  [2]&#x3D;&gt;</span><br><span class=\"line\">  string(32) &quot;Table &#39;seven.user&#39; doesn&#39;t exist&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当未设置错误级别时，输出结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PHP Fatal error:  Uncaught exception &#39;PDOException&#39; with message &#39;SQLSTATE[42S02]: Base table or view not found: 1146 Table &#39;seven.user&#39; doesn&#39;t exist&#39; in &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php:119</span><br><span class=\"line\">Stack trace:</span><br><span class=\"line\">#0 &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php(119): PDOStatement-&gt;execute()</span><br><span class=\"line\">#1 &#123;main&#125;</span><br><span class=\"line\">  thrown in &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php on line 119</span><br></pre></td></tr></table></figure>\n\n<p>注意:<strong>这里的错误是Statement级别的,不是PHP级别,所以需要使用$stmt-&gt;errorInfo()来获取错误信息</strong>.</p>\n<h4 id=\"6-2-PDO-ERRMODE-WARNING\"><a href=\"#6-2-PDO-ERRMODE-WARNING\" class=\"headerlink\" title=\"6.2 PDO::ERRMODE_WARNING\"></a>6.2 PDO::ERRMODE_WARNING</h4><p>该模式下,出错会产生一个PHP的警告(warning), 同时会设置Statement级别和errorinfo.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING);</span><br><span class=\"line\">$name = <span class=\"string\">&quot;Seven&quot;</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">&#x27;SELECT * FROM user WHERE user_name =:name&#x27;</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">$stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br><span class=\"line\">$code = $stmt-&gt;errorCode();</span><br><span class=\"line\"><span class=\"comment\">// var_dump($code);echo &#x27;&lt;br&gt;&#x27;;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">empty</span>($code)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ($row = $stmt-&gt;fetchObject()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;score&#x27;</span>],<span class=\"string\">&quot;&lt;br&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Error occurred when execut SQL &#x27;</span>, $sql, <span class=\"string\">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;ErrorInfo:&lt;br&gt;&lt;pre&gt;&#x27;</span>;</span><br><span class=\"line\">    var_dump($stmt-&gt;errorInfo());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行脚本结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PHP Warning:  PDOStatement::execute(): SQLSTATE[42S02]: Base table or view not found: 1146 Table &#39;seven.user&#39; doesn&#39;t exist in &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php on line 157</span><br><span class=\"line\">Error occurred when execut SQL SELECT * FROM user WHERE user_name &#x3D;:name&lt;br&gt;ErrorInfo:&lt;br&gt;&lt;pre&gt;array(3) &#123;</span><br><span class=\"line\">  [0]&#x3D;&gt;</span><br><span class=\"line\">  string(5) &quot;42S02&quot;</span><br><span class=\"line\">  [1]&#x3D;&gt;</span><br><span class=\"line\">  int(1146)</span><br><span class=\"line\">  [2]&#x3D;&gt;</span><br><span class=\"line\">  string(32) &quot;Table &#39;seven.user&#39; doesn&#39;t exist&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>与SILENT模式相比，多了一个Warning.</strong></p>\n<h4 id=\"6-3-PDO-ERRMODE-EXCEPTION\"><a href=\"#6-3-PDO-ERRMODE-EXCEPTION\" class=\"headerlink\" title=\"6.3 PDO:: ERRMODE_EXCEPTION\"></a>6.3 PDO:: ERRMODE_EXCEPTION</h4><p>在这个模式下，出错会产生一个PHP的错误（PDOException），同时也会设置Statement级别的errorinfo。不过这个时候，我们就可以通过try{…}catch{…}的方式来捕获产生的异常。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class=\"line\">$name = <span class=\"string\">&#x27;Seven&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    $sql = <span class=\"string\">&#x27;SELECT * FROM user WHERE user_name =:name&#x27;</span>;</span><br><span class=\"line\">    $stmt = $dbh-&gt;prepare($sql);</span><br><span class=\"line\">    $stmt-&gt;bindParam(<span class=\"string\">&#x27;:name&#x27;</span>, $name, PDO::PARAM_STR);</span><br><span class=\"line\">    $stmt-&gt;execute();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ($row = $stmt-&gt;fetchObject()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> $row[<span class=\"string\">&#x27;id&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;name&#x27;</span>],<span class=\"string\">&quot;\\t&quot;</span>,$row[<span class=\"string\">&#x27;score&#x27;</span>],<span class=\"string\">&quot;&lt;br&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(PDOException $e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;PDO Exception Caught.&#x27;</span> . <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Error occurred with executed SQL: &#x27;</span>.$sql.<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Error: &#x27;</span> . $e-&gt;getMessage(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Code: &#x27;</span>. $e-&gt;getCode(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;File: &#x27;</span>. $e-&gt;getFile(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Line: &#x27;</span>. $e-&gt;getLine(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;Trace: &#x27;</span>. $e-&gt;getTraceAsString(). <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行脚本结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PDO Exception Caught.</span><br><span class=\"line\">Error occurred with executed SQL: SELECT * FROM user WHERE user_name &#x3D;:name</span><br><span class=\"line\">Error: SQLSTATE[42S02]: Base table or view not found: 1146 Table &#39;seven.user&#39; doesn&#39;t exist</span><br><span class=\"line\">Code: 42S02</span><br><span class=\"line\">File: &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php</span><br><span class=\"line\">Line: 196</span><br><span class=\"line\">Trace: #0 &#x2F;home&#x2F;cdyf&#x2F;tutorial&#x2F;PDO&#x2F;Pdo_test.php(196): PDOStatement-&gt;execute()</span><br><span class=\"line\">#1 &#123;main&#125;</span><br></pre></td></tr></table></figure>\n<p>通过try{…}catch{…}的方式，可以捕获execute时产生的异常，可以跟踪到文件和行数级别。</p>\n<h3 id=\"7-防止SQL注入\"><a href=\"#7-防止SQL注入\" class=\"headerlink\" title=\"7 防止SQL注入\"></a>7 防止SQL注入</h3><ul>\n<li>SQL注入就是攻击者在用户输入的地方输入sql语句从而导致该语句在数据库中执行.</li>\n<li>避免SQL注入的准则: 在外部署据到达数据库之前线对他进行转义.</li>\n</ul>\n<h4 id=\"7-1-query方式防止sql注入方法\"><a href=\"#7-1-query方式防止sql注入方法\" class=\"headerlink\" title=\"7.1 query方式防止sql注入方法\"></a>7.1 query方式防止sql注入方法</h4><p>query方式不能自动转义,需要手动调用$hdb-&gt;quote方法来转.</p>\n<h4 id=\"7-2-预编译方法避免sql注入原理\"><a href=\"#7-2-预编译方法避免sql注入原理\" class=\"headerlink\" title=\"7.2 预编译方法避免sql注入原理\"></a>7.2 预编译方法避免sql注入原理</h4><ul>\n<li>其原理如下:<br>当调用prepare()时，查询语句已经发送给了数据库服务器，此时只有占位符 发送过去，没有用户提交的数据；当调用到execute()时，用户提交过来的值才会传送给数据库，它们是分开传送的，所以不会产生SQL注入的风险。</li>\n</ul>"},{"title":"PHP7内核-Cli","date":"2020-08-21T10:06:04.000Z","_content":"\n\n\n#### 1 简介\nCli（Command line Interface），命令行接口，用于在命令行下执行PHP脚本，类似于Shell那样，是执行PHP脚本最简便的一种方式。\n\n<!--more-->\n\nCli模式通过执行变异的PHP二进制程序即可启动，它定义了很多命令行参数，不同的参数对应不同的处理，例如：\n- 获取cli的参数的帮助文档：`-h参数`\n```\nphp -h\n```\n- 执行PHP脚本文件：`php  脚本名.php`\n```\nphp script.php\n```\n- 直接执行PHP代码： `-r参数`(代码需用引号括起来)\n```\nphp -r \"phpinfo();\"\n```\n- 输出PHP版本：`-v参数`\n```\nphp -v\n```\n- 输出已安装的扩展：`-m参数`\n```php\nphp -m\n```\n- 交互模式运行PHP：`-a参数`\n```php\n$ php -a\nInteractive mode enabled\n\n\nphp > $a = 1;\nphp > $b = 2;\nphp > echo $a + $b;\n3\n```\n#### 2 执行流程\n<u>Cli是单进程模式，处理完请求后就直接关闭了</u>，**生命周期**为：\n\n- ①、`module startup`\n- ②、`request startup`\n- ③、`execute script`\n- ④、`request shutdown`\n- ⑤、`module shurdown`\n\n\n\n处理的关键过程为：\nmain()->php_cli_startup()->do_cli()->php_module_shutdown()\n\n*注：若是查询系统信息之类的请求，如：-v、-m、-i之类的，则不需要经历PHP请求的生命周期。*\n\n\n\n#### 3 Cli模式下获取要运行的PHP代码\n\n##### 3.1 让PHP运行指定文件\n以下两种方法（使用或不使用 -f 参数）都能够运行给定的 my_script.php 文件。可以选择任何文件来运行，**指定的PHP脚本并非必须要以 .php 为扩展名**，它们可以有任意的文件名和扩展名。\n```\nphp my_script.php\n\nphp -f my_script.php\n```\n##### 3.2 载明两行直接运行PHP代码\n使用-r参数引用要执行的代码, 其中代码需要`使用引号括起来`。  \n*注：此种方式下php代码不能添加开始和结束标记符。*\n\n```\nphp -r 'print_r(get_defined_constants());'\n```\n\n##### 3.3 通过标准输入（stdin）提供需要运行的php代码\n使用该方式，可以动态地生成PHP代码并通过命令行运行这些代码\n```\n$ some_application | some_filter | php | sort -u >final_output.txt\n```\n\n##### 3.5 将php脚本作为shell脚本使用\n写一个php脚本，并在第一行以`#！/usr/bin/php`开头，在其后加上以 PHP 开始和结尾标记符包含的正常的 PHP 代码，然后为该文件设置正确的运行属性（例如：`chmod +x test`）。该方法可以使得该文件能够像Shell脚本或 Perl 脚本一样被直接执行。\n\n```\n#!/usr/bin/php\n<?php\n    var_dump($argv);\n?>\n```\n\n假设文件名为test，并放置在当前目录下：\n```\n$ chomod +x test\n$ ./test --foo\narray(2) {\n  [0] =>\n  string(6) \"./test\"\n  [1] =>\n  string(5) \"--foo\"\n}\n\n```\n\n#### 4 内置web服务器\n从PHP5.4.0开始，Cli SAPI提供了一个内置web服务器，这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。  \n详见：[内置Web Server](https://www.php.net/manual/zh/features.commandline.webserver.php)","source":"_posts/PHP7内核-Cli.md","raw":"---\ntitle: PHP7内核-Cli\ndate: 2020-08-21 18:06:04\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n\n\n#### 1 简介\nCli（Command line Interface），命令行接口，用于在命令行下执行PHP脚本，类似于Shell那样，是执行PHP脚本最简便的一种方式。\n\n<!--more-->\n\nCli模式通过执行变异的PHP二进制程序即可启动，它定义了很多命令行参数，不同的参数对应不同的处理，例如：\n- 获取cli的参数的帮助文档：`-h参数`\n```\nphp -h\n```\n- 执行PHP脚本文件：`php  脚本名.php`\n```\nphp script.php\n```\n- 直接执行PHP代码： `-r参数`(代码需用引号括起来)\n```\nphp -r \"phpinfo();\"\n```\n- 输出PHP版本：`-v参数`\n```\nphp -v\n```\n- 输出已安装的扩展：`-m参数`\n```php\nphp -m\n```\n- 交互模式运行PHP：`-a参数`\n```php\n$ php -a\nInteractive mode enabled\n\n\nphp > $a = 1;\nphp > $b = 2;\nphp > echo $a + $b;\n3\n```\n#### 2 执行流程\n<u>Cli是单进程模式，处理完请求后就直接关闭了</u>，**生命周期**为：\n\n- ①、`module startup`\n- ②、`request startup`\n- ③、`execute script`\n- ④、`request shutdown`\n- ⑤、`module shurdown`\n\n\n\n处理的关键过程为：\nmain()->php_cli_startup()->do_cli()->php_module_shutdown()\n\n*注：若是查询系统信息之类的请求，如：-v、-m、-i之类的，则不需要经历PHP请求的生命周期。*\n\n\n\n#### 3 Cli模式下获取要运行的PHP代码\n\n##### 3.1 让PHP运行指定文件\n以下两种方法（使用或不使用 -f 参数）都能够运行给定的 my_script.php 文件。可以选择任何文件来运行，**指定的PHP脚本并非必须要以 .php 为扩展名**，它们可以有任意的文件名和扩展名。\n```\nphp my_script.php\n\nphp -f my_script.php\n```\n##### 3.2 载明两行直接运行PHP代码\n使用-r参数引用要执行的代码, 其中代码需要`使用引号括起来`。  \n*注：此种方式下php代码不能添加开始和结束标记符。*\n\n```\nphp -r 'print_r(get_defined_constants());'\n```\n\n##### 3.3 通过标准输入（stdin）提供需要运行的php代码\n使用该方式，可以动态地生成PHP代码并通过命令行运行这些代码\n```\n$ some_application | some_filter | php | sort -u >final_output.txt\n```\n\n##### 3.5 将php脚本作为shell脚本使用\n写一个php脚本，并在第一行以`#！/usr/bin/php`开头，在其后加上以 PHP 开始和结尾标记符包含的正常的 PHP 代码，然后为该文件设置正确的运行属性（例如：`chmod +x test`）。该方法可以使得该文件能够像Shell脚本或 Perl 脚本一样被直接执行。\n\n```\n#!/usr/bin/php\n<?php\n    var_dump($argv);\n?>\n```\n\n假设文件名为test，并放置在当前目录下：\n```\n$ chomod +x test\n$ ./test --foo\narray(2) {\n  [0] =>\n  string(6) \"./test\"\n  [1] =>\n  string(5) \"--foo\"\n}\n\n```\n\n#### 4 内置web服务器\n从PHP5.4.0开始，Cli SAPI提供了一个内置web服务器，这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。  \n详见：[内置Web Server](https://www.php.net/manual/zh/features.commandline.webserver.php)","slug":"PHP7内核-Cli","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkp002a45g3gcrg6ab4","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>Cli（Command line Interface），命令行接口，用于在命令行下执行PHP脚本，类似于Shell那样，是执行PHP脚本最简便的一种方式。</p>\n<a id=\"more\"></a>\n\n<p>Cli模式通过执行变异的PHP二进制程序即可启动，它定义了很多命令行参数，不同的参数对应不同的处理，例如：</p>\n<ul>\n<li><p>获取cli的参数的帮助文档：<code>-h参数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -h</span><br></pre></td></tr></table></figure></li>\n<li><p>执行PHP脚本文件：<code>php  脚本名.php</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php script.php</span><br></pre></td></tr></table></figure></li>\n<li><p>直接执行PHP代码： <code>-r参数</code>(代码需用引号括起来)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &quot;phpinfo();&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>输出PHP版本：<code>-v参数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -v</span><br></pre></td></tr></table></figure></li>\n<li><p>输出已安装的扩展：<code>-m参数</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -m</span><br></pre></td></tr></table></figure></li>\n<li><p>交互模式运行PHP：<code>-a参数</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ php -a</span><br><span class=\"line\">Interactive mode enabled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">php &gt; $a = <span class=\"number\">1</span>;</span><br><span class=\"line\">php &gt; $b = <span class=\"number\">2</span>;</span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> $a + $b;</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-执行流程\"><a href=\"#2-执行流程\" class=\"headerlink\" title=\"2 执行流程\"></a>2 执行流程</h4><p><u>Cli是单进程模式，处理完请求后就直接关闭了</u>，<strong>生命周期</strong>为：</p>\n</li>\n<li><p>①、<code>module startup</code></p>\n</li>\n<li><p>②、<code>request startup</code></p>\n</li>\n<li><p>③、<code>execute script</code></p>\n</li>\n<li><p>④、<code>request shutdown</code></p>\n</li>\n<li><p>⑤、<code>module shurdown</code></p>\n</li>\n</ul>\n<p>处理的关键过程为：<br>main()-&gt;php_cli_startup()-&gt;do_cli()-&gt;php_module_shutdown()</p>\n<p><em>注：若是查询系统信息之类的请求，如：-v、-m、-i之类的，则不需要经历PHP请求的生命周期。</em></p>\n<h4 id=\"3-Cli模式下获取要运行的PHP代码\"><a href=\"#3-Cli模式下获取要运行的PHP代码\" class=\"headerlink\" title=\"3 Cli模式下获取要运行的PHP代码\"></a>3 Cli模式下获取要运行的PHP代码</h4><h5 id=\"3-1-让PHP运行指定文件\"><a href=\"#3-1-让PHP运行指定文件\" class=\"headerlink\" title=\"3.1 让PHP运行指定文件\"></a>3.1 让PHP运行指定文件</h5><p>以下两种方法（使用或不使用 -f 参数）都能够运行给定的 my_script.php 文件。可以选择任何文件来运行，<strong>指定的PHP脚本并非必须要以 .php 为扩展名</strong>，它们可以有任意的文件名和扩展名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php my_script.php</span><br><span class=\"line\"></span><br><span class=\"line\">php -f my_script.php</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-载明两行直接运行PHP代码\"><a href=\"#3-2-载明两行直接运行PHP代码\" class=\"headerlink\" title=\"3.2 载明两行直接运行PHP代码\"></a>3.2 载明两行直接运行PHP代码</h5><p>使用-r参数引用要执行的代码, 其中代码需要<code>使用引号括起来</code>。<br><em>注：此种方式下php代码不能添加开始和结束标记符。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &#39;print_r(get_defined_constants());&#39;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-3-通过标准输入（stdin）提供需要运行的php代码\"><a href=\"#3-3-通过标准输入（stdin）提供需要运行的php代码\" class=\"headerlink\" title=\"3.3 通过标准输入（stdin）提供需要运行的php代码\"></a>3.3 通过标准输入（stdin）提供需要运行的php代码</h5><p>使用该方式，可以动态地生成PHP代码并通过命令行运行这些代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ some_application | some_filter | php | sort -u &gt;final_output.txt</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-5-将php脚本作为shell脚本使用\"><a href=\"#3-5-将php脚本作为shell脚本使用\" class=\"headerlink\" title=\"3.5 将php脚本作为shell脚本使用\"></a>3.5 将php脚本作为shell脚本使用</h5><p>写一个php脚本，并在第一行以<code>#！/usr/bin/php</code>开头，在其后加上以 PHP 开始和结尾标记符包含的正常的 PHP 代码，然后为该文件设置正确的运行属性（例如：<code>chmod +x test</code>）。该方法可以使得该文件能够像Shell脚本或 Perl 脚本一样被直接执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">    var_dump($argv);</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>假设文件名为test，并放置在当前目录下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chomod +x test</span><br><span class=\"line\">$ .&#x2F;test --foo</span><br><span class=\"line\">array(2) &#123;</span><br><span class=\"line\">  [0] &#x3D;&gt;</span><br><span class=\"line\">  string(6) &quot;.&#x2F;test&quot;</span><br><span class=\"line\">  [1] &#x3D;&gt;</span><br><span class=\"line\">  string(5) &quot;--foo&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-内置web服务器\"><a href=\"#4-内置web服务器\" class=\"headerlink\" title=\"4 内置web服务器\"></a>4 内置web服务器</h4><p>从PHP5.4.0开始，Cli SAPI提供了一个内置web服务器，这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。<br>详见：<a href=\"https://www.php.net/manual/zh/features.commandline.webserver.php\">内置Web Server</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>Cli（Command line Interface），命令行接口，用于在命令行下执行PHP脚本，类似于Shell那样，是执行PHP脚本最简便的一种方式。</p>","more":"<p>Cli模式通过执行变异的PHP二进制程序即可启动，它定义了很多命令行参数，不同的参数对应不同的处理，例如：</p>\n<ul>\n<li><p>获取cli的参数的帮助文档：<code>-h参数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -h</span><br></pre></td></tr></table></figure></li>\n<li><p>执行PHP脚本文件：<code>php  脚本名.php</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php script.php</span><br></pre></td></tr></table></figure></li>\n<li><p>直接执行PHP代码： <code>-r参数</code>(代码需用引号括起来)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &quot;phpinfo();&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>输出PHP版本：<code>-v参数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -v</span><br></pre></td></tr></table></figure></li>\n<li><p>输出已安装的扩展：<code>-m参数</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -m</span><br></pre></td></tr></table></figure></li>\n<li><p>交互模式运行PHP：<code>-a参数</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ php -a</span><br><span class=\"line\">Interactive mode enabled</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">php &gt; $a = <span class=\"number\">1</span>;</span><br><span class=\"line\">php &gt; $b = <span class=\"number\">2</span>;</span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> $a + $b;</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-执行流程\"><a href=\"#2-执行流程\" class=\"headerlink\" title=\"2 执行流程\"></a>2 执行流程</h4><p><u>Cli是单进程模式，处理完请求后就直接关闭了</u>，<strong>生命周期</strong>为：</p>\n</li>\n<li><p>①、<code>module startup</code></p>\n</li>\n<li><p>②、<code>request startup</code></p>\n</li>\n<li><p>③、<code>execute script</code></p>\n</li>\n<li><p>④、<code>request shutdown</code></p>\n</li>\n<li><p>⑤、<code>module shurdown</code></p>\n</li>\n</ul>\n<p>处理的关键过程为：<br>main()-&gt;php_cli_startup()-&gt;do_cli()-&gt;php_module_shutdown()</p>\n<p><em>注：若是查询系统信息之类的请求，如：-v、-m、-i之类的，则不需要经历PHP请求的生命周期。</em></p>\n<h4 id=\"3-Cli模式下获取要运行的PHP代码\"><a href=\"#3-Cli模式下获取要运行的PHP代码\" class=\"headerlink\" title=\"3 Cli模式下获取要运行的PHP代码\"></a>3 Cli模式下获取要运行的PHP代码</h4><h5 id=\"3-1-让PHP运行指定文件\"><a href=\"#3-1-让PHP运行指定文件\" class=\"headerlink\" title=\"3.1 让PHP运行指定文件\"></a>3.1 让PHP运行指定文件</h5><p>以下两种方法（使用或不使用 -f 参数）都能够运行给定的 my_script.php 文件。可以选择任何文件来运行，<strong>指定的PHP脚本并非必须要以 .php 为扩展名</strong>，它们可以有任意的文件名和扩展名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php my_script.php</span><br><span class=\"line\"></span><br><span class=\"line\">php -f my_script.php</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-载明两行直接运行PHP代码\"><a href=\"#3-2-载明两行直接运行PHP代码\" class=\"headerlink\" title=\"3.2 载明两行直接运行PHP代码\"></a>3.2 载明两行直接运行PHP代码</h5><p>使用-r参数引用要执行的代码, 其中代码需要<code>使用引号括起来</code>。<br><em>注：此种方式下php代码不能添加开始和结束标记符。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -r &#39;print_r(get_defined_constants());&#39;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-3-通过标准输入（stdin）提供需要运行的php代码\"><a href=\"#3-3-通过标准输入（stdin）提供需要运行的php代码\" class=\"headerlink\" title=\"3.3 通过标准输入（stdin）提供需要运行的php代码\"></a>3.3 通过标准输入（stdin）提供需要运行的php代码</h5><p>使用该方式，可以动态地生成PHP代码并通过命令行运行这些代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ some_application | some_filter | php | sort -u &gt;final_output.txt</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-5-将php脚本作为shell脚本使用\"><a href=\"#3-5-将php脚本作为shell脚本使用\" class=\"headerlink\" title=\"3.5 将php脚本作为shell脚本使用\"></a>3.5 将php脚本作为shell脚本使用</h5><p>写一个php脚本，并在第一行以<code>#！/usr/bin/php</code>开头，在其后加上以 PHP 开始和结尾标记符包含的正常的 PHP 代码，然后为该文件设置正确的运行属性（例如：<code>chmod +x test</code>）。该方法可以使得该文件能够像Shell脚本或 Perl 脚本一样被直接执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">    var_dump($argv);</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>假设文件名为test，并放置在当前目录下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chomod +x test</span><br><span class=\"line\">$ .&#x2F;test --foo</span><br><span class=\"line\">array(2) &#123;</span><br><span class=\"line\">  [0] &#x3D;&gt;</span><br><span class=\"line\">  string(6) &quot;.&#x2F;test&quot;</span><br><span class=\"line\">  [1] &#x3D;&gt;</span><br><span class=\"line\">  string(5) &quot;--foo&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-内置web服务器\"><a href=\"#4-内置web服务器\" class=\"headerlink\" title=\"4 内置web服务器\"></a>4 内置web服务器</h4><p>从PHP5.4.0开始，Cli SAPI提供了一个内置web服务器，这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。<br>详见：<a href=\"https://www.php.net/manual/zh/features.commandline.webserver.php\">内置Web Server</a></p>"},{"title":"Protobuf简介及安装","date":"2020-08-25T08:14:48.000Z","_content":"\n#### 1 简介\n\nProtobuf是谷歌的开源序列化协议框架，结构类似于XML，JSON这种，显著的特点是二进制的，效率高，主要用于通信协议和数据存储等方面，算是一种结构化数据的表示方法。\n\n<!--more-->\n\n#### 2 安装方法\n\n##### 2.1 Ubuntu下安装\n\n- 要编译安装protobuf，首先需要安装以下必要的工具.\n\n  安装方法：\n\n```bash\nsudo apt-get install autoconf automake libtool curl make g++ unzip\n```\n\n- 获取源文件\n\n  - 方法一：直接下载发行版\n\n    [下载地址](https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4)\n\n  - 方法二：通过git clone下载 \n\n    ```bash\n    git clone https://github.com/protocolbuffers/protobuf.git cd protobuf git submodule update --init --recursive ./autogen.sh\n    ```\n\n  - 编译安装C++ Protocal Buffer运行时和Protocal Buffer编译器（protoc）\n\n    ```bash\n    ./configure make make check sudo make install sudo ldconfig # refresh shared library cache.\n    ```\n\n    *注：默认安装位置为：*\n\n    ```bash\n    /usr/local\n    ```\n\n    可通过以下命令指定安装路径\n\n    ```bash\n    ./configure --prefix=/usr\n    ```\n\n  - 查看是否安装成功\n  \n    ```bash\n    protoc --version\n    ```\n  \n\n\n#### 参考资料\n\n1. [protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf/tree/master/php)\n\n2. [Protobuf 小试牛刀](https://www.cnblogs.com/52fhy/p/11106670.html)\n\n3. [protobuf简单介绍和ubuntu 16.04环境下安装](https://blog.csdn.net/kdchxue/article/details/81046192)","source":"_posts/Protobuf简介及安装.md","raw":"---\ntitle: Protobuf简介及安装\ndate: 2020-08-25 16:14:48\ntags: [\"Protobuf\"]\ncategories: [\"Protobuf\"]\n---\n\n#### 1 简介\n\nProtobuf是谷歌的开源序列化协议框架，结构类似于XML，JSON这种，显著的特点是二进制的，效率高，主要用于通信协议和数据存储等方面，算是一种结构化数据的表示方法。\n\n<!--more-->\n\n#### 2 安装方法\n\n##### 2.1 Ubuntu下安装\n\n- 要编译安装protobuf，首先需要安装以下必要的工具.\n\n  安装方法：\n\n```bash\nsudo apt-get install autoconf automake libtool curl make g++ unzip\n```\n\n- 获取源文件\n\n  - 方法一：直接下载发行版\n\n    [下载地址](https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4)\n\n  - 方法二：通过git clone下载 \n\n    ```bash\n    git clone https://github.com/protocolbuffers/protobuf.git cd protobuf git submodule update --init --recursive ./autogen.sh\n    ```\n\n  - 编译安装C++ Protocal Buffer运行时和Protocal Buffer编译器（protoc）\n\n    ```bash\n    ./configure make make check sudo make install sudo ldconfig # refresh shared library cache.\n    ```\n\n    *注：默认安装位置为：*\n\n    ```bash\n    /usr/local\n    ```\n\n    可通过以下命令指定安装路径\n\n    ```bash\n    ./configure --prefix=/usr\n    ```\n\n  - 查看是否安装成功\n  \n    ```bash\n    protoc --version\n    ```\n  \n\n\n#### 参考资料\n\n1. [protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf/tree/master/php)\n\n2. [Protobuf 小试牛刀](https://www.cnblogs.com/52fhy/p/11106670.html)\n\n3. [protobuf简单介绍和ubuntu 16.04环境下安装](https://blog.csdn.net/kdchxue/article/details/81046192)","slug":"Protobuf简介及安装","published":1,"updated":"2020-09-17T08:14:33.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkq002c45g33a3mhoay","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>Protobuf是谷歌的开源序列化协议框架，结构类似于XML，JSON这种，显著的特点是二进制的，效率高，主要用于通信协议和数据存储等方面，算是一种结构化数据的表示方法。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"2-安装方法\"><a href=\"#2-安装方法\" class=\"headerlink\" title=\"2 安装方法\"></a>2 安装方法</h4><h5 id=\"2-1-Ubuntu下安装\"><a href=\"#2-1-Ubuntu下安装\" class=\"headerlink\" title=\"2.1 Ubuntu下安装\"></a>2.1 Ubuntu下安装</h5><ul>\n<li><p>要编译安装protobuf，首先需要安装以下必要的工具.</p>\n<p>安装方法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install autoconf automake libtool curl make g++ unzip</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>获取源文件</p>\n<ul>\n<li><p>方法一：直接下载发行版</p>\n<p><a href=\"https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4\">下载地址</a></p>\n</li>\n<li><p>方法二：通过git clone下载 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/protocolbuffers/protobuf.git <span class=\"built_in\">cd</span> protobuf git submodule update --init --recursive ./autogen.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译安装C++ Protocal Buffer运行时和Protocal Buffer编译器（protoc）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure make make check sudo make install sudo ldconfig <span class=\"comment\"># refresh shared library cache.</span></span><br></pre></td></tr></table></figure>\n\n<p><em>注：默认安装位置为：</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/<span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n\n<p>可通过以下命令指定安装路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --version</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><p><a href=\"https://github.com/protocolbuffers/protobuf/tree/master/php\">protocolbuffers/protobuf</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/52fhy/p/11106670.html\">Protobuf 小试牛刀</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/kdchxue/article/details/81046192\">protobuf简单介绍和ubuntu 16.04环境下安装</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>Protobuf是谷歌的开源序列化协议框架，结构类似于XML，JSON这种，显著的特点是二进制的，效率高，主要用于通信协议和数据存储等方面，算是一种结构化数据的表示方法。</p>","more":"<h4 id=\"2-安装方法\"><a href=\"#2-安装方法\" class=\"headerlink\" title=\"2 安装方法\"></a>2 安装方法</h4><h5 id=\"2-1-Ubuntu下安装\"><a href=\"#2-1-Ubuntu下安装\" class=\"headerlink\" title=\"2.1 Ubuntu下安装\"></a>2.1 Ubuntu下安装</h5><ul>\n<li><p>要编译安装protobuf，首先需要安装以下必要的工具.</p>\n<p>安装方法：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install autoconf automake libtool curl make g++ unzip</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>获取源文件</p>\n<ul>\n<li><p>方法一：直接下载发行版</p>\n<p><a href=\"https://github.com/protocolbuffers/protobuf/releases/tag/v3.11.4\">下载地址</a></p>\n</li>\n<li><p>方法二：通过git clone下载 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/protocolbuffers/protobuf.git <span class=\"built_in\">cd</span> protobuf git submodule update --init --recursive ./autogen.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译安装C++ Protocal Buffer运行时和Protocal Buffer编译器（protoc）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure make make check sudo make install sudo ldconfig <span class=\"comment\"># refresh shared library cache.</span></span><br></pre></td></tr></table></figure>\n\n<p><em>注：默认安装位置为：</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/<span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n\n<p>可通过以下命令指定安装路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --version</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><p><a href=\"https://github.com/protocolbuffers/protobuf/tree/master/php\">protocolbuffers/protobuf</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/52fhy/p/11106670.html\">Protobuf 小试牛刀</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/kdchxue/article/details/81046192\">protobuf简单介绍和ubuntu 16.04环境下安装</a></p>\n</li>\n</ol>"},{"title":"Redis-踩坑记录","date":"2020-09-04T02:54:33.000Z","_content":"\n记录一些平时遇到的Redis的坑...\n\n<!--more-->\n\n### 1 Bitmap使用踩坑\n\n#### 1.1 引入\n\n最近在做RTA功能，实现精准投放，主要流程是媒体平台将用户加密设备号下发给广告主，广告主根据自有数据，对设备号进行过滤，并返回投放竞价信息, 实现个性化用户筛选(是否参与竞价)及流量实时优选(根据返回信息实现优选).\n\n#### 1.2 问题\n\n- 媒体平台对RTA接口响应要求高(例如,广点通限制请求响应时间在60ms之内),其中网络耗时已经高达40到50ms,因此,对于我们提供的RTA接口的逻辑处理时间必须限制在10到15ms之内.\n- QPS高达15W,若直接丛数据库查询,将导致数据库实例单机负载高,查询速度降低.\n- 现在用户设备号数量约为2.3亿.\n\n\n\n#### 1.3 解决方案\n\n考虑其响应时间限制,使用Redis存储的方案，减少直接的DB访问,提高响应速度。\n\n- - 方案一：使用bitmap方式进行存储\n  - 方案二：将设备信息通过key-value方式存储。\n\n\n\n##### 1.3.1 使用bitmap方式进行存储\n\n思路: bitmap中bit映射被限制在512M之内，所以最大为32位，即offset最大为‭2^(32)-1 (即4294967295)‬，对于2.3亿多的数据直接通过一个key就能存储。\n\n媒体平台推送过来的设备号是md5加密后的imei或者idfa，是128位（16字节）的散列值。而offset应该为整数，因此需将设备号转换为唯一对应的整型数值。但查询了一堆资料均没有找到方法直接转换。\n\n考虑使用CRC32方式，对设备号进行转换，然后将crc32的结果作为offset，为了减少冲突，将设备号的最后3位拼接在key上，即key的数量为4096个。\n\n问题来了，crc32的结果非常大，导致一个key的内存占用高达几百兆，DBA分配的测试集群一共20G，只写入了73个key，内存就满了。。。\n\n后续是将设备号的最后1位拼接在key上，即key的数量为16个，这样能保证内存占用少（16个key对应的内存占用最大为：8G）。\n\n但是新的问题又来了，由于key的数量减少了，可能导致所有的key都被哈希到一个分片，且还是无法保证其唯一性。另外crc32转换为数字方式仍然有冲突的风险。\n\n\n\n##### 1.3.2 使用key-value的方式\n\n之前因为2亿的数据，担心内存占用太大，但在后续测试过程中，发现10000条数据写入占用1.11M，即2亿占用内存大约为20多G，是在能接收的范围，且数据可靠。\n\n### 1.4 总结：\n\n`bitmap的offset需要数字方式或者能转换为数字形式，且offset应该尽可能小！！！！`\n\n\n\n### 2 Redis 热键访问\n\n#### 2.1 引入\n\n也是处理RTA逻辑,在公司内部处理逻辑中,需要根据用户设备命中的策略,返回相应的排除竞价的账户id.\n\n#### 2.2 问题\n\n由于QPS过高，直接通过查询数据库，对数据库造成的压力大,DBA同学开始找麻烦了...\n\n#### 2.3 解决\n\n在数据库层之前增加一层缓存层,优先从缓存中获取数据,若数据不存在,再查询数据库,并写入缓存.从而减少数据库压力.账户信息属于变动不频繁的数据, 设置1小时的过期时间,期间的数据不一致,尚且可以接收.\n\n\n\n#### 2.4 踩坑\n\n目前公司对接了多个渠道的RTA,例如,头条的穿山甲,腾讯的广点通,华为的Ads等等,每个渠道的账户均不同,因此将账户id写入缓存时是以渠道为key,即一个渠道对应一个key.每个请求过来时均会获取该渠道的账户信息.\n\n此时,在高QPS的下,Redis key分布不均匀,造成一个实例负载非常高,读缓存时长增加,整体响应时间增加,造成大量请求超时的情况.\n\n##### 2.4.1 解决\n\n多设置几个key，使redis分布均匀...\n\n\n\n### 参考资料\n\n[一看就懂系列之 详解redis的bitmap在亿级项目中的应用](https://blog.csdn.net/u011957758/article/details/74783347)\n\n[精准营销系列:RTA投放](https://zhuanlan.zhihu.com/p/103574447)\n\n","source":"_posts/Redis-踩坑记录.md","raw":"---\ntitle: Redis-踩坑记录\ndate: 2020-09-04 10:54:33\ntags: [\"Redis\"]\ncategories: [\"Redis\"]\n---\n\n记录一些平时遇到的Redis的坑...\n\n<!--more-->\n\n### 1 Bitmap使用踩坑\n\n#### 1.1 引入\n\n最近在做RTA功能，实现精准投放，主要流程是媒体平台将用户加密设备号下发给广告主，广告主根据自有数据，对设备号进行过滤，并返回投放竞价信息, 实现个性化用户筛选(是否参与竞价)及流量实时优选(根据返回信息实现优选).\n\n#### 1.2 问题\n\n- 媒体平台对RTA接口响应要求高(例如,广点通限制请求响应时间在60ms之内),其中网络耗时已经高达40到50ms,因此,对于我们提供的RTA接口的逻辑处理时间必须限制在10到15ms之内.\n- QPS高达15W,若直接丛数据库查询,将导致数据库实例单机负载高,查询速度降低.\n- 现在用户设备号数量约为2.3亿.\n\n\n\n#### 1.3 解决方案\n\n考虑其响应时间限制,使用Redis存储的方案，减少直接的DB访问,提高响应速度。\n\n- - 方案一：使用bitmap方式进行存储\n  - 方案二：将设备信息通过key-value方式存储。\n\n\n\n##### 1.3.1 使用bitmap方式进行存储\n\n思路: bitmap中bit映射被限制在512M之内，所以最大为32位，即offset最大为‭2^(32)-1 (即4294967295)‬，对于2.3亿多的数据直接通过一个key就能存储。\n\n媒体平台推送过来的设备号是md5加密后的imei或者idfa，是128位（16字节）的散列值。而offset应该为整数，因此需将设备号转换为唯一对应的整型数值。但查询了一堆资料均没有找到方法直接转换。\n\n考虑使用CRC32方式，对设备号进行转换，然后将crc32的结果作为offset，为了减少冲突，将设备号的最后3位拼接在key上，即key的数量为4096个。\n\n问题来了，crc32的结果非常大，导致一个key的内存占用高达几百兆，DBA分配的测试集群一共20G，只写入了73个key，内存就满了。。。\n\n后续是将设备号的最后1位拼接在key上，即key的数量为16个，这样能保证内存占用少（16个key对应的内存占用最大为：8G）。\n\n但是新的问题又来了，由于key的数量减少了，可能导致所有的key都被哈希到一个分片，且还是无法保证其唯一性。另外crc32转换为数字方式仍然有冲突的风险。\n\n\n\n##### 1.3.2 使用key-value的方式\n\n之前因为2亿的数据，担心内存占用太大，但在后续测试过程中，发现10000条数据写入占用1.11M，即2亿占用内存大约为20多G，是在能接收的范围，且数据可靠。\n\n### 1.4 总结：\n\n`bitmap的offset需要数字方式或者能转换为数字形式，且offset应该尽可能小！！！！`\n\n\n\n### 2 Redis 热键访问\n\n#### 2.1 引入\n\n也是处理RTA逻辑,在公司内部处理逻辑中,需要根据用户设备命中的策略,返回相应的排除竞价的账户id.\n\n#### 2.2 问题\n\n由于QPS过高，直接通过查询数据库，对数据库造成的压力大,DBA同学开始找麻烦了...\n\n#### 2.3 解决\n\n在数据库层之前增加一层缓存层,优先从缓存中获取数据,若数据不存在,再查询数据库,并写入缓存.从而减少数据库压力.账户信息属于变动不频繁的数据, 设置1小时的过期时间,期间的数据不一致,尚且可以接收.\n\n\n\n#### 2.4 踩坑\n\n目前公司对接了多个渠道的RTA,例如,头条的穿山甲,腾讯的广点通,华为的Ads等等,每个渠道的账户均不同,因此将账户id写入缓存时是以渠道为key,即一个渠道对应一个key.每个请求过来时均会获取该渠道的账户信息.\n\n此时,在高QPS的下,Redis key分布不均匀,造成一个实例负载非常高,读缓存时长增加,整体响应时间增加,造成大量请求超时的情况.\n\n##### 2.4.1 解决\n\n多设置几个key，使redis分布均匀...\n\n\n\n### 参考资料\n\n[一看就懂系列之 详解redis的bitmap在亿级项目中的应用](https://blog.csdn.net/u011957758/article/details/74783347)\n\n[精准营销系列:RTA投放](https://zhuanlan.zhihu.com/p/103574447)\n\n","slug":"Redis-踩坑记录","published":1,"updated":"2020-09-04T03:58:52.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabks002h45g373ts8rvr","content":"<p>记录一些平时遇到的Redis的坑…</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-Bitmap使用踩坑\"><a href=\"#1-Bitmap使用踩坑\" class=\"headerlink\" title=\"1 Bitmap使用踩坑\"></a>1 Bitmap使用踩坑</h3><h4 id=\"1-1-引入\"><a href=\"#1-1-引入\" class=\"headerlink\" title=\"1.1 引入\"></a>1.1 引入</h4><p>最近在做RTA功能，实现精准投放，主要流程是媒体平台将用户加密设备号下发给广告主，广告主根据自有数据，对设备号进行过滤，并返回投放竞价信息, 实现个性化用户筛选(是否参与竞价)及流量实时优选(根据返回信息实现优选).</p>\n<h4 id=\"1-2-问题\"><a href=\"#1-2-问题\" class=\"headerlink\" title=\"1.2 问题\"></a>1.2 问题</h4><ul>\n<li>媒体平台对RTA接口响应要求高(例如,广点通限制请求响应时间在60ms之内),其中网络耗时已经高达40到50ms,因此,对于我们提供的RTA接口的逻辑处理时间必须限制在10到15ms之内.</li>\n<li>QPS高达15W,若直接丛数据库查询,将导致数据库实例单机负载高,查询速度降低.</li>\n<li>现在用户设备号数量约为2.3亿.</li>\n</ul>\n<h4 id=\"1-3-解决方案\"><a href=\"#1-3-解决方案\" class=\"headerlink\" title=\"1.3 解决方案\"></a>1.3 解决方案</h4><p>考虑其响应时间限制,使用Redis存储的方案，减少直接的DB访问,提高响应速度。</p>\n<ul>\n<li><ul>\n<li>方案一：使用bitmap方式进行存储</li>\n<li>方案二：将设备信息通过key-value方式存储。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"1-3-1-使用bitmap方式进行存储\"><a href=\"#1-3-1-使用bitmap方式进行存储\" class=\"headerlink\" title=\"1.3.1 使用bitmap方式进行存储\"></a>1.3.1 使用bitmap方式进行存储</h5><p>思路: bitmap中bit映射被限制在512M之内，所以最大为32位，即offset最大为‭2^(32)-1 (即4294967295)‬，对于2.3亿多的数据直接通过一个key就能存储。</p>\n<p>媒体平台推送过来的设备号是md5加密后的imei或者idfa，是128位（16字节）的散列值。而offset应该为整数，因此需将设备号转换为唯一对应的整型数值。但查询了一堆资料均没有找到方法直接转换。</p>\n<p>考虑使用CRC32方式，对设备号进行转换，然后将crc32的结果作为offset，为了减少冲突，将设备号的最后3位拼接在key上，即key的数量为4096个。</p>\n<p>问题来了，crc32的结果非常大，导致一个key的内存占用高达几百兆，DBA分配的测试集群一共20G，只写入了73个key，内存就满了。。。</p>\n<p>后续是将设备号的最后1位拼接在key上，即key的数量为16个，这样能保证内存占用少（16个key对应的内存占用最大为：8G）。</p>\n<p>但是新的问题又来了，由于key的数量减少了，可能导致所有的key都被哈希到一个分片，且还是无法保证其唯一性。另外crc32转换为数字方式仍然有冲突的风险。</p>\n<h5 id=\"1-3-2-使用key-value的方式\"><a href=\"#1-3-2-使用key-value的方式\" class=\"headerlink\" title=\"1.3.2 使用key-value的方式\"></a>1.3.2 使用key-value的方式</h5><p>之前因为2亿的数据，担心内存占用太大，但在后续测试过程中，发现10000条数据写入占用1.11M，即2亿占用内存大约为20多G，是在能接收的范围，且数据可靠。</p>\n<h3 id=\"1-4-总结：\"><a href=\"#1-4-总结：\" class=\"headerlink\" title=\"1.4 总结：\"></a>1.4 总结：</h3><p><code>bitmap的offset需要数字方式或者能转换为数字形式，且offset应该尽可能小！！！！</code></p>\n<h3 id=\"2-Redis-热键访问\"><a href=\"#2-Redis-热键访问\" class=\"headerlink\" title=\"2 Redis 热键访问\"></a>2 Redis 热键访问</h3><h4 id=\"2-1-引入\"><a href=\"#2-1-引入\" class=\"headerlink\" title=\"2.1 引入\"></a>2.1 引入</h4><p>也是处理RTA逻辑,在公司内部处理逻辑中,需要根据用户设备命中的策略,返回相应的排除竞价的账户id.</p>\n<h4 id=\"2-2-问题\"><a href=\"#2-2-问题\" class=\"headerlink\" title=\"2.2 问题\"></a>2.2 问题</h4><p>由于QPS过高，直接通过查询数据库，对数据库造成的压力大,DBA同学开始找麻烦了…</p>\n<h4 id=\"2-3-解决\"><a href=\"#2-3-解决\" class=\"headerlink\" title=\"2.3 解决\"></a>2.3 解决</h4><p>在数据库层之前增加一层缓存层,优先从缓存中获取数据,若数据不存在,再查询数据库,并写入缓存.从而减少数据库压力.账户信息属于变动不频繁的数据, 设置1小时的过期时间,期间的数据不一致,尚且可以接收.</p>\n<h4 id=\"2-4-踩坑\"><a href=\"#2-4-踩坑\" class=\"headerlink\" title=\"2.4 踩坑\"></a>2.4 踩坑</h4><p>目前公司对接了多个渠道的RTA,例如,头条的穿山甲,腾讯的广点通,华为的Ads等等,每个渠道的账户均不同,因此将账户id写入缓存时是以渠道为key,即一个渠道对应一个key.每个请求过来时均会获取该渠道的账户信息.</p>\n<p>此时,在高QPS的下,Redis key分布不均匀,造成一个实例负载非常高,读缓存时长增加,整体响应时间增加,造成大量请求超时的情况.</p>\n<h5 id=\"2-4-1-解决\"><a href=\"#2-4-1-解决\" class=\"headerlink\" title=\"2.4.1 解决\"></a>2.4.1 解决</h5><p>多设置几个key，使redis分布均匀…</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/u011957758/article/details/74783347\">一看就懂系列之 详解redis的bitmap在亿级项目中的应用</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/103574447\">精准营销系列:RTA投放</a></p>\n","site":{"data":{}},"excerpt":"<p>记录一些平时遇到的Redis的坑…</p>","more":"<h3 id=\"1-Bitmap使用踩坑\"><a href=\"#1-Bitmap使用踩坑\" class=\"headerlink\" title=\"1 Bitmap使用踩坑\"></a>1 Bitmap使用踩坑</h3><h4 id=\"1-1-引入\"><a href=\"#1-1-引入\" class=\"headerlink\" title=\"1.1 引入\"></a>1.1 引入</h4><p>最近在做RTA功能，实现精准投放，主要流程是媒体平台将用户加密设备号下发给广告主，广告主根据自有数据，对设备号进行过滤，并返回投放竞价信息, 实现个性化用户筛选(是否参与竞价)及流量实时优选(根据返回信息实现优选).</p>\n<h4 id=\"1-2-问题\"><a href=\"#1-2-问题\" class=\"headerlink\" title=\"1.2 问题\"></a>1.2 问题</h4><ul>\n<li>媒体平台对RTA接口响应要求高(例如,广点通限制请求响应时间在60ms之内),其中网络耗时已经高达40到50ms,因此,对于我们提供的RTA接口的逻辑处理时间必须限制在10到15ms之内.</li>\n<li>QPS高达15W,若直接丛数据库查询,将导致数据库实例单机负载高,查询速度降低.</li>\n<li>现在用户设备号数量约为2.3亿.</li>\n</ul>\n<h4 id=\"1-3-解决方案\"><a href=\"#1-3-解决方案\" class=\"headerlink\" title=\"1.3 解决方案\"></a>1.3 解决方案</h4><p>考虑其响应时间限制,使用Redis存储的方案，减少直接的DB访问,提高响应速度。</p>\n<ul>\n<li><ul>\n<li>方案一：使用bitmap方式进行存储</li>\n<li>方案二：将设备信息通过key-value方式存储。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"1-3-1-使用bitmap方式进行存储\"><a href=\"#1-3-1-使用bitmap方式进行存储\" class=\"headerlink\" title=\"1.3.1 使用bitmap方式进行存储\"></a>1.3.1 使用bitmap方式进行存储</h5><p>思路: bitmap中bit映射被限制在512M之内，所以最大为32位，即offset最大为‭2^(32)-1 (即4294967295)‬，对于2.3亿多的数据直接通过一个key就能存储。</p>\n<p>媒体平台推送过来的设备号是md5加密后的imei或者idfa，是128位（16字节）的散列值。而offset应该为整数，因此需将设备号转换为唯一对应的整型数值。但查询了一堆资料均没有找到方法直接转换。</p>\n<p>考虑使用CRC32方式，对设备号进行转换，然后将crc32的结果作为offset，为了减少冲突，将设备号的最后3位拼接在key上，即key的数量为4096个。</p>\n<p>问题来了，crc32的结果非常大，导致一个key的内存占用高达几百兆，DBA分配的测试集群一共20G，只写入了73个key，内存就满了。。。</p>\n<p>后续是将设备号的最后1位拼接在key上，即key的数量为16个，这样能保证内存占用少（16个key对应的内存占用最大为：8G）。</p>\n<p>但是新的问题又来了，由于key的数量减少了，可能导致所有的key都被哈希到一个分片，且还是无法保证其唯一性。另外crc32转换为数字方式仍然有冲突的风险。</p>\n<h5 id=\"1-3-2-使用key-value的方式\"><a href=\"#1-3-2-使用key-value的方式\" class=\"headerlink\" title=\"1.3.2 使用key-value的方式\"></a>1.3.2 使用key-value的方式</h5><p>之前因为2亿的数据，担心内存占用太大，但在后续测试过程中，发现10000条数据写入占用1.11M，即2亿占用内存大约为20多G，是在能接收的范围，且数据可靠。</p>\n<h3 id=\"1-4-总结：\"><a href=\"#1-4-总结：\" class=\"headerlink\" title=\"1.4 总结：\"></a>1.4 总结：</h3><p><code>bitmap的offset需要数字方式或者能转换为数字形式，且offset应该尽可能小！！！！</code></p>\n<h3 id=\"2-Redis-热键访问\"><a href=\"#2-Redis-热键访问\" class=\"headerlink\" title=\"2 Redis 热键访问\"></a>2 Redis 热键访问</h3><h4 id=\"2-1-引入\"><a href=\"#2-1-引入\" class=\"headerlink\" title=\"2.1 引入\"></a>2.1 引入</h4><p>也是处理RTA逻辑,在公司内部处理逻辑中,需要根据用户设备命中的策略,返回相应的排除竞价的账户id.</p>\n<h4 id=\"2-2-问题\"><a href=\"#2-2-问题\" class=\"headerlink\" title=\"2.2 问题\"></a>2.2 问题</h4><p>由于QPS过高，直接通过查询数据库，对数据库造成的压力大,DBA同学开始找麻烦了…</p>\n<h4 id=\"2-3-解决\"><a href=\"#2-3-解决\" class=\"headerlink\" title=\"2.3 解决\"></a>2.3 解决</h4><p>在数据库层之前增加一层缓存层,优先从缓存中获取数据,若数据不存在,再查询数据库,并写入缓存.从而减少数据库压力.账户信息属于变动不频繁的数据, 设置1小时的过期时间,期间的数据不一致,尚且可以接收.</p>\n<h4 id=\"2-4-踩坑\"><a href=\"#2-4-踩坑\" class=\"headerlink\" title=\"2.4 踩坑\"></a>2.4 踩坑</h4><p>目前公司对接了多个渠道的RTA,例如,头条的穿山甲,腾讯的广点通,华为的Ads等等,每个渠道的账户均不同,因此将账户id写入缓存时是以渠道为key,即一个渠道对应一个key.每个请求过来时均会获取该渠道的账户信息.</p>\n<p>此时,在高QPS的下,Redis key分布不均匀,造成一个实例负载非常高,读缓存时长增加,整体响应时间增加,造成大量请求超时的情况.</p>\n<h5 id=\"2-4-1-解决\"><a href=\"#2-4-1-解决\" class=\"headerlink\" title=\"2.4.1 解决\"></a>2.4.1 解决</h5><p>多设置几个key，使redis分布均匀…</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/u011957758/article/details/74783347\">一看就懂系列之 详解redis的bitmap在亿级项目中的应用</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/103574447\">精准营销系列:RTA投放</a></p>"},{"title":"Redis设计与实现-RDB持久化","date":"2020-09-03T07:52:31.000Z","_content":"\nRedis是内存数据库，它将自己的数据库状态储存在内存里面，若不将其保存到磁盘上，一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此Redis提供了RDB持久化功能，将Redis内存中的数据库状态保存到磁盘里面，避免数据意外丢失。\n\n<!--more-->\n\nRDB持久化可以手动执行，也可以根据服务器配选项定期执行，将某个时间点的数据库状态保存到RDB文件中，也可通过该文件还原生成RDB文件时的数据库状态。\n\n### 1 RDB文件的创建与载入\n\n#### 1.1 RDB文件的创建\n\nRedis通过以下两个命令，可生成RDB文件。\n\n- ①、`同步保存到磁盘命令`\n\n```\nSAVE\n```\n\n- ②、`在后台异步保存当前数据到磁盘命令`\n\n```\nBGSAVE\n```\n\n其中，\n\n- `SAVE命令会阻塞Redis服务器进程`，直到RDB文件创建完毕。\n- `BGSAVE命令是异步的，它将派生出一个子进程`，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。\n\n创建RDB文件实际工作由`rdb.c/rdbSave函数`完成，SAVE和BGSAVE命令会以不同的方式调用该函数。\n\n\n\nBGSAVE以子进程方式执行，在执行时，会拒绝新进入的SAVE、BGSAGE命令。而BGREWRITEAOF命令将会被延迟到BGSAVE命令执行结束。\n\nBGREWRITEAOF命令执行时，新进入的BGSAVE命令将被拒绝。\n\n\n\n#### 1.2 RDB文件的载入\n\nRDB`文件的载入工作是在服务器启动时自动执行的`，Redis并没有提供专门用于载入RDB文件的命令。\n\n*注：AOP文件的更新频率通常比RDB文件的更频率高，因此，若服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。*\n\n\n\n<u>RDB文件载入时，服务器将一直处于阻塞状态，直到载入工作完成为止。</u>\n\n\n\n### 2 自动间隔保存\n\n由于BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置（`/etc/redis/redis.conf`配置文件）的`save`选项，让服务器每隔一段时间自动执行一次BGSAVE命令。\n\n\n\n示例：当前Redis默认配置save选项如下，当条件满足时，BGSAVE命令将被执行。\n\n```\n# 服务器在900秒之内，对数据库进行了至少1次修改。\nsave 900 1\n# 服务器在300秒之内，对数据库进行了至少10次修改。\nsave 300 10\n# 服务器在60秒之内，对数据库进行了至少10000次修改。\nsave 60 10000\n```\n\n\n\n#### 2.1 设置保存条件\n\n当Redis服务启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，若未主动设置save选项，那么服务器将使用redis.conf文件中默认的save条件：\n\n```\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n\n\n在`redisServer结构`中有一个`saveparams`属性，用于保存save设置的保存条件。\n\n```c\nstruct redisServer {\n    // ...\n    // 记录了保存条件的数组.\n    struct saveparam *saveparams;\n    // ...\n};\n```\n\n\n\n默认条件下服务器状态中的`saveparams`数组示意如下：\n\n![默认条件下服务器状态中的saveparams数组示意](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/默认条件下服务器状态中的saveparams数组示意.png)\n\n\n\n#### 2.2 dirty计数器和lastsave属性\n\n- **dirty计数器属性**: 记录距离上一次成功执行`SAVE`或者`BGSAVE`命令之后，服务器对数据状态（服务器中所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。\n\n- **lastsave属性**: 是一个UNIX时间戳，记录了服务器上一次成功执行`SAVE`或者`BGSAVE`命令的时间。\n\n\n\n#### 2.3 检查保存条件是否满足\n\nRedis的服务器周期性操作函数serverCron默认每隔`100ms`就执行一次，`该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的条件是否满足，若满足，则执行BGSAVE命令。`\n\n\n\n示例：服务器状态如下，其中dirty为123，表示距离上一次执行SAVE或者BGSAVE命令后，数据状态修改了123次，此时，若时间来到1378271101时，即301秒后，服务器将自动执行一次BGSAVE命令。执行完成后dirty属性将被清零。\n\n![服务器状态如下，其中dirty为123](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/服务器状态如下，其中dirty为123.png)\n\n\n\n### 3 RDB文件结构\n\n`RDB文件是一个经过压缩的二进制文件，由多个部分组成`，对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。\n\n\n\n一个完整的RDB文件包含以下几个部分，如下图所示：\n\n![一个完整的RDB文件包含以下几个部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/一个完整的RDB文件包含以下几个部分.png)\n\n- ①、`REDIS`：长度为5字节的常量，保存着`\"REDIS\"`5个字符，通过这5个字符，程序在载入文件时，快速检查所在入的文件是否RDB文件。\n- ②、`db_version`：长度为4字节，它的值是一个字符串表示整数，记录了RDB文件的版本号，例如“0006”就代表RDB文件的版本为第六版。\n- ③、`databases`：包含着零个或任意多个数据库，以及各个数据库中的键值对数据。\n- ④、`EOF`：长度为1字节的常量，标志着RDB文件正文内容的结束。\n- ⑤、`check_sum`：长度为8字节的无符号整数，保存着通过REDIS、db_version、databases、EOF四个部分计算出的校验和。\n\n\n\n#### 3.1 databases部分\n\n一个RDB文件的`databases`部分可以`保存任意多个非空数据库`。\n\n每个非空数据库在RDB文件中都保存着以下三个部分：\n\n![每个非空数据库在RDB文件中都保存着以下三个部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/每个非空数据库在RDB文件中都保存着以下三个部分.png)\n\n- ①、`SELECTDB`：长度为1字节的常量，表示接下来读取的将是一个数据库号码。\n- ②、`db_number`：长度为1字节/2字节/5字节的数据库号码。程序根据该号码，调用SELECT命令切换数据库。\n- ③、`key_value_pairs`：保存数据库中所有的键值对数据（注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起）。\n\n\n\n#### 3.2 key_value_pairs部分\n\nRDB文件的每个`key_value_pairs`：保存数据库中所有的键值对数据（*注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起*）。\n\n\n\n##### 3.2.1 不带过期时间的键值对组成\n\n不带过期时间的键值对由以下三个部分组成：\n\n![不带过期时间的键值对由以下三个部分组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/不带过期时间的键值对由以下三个部分组成.png)\n\n- ①、`Type`：记录了value的类型，长度为1字节的常量，包括以下常量，每种常量都代表了一种类型或者底层编码，服务器根据type的值决定如何读入和解释value数据。\n\n- - REDIS_RDB_TYPE_STRING\n  - REDIS_RDB_TYPE_LIST\n  - REDIS_RDB_TYPE_SET\n  - REDIS_RDB_TYPE_ZSET\n  - REDIS_RDB_TYPE_HASH\n  - REDIS_RDB_TYPE_LIST_ZIPLIST\n  - REDIS_RDB_TYPE_SET_INTSET\n  - REDIS_RDB_TYPE_ZSET_ZIPLIST\n  - REDIS_RDB_TYPE_HASH_ZIPLIST\n\n- ②、`key`：保存了键值对的键对象\n\n- ③、`value`：保存了键值对的值对象。\n\n\n\n##### 3.2.2 带过期时间的键值对组成\n\n带过期时间的键值对在RDB文件中的组成如下：\n\n![带过期时间的键值对在RDB文件中的组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/带过期时间的键值对在RDB文件中的组成.png)\n\n其中TYPE、key、value三个部分的意义均与不带过期时间的组成相同。\n\n- ①、EXPIRETIME_MS：长度为1字节的常量，表示接下来读入的是一个以毫秒为单位的过期时间。\n- ②、ms：8字节长的带符号的整数，记录了一个以毫秒为单位的UNIX时间戳。\n\n\n\n#### 3.3 value编码\n\nRDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都有与之对应的Type记录，根据类型的不同，value部分的结构，长度也会有所不同。\n\n\n\n### 4 分析RDB文件\n\n通过Linux的`od指令`来分析Redis服务器产生的RDB文件，使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。RDB文件路径可通过`/etc/redis/redis.conf`文件中查看，如下所示，因此RDB文件路径为：`/var/lib/redis/dump.rdb`\n\n\n\n`/etc/redis/redis.conf`中配置如下:\n\n```\n# 打印的RDB文件名。\ndbfilename dump.rdb\n#\n# 路径.\ndir /var/lib/redis\n```\n\n\n\n#### 4.1 不包含任何键值对的RDB文件\n\n执行以下命令，创建一个数据库状态为空的RDB文件：\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> save\nOK\n```\n\n\n\n通过od命令打印RDB文件内容，并使用ASCII或反斜杠序列展示结果(`-c参数`), 如下所示：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 377 334 263   C 360   Z 334\n0000020 362   V\n0000022\n```\n\n其中：\n\n- 五个字节的“REDIS”字符串\n- 四个字节的版本号（0006）\n- 377是EOF常量\n- 334 263   C 360   Z 334 362   V为8个字节的校验和\n\n\n\n#### 4.2 包含字符串键的RDB文件\n\n执行以下命令，分析一个带有单个字符串键的数据库：\n\n```bash\n127.0.0.1:6379> flushdb\nOK\n127.0.0.1:6379> set msg \"HELLO\"\nOK\n127.0.0.1:6379> save\nOK\n```\n\n\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0  \\0 003   m   s   g\n0000020 005   H   E   L   L   O 377  \\n   < 342 005   <   A 217   4\n0000037\n```\n\n其中:\n\n- 五个字节的“REDIS”字符串\n- 四个字节的版本号（0006）\n- 376表示SELECTED常量\n- \\0表示数据库0\n- \\0表示表示字符串\n- 003表示msg的长度\n- msg表示key\n- 005表示value的长度\n- HEELO为value\n- 377是EOF常量\n-  \\n   < 342 005   <   A 217   4为8个字节的校验和\n\n\n\n#### 4.3 包含过期时间的字符串键的RDB文件\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> setex msg 10086 \"HELLO\"\nOK\n127.0.0.1:6379> save\nOK\n```\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0 374 375   3   {   3\n0000020   r 001  \\0  \\0  \\0 003   m   s   g 005   H   E   L   L   O 377\n0000040 317   W 312 301 337 313 364 201\n0000050\n```\n\n\n\n#### 4.4 包含一个集合键的RDB文件\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> sadd lang \"C\" \"JAVA\" \"RUBY\"\n(integer) 3\n127.0.0.1:6379> SAVE\nOK\n```\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0 002 004   l   a   n\n0000020   g 003 004   J   A   V   A 004   R   U   B   Y 001   C 377   u\n0000040 177 235 372   z 334  \\f 216\n0000047\n```\n\n","source":"_posts/Redis设计与实现-RDB持久化.md","raw":"---\ntitle: Redis设计与实现-RDB持久化\ndate: 2020-09-03 15:52:31\ntags: [\"Redis\",\"Note\",\"Redis设计与实现\"]\ncategories: [\"Redis\"]\n---\n\nRedis是内存数据库，它将自己的数据库状态储存在内存里面，若不将其保存到磁盘上，一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此Redis提供了RDB持久化功能，将Redis内存中的数据库状态保存到磁盘里面，避免数据意外丢失。\n\n<!--more-->\n\nRDB持久化可以手动执行，也可以根据服务器配选项定期执行，将某个时间点的数据库状态保存到RDB文件中，也可通过该文件还原生成RDB文件时的数据库状态。\n\n### 1 RDB文件的创建与载入\n\n#### 1.1 RDB文件的创建\n\nRedis通过以下两个命令，可生成RDB文件。\n\n- ①、`同步保存到磁盘命令`\n\n```\nSAVE\n```\n\n- ②、`在后台异步保存当前数据到磁盘命令`\n\n```\nBGSAVE\n```\n\n其中，\n\n- `SAVE命令会阻塞Redis服务器进程`，直到RDB文件创建完毕。\n- `BGSAVE命令是异步的，它将派生出一个子进程`，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。\n\n创建RDB文件实际工作由`rdb.c/rdbSave函数`完成，SAVE和BGSAVE命令会以不同的方式调用该函数。\n\n\n\nBGSAVE以子进程方式执行，在执行时，会拒绝新进入的SAVE、BGSAGE命令。而BGREWRITEAOF命令将会被延迟到BGSAVE命令执行结束。\n\nBGREWRITEAOF命令执行时，新进入的BGSAVE命令将被拒绝。\n\n\n\n#### 1.2 RDB文件的载入\n\nRDB`文件的载入工作是在服务器启动时自动执行的`，Redis并没有提供专门用于载入RDB文件的命令。\n\n*注：AOP文件的更新频率通常比RDB文件的更频率高，因此，若服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。*\n\n\n\n<u>RDB文件载入时，服务器将一直处于阻塞状态，直到载入工作完成为止。</u>\n\n\n\n### 2 自动间隔保存\n\n由于BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置（`/etc/redis/redis.conf`配置文件）的`save`选项，让服务器每隔一段时间自动执行一次BGSAVE命令。\n\n\n\n示例：当前Redis默认配置save选项如下，当条件满足时，BGSAVE命令将被执行。\n\n```\n# 服务器在900秒之内，对数据库进行了至少1次修改。\nsave 900 1\n# 服务器在300秒之内，对数据库进行了至少10次修改。\nsave 300 10\n# 服务器在60秒之内，对数据库进行了至少10000次修改。\nsave 60 10000\n```\n\n\n\n#### 2.1 设置保存条件\n\n当Redis服务启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，若未主动设置save选项，那么服务器将使用redis.conf文件中默认的save条件：\n\n```\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n\n\n在`redisServer结构`中有一个`saveparams`属性，用于保存save设置的保存条件。\n\n```c\nstruct redisServer {\n    // ...\n    // 记录了保存条件的数组.\n    struct saveparam *saveparams;\n    // ...\n};\n```\n\n\n\n默认条件下服务器状态中的`saveparams`数组示意如下：\n\n![默认条件下服务器状态中的saveparams数组示意](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/默认条件下服务器状态中的saveparams数组示意.png)\n\n\n\n#### 2.2 dirty计数器和lastsave属性\n\n- **dirty计数器属性**: 记录距离上一次成功执行`SAVE`或者`BGSAVE`命令之后，服务器对数据状态（服务器中所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。\n\n- **lastsave属性**: 是一个UNIX时间戳，记录了服务器上一次成功执行`SAVE`或者`BGSAVE`命令的时间。\n\n\n\n#### 2.3 检查保存条件是否满足\n\nRedis的服务器周期性操作函数serverCron默认每隔`100ms`就执行一次，`该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的条件是否满足，若满足，则执行BGSAVE命令。`\n\n\n\n示例：服务器状态如下，其中dirty为123，表示距离上一次执行SAVE或者BGSAVE命令后，数据状态修改了123次，此时，若时间来到1378271101时，即301秒后，服务器将自动执行一次BGSAVE命令。执行完成后dirty属性将被清零。\n\n![服务器状态如下，其中dirty为123](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/服务器状态如下，其中dirty为123.png)\n\n\n\n### 3 RDB文件结构\n\n`RDB文件是一个经过压缩的二进制文件，由多个部分组成`，对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。\n\n\n\n一个完整的RDB文件包含以下几个部分，如下图所示：\n\n![一个完整的RDB文件包含以下几个部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/一个完整的RDB文件包含以下几个部分.png)\n\n- ①、`REDIS`：长度为5字节的常量，保存着`\"REDIS\"`5个字符，通过这5个字符，程序在载入文件时，快速检查所在入的文件是否RDB文件。\n- ②、`db_version`：长度为4字节，它的值是一个字符串表示整数，记录了RDB文件的版本号，例如“0006”就代表RDB文件的版本为第六版。\n- ③、`databases`：包含着零个或任意多个数据库，以及各个数据库中的键值对数据。\n- ④、`EOF`：长度为1字节的常量，标志着RDB文件正文内容的结束。\n- ⑤、`check_sum`：长度为8字节的无符号整数，保存着通过REDIS、db_version、databases、EOF四个部分计算出的校验和。\n\n\n\n#### 3.1 databases部分\n\n一个RDB文件的`databases`部分可以`保存任意多个非空数据库`。\n\n每个非空数据库在RDB文件中都保存着以下三个部分：\n\n![每个非空数据库在RDB文件中都保存着以下三个部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/每个非空数据库在RDB文件中都保存着以下三个部分.png)\n\n- ①、`SELECTDB`：长度为1字节的常量，表示接下来读取的将是一个数据库号码。\n- ②、`db_number`：长度为1字节/2字节/5字节的数据库号码。程序根据该号码，调用SELECT命令切换数据库。\n- ③、`key_value_pairs`：保存数据库中所有的键值对数据（注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起）。\n\n\n\n#### 3.2 key_value_pairs部分\n\nRDB文件的每个`key_value_pairs`：保存数据库中所有的键值对数据（*注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起*）。\n\n\n\n##### 3.2.1 不带过期时间的键值对组成\n\n不带过期时间的键值对由以下三个部分组成：\n\n![不带过期时间的键值对由以下三个部分组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/不带过期时间的键值对由以下三个部分组成.png)\n\n- ①、`Type`：记录了value的类型，长度为1字节的常量，包括以下常量，每种常量都代表了一种类型或者底层编码，服务器根据type的值决定如何读入和解释value数据。\n\n- - REDIS_RDB_TYPE_STRING\n  - REDIS_RDB_TYPE_LIST\n  - REDIS_RDB_TYPE_SET\n  - REDIS_RDB_TYPE_ZSET\n  - REDIS_RDB_TYPE_HASH\n  - REDIS_RDB_TYPE_LIST_ZIPLIST\n  - REDIS_RDB_TYPE_SET_INTSET\n  - REDIS_RDB_TYPE_ZSET_ZIPLIST\n  - REDIS_RDB_TYPE_HASH_ZIPLIST\n\n- ②、`key`：保存了键值对的键对象\n\n- ③、`value`：保存了键值对的值对象。\n\n\n\n##### 3.2.2 带过期时间的键值对组成\n\n带过期时间的键值对在RDB文件中的组成如下：\n\n![带过期时间的键值对在RDB文件中的组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-RDB持久化/带过期时间的键值对在RDB文件中的组成.png)\n\n其中TYPE、key、value三个部分的意义均与不带过期时间的组成相同。\n\n- ①、EXPIRETIME_MS：长度为1字节的常量，表示接下来读入的是一个以毫秒为单位的过期时间。\n- ②、ms：8字节长的带符号的整数，记录了一个以毫秒为单位的UNIX时间戳。\n\n\n\n#### 3.3 value编码\n\nRDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都有与之对应的Type记录，根据类型的不同，value部分的结构，长度也会有所不同。\n\n\n\n### 4 分析RDB文件\n\n通过Linux的`od指令`来分析Redis服务器产生的RDB文件，使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。RDB文件路径可通过`/etc/redis/redis.conf`文件中查看，如下所示，因此RDB文件路径为：`/var/lib/redis/dump.rdb`\n\n\n\n`/etc/redis/redis.conf`中配置如下:\n\n```\n# 打印的RDB文件名。\ndbfilename dump.rdb\n#\n# 路径.\ndir /var/lib/redis\n```\n\n\n\n#### 4.1 不包含任何键值对的RDB文件\n\n执行以下命令，创建一个数据库状态为空的RDB文件：\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> save\nOK\n```\n\n\n\n通过od命令打印RDB文件内容，并使用ASCII或反斜杠序列展示结果(`-c参数`), 如下所示：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 377 334 263   C 360   Z 334\n0000020 362   V\n0000022\n```\n\n其中：\n\n- 五个字节的“REDIS”字符串\n- 四个字节的版本号（0006）\n- 377是EOF常量\n- 334 263   C 360   Z 334 362   V为8个字节的校验和\n\n\n\n#### 4.2 包含字符串键的RDB文件\n\n执行以下命令，分析一个带有单个字符串键的数据库：\n\n```bash\n127.0.0.1:6379> flushdb\nOK\n127.0.0.1:6379> set msg \"HELLO\"\nOK\n127.0.0.1:6379> save\nOK\n```\n\n\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0  \\0 003   m   s   g\n0000020 005   H   E   L   L   O 377  \\n   < 342 005   <   A 217   4\n0000037\n```\n\n其中:\n\n- 五个字节的“REDIS”字符串\n- 四个字节的版本号（0006）\n- 376表示SELECTED常量\n- \\0表示数据库0\n- \\0表示表示字符串\n- 003表示msg的长度\n- msg表示key\n- 005表示value的长度\n- HEELO为value\n- 377是EOF常量\n-  \\n   < 342 005   <   A 217   4为8个字节的校验和\n\n\n\n#### 4.3 包含过期时间的字符串键的RDB文件\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> setex msg 10086 \"HELLO\"\nOK\n127.0.0.1:6379> save\nOK\n```\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0 374 375   3   {   3\n0000020   r 001  \\0  \\0  \\0 003   m   s   g 005   H   E   L   L   O 377\n0000040 317   W 312 301 337 313 364 201\n0000050\n```\n\n\n\n#### 4.4 包含一个集合键的RDB文件\n\n```bash\n127.0.0.1:6379> flushall\nOK\n127.0.0.1:6379> sadd lang \"C\" \"JAVA\" \"RUBY\"\n(integer) 3\n127.0.0.1:6379> SAVE\nOK\n```\n\n通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(`-c参数`)：\n\n```bash\n$ od -c dump.rdb\n0000000   R   E   D   I   S   0   0   0   6 376  \\0 002 004   l   a   n\n0000020   g 003 004   J   A   V   A 004   R   U   B   Y 001   C 377   u\n0000040 177 235 372   z 334  \\f 216\n0000047\n```\n\n","slug":"Redis设计与实现-RDB持久化","published":1,"updated":"2020-09-24T10:16:04.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkv002j45g3c6wv3cyl","content":"<p>Redis是内存数据库，它将自己的数据库状态储存在内存里面，若不将其保存到磁盘上，一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此Redis提供了RDB持久化功能，将Redis内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p>\n<a id=\"more\"></a>\n\n<p>RDB持久化可以手动执行，也可以根据服务器配选项定期执行，将某个时间点的数据库状态保存到RDB文件中，也可通过该文件还原生成RDB文件时的数据库状态。</p>\n<h3 id=\"1-RDB文件的创建与载入\"><a href=\"#1-RDB文件的创建与载入\" class=\"headerlink\" title=\"1 RDB文件的创建与载入\"></a>1 RDB文件的创建与载入</h3><h4 id=\"1-1-RDB文件的创建\"><a href=\"#1-1-RDB文件的创建\" class=\"headerlink\" title=\"1.1 RDB文件的创建\"></a>1.1 RDB文件的创建</h4><p>Redis通过以下两个命令，可生成RDB文件。</p>\n<ul>\n<li>①、<code>同步保存到磁盘命令</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAVE</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、<code>在后台异步保存当前数据到磁盘命令</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BGSAVE</span><br></pre></td></tr></table></figure>\n\n<p>其中，</p>\n<ul>\n<li><code>SAVE命令会阻塞Redis服务器进程</code>，直到RDB文件创建完毕。</li>\n<li><code>BGSAVE命令是异步的，它将派生出一个子进程</code>，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</li>\n</ul>\n<p>创建RDB文件实际工作由<code>rdb.c/rdbSave函数</code>完成，SAVE和BGSAVE命令会以不同的方式调用该函数。</p>\n<p>BGSAVE以子进程方式执行，在执行时，会拒绝新进入的SAVE、BGSAGE命令。而BGREWRITEAOF命令将会被延迟到BGSAVE命令执行结束。</p>\n<p>BGREWRITEAOF命令执行时，新进入的BGSAVE命令将被拒绝。</p>\n<h4 id=\"1-2-RDB文件的载入\"><a href=\"#1-2-RDB文件的载入\" class=\"headerlink\" title=\"1.2 RDB文件的载入\"></a>1.2 RDB文件的载入</h4><p>RDB<code>文件的载入工作是在服务器启动时自动执行的</code>，Redis并没有提供专门用于载入RDB文件的命令。</p>\n<p><em>注：AOP文件的更新频率通常比RDB文件的更频率高，因此，若服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</em></p>\n<p><u>RDB文件载入时，服务器将一直处于阻塞状态，直到载入工作完成为止。</u></p>\n<h3 id=\"2-自动间隔保存\"><a href=\"#2-自动间隔保存\" class=\"headerlink\" title=\"2 自动间隔保存\"></a>2 自动间隔保存</h3><p>由于BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置（<code>/etc/redis/redis.conf</code>配置文件）的<code>save</code>选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p>\n<p>示例：当前Redis默认配置save选项如下，当条件满足时，BGSAVE命令将被执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 服务器在900秒之内，对数据库进行了至少1次修改。</span><br><span class=\"line\">save 900 1</span><br><span class=\"line\"># 服务器在300秒之内，对数据库进行了至少10次修改。</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\"># 服务器在60秒之内，对数据库进行了至少10000次修改。</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-设置保存条件\"><a href=\"#2-1-设置保存条件\" class=\"headerlink\" title=\"2.1 设置保存条件\"></a>2.1 设置保存条件</h4><p>当Redis服务启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，若未主动设置save选项，那么服务器将使用redis.conf文件中默认的save条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save 900 1</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在<code>redisServer结构</code>中有一个<code>saveparams</code>属性，用于保存save设置的保存条件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录了保存条件的数组.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">saveparam</span> *<span class=\"title\">saveparams</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认条件下服务器状态中的<code>saveparams</code>数组示意如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E9%BB%98%E8%AE%A4%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84saveparams%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F.png\" alt=\"默认条件下服务器状态中的saveparams数组示意\"></p>\n<h4 id=\"2-2-dirty计数器和lastsave属性\"><a href=\"#2-2-dirty计数器和lastsave属性\" class=\"headerlink\" title=\"2.2 dirty计数器和lastsave属性\"></a>2.2 dirty计数器和lastsave属性</h4><ul>\n<li><p><strong>dirty计数器属性</strong>: 记录距离上一次成功执行<code>SAVE</code>或者<code>BGSAVE</code>命令之后，服务器对数据状态（服务器中所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</p>\n</li>\n<li><p><strong>lastsave属性</strong>: 是一个UNIX时间戳，记录了服务器上一次成功执行<code>SAVE</code>或者<code>BGSAVE</code>命令的时间。</p>\n</li>\n</ul>\n<h4 id=\"2-3-检查保存条件是否满足\"><a href=\"#2-3-检查保存条件是否满足\" class=\"headerlink\" title=\"2.3 检查保存条件是否满足\"></a>2.3 检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数serverCron默认每隔<code>100ms</code>就执行一次，<code>该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的条件是否满足，若满足，则执行BGSAVE命令。</code></p>\n<p>示例：服务器状态如下，其中dirty为123，表示距离上一次执行SAVE或者BGSAVE命令后，数据状态修改了123次，此时，若时间来到1378271101时，即301秒后，服务器将自动执行一次BGSAVE命令。执行完成后dirty属性将被清零。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E5%A6%82%E4%B8%8B%EF%BC%8C%E5%85%B6%E4%B8%ADdirty%E4%B8%BA123.png\" alt=\"服务器状态如下，其中dirty为123\"></p>\n<h3 id=\"3-RDB文件结构\"><a href=\"#3-RDB文件结构\" class=\"headerlink\" title=\"3 RDB文件结构\"></a>3 RDB文件结构</h3><p><code>RDB文件是一个经过压缩的二进制文件，由多个部分组成</code>，对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。</p>\n<p>一个完整的RDB文件包含以下几个部分，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84RDB%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86.png\" alt=\"一个完整的RDB文件包含以下几个部分\"></p>\n<ul>\n<li>①、<code>REDIS</code>：长度为5字节的常量，保存着<code>&quot;REDIS&quot;</code>5个字符，通过这5个字符，程序在载入文件时，快速检查所在入的文件是否RDB文件。</li>\n<li>②、<code>db_version</code>：长度为4字节，它的值是一个字符串表示整数，记录了RDB文件的版本号，例如“0006”就代表RDB文件的版本为第六版。</li>\n<li>③、<code>databases</code>：包含着零个或任意多个数据库，以及各个数据库中的键值对数据。</li>\n<li>④、<code>EOF</code>：长度为1字节的常量，标志着RDB文件正文内容的结束。</li>\n<li>⑤、<code>check_sum</code>：长度为8字节的无符号整数，保存着通过REDIS、db_version、databases、EOF四个部分计算出的校验和。</li>\n</ul>\n<h4 id=\"3-1-databases部分\"><a href=\"#3-1-databases部分\" class=\"headerlink\" title=\"3.1 databases部分\"></a>3.1 databases部分</h4><p>一个RDB文件的<code>databases</code>部分可以<code>保存任意多个非空数据库</code>。</p>\n<p>每个非空数据库在RDB文件中都保存着以下三个部分：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E6%AF%8F%E4%B8%AA%E9%9D%9E%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E9%83%BD%E4%BF%9D%E5%AD%98%E7%9D%80%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86.png\" alt=\"每个非空数据库在RDB文件中都保存着以下三个部分\"></p>\n<ul>\n<li>①、<code>SELECTDB</code>：长度为1字节的常量，表示接下来读取的将是一个数据库号码。</li>\n<li>②、<code>db_number</code>：长度为1字节/2字节/5字节的数据库号码。程序根据该号码，调用SELECT命令切换数据库。</li>\n<li>③、<code>key_value_pairs</code>：保存数据库中所有的键值对数据（注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起）。</li>\n</ul>\n<h4 id=\"3-2-key-value-pairs部分\"><a href=\"#3-2-key-value-pairs部分\" class=\"headerlink\" title=\"3.2 key_value_pairs部分\"></a>3.2 key_value_pairs部分</h4><p>RDB文件的每个<code>key_value_pairs</code>：保存数据库中所有的键值对数据（<em>注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起</em>）。</p>\n<h5 id=\"3-2-1-不带过期时间的键值对组成\"><a href=\"#3-2-1-不带过期时间的键值对组成\" class=\"headerlink\" title=\"3.2.1 不带过期时间的键值对组成\"></a>3.2.1 不带过期时间的键值对组成</h5><p>不带过期时间的键值对由以下三个部分组成：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E4%B8%8D%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E7%94%B1%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png\" alt=\"不带过期时间的键值对由以下三个部分组成\"></p>\n<ul>\n<li><p>①、<code>Type</code>：记录了value的类型，长度为1字节的常量，包括以下常量，每种常量都代表了一种类型或者底层编码，服务器根据type的值决定如何读入和解释value数据。</p>\n</li>\n<li><ul>\n<li>REDIS_RDB_TYPE_STRING</li>\n<li>REDIS_RDB_TYPE_LIST</li>\n<li>REDIS_RDB_TYPE_SET</li>\n<li>REDIS_RDB_TYPE_ZSET</li>\n<li>REDIS_RDB_TYPE_HASH</li>\n<li>REDIS_RDB_TYPE_LIST_ZIPLIST</li>\n<li>REDIS_RDB_TYPE_SET_INTSET</li>\n<li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li>\n<li>REDIS_RDB_TYPE_HASH_ZIPLIST</li>\n</ul>\n</li>\n<li><p>②、<code>key</code>：保存了键值对的键对象</p>\n</li>\n<li><p>③、<code>value</code>：保存了键值对的值对象。</p>\n</li>\n</ul>\n<h5 id=\"3-2-2-带过期时间的键值对组成\"><a href=\"#3-2-2-带过期时间的键值对组成\" class=\"headerlink\" title=\"3.2.2 带过期时间的键值对组成\"></a>3.2.2 带过期时间的键值对组成</h5><p>带过期时间的键值对在RDB文件中的组成如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E5%9C%A8RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BB%84%E6%88%90.png\" alt=\"带过期时间的键值对在RDB文件中的组成\"></p>\n<p>其中TYPE、key、value三个部分的意义均与不带过期时间的组成相同。</p>\n<ul>\n<li>①、EXPIRETIME_MS：长度为1字节的常量，表示接下来读入的是一个以毫秒为单位的过期时间。</li>\n<li>②、ms：8字节长的带符号的整数，记录了一个以毫秒为单位的UNIX时间戳。</li>\n</ul>\n<h4 id=\"3-3-value编码\"><a href=\"#3-3-value编码\" class=\"headerlink\" title=\"3.3 value编码\"></a>3.3 value编码</h4><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都有与之对应的Type记录，根据类型的不同，value部分的结构，长度也会有所不同。</p>\n<h3 id=\"4-分析RDB文件\"><a href=\"#4-分析RDB文件\" class=\"headerlink\" title=\"4 分析RDB文件\"></a>4 分析RDB文件</h3><p>通过Linux的<code>od指令</code>来分析Redis服务器产生的RDB文件，使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。RDB文件路径可通过<code>/etc/redis/redis.conf</code>文件中查看，如下所示，因此RDB文件路径为：<code>/var/lib/redis/dump.rdb</code></p>\n<p><code>/etc/redis/redis.conf</code>中配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 打印的RDB文件名。</span><br><span class=\"line\">dbfilename dump.rdb</span><br><span class=\"line\">#</span><br><span class=\"line\"># 路径.</span><br><span class=\"line\">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-1-不包含任何键值对的RDB文件\"><a href=\"#4-1-不包含任何键值对的RDB文件\" class=\"headerlink\" title=\"4.1 不包含任何键值对的RDB文件\"></a>4.1 不包含任何键值对的RDB文件</h4><p>执行以下命令，创建一个数据库状态为空的RDB文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过od命令打印RDB文件内容，并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>), 如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 377 334 263   C 360   Z 334</span><br><span class=\"line\">0000020 362   V</span><br><span class=\"line\">0000022</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li>五个字节的“REDIS”字符串</li>\n<li>四个字节的版本号（0006）</li>\n<li>377是EOF常量</li>\n<li>334 263   C 360   Z 334 362   V为8个字节的校验和</li>\n</ul>\n<h4 id=\"4-2-包含字符串键的RDB文件\"><a href=\"#4-2-包含字符串键的RDB文件\" class=\"headerlink\" title=\"4.2 包含字符串键的RDB文件\"></a>4.2 包含字符串键的RDB文件</h4><p>执行以下命令，分析一个带有单个字符串键的数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushdb</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;HELLO&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0  \\0 003   m   s   g</span><br><span class=\"line\">0000020 005   H   E   L   L   O 377  \\n   &lt; 342 005   &lt;   A 217   4</span><br><span class=\"line\">0000037</span><br></pre></td></tr></table></figure>\n\n<p>其中:</p>\n<ul>\n<li>五个字节的“REDIS”字符串</li>\n<li>四个字节的版本号（0006）</li>\n<li>376表示SELECTED常量</li>\n<li>\\0表示数据库0</li>\n<li>\\0表示表示字符串</li>\n<li>003表示msg的长度</li>\n<li>msg表示key</li>\n<li>005表示value的长度</li>\n<li>HEELO为value</li>\n<li>377是EOF常量</li>\n<li>\\n   &lt; 342 005   &lt;   A 217   4为8个字节的校验和</li>\n</ul>\n<h4 id=\"4-3-包含过期时间的字符串键的RDB文件\"><a href=\"#4-3-包含过期时间的字符串键的RDB文件\" class=\"headerlink\" title=\"4.3 包含过期时间的字符串键的RDB文件\"></a>4.3 包含过期时间的字符串键的RDB文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; setex msg 10086 <span class=\"string\">&quot;HELLO&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0 374 375   3   &#123;   3</span><br><span class=\"line\">0000020   r 001  \\0  \\0  \\0 003   m   s   g 005   H   E   L   L   O 377</span><br><span class=\"line\">0000040 317   W 312 301 337 313 364 201</span><br><span class=\"line\">0000050</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-4-包含一个集合键的RDB文件\"><a href=\"#4-4-包含一个集合键的RDB文件\" class=\"headerlink\" title=\"4.4 包含一个集合键的RDB文件\"></a>4.4 包含一个集合键的RDB文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd lang <span class=\"string\">&quot;C&quot;</span> <span class=\"string\">&quot;JAVA&quot;</span> <span class=\"string\">&quot;RUBY&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SAVE</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0 002 004   l   a   n</span><br><span class=\"line\">0000020   g 003 004   J   A   V   A 004   R   U   B   Y 001   C 377   u</span><br><span class=\"line\">0000040 177 235 372   z 334  \\f 216</span><br><span class=\"line\">0000047</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Redis是内存数据库，它将自己的数据库状态储存在内存里面，若不将其保存到磁盘上，一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此Redis提供了RDB持久化功能，将Redis内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p>","more":"<p>RDB持久化可以手动执行，也可以根据服务器配选项定期执行，将某个时间点的数据库状态保存到RDB文件中，也可通过该文件还原生成RDB文件时的数据库状态。</p>\n<h3 id=\"1-RDB文件的创建与载入\"><a href=\"#1-RDB文件的创建与载入\" class=\"headerlink\" title=\"1 RDB文件的创建与载入\"></a>1 RDB文件的创建与载入</h3><h4 id=\"1-1-RDB文件的创建\"><a href=\"#1-1-RDB文件的创建\" class=\"headerlink\" title=\"1.1 RDB文件的创建\"></a>1.1 RDB文件的创建</h4><p>Redis通过以下两个命令，可生成RDB文件。</p>\n<ul>\n<li>①、<code>同步保存到磁盘命令</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAVE</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、<code>在后台异步保存当前数据到磁盘命令</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BGSAVE</span><br></pre></td></tr></table></figure>\n\n<p>其中，</p>\n<ul>\n<li><code>SAVE命令会阻塞Redis服务器进程</code>，直到RDB文件创建完毕。</li>\n<li><code>BGSAVE命令是异步的，它将派生出一个子进程</code>，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</li>\n</ul>\n<p>创建RDB文件实际工作由<code>rdb.c/rdbSave函数</code>完成，SAVE和BGSAVE命令会以不同的方式调用该函数。</p>\n<p>BGSAVE以子进程方式执行，在执行时，会拒绝新进入的SAVE、BGSAGE命令。而BGREWRITEAOF命令将会被延迟到BGSAVE命令执行结束。</p>\n<p>BGREWRITEAOF命令执行时，新进入的BGSAVE命令将被拒绝。</p>\n<h4 id=\"1-2-RDB文件的载入\"><a href=\"#1-2-RDB文件的载入\" class=\"headerlink\" title=\"1.2 RDB文件的载入\"></a>1.2 RDB文件的载入</h4><p>RDB<code>文件的载入工作是在服务器启动时自动执行的</code>，Redis并没有提供专门用于载入RDB文件的命令。</p>\n<p><em>注：AOP文件的更新频率通常比RDB文件的更频率高，因此，若服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</em></p>\n<p><u>RDB文件载入时，服务器将一直处于阻塞状态，直到载入工作完成为止。</u></p>\n<h3 id=\"2-自动间隔保存\"><a href=\"#2-自动间隔保存\" class=\"headerlink\" title=\"2 自动间隔保存\"></a>2 自动间隔保存</h3><p>由于BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置（<code>/etc/redis/redis.conf</code>配置文件）的<code>save</code>选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p>\n<p>示例：当前Redis默认配置save选项如下，当条件满足时，BGSAVE命令将被执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 服务器在900秒之内，对数据库进行了至少1次修改。</span><br><span class=\"line\">save 900 1</span><br><span class=\"line\"># 服务器在300秒之内，对数据库进行了至少10次修改。</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\"># 服务器在60秒之内，对数据库进行了至少10000次修改。</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-设置保存条件\"><a href=\"#2-1-设置保存条件\" class=\"headerlink\" title=\"2.1 设置保存条件\"></a>2.1 设置保存条件</h4><p>当Redis服务启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，若未主动设置save选项，那么服务器将使用redis.conf文件中默认的save条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save 900 1</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在<code>redisServer结构</code>中有一个<code>saveparams</code>属性，用于保存save设置的保存条件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录了保存条件的数组.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">saveparam</span> *<span class=\"title\">saveparams</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>默认条件下服务器状态中的<code>saveparams</code>数组示意如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E9%BB%98%E8%AE%A4%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84saveparams%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F.png\" alt=\"默认条件下服务器状态中的saveparams数组示意\"></p>\n<h4 id=\"2-2-dirty计数器和lastsave属性\"><a href=\"#2-2-dirty计数器和lastsave属性\" class=\"headerlink\" title=\"2.2 dirty计数器和lastsave属性\"></a>2.2 dirty计数器和lastsave属性</h4><ul>\n<li><p><strong>dirty计数器属性</strong>: 记录距离上一次成功执行<code>SAVE</code>或者<code>BGSAVE</code>命令之后，服务器对数据状态（服务器中所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</p>\n</li>\n<li><p><strong>lastsave属性</strong>: 是一个UNIX时间戳，记录了服务器上一次成功执行<code>SAVE</code>或者<code>BGSAVE</code>命令的时间。</p>\n</li>\n</ul>\n<h4 id=\"2-3-检查保存条件是否满足\"><a href=\"#2-3-检查保存条件是否满足\" class=\"headerlink\" title=\"2.3 检查保存条件是否满足\"></a>2.3 检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数serverCron默认每隔<code>100ms</code>就执行一次，<code>该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的条件是否满足，若满足，则执行BGSAVE命令。</code></p>\n<p>示例：服务器状态如下，其中dirty为123，表示距离上一次执行SAVE或者BGSAVE命令后，数据状态修改了123次，此时，若时间来到1378271101时，即301秒后，服务器将自动执行一次BGSAVE命令。执行完成后dirty属性将被清零。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E5%A6%82%E4%B8%8B%EF%BC%8C%E5%85%B6%E4%B8%ADdirty%E4%B8%BA123.png\" alt=\"服务器状态如下，其中dirty为123\"></p>\n<h3 id=\"3-RDB文件结构\"><a href=\"#3-RDB文件结构\" class=\"headerlink\" title=\"3 RDB文件结构\"></a>3 RDB文件结构</h3><p><code>RDB文件是一个经过压缩的二进制文件，由多个部分组成</code>，对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。</p>\n<p>一个完整的RDB文件包含以下几个部分，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84RDB%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86.png\" alt=\"一个完整的RDB文件包含以下几个部分\"></p>\n<ul>\n<li>①、<code>REDIS</code>：长度为5字节的常量，保存着<code>&quot;REDIS&quot;</code>5个字符，通过这5个字符，程序在载入文件时，快速检查所在入的文件是否RDB文件。</li>\n<li>②、<code>db_version</code>：长度为4字节，它的值是一个字符串表示整数，记录了RDB文件的版本号，例如“0006”就代表RDB文件的版本为第六版。</li>\n<li>③、<code>databases</code>：包含着零个或任意多个数据库，以及各个数据库中的键值对数据。</li>\n<li>④、<code>EOF</code>：长度为1字节的常量，标志着RDB文件正文内容的结束。</li>\n<li>⑤、<code>check_sum</code>：长度为8字节的无符号整数，保存着通过REDIS、db_version、databases、EOF四个部分计算出的校验和。</li>\n</ul>\n<h4 id=\"3-1-databases部分\"><a href=\"#3-1-databases部分\" class=\"headerlink\" title=\"3.1 databases部分\"></a>3.1 databases部分</h4><p>一个RDB文件的<code>databases</code>部分可以<code>保存任意多个非空数据库</code>。</p>\n<p>每个非空数据库在RDB文件中都保存着以下三个部分：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E6%AF%8F%E4%B8%AA%E9%9D%9E%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E9%83%BD%E4%BF%9D%E5%AD%98%E7%9D%80%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86.png\" alt=\"每个非空数据库在RDB文件中都保存着以下三个部分\"></p>\n<ul>\n<li>①、<code>SELECTDB</code>：长度为1字节的常量，表示接下来读取的将是一个数据库号码。</li>\n<li>②、<code>db_number</code>：长度为1字节/2字节/5字节的数据库号码。程序根据该号码，调用SELECT命令切换数据库。</li>\n<li>③、<code>key_value_pairs</code>：保存数据库中所有的键值对数据（注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起）。</li>\n</ul>\n<h4 id=\"3-2-key-value-pairs部分\"><a href=\"#3-2-key-value-pairs部分\" class=\"headerlink\" title=\"3.2 key_value_pairs部分\"></a>3.2 key_value_pairs部分</h4><p>RDB文件的每个<code>key_value_pairs</code>：保存数据库中所有的键值对数据（<em>注：若键值对带有过期时间，那么过期时间也会和键值对保存在一起</em>）。</p>\n<h5 id=\"3-2-1-不带过期时间的键值对组成\"><a href=\"#3-2-1-不带过期时间的键值对组成\" class=\"headerlink\" title=\"3.2.1 不带过期时间的键值对组成\"></a>3.2.1 不带过期时间的键值对组成</h5><p>不带过期时间的键值对由以下三个部分组成：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E4%B8%8D%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E7%94%B1%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png\" alt=\"不带过期时间的键值对由以下三个部分组成\"></p>\n<ul>\n<li><p>①、<code>Type</code>：记录了value的类型，长度为1字节的常量，包括以下常量，每种常量都代表了一种类型或者底层编码，服务器根据type的值决定如何读入和解释value数据。</p>\n</li>\n<li><ul>\n<li>REDIS_RDB_TYPE_STRING</li>\n<li>REDIS_RDB_TYPE_LIST</li>\n<li>REDIS_RDB_TYPE_SET</li>\n<li>REDIS_RDB_TYPE_ZSET</li>\n<li>REDIS_RDB_TYPE_HASH</li>\n<li>REDIS_RDB_TYPE_LIST_ZIPLIST</li>\n<li>REDIS_RDB_TYPE_SET_INTSET</li>\n<li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li>\n<li>REDIS_RDB_TYPE_HASH_ZIPLIST</li>\n</ul>\n</li>\n<li><p>②、<code>key</code>：保存了键值对的键对象</p>\n</li>\n<li><p>③、<code>value</code>：保存了键值对的值对象。</p>\n</li>\n</ul>\n<h5 id=\"3-2-2-带过期时间的键值对组成\"><a href=\"#3-2-2-带过期时间的键值对组成\" class=\"headerlink\" title=\"3.2.2 带过期时间的键值对组成\"></a>3.2.2 带过期时间的键值对组成</h5><p>带过期时间的键值对在RDB文件中的组成如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-RDB%E6%8C%81%E4%B9%85%E5%8C%96/%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E5%9C%A8RDB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BB%84%E6%88%90.png\" alt=\"带过期时间的键值对在RDB文件中的组成\"></p>\n<p>其中TYPE、key、value三个部分的意义均与不带过期时间的组成相同。</p>\n<ul>\n<li>①、EXPIRETIME_MS：长度为1字节的常量，表示接下来读入的是一个以毫秒为单位的过期时间。</li>\n<li>②、ms：8字节长的带符号的整数，记录了一个以毫秒为单位的UNIX时间戳。</li>\n</ul>\n<h4 id=\"3-3-value编码\"><a href=\"#3-3-value编码\" class=\"headerlink\" title=\"3.3 value编码\"></a>3.3 value编码</h4><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都有与之对应的Type记录，根据类型的不同，value部分的结构，长度也会有所不同。</p>\n<h3 id=\"4-分析RDB文件\"><a href=\"#4-分析RDB文件\" class=\"headerlink\" title=\"4 分析RDB文件\"></a>4 分析RDB文件</h3><p>通过Linux的<code>od指令</code>来分析Redis服务器产生的RDB文件，使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。RDB文件路径可通过<code>/etc/redis/redis.conf</code>文件中查看，如下所示，因此RDB文件路径为：<code>/var/lib/redis/dump.rdb</code></p>\n<p><code>/etc/redis/redis.conf</code>中配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 打印的RDB文件名。</span><br><span class=\"line\">dbfilename dump.rdb</span><br><span class=\"line\">#</span><br><span class=\"line\"># 路径.</span><br><span class=\"line\">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-1-不包含任何键值对的RDB文件\"><a href=\"#4-1-不包含任何键值对的RDB文件\" class=\"headerlink\" title=\"4.1 不包含任何键值对的RDB文件\"></a>4.1 不包含任何键值对的RDB文件</h4><p>执行以下命令，创建一个数据库状态为空的RDB文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过od命令打印RDB文件内容，并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>), 如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 377 334 263   C 360   Z 334</span><br><span class=\"line\">0000020 362   V</span><br><span class=\"line\">0000022</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li>五个字节的“REDIS”字符串</li>\n<li>四个字节的版本号（0006）</li>\n<li>377是EOF常量</li>\n<li>334 263   C 360   Z 334 362   V为8个字节的校验和</li>\n</ul>\n<h4 id=\"4-2-包含字符串键的RDB文件\"><a href=\"#4-2-包含字符串键的RDB文件\" class=\"headerlink\" title=\"4.2 包含字符串键的RDB文件\"></a>4.2 包含字符串键的RDB文件</h4><p>执行以下命令，分析一个带有单个字符串键的数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushdb</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;HELLO&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0  \\0 003   m   s   g</span><br><span class=\"line\">0000020 005   H   E   L   L   O 377  \\n   &lt; 342 005   &lt;   A 217   4</span><br><span class=\"line\">0000037</span><br></pre></td></tr></table></figure>\n\n<p>其中:</p>\n<ul>\n<li>五个字节的“REDIS”字符串</li>\n<li>四个字节的版本号（0006）</li>\n<li>376表示SELECTED常量</li>\n<li>\\0表示数据库0</li>\n<li>\\0表示表示字符串</li>\n<li>003表示msg的长度</li>\n<li>msg表示key</li>\n<li>005表示value的长度</li>\n<li>HEELO为value</li>\n<li>377是EOF常量</li>\n<li>\\n   &lt; 342 005   &lt;   A 217   4为8个字节的校验和</li>\n</ul>\n<h4 id=\"4-3-包含过期时间的字符串键的RDB文件\"><a href=\"#4-3-包含过期时间的字符串键的RDB文件\" class=\"headerlink\" title=\"4.3 包含过期时间的字符串键的RDB文件\"></a>4.3 包含过期时间的字符串键的RDB文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; setex msg 10086 <span class=\"string\">&quot;HELLO&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0 374 375   3   &#123;   3</span><br><span class=\"line\">0000020   r 001  \\0  \\0  \\0 003   m   s   g 005   H   E   L   L   O 377</span><br><span class=\"line\">0000040 317   W 312 301 337 313 364 201</span><br><span class=\"line\">0000050</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-4-包含一个集合键的RDB文件\"><a href=\"#4-4-包含一个集合键的RDB文件\" class=\"headerlink\" title=\"4.4 包含一个集合键的RDB文件\"></a>4.4 包含一个集合键的RDB文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; flushall</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; sadd lang <span class=\"string\">&quot;C&quot;</span> <span class=\"string\">&quot;JAVA&quot;</span> <span class=\"string\">&quot;RUBY&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; SAVE</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n\n<p>通过od命令打印RDB文件内容, 并使用ASCII或反斜杠序列展示结果(<code>-c参数</code>)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ od -c dump.rdb</span><br><span class=\"line\">0000000   R   E   D   I   S   0   0   0   6 376  \\0 002 004   l   a   n</span><br><span class=\"line\">0000020   g 003 004   J   A   V   A 004   R   U   B   Y 001   C 377   u</span><br><span class=\"line\">0000040 177 235 372   z 334  \\f 216</span><br><span class=\"line\">0000047</span><br></pre></td></tr></table></figure>"},{"title":"Redis设计与实现-Redis键过期及删除策略","date":"2020-09-03T06:51:51.000Z","_content":"\n### 1 设置键的生存时间或过期时间\n\n通过以下命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置`生存时间`（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。\n\n<!--more-->\n\n- 以`秒`为单位设置过期时间命令：\n\n\n```\nEXPIRE key seconds\n```\n\n- 以`毫秒`为单位设置过期时间命令：\n\n\n```\nPEXPIRE key milliseconds\n```\n\n- 若过期时间是一个UNIX时间戳，以秒为单位设置过期时间命令:\n\n\n```\nEXPIREAT key timestamp\n```\n\n- 若过期时间是一个UNIX时间戳，以微秒为单位设置过期时间命令:\n\n\n```\nPEXPIREAT key milliseconds-timestamp\n```\n\n**注：虽然过期的单位及命令不同，但<u>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</u>。**\n\n\n\n#### 1.1 保存过期时间\n\nredisDb结构的`expires字典`保存了数据库中所有键的过期时间，我们称这个字典为过期字典。\n\n```c\ntypedef struct redisDb {\n    // ...\n    // 过期字典，保存着键的过期时间.\n    dict *expires;\n    // ...\n} redisDb;\n```\n\n其中，\n\n- 过期字典的`键是一个指针`，这个指针指向键空间中的某个键对象。（也就是某个数据库键）。\n- 过期字典的`值是一个long long类型的整数`，这个整数保存了键所指向的数据库键的过期时间——`一个毫秒精度的UNIX时间戳`。\n\n\n\n当客户端执行`PEXPIREAT`等命令设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。\n\n\n\n示例：带有过期字典的数据库示意图\n\n![带有过期字典的数据库示意图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis键过期及删除策略/带有过期字典的数据库示意图.png)\n\n\n\n其中，alphabet和book键对象出现了两次，实际上，键空间和过期字典的键都指向同一个键对象，所以并不会出现任何重复对象。\n\n\n\n#### 1.2 移除过期时间\n\n通过以下命令可以`移除一个键的过期时间`：\n\n```\nPERSIST <key>\n```\n\nPERSIST命令就是PEXPIREAT命令的反操作，PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联。\n\n\n\n#### 1.3 计算并返回剩余生存时间\n\n通过以下命令可以返回键的剩余生存时间：\n\n- ①、以秒为单位返回\n\n```\nTTL <key>\n```\n\n- ②、以毫秒为单位返回\n\n```\nPTTL <key>\n```\n\n\n\n### 2 过期删除策略\n\n**若一个键过期了，它什么时候会被删除呢？可能情况有哪些？**\n\n- ①、`定时删除`：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。\n- ②、`惰性删除`：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，吐过过期的话，就删除该键，如果没有过期，则返回该键。\n- ③、`定期删除`：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。\n\n\n\n#### 2.1 定时删除\n\n定时删除策略的**优点**：通过使用定时器，定时删除策略可以保证过期键会尽快地被删除，并释放过期键所占用的内存。(内存友好)\n\n但定时删除策略的**缺点**：它对CPU时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张，但CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐造成影响。另外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个时间的时间复杂度为O(N)，并不能高效地处理大量时间事件。(CPU不友好)\n\n因此，要让服务器创建大量的定时器，从而实现定时删除策略，现阶段来说并不现实。\n\n\n\n#### 2.2 惰性删除\n\n惰性删除的**优点**：对CPU时间友好，程序只会在取出键时才对建进行过期检查，保证删除过期键的操作只会在费做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的国期间上花费任何CPU时间。\n\n惰性删除的**缺点**：对内存不友好，若一个键已经过期，而这个键又仍然留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。若数据库中有非常多的过期键，而这些过期键又恰好没有访问的话，那么他们也许永远不会被删除（除非用户手动执行`flushdb`），我们甚至可以将这种情况看做`内存泄漏`。\n\n\n\n#### 2.3 定期删除\n\n对于定时删除及惰性删除，均有一些明显的缺陷：\n\n- 定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。\n- 惰性删除浪费太多内存，有内存泄露的风险。\n\n\n\n定期删除策略是前两种策略的一种整合和折中。\n\n- 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。\n- 通过定期删除过期键，定期删除策略有效的减少了因为过期键而带来的内存浪费。\n\n\n\n#### 2.4 Redis的过期键删除策略\n\nRedis实际上用的`惰性删除及定期删除策略`，通过配合使用这两种删除策略，服务器可以很好地合理使用CPU时间和避免浪费内存空间之间取得平衡。\n\n\n\n##### 2.4.1 惰性删除策略的实现\n\n过期键的惰性删除策略是由`db.c/expireIfNeeded`函数实现的，所有读写数据库的Redis命令在执行前都会调用expireIdNeeded函数对输入键进行检查：\n\n- 若输入键`已经过期`，那么expireIfNeeded函数将输入键从数据库中删除。\n- 若输入键`未过期`，那么expireIfNeeded函数不做动作。\n\n注：由于expireIfNeeded函数会将过期键删除，所以每个命令的实现都要能同时处理键存在及键不存在两种情况。\n\n\n\n##### 2.4.2定期删除策略的实现\n\n过期键的定期删除策略由`redis.c/activeExpireCycle`函数实现，每当Redis的服务周期性操作`redis.c/serverCron`函数执行时，activeExpireCycle函数就会被调用。\n\n**activeExpireCycle函数的逻辑**：在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中`随机检查一部分键的过期时间`，并删除其中的过期键。\n\n\n\n### 3 AOF、RDB和复制功能对过期键的处理\n\n#### 3.1 生成RDB文件\n\n执行以下命令将创建一个新的RDB文件，此时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。\n\n- ①、同步保存到磁盘命令\n\n```\nSAVE\n```\n\n- ②、在后台异步保存当前数据到磁盘命令\n\n```\nBGSAVE\n```\n\n\n\n#### 3.2 载入RDB文件\n\n在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：\n\n- ①、若服务器以**主服务器模式**运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。\n- ②、若服务器以**从服务器模式**运行，那么在载入RDB文件时，文件保存的所有键，无论是否过期，都会被载入到数据库中。（*注：因为主从服务器在进行数据同步时，从服务器的数据库就会被清空，所以，一般来说，过期键对载入RDB文件的从服务器也不会造成影响*）\n\n\n\n#### 3.3 AOF文件写入\n\n当服务器以**AOF（AppendOnlyFile）持久化模式**运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。\n\n当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式记录该键已经被删除。\n\n\n\n示例：若客户端使用`GET message`命令试图访问过期的message键，那么服务器将执行以下三个动作。\n\n- ①、从数据库中删除message键。\n- ②、追加一条DEL message命令到AOF文件。\n- ③、向执行GET命令的客户端返回空回复。\n\n\n\n#### 3.4 AOF重写\n\n在执行AOF重写的过程中，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。因此，数据库中包含过期键不会对AOF重写造成影响。\n\n\n\n#### 3.5 复制\n\n当服务器运行在**复制模式**下时，从服务器的过期键删除动作由主服务器控制。\n\n- 当主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。\n- 当从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。\n- 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。\n\n\n\n**为什么要通过主服务器来控制从服务器统一的删除过期键呢**？\n\n保证主从服务器数据库的一致性。\n\n\n\n### 参考资料\n\n1.redis设计与实现（第二版） 黄健宏","source":"_posts/Redis设计与实现-Redis键过期及删除策略.md","raw":"---\ntitle: Redis设计与实现-Redis键过期及删除策略\ndate: 2020-09-03 14:51:51\ntags: [\"Redis\",\"Note\",\"Redis设计与实现\"]\ncategories: [\"Redis\"]\n---\n\n### 1 设置键的生存时间或过期时间\n\n通过以下命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置`生存时间`（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。\n\n<!--more-->\n\n- 以`秒`为单位设置过期时间命令：\n\n\n```\nEXPIRE key seconds\n```\n\n- 以`毫秒`为单位设置过期时间命令：\n\n\n```\nPEXPIRE key milliseconds\n```\n\n- 若过期时间是一个UNIX时间戳，以秒为单位设置过期时间命令:\n\n\n```\nEXPIREAT key timestamp\n```\n\n- 若过期时间是一个UNIX时间戳，以微秒为单位设置过期时间命令:\n\n\n```\nPEXPIREAT key milliseconds-timestamp\n```\n\n**注：虽然过期的单位及命令不同，但<u>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</u>。**\n\n\n\n#### 1.1 保存过期时间\n\nredisDb结构的`expires字典`保存了数据库中所有键的过期时间，我们称这个字典为过期字典。\n\n```c\ntypedef struct redisDb {\n    // ...\n    // 过期字典，保存着键的过期时间.\n    dict *expires;\n    // ...\n} redisDb;\n```\n\n其中，\n\n- 过期字典的`键是一个指针`，这个指针指向键空间中的某个键对象。（也就是某个数据库键）。\n- 过期字典的`值是一个long long类型的整数`，这个整数保存了键所指向的数据库键的过期时间——`一个毫秒精度的UNIX时间戳`。\n\n\n\n当客户端执行`PEXPIREAT`等命令设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。\n\n\n\n示例：带有过期字典的数据库示意图\n\n![带有过期字典的数据库示意图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis键过期及删除策略/带有过期字典的数据库示意图.png)\n\n\n\n其中，alphabet和book键对象出现了两次，实际上，键空间和过期字典的键都指向同一个键对象，所以并不会出现任何重复对象。\n\n\n\n#### 1.2 移除过期时间\n\n通过以下命令可以`移除一个键的过期时间`：\n\n```\nPERSIST <key>\n```\n\nPERSIST命令就是PEXPIREAT命令的反操作，PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联。\n\n\n\n#### 1.3 计算并返回剩余生存时间\n\n通过以下命令可以返回键的剩余生存时间：\n\n- ①、以秒为单位返回\n\n```\nTTL <key>\n```\n\n- ②、以毫秒为单位返回\n\n```\nPTTL <key>\n```\n\n\n\n### 2 过期删除策略\n\n**若一个键过期了，它什么时候会被删除呢？可能情况有哪些？**\n\n- ①、`定时删除`：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。\n- ②、`惰性删除`：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，吐过过期的话，就删除该键，如果没有过期，则返回该键。\n- ③、`定期删除`：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。\n\n\n\n#### 2.1 定时删除\n\n定时删除策略的**优点**：通过使用定时器，定时删除策略可以保证过期键会尽快地被删除，并释放过期键所占用的内存。(内存友好)\n\n但定时删除策略的**缺点**：它对CPU时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张，但CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐造成影响。另外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个时间的时间复杂度为O(N)，并不能高效地处理大量时间事件。(CPU不友好)\n\n因此，要让服务器创建大量的定时器，从而实现定时删除策略，现阶段来说并不现实。\n\n\n\n#### 2.2 惰性删除\n\n惰性删除的**优点**：对CPU时间友好，程序只会在取出键时才对建进行过期检查，保证删除过期键的操作只会在费做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的国期间上花费任何CPU时间。\n\n惰性删除的**缺点**：对内存不友好，若一个键已经过期，而这个键又仍然留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。若数据库中有非常多的过期键，而这些过期键又恰好没有访问的话，那么他们也许永远不会被删除（除非用户手动执行`flushdb`），我们甚至可以将这种情况看做`内存泄漏`。\n\n\n\n#### 2.3 定期删除\n\n对于定时删除及惰性删除，均有一些明显的缺陷：\n\n- 定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。\n- 惰性删除浪费太多内存，有内存泄露的风险。\n\n\n\n定期删除策略是前两种策略的一种整合和折中。\n\n- 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。\n- 通过定期删除过期键，定期删除策略有效的减少了因为过期键而带来的内存浪费。\n\n\n\n#### 2.4 Redis的过期键删除策略\n\nRedis实际上用的`惰性删除及定期删除策略`，通过配合使用这两种删除策略，服务器可以很好地合理使用CPU时间和避免浪费内存空间之间取得平衡。\n\n\n\n##### 2.4.1 惰性删除策略的实现\n\n过期键的惰性删除策略是由`db.c/expireIfNeeded`函数实现的，所有读写数据库的Redis命令在执行前都会调用expireIdNeeded函数对输入键进行检查：\n\n- 若输入键`已经过期`，那么expireIfNeeded函数将输入键从数据库中删除。\n- 若输入键`未过期`，那么expireIfNeeded函数不做动作。\n\n注：由于expireIfNeeded函数会将过期键删除，所以每个命令的实现都要能同时处理键存在及键不存在两种情况。\n\n\n\n##### 2.4.2定期删除策略的实现\n\n过期键的定期删除策略由`redis.c/activeExpireCycle`函数实现，每当Redis的服务周期性操作`redis.c/serverCron`函数执行时，activeExpireCycle函数就会被调用。\n\n**activeExpireCycle函数的逻辑**：在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中`随机检查一部分键的过期时间`，并删除其中的过期键。\n\n\n\n### 3 AOF、RDB和复制功能对过期键的处理\n\n#### 3.1 生成RDB文件\n\n执行以下命令将创建一个新的RDB文件，此时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。\n\n- ①、同步保存到磁盘命令\n\n```\nSAVE\n```\n\n- ②、在后台异步保存当前数据到磁盘命令\n\n```\nBGSAVE\n```\n\n\n\n#### 3.2 载入RDB文件\n\n在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：\n\n- ①、若服务器以**主服务器模式**运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。\n- ②、若服务器以**从服务器模式**运行，那么在载入RDB文件时，文件保存的所有键，无论是否过期，都会被载入到数据库中。（*注：因为主从服务器在进行数据同步时，从服务器的数据库就会被清空，所以，一般来说，过期键对载入RDB文件的从服务器也不会造成影响*）\n\n\n\n#### 3.3 AOF文件写入\n\n当服务器以**AOF（AppendOnlyFile）持久化模式**运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。\n\n当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式记录该键已经被删除。\n\n\n\n示例：若客户端使用`GET message`命令试图访问过期的message键，那么服务器将执行以下三个动作。\n\n- ①、从数据库中删除message键。\n- ②、追加一条DEL message命令到AOF文件。\n- ③、向执行GET命令的客户端返回空回复。\n\n\n\n#### 3.4 AOF重写\n\n在执行AOF重写的过程中，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。因此，数据库中包含过期键不会对AOF重写造成影响。\n\n\n\n#### 3.5 复制\n\n当服务器运行在**复制模式**下时，从服务器的过期键删除动作由主服务器控制。\n\n- 当主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。\n- 当从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。\n- 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。\n\n\n\n**为什么要通过主服务器来控制从服务器统一的删除过期键呢**？\n\n保证主从服务器数据库的一致性。\n\n\n\n### 参考资料\n\n1.redis设计与实现（第二版） 黄健宏","slug":"Redis设计与实现-Redis键过期及删除策略","published":1,"updated":"2020-09-24T10:04:37.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkw002n45g3c2d1epwx","content":"<h3 id=\"1-设置键的生存时间或过期时间\"><a href=\"#1-设置键的生存时间或过期时间\" class=\"headerlink\" title=\"1 设置键的生存时间或过期时间\"></a>1 设置键的生存时间或过期时间</h3><p>通过以下命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置<code>生存时间</code>（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p>\n<a id=\"more\"></a>\n\n<ul>\n<li>以<code>秒</code>为单位设置过期时间命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPIRE key seconds</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以<code>毫秒</code>为单位设置过期时间命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PEXPIRE key milliseconds</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若过期时间是一个UNIX时间戳，以秒为单位设置过期时间命令:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPIREAT key timestamp</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若过期时间是一个UNIX时间戳，以微秒为单位设置过期时间命令:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PEXPIREAT key milliseconds-timestamp</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：虽然过期的单位及命令不同，但<u>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</u>。</strong></p>\n<h4 id=\"1-1-保存过期时间\"><a href=\"#1-1-保存过期时间\" class=\"headerlink\" title=\"1.1 保存过期时间\"></a>1.1 保存过期时间</h4><p>redisDb结构的<code>expires字典</code>保存了数据库中所有键的过期时间，我们称这个字典为过期字典。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDb</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 过期字典，保存着键的过期时间.</span></span><br><span class=\"line\">    dict *expires;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; redisDb;</span><br></pre></td></tr></table></figure>\n\n<p>其中，</p>\n<ul>\n<li>过期字典的<code>键是一个指针</code>，这个指针指向键空间中的某个键对象。（也就是某个数据库键）。</li>\n<li>过期字典的<code>值是一个long long类型的整数</code>，这个整数保存了键所指向的数据库键的过期时间——<code>一个毫秒精度的UNIX时间戳</code>。</li>\n</ul>\n<p>当客户端执行<code>PEXPIREAT</code>等命令设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。</p>\n<p>示例：带有过期字典的数据库示意图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E9%94%AE%E8%BF%87%E6%9C%9F%E5%8F%8A%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/%E5%B8%A6%E6%9C%89%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"带有过期字典的数据库示意图\"></p>\n<p>其中，alphabet和book键对象出现了两次，实际上，键空间和过期字典的键都指向同一个键对象，所以并不会出现任何重复对象。</p>\n<h4 id=\"1-2-移除过期时间\"><a href=\"#1-2-移除过期时间\" class=\"headerlink\" title=\"1.2 移除过期时间\"></a>1.2 移除过期时间</h4><p>通过以下命令可以<code>移除一个键的过期时间</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PERSIST &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>PERSIST命令就是PEXPIREAT命令的反操作，PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联。</p>\n<h4 id=\"1-3-计算并返回剩余生存时间\"><a href=\"#1-3-计算并返回剩余生存时间\" class=\"headerlink\" title=\"1.3 计算并返回剩余生存时间\"></a>1.3 计算并返回剩余生存时间</h4><p>通过以下命令可以返回键的剩余生存时间：</p>\n<ul>\n<li>①、以秒为单位返回</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、以毫秒为单位返回</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PTTL &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-过期删除策略\"><a href=\"#2-过期删除策略\" class=\"headerlink\" title=\"2 过期删除策略\"></a>2 过期删除策略</h3><p><strong>若一个键过期了，它什么时候会被删除呢？可能情况有哪些？</strong></p>\n<ul>\n<li>①、<code>定时删除</code>：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>\n<li>②、<code>惰性删除</code>：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，吐过过期的话，就删除该键，如果没有过期，则返回该键。</li>\n<li>③、<code>定期删除</code>：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>\n</ul>\n<h4 id=\"2-1-定时删除\"><a href=\"#2-1-定时删除\" class=\"headerlink\" title=\"2.1 定时删除\"></a>2.1 定时删除</h4><p>定时删除策略的<strong>优点</strong>：通过使用定时器，定时删除策略可以保证过期键会尽快地被删除，并释放过期键所占用的内存。(内存友好)</p>\n<p>但定时删除策略的<strong>缺点</strong>：它对CPU时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张，但CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐造成影响。另外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个时间的时间复杂度为O(N)，并不能高效地处理大量时间事件。(CPU不友好)</p>\n<p>因此，要让服务器创建大量的定时器，从而实现定时删除策略，现阶段来说并不现实。</p>\n<h4 id=\"2-2-惰性删除\"><a href=\"#2-2-惰性删除\" class=\"headerlink\" title=\"2.2 惰性删除\"></a>2.2 惰性删除</h4><p>惰性删除的<strong>优点</strong>：对CPU时间友好，程序只会在取出键时才对建进行过期检查，保证删除过期键的操作只会在费做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的国期间上花费任何CPU时间。</p>\n<p>惰性删除的<strong>缺点</strong>：对内存不友好，若一个键已经过期，而这个键又仍然留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。若数据库中有非常多的过期键，而这些过期键又恰好没有访问的话，那么他们也许永远不会被删除（除非用户手动执行<code>flushdb</code>），我们甚至可以将这种情况看做<code>内存泄漏</code>。</p>\n<h4 id=\"2-3-定期删除\"><a href=\"#2-3-定期删除\" class=\"headerlink\" title=\"2.3 定期删除\"></a>2.3 定期删除</h4><p>对于定时删除及惰性删除，均有一些明显的缺陷：</p>\n<ul>\n<li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li>\n<li>惰性删除浪费太多内存，有内存泄露的风险。</li>\n</ul>\n<p>定期删除策略是前两种策略的一种整合和折中。</p>\n<ul>\n<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>\n<li>通过定期删除过期键，定期删除策略有效的减少了因为过期键而带来的内存浪费。</li>\n</ul>\n<h4 id=\"2-4-Redis的过期键删除策略\"><a href=\"#2-4-Redis的过期键删除策略\" class=\"headerlink\" title=\"2.4 Redis的过期键删除策略\"></a>2.4 Redis的过期键删除策略</h4><p>Redis实际上用的<code>惰性删除及定期删除策略</code>，通过配合使用这两种删除策略，服务器可以很好地合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>\n<h5 id=\"2-4-1-惰性删除策略的实现\"><a href=\"#2-4-1-惰性删除策略的实现\" class=\"headerlink\" title=\"2.4.1 惰性删除策略的实现\"></a>2.4.1 惰性删除策略的实现</h5><p>过期键的惰性删除策略是由<code>db.c/expireIfNeeded</code>函数实现的，所有读写数据库的Redis命令在执行前都会调用expireIdNeeded函数对输入键进行检查：</p>\n<ul>\n<li>若输入键<code>已经过期</code>，那么expireIfNeeded函数将输入键从数据库中删除。</li>\n<li>若输入键<code>未过期</code>，那么expireIfNeeded函数不做动作。</li>\n</ul>\n<p>注：由于expireIfNeeded函数会将过期键删除，所以每个命令的实现都要能同时处理键存在及键不存在两种情况。</p>\n<h5 id=\"2-4-2定期删除策略的实现\"><a href=\"#2-4-2定期删除策略的实现\" class=\"headerlink\" title=\"2.4.2定期删除策略的实现\"></a>2.4.2定期删除策略的实现</h5><p>过期键的定期删除策略由<code>redis.c/activeExpireCycle</code>函数实现，每当Redis的服务周期性操作<code>redis.c/serverCron</code>函数执行时，activeExpireCycle函数就会被调用。</p>\n<p><strong>activeExpireCycle函数的逻辑</strong>：在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中<code>随机检查一部分键的过期时间</code>，并删除其中的过期键。</p>\n<h3 id=\"3-AOF、RDB和复制功能对过期键的处理\"><a href=\"#3-AOF、RDB和复制功能对过期键的处理\" class=\"headerlink\" title=\"3 AOF、RDB和复制功能对过期键的处理\"></a>3 AOF、RDB和复制功能对过期键的处理</h3><h4 id=\"3-1-生成RDB文件\"><a href=\"#3-1-生成RDB文件\" class=\"headerlink\" title=\"3.1 生成RDB文件\"></a>3.1 生成RDB文件</h4><p>执行以下命令将创建一个新的RDB文件，此时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p>\n<ul>\n<li>①、同步保存到磁盘命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAVE</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、在后台异步保存当前数据到磁盘命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BGSAVE</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-载入RDB文件\"><a href=\"#3-2-载入RDB文件\" class=\"headerlink\" title=\"3.2 载入RDB文件\"></a>3.2 载入RDB文件</h4><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p>\n<ul>\n<li>①、若服务器以<strong>主服务器模式</strong>运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li>\n<li>②、若服务器以<strong>从服务器模式</strong>运行，那么在载入RDB文件时，文件保存的所有键，无论是否过期，都会被载入到数据库中。（<em>注：因为主从服务器在进行数据同步时，从服务器的数据库就会被清空，所以，一般来说，过期键对载入RDB文件的从服务器也不会造成影响</em>）</li>\n</ul>\n<h4 id=\"3-3-AOF文件写入\"><a href=\"#3-3-AOF文件写入\" class=\"headerlink\" title=\"3.3 AOF文件写入\"></a>3.3 AOF文件写入</h4><p>当服务器以<strong>AOF（AppendOnlyFile）持久化模式</strong>运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p>\n<p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式记录该键已经被删除。</p>\n<p>示例：若客户端使用<code>GET message</code>命令试图访问过期的message键，那么服务器将执行以下三个动作。</p>\n<ul>\n<li>①、从数据库中删除message键。</li>\n<li>②、追加一条DEL message命令到AOF文件。</li>\n<li>③、向执行GET命令的客户端返回空回复。</li>\n</ul>\n<h4 id=\"3-4-AOF重写\"><a href=\"#3-4-AOF重写\" class=\"headerlink\" title=\"3.4 AOF重写\"></a>3.4 AOF重写</h4><p>在执行AOF重写的过程中，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。因此，数据库中包含过期键不会对AOF重写造成影响。</p>\n<h4 id=\"3-5-复制\"><a href=\"#3-5-复制\" class=\"headerlink\" title=\"3.5 复制\"></a>3.5 复制</h4><p>当服务器运行在<strong>复制模式</strong>下时，从服务器的过期键删除动作由主服务器控制。</p>\n<ul>\n<li>当主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li>\n<li>当从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li>\n<li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li>\n</ul>\n<p><strong>为什么要通过主服务器来控制从服务器统一的删除过期键呢</strong>？</p>\n<p>保证主从服务器数据库的一致性。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>1.redis设计与实现（第二版） 黄健宏</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-设置键的生存时间或过期时间\"><a href=\"#1-设置键的生存时间或过期时间\" class=\"headerlink\" title=\"1 设置键的生存时间或过期时间\"></a>1 设置键的生存时间或过期时间</h3><p>通过以下命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置<code>生存时间</code>（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p>","more":"<ul>\n<li>以<code>秒</code>为单位设置过期时间命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPIRE key seconds</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以<code>毫秒</code>为单位设置过期时间命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PEXPIRE key milliseconds</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若过期时间是一个UNIX时间戳，以秒为单位设置过期时间命令:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPIREAT key timestamp</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>若过期时间是一个UNIX时间戳，以微秒为单位设置过期时间命令:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PEXPIREAT key milliseconds-timestamp</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：虽然过期的单位及命令不同，但<u>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</u>。</strong></p>\n<h4 id=\"1-1-保存过期时间\"><a href=\"#1-1-保存过期时间\" class=\"headerlink\" title=\"1.1 保存过期时间\"></a>1.1 保存过期时间</h4><p>redisDb结构的<code>expires字典</code>保存了数据库中所有键的过期时间，我们称这个字典为过期字典。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDb</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 过期字典，保存着键的过期时间.</span></span><br><span class=\"line\">    dict *expires;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; redisDb;</span><br></pre></td></tr></table></figure>\n\n<p>其中，</p>\n<ul>\n<li>过期字典的<code>键是一个指针</code>，这个指针指向键空间中的某个键对象。（也就是某个数据库键）。</li>\n<li>过期字典的<code>值是一个long long类型的整数</code>，这个整数保存了键所指向的数据库键的过期时间——<code>一个毫秒精度的UNIX时间戳</code>。</li>\n</ul>\n<p>当客户端执行<code>PEXPIREAT</code>等命令设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。</p>\n<p>示例：带有过期字典的数据库示意图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E9%94%AE%E8%BF%87%E6%9C%9F%E5%8F%8A%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/%E5%B8%A6%E6%9C%89%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"带有过期字典的数据库示意图\"></p>\n<p>其中，alphabet和book键对象出现了两次，实际上，键空间和过期字典的键都指向同一个键对象，所以并不会出现任何重复对象。</p>\n<h4 id=\"1-2-移除过期时间\"><a href=\"#1-2-移除过期时间\" class=\"headerlink\" title=\"1.2 移除过期时间\"></a>1.2 移除过期时间</h4><p>通过以下命令可以<code>移除一个键的过期时间</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PERSIST &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>PERSIST命令就是PEXPIREAT命令的反操作，PERSIST命令在过期字典中查找给定的键，并解除键和值在过期字典中的关联。</p>\n<h4 id=\"1-3-计算并返回剩余生存时间\"><a href=\"#1-3-计算并返回剩余生存时间\" class=\"headerlink\" title=\"1.3 计算并返回剩余生存时间\"></a>1.3 计算并返回剩余生存时间</h4><p>通过以下命令可以返回键的剩余生存时间：</p>\n<ul>\n<li>①、以秒为单位返回</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、以毫秒为单位返回</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PTTL &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-过期删除策略\"><a href=\"#2-过期删除策略\" class=\"headerlink\" title=\"2 过期删除策略\"></a>2 过期删除策略</h3><p><strong>若一个键过期了，它什么时候会被删除呢？可能情况有哪些？</strong></p>\n<ul>\n<li>①、<code>定时删除</code>：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>\n<li>②、<code>惰性删除</code>：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，吐过过期的话，就删除该键，如果没有过期，则返回该键。</li>\n<li>③、<code>定期删除</code>：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>\n</ul>\n<h4 id=\"2-1-定时删除\"><a href=\"#2-1-定时删除\" class=\"headerlink\" title=\"2.1 定时删除\"></a>2.1 定时删除</h4><p>定时删除策略的<strong>优点</strong>：通过使用定时器，定时删除策略可以保证过期键会尽快地被删除，并释放过期键所占用的内存。(内存友好)</p>\n<p>但定时删除策略的<strong>缺点</strong>：它对CPU时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张，但CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐造成影响。另外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个时间的时间复杂度为O(N)，并不能高效地处理大量时间事件。(CPU不友好)</p>\n<p>因此，要让服务器创建大量的定时器，从而实现定时删除策略，现阶段来说并不现实。</p>\n<h4 id=\"2-2-惰性删除\"><a href=\"#2-2-惰性删除\" class=\"headerlink\" title=\"2.2 惰性删除\"></a>2.2 惰性删除</h4><p>惰性删除的<strong>优点</strong>：对CPU时间友好，程序只会在取出键时才对建进行过期检查，保证删除过期键的操作只会在费做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的国期间上花费任何CPU时间。</p>\n<p>惰性删除的<strong>缺点</strong>：对内存不友好，若一个键已经过期，而这个键又仍然留在数据库中，那么只要这个过期键不被删除，他所占用的内存就不会释放。若数据库中有非常多的过期键，而这些过期键又恰好没有访问的话，那么他们也许永远不会被删除（除非用户手动执行<code>flushdb</code>），我们甚至可以将这种情况看做<code>内存泄漏</code>。</p>\n<h4 id=\"2-3-定期删除\"><a href=\"#2-3-定期删除\" class=\"headerlink\" title=\"2.3 定期删除\"></a>2.3 定期删除</h4><p>对于定时删除及惰性删除，均有一些明显的缺陷：</p>\n<ul>\n<li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li>\n<li>惰性删除浪费太多内存，有内存泄露的风险。</li>\n</ul>\n<p>定期删除策略是前两种策略的一种整合和折中。</p>\n<ul>\n<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>\n<li>通过定期删除过期键，定期删除策略有效的减少了因为过期键而带来的内存浪费。</li>\n</ul>\n<h4 id=\"2-4-Redis的过期键删除策略\"><a href=\"#2-4-Redis的过期键删除策略\" class=\"headerlink\" title=\"2.4 Redis的过期键删除策略\"></a>2.4 Redis的过期键删除策略</h4><p>Redis实际上用的<code>惰性删除及定期删除策略</code>，通过配合使用这两种删除策略，服务器可以很好地合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>\n<h5 id=\"2-4-1-惰性删除策略的实现\"><a href=\"#2-4-1-惰性删除策略的实现\" class=\"headerlink\" title=\"2.4.1 惰性删除策略的实现\"></a>2.4.1 惰性删除策略的实现</h5><p>过期键的惰性删除策略是由<code>db.c/expireIfNeeded</code>函数实现的，所有读写数据库的Redis命令在执行前都会调用expireIdNeeded函数对输入键进行检查：</p>\n<ul>\n<li>若输入键<code>已经过期</code>，那么expireIfNeeded函数将输入键从数据库中删除。</li>\n<li>若输入键<code>未过期</code>，那么expireIfNeeded函数不做动作。</li>\n</ul>\n<p>注：由于expireIfNeeded函数会将过期键删除，所以每个命令的实现都要能同时处理键存在及键不存在两种情况。</p>\n<h5 id=\"2-4-2定期删除策略的实现\"><a href=\"#2-4-2定期删除策略的实现\" class=\"headerlink\" title=\"2.4.2定期删除策略的实现\"></a>2.4.2定期删除策略的实现</h5><p>过期键的定期删除策略由<code>redis.c/activeExpireCycle</code>函数实现，每当Redis的服务周期性操作<code>redis.c/serverCron</code>函数执行时，activeExpireCycle函数就会被调用。</p>\n<p><strong>activeExpireCycle函数的逻辑</strong>：在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中<code>随机检查一部分键的过期时间</code>，并删除其中的过期键。</p>\n<h3 id=\"3-AOF、RDB和复制功能对过期键的处理\"><a href=\"#3-AOF、RDB和复制功能对过期键的处理\" class=\"headerlink\" title=\"3 AOF、RDB和复制功能对过期键的处理\"></a>3 AOF、RDB和复制功能对过期键的处理</h3><h4 id=\"3-1-生成RDB文件\"><a href=\"#3-1-生成RDB文件\" class=\"headerlink\" title=\"3.1 生成RDB文件\"></a>3.1 生成RDB文件</h4><p>执行以下命令将创建一个新的RDB文件，此时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p>\n<ul>\n<li>①、同步保存到磁盘命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAVE</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、在后台异步保存当前数据到磁盘命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BGSAVE</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-载入RDB文件\"><a href=\"#3-2-载入RDB文件\" class=\"headerlink\" title=\"3.2 载入RDB文件\"></a>3.2 载入RDB文件</h4><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p>\n<ul>\n<li>①、若服务器以<strong>主服务器模式</strong>运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li>\n<li>②、若服务器以<strong>从服务器模式</strong>运行，那么在载入RDB文件时，文件保存的所有键，无论是否过期，都会被载入到数据库中。（<em>注：因为主从服务器在进行数据同步时，从服务器的数据库就会被清空，所以，一般来说，过期键对载入RDB文件的从服务器也不会造成影响</em>）</li>\n</ul>\n<h4 id=\"3-3-AOF文件写入\"><a href=\"#3-3-AOF文件写入\" class=\"headerlink\" title=\"3.3 AOF文件写入\"></a>3.3 AOF文件写入</h4><p>当服务器以<strong>AOF（AppendOnlyFile）持久化模式</strong>运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p>\n<p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式记录该键已经被删除。</p>\n<p>示例：若客户端使用<code>GET message</code>命令试图访问过期的message键，那么服务器将执行以下三个动作。</p>\n<ul>\n<li>①、从数据库中删除message键。</li>\n<li>②、追加一条DEL message命令到AOF文件。</li>\n<li>③、向执行GET命令的客户端返回空回复。</li>\n</ul>\n<h4 id=\"3-4-AOF重写\"><a href=\"#3-4-AOF重写\" class=\"headerlink\" title=\"3.4 AOF重写\"></a>3.4 AOF重写</h4><p>在执行AOF重写的过程中，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。因此，数据库中包含过期键不会对AOF重写造成影响。</p>\n<h4 id=\"3-5-复制\"><a href=\"#3-5-复制\" class=\"headerlink\" title=\"3.5 复制\"></a>3.5 复制</h4><p>当服务器运行在<strong>复制模式</strong>下时，从服务器的过期键删除动作由主服务器控制。</p>\n<ul>\n<li>当主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li>\n<li>当从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li>\n<li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li>\n</ul>\n<p><strong>为什么要通过主服务器来控制从服务器统一的删除过期键呢</strong>？</p>\n<p>保证主从服务器数据库的一致性。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>1.redis设计与实现（第二版） 黄健宏</p>"},{"title":"TCP/IP-三次握手与四次挥手","date":"2020-09-23T09:16:33.000Z","_content":"\n### 1 引言\n\n之前面试被问到三次握手，四次挥手，回答的一塌糊涂．．．\n\n<!--more-->\n\n### 2 三次握手\n\n三次握手过程：\n\n- TCP服务器进程先创建传输控制块TCB，进入LISTEN状态。\n- TCP客户端进程创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同部位`SYN=1`，同时选择一个初始序列号`seq=x`，此时，TCP客户端进程进入`SYN-SENT`(同步已发送状态)状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但要消耗一个序号。\n- TCP服务器接收到请求报文后，如果同意连接，则发出确认报文，确认报文中应该`ACK=1,SYN=1,`确认号是`ack=x+1`,同时为自己初始化一个序列号`seq=y`，此时，TCP服务器进程进入了`SYN-RCVD（同步收到）`状态。这个报文也不能携带数据，但是同样要消耗一个序号。\n- TCP客户进程收到确认后，还要向服务器给出确认，确认报文的`ACK=1，ack=y+1，seq=x+1`，此时，TCP连接建立，客户端进入ESTABLISHED(已建立连接)状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。\n- 当服务器收到客户端的确认后也进入ESTABLISHED状态，开始通信。\n\n示意图：   \n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/TCP-IP/三次握手.png\" alt=\"三次握手\" style=\"zoom:67%;\" />\n\n### 3 四次挥手\n\n四次挥手过程：\n\n- 客户端进程发出连接释放报文，并且停止发送数据。释放诗句报文首部，FIN=1，seq=u（等于前面已经传送过的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文即使不携带数据，也要消耗一个序号。\n- 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，seq=v，此时，服务器进CLOSE-WAIT（关闭等待）状态。TCP服务器通知上层应用进程，客户端已经没有数据要发送了，但服务器若发送数据，客户端依然要接受。这个状态要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n- 客户端收到服务器的确认请求后，此时，客户端进入FIN-WAIT-2（终止等待2）状态，等待服务器发送链接释放报文（在这之前还需要接收服务器发送的最后的数据）。\n- 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1,ack=u+1,seq=w,此时服务器就进入了LAST-ACK（最后确认）状态，等待客户端确认。\n- 客户端收到服务器的链接释放报文后，必须发送确认，ACK=1,ack=w+1，seq=u+1，此时，客户端就进入了TIME-WAIT(时间等待)状态。（注意：此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB之后，才进入CLOSE状态。）\n- 服务器只要收到了客户端发出的确认，立即进入CLOSE状态，同样，撤销TCB后，就结束了这次TCP连接。（服务器结束TCP连接的时间要早于客户端。）\n\n​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/TCP-IP/四次挥手.png\" alt=\"四次挥手\" style=\"zoom:67%;\" />\n\n### 4 常见面试问题\n\n#### 4.1 为什么TCP客户端最后还要发送一次确认呢？\n\n**主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。**\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n　　\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n　　\n\n#### 4.2 为什么建立连接是三次握手，关闭连接确是四次挥手呢？\n\n建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。\n\n而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，服务方ACK和FIN一般都会分开发送，从而导致多了一次。\n　　\n\n#### 4.3 如果已经建立了连接，但是客户端突然出现故障了怎么办？\n\nTCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n　　\n\n#### 4.4 TCP四次挥手为什么客户端最后还要等待2MSL？\n\nMSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。\n第一，**保证客户端发送的最后一个ACK报文能够到达服务器**，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。\n第二，**防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中**。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。\n\n\n\n------\n### 参考资料\n\n[两张动图-彻底明白TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)\n[TCP的三次握手与四次挥手理解及面试题（很全面）](https://blog.csdn.net/qq_38950316/article/details/81087809)","source":"_posts/TCP-IP-三次握手与四次挥手.md","raw":"---\ntitle: TCP/IP-三次握手与四次挥手\ndate: 2020-09-23 17:16:33\ntags: [\"TCP/IP\",\"Interview\"]\ncategories: [\"TCP/IP\"]\n---\n\n### 1 引言\n\n之前面试被问到三次握手，四次挥手，回答的一塌糊涂．．．\n\n<!--more-->\n\n### 2 三次握手\n\n三次握手过程：\n\n- TCP服务器进程先创建传输控制块TCB，进入LISTEN状态。\n- TCP客户端进程创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同部位`SYN=1`，同时选择一个初始序列号`seq=x`，此时，TCP客户端进程进入`SYN-SENT`(同步已发送状态)状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但要消耗一个序号。\n- TCP服务器接收到请求报文后，如果同意连接，则发出确认报文，确认报文中应该`ACK=1,SYN=1,`确认号是`ack=x+1`,同时为自己初始化一个序列号`seq=y`，此时，TCP服务器进程进入了`SYN-RCVD（同步收到）`状态。这个报文也不能携带数据，但是同样要消耗一个序号。\n- TCP客户进程收到确认后，还要向服务器给出确认，确认报文的`ACK=1，ack=y+1，seq=x+1`，此时，TCP连接建立，客户端进入ESTABLISHED(已建立连接)状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。\n- 当服务器收到客户端的确认后也进入ESTABLISHED状态，开始通信。\n\n示意图：   \n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/TCP-IP/三次握手.png\" alt=\"三次握手\" style=\"zoom:67%;\" />\n\n### 3 四次挥手\n\n四次挥手过程：\n\n- 客户端进程发出连接释放报文，并且停止发送数据。释放诗句报文首部，FIN=1，seq=u（等于前面已经传送过的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文即使不携带数据，也要消耗一个序号。\n- 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，seq=v，此时，服务器进CLOSE-WAIT（关闭等待）状态。TCP服务器通知上层应用进程，客户端已经没有数据要发送了，但服务器若发送数据，客户端依然要接受。这个状态要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n- 客户端收到服务器的确认请求后，此时，客户端进入FIN-WAIT-2（终止等待2）状态，等待服务器发送链接释放报文（在这之前还需要接收服务器发送的最后的数据）。\n- 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1,ack=u+1,seq=w,此时服务器就进入了LAST-ACK（最后确认）状态，等待客户端确认。\n- 客户端收到服务器的链接释放报文后，必须发送确认，ACK=1,ack=w+1，seq=u+1，此时，客户端就进入了TIME-WAIT(时间等待)状态。（注意：此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB之后，才进入CLOSE状态。）\n- 服务器只要收到了客户端发出的确认，立即进入CLOSE状态，同样，撤销TCB后，就结束了这次TCP连接。（服务器结束TCP连接的时间要早于客户端。）\n\n​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/TCP-IP/四次挥手.png\" alt=\"四次挥手\" style=\"zoom:67%;\" />\n\n### 4 常见面试问题\n\n#### 4.1 为什么TCP客户端最后还要发送一次确认呢？\n\n**主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。**\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n　　\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n　　\n\n#### 4.2 为什么建立连接是三次握手，关闭连接确是四次挥手呢？\n\n建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。\n\n而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，服务方ACK和FIN一般都会分开发送，从而导致多了一次。\n　　\n\n#### 4.3 如果已经建立了连接，但是客户端突然出现故障了怎么办？\n\nTCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n　　\n\n#### 4.4 TCP四次挥手为什么客户端最后还要等待2MSL？\n\nMSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。\n第一，**保证客户端发送的最后一个ACK报文能够到达服务器**，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。\n第二，**防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中**。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。\n\n\n\n------\n### 参考资料\n\n[两张动图-彻底明白TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)\n[TCP的三次握手与四次挥手理解及面试题（很全面）](https://blog.csdn.net/qq_38950316/article/details/81087809)","slug":"TCP-IP-三次握手与四次挥手","published":1,"updated":"2020-09-23T09:59:14.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabky002q45g3dmymg1en","content":"<h3 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h3><p>之前面试被问到三次握手，四次挥手，回答的一塌糊涂．．．</p>\n<a id=\"more\"></a>\n\n<h3 id=\"2-三次握手\"><a href=\"#2-三次握手\" class=\"headerlink\" title=\"2 三次握手\"></a>2 三次握手</h3><p>三次握手过程：</p>\n<ul>\n<li>TCP服务器进程先创建传输控制块TCB，进入LISTEN状态。</li>\n<li>TCP客户端进程创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同部位<code>SYN=1</code>，同时选择一个初始序列号<code>seq=x</code>，此时，TCP客户端进程进入<code>SYN-SENT</code>(同步已发送状态)状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但要消耗一个序号。</li>\n<li>TCP服务器接收到请求报文后，如果同意连接，则发出确认报文，确认报文中应该<code>ACK=1,SYN=1,</code>确认号是<code>ack=x+1</code>,同时为自己初始化一个序列号<code>seq=y</code>，此时，TCP服务器进程进入了<code>SYN-RCVD（同步收到）</code>状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>\n<li>TCP客户进程收到确认后，还要向服务器给出确认，确认报文的<code>ACK=1，ack=y+1，seq=x+1</code>，此时，TCP连接建立，客户端进入ESTABLISHED(已建立连接)状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>\n<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，开始通信。</li>\n</ul>\n<p>示意图：   </p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/TCP-IP/三次握手.png\" alt=\"三次握手\" style=\"zoom:67%;\" />\n\n<h3 id=\"3-四次挥手\"><a href=\"#3-四次挥手\" class=\"headerlink\" title=\"3 四次挥手\"></a>3 四次挥手</h3><p>四次挥手过程：</p>\n<ul>\n<li>客户端进程发出连接释放报文，并且停止发送数据。释放诗句报文首部，FIN=1，seq=u（等于前面已经传送过的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文即使不携带数据，也要消耗一个序号。</li>\n<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，seq=v，此时，服务器进CLOSE-WAIT（关闭等待）状态。TCP服务器通知上层应用进程，客户端已经没有数据要发送了，但服务器若发送数据，客户端依然要接受。这个状态要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>\n<li>客户端收到服务器的确认请求后，此时，客户端进入FIN-WAIT-2（终止等待2）状态，等待服务器发送链接释放报文（在这之前还需要接收服务器发送的最后的数据）。</li>\n<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1,ack=u+1,seq=w,此时服务器就进入了LAST-ACK（最后确认）状态，等待客户端确认。</li>\n<li>客户端收到服务器的链接释放报文后，必须发送确认，ACK=1,ack=w+1，seq=u+1，此时，客户端就进入了TIME-WAIT(时间等待)状态。（注意：此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB之后，才进入CLOSE状态。）</li>\n<li>服务器只要收到了客户端发出的确认，立即进入CLOSE状态，同样，撤销TCB后，就结束了这次TCP连接。（服务器结束TCP连接的时间要早于客户端。）</li>\n</ul>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/TCP-IP/四次挥手.png\" alt=\"四次挥手\" style=\"zoom:67%;\" /></p>\n<h3 id=\"4-常见面试问题\"><a href=\"#4-常见面试问题\" class=\"headerlink\" title=\"4 常见面试问题\"></a>4 常见面试问题</h3><h4 id=\"4-1-为什么TCP客户端最后还要发送一次确认呢？\"><a href=\"#4-1-为什么TCP客户端最后还要发送一次确认呢？\" class=\"headerlink\" title=\"4.1 为什么TCP客户端最后还要发送一次确认呢？\"></a>4.1 为什么TCP客户端最后还要发送一次确认呢？</h4><p><strong>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</strong></p>\n<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br>　　<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n　　</p>\n<h4 id=\"4-2-为什么建立连接是三次握手，关闭连接确是四次挥手呢？\"><a href=\"#4-2-为什么建立连接是三次握手，关闭连接确是四次挥手呢？\" class=\"headerlink\" title=\"4.2 为什么建立连接是三次握手，关闭连接确是四次挥手呢？\"></a>4.2 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p>\n<p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，服务方ACK和FIN一般都会分开发送，从而导致多了一次。\n　　</p>\n<h4 id=\"4-3-如果已经建立了连接，但是客户端突然出现故障了怎么办？\"><a href=\"#4-3-如果已经建立了连接，但是客户端突然出现故障了怎么办？\" class=\"headerlink\" title=\"4.3 如果已经建立了连接，但是客户端突然出现故障了怎么办？\"></a>4.3 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n　　</p>\n<h4 id=\"4-4-TCP四次挥手为什么客户端最后还要等待2MSL？\"><a href=\"#4-4-TCP四次挥手为什么客户端最后还要等待2MSL？\" class=\"headerlink\" title=\"4.4 TCP四次挥手为什么客户端最后还要等待2MSL？\"></a>4.4 TCP四次挥手为什么客户端最后还要等待2MSL？</h4><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。<br>第一，<strong>保证客户端发送的最后一个ACK报文能够到达服务器</strong>，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<br>第二，<strong>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中</strong>。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\">两张动图-彻底明白TCP的三次握手与四次挥手</a><br><a href=\"https://blog.csdn.net/qq_38950316/article/details/81087809\">TCP的三次握手与四次挥手理解及面试题（很全面）</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1 引言\"></a>1 引言</h3><p>之前面试被问到三次握手，四次挥手，回答的一塌糊涂．．．</p>","more":"<h3 id=\"2-三次握手\"><a href=\"#2-三次握手\" class=\"headerlink\" title=\"2 三次握手\"></a>2 三次握手</h3><p>三次握手过程：</p>\n<ul>\n<li>TCP服务器进程先创建传输控制块TCB，进入LISTEN状态。</li>\n<li>TCP客户端进程创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同部位<code>SYN=1</code>，同时选择一个初始序列号<code>seq=x</code>，此时，TCP客户端进程进入<code>SYN-SENT</code>(同步已发送状态)状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但要消耗一个序号。</li>\n<li>TCP服务器接收到请求报文后，如果同意连接，则发出确认报文，确认报文中应该<code>ACK=1,SYN=1,</code>确认号是<code>ack=x+1</code>,同时为自己初始化一个序列号<code>seq=y</code>，此时，TCP服务器进程进入了<code>SYN-RCVD（同步收到）</code>状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>\n<li>TCP客户进程收到确认后，还要向服务器给出确认，确认报文的<code>ACK=1，ack=y+1，seq=x+1</code>，此时，TCP连接建立，客户端进入ESTABLISHED(已建立连接)状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>\n<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，开始通信。</li>\n</ul>\n<p>示意图：   </p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/TCP-IP/三次握手.png\" alt=\"三次握手\" style=\"zoom:67%;\" />\n\n<h3 id=\"3-四次挥手\"><a href=\"#3-四次挥手\" class=\"headerlink\" title=\"3 四次挥手\"></a>3 四次挥手</h3><p>四次挥手过程：</p>\n<ul>\n<li>客户端进程发出连接释放报文，并且停止发送数据。释放诗句报文首部，FIN=1，seq=u（等于前面已经传送过的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文即使不携带数据，也要消耗一个序号。</li>\n<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，seq=v，此时，服务器进CLOSE-WAIT（关闭等待）状态。TCP服务器通知上层应用进程，客户端已经没有数据要发送了，但服务器若发送数据，客户端依然要接受。这个状态要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>\n<li>客户端收到服务器的确认请求后，此时，客户端进入FIN-WAIT-2（终止等待2）状态，等待服务器发送链接释放报文（在这之前还需要接收服务器发送的最后的数据）。</li>\n<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1,ack=u+1,seq=w,此时服务器就进入了LAST-ACK（最后确认）状态，等待客户端确认。</li>\n<li>客户端收到服务器的链接释放报文后，必须发送确认，ACK=1,ack=w+1，seq=u+1，此时，客户端就进入了TIME-WAIT(时间等待)状态。（注意：此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB之后，才进入CLOSE状态。）</li>\n<li>服务器只要收到了客户端发出的确认，立即进入CLOSE状态，同样，撤销TCB后，就结束了这次TCP连接。（服务器结束TCP连接的时间要早于客户端。）</li>\n</ul>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/TCP-IP/四次挥手.png\" alt=\"四次挥手\" style=\"zoom:67%;\" /></p>\n<h3 id=\"4-常见面试问题\"><a href=\"#4-常见面试问题\" class=\"headerlink\" title=\"4 常见面试问题\"></a>4 常见面试问题</h3><h4 id=\"4-1-为什么TCP客户端最后还要发送一次确认呢？\"><a href=\"#4-1-为什么TCP客户端最后还要发送一次确认呢？\" class=\"headerlink\" title=\"4.1 为什么TCP客户端最后还要发送一次确认呢？\"></a>4.1 为什么TCP客户端最后还要发送一次确认呢？</h4><p><strong>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</strong></p>\n<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br>　　<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n　　</p>\n<h4 id=\"4-2-为什么建立连接是三次握手，关闭连接确是四次挥手呢？\"><a href=\"#4-2-为什么建立连接是三次握手，关闭连接确是四次挥手呢？\" class=\"headerlink\" title=\"4.2 为什么建立连接是三次握手，关闭连接确是四次挥手呢？\"></a>4.2 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p>\n<p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，服务方ACK和FIN一般都会分开发送，从而导致多了一次。\n　　</p>\n<h4 id=\"4-3-如果已经建立了连接，但是客户端突然出现故障了怎么办？\"><a href=\"#4-3-如果已经建立了连接，但是客户端突然出现故障了怎么办？\" class=\"headerlink\" title=\"4.3 如果已经建立了连接，但是客户端突然出现故障了怎么办？\"></a>4.3 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n　　</p>\n<h4 id=\"4-4-TCP四次挥手为什么客户端最后还要等待2MSL？\"><a href=\"#4-4-TCP四次挥手为什么客户端最后还要等待2MSL？\" class=\"headerlink\" title=\"4.4 TCP四次挥手为什么客户端最后还要等待2MSL？\"></a>4.4 TCP四次挥手为什么客户端最后还要等待2MSL？</h4><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。<br>第一，<strong>保证客户端发送的最后一个ACK报文能够到达服务器</strong>，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<br>第二，<strong>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中</strong>。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\">两张动图-彻底明白TCP的三次握手与四次挥手</a><br><a href=\"https://blog.csdn.net/qq_38950316/article/details/81087809\">TCP的三次握手与四次挥手理解及面试题（很全面）</a></p>"},{"title":"Ubuntu16.04-Github配置及使用","date":"2020-08-18T09:50:49.000Z","_content":"\n#### 一、Git安装\n\n安装命令：\n```\nsudo apt-get install git\n```\n\n<!--more-->\n\n#### 二、Github账号\n\n##### 2.1 注册GitHub账号\n注册地址：[官网](https://github.com/)\n\n##### 2.2 SSH配置\n配置方式参考：Ubuntu 16.04-设置SSH密钥.md\n\n##### 2.3 GitHub配置\n- 去登录github账户，在右上角点击头像找到Settings\n- 点进去后点击左侧栏中的SSH and GPG keys\n- 点击右侧New SSH key\n- 随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来\n- 保存即可\n\n##### 2.4 连接测试\n终端输入以下命令：\n```\n$ ssh -T git@github.com\nHi Jovry-Lee! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n表示github配置完成。\n\n#### 三、配置本地Git个人信息\n    Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。\n##### 3.1 配置全局个人信息\n```\n$ git config --global user.name \"your github name\"\n$ git config --global user.email \"youraddress@youremail.com\"\n```\n\n##### 3.2 配置单个项目个人信息\n    设置单个项目信息\n```\n$ git config user.name \"your github name\"\n$ git config user.email \"youraddress@youremail.com\"\n```\n\n#### 四、上传本地项目到GitHub\n##### 4.1 创建远程代码仓库\n- 点击右上角“＋”旁边的小三角，选择“New repository”；\n- 填写代码仓库信息；\n- 点击“Create repository”。\n\n##### 4.2 设置本地仓库\n```\n#把这个目录变成Git可以管理的仓库\ngit init\n# 文件添加到仓库\ngit add README.md\n# 添加所有文件.\ngit add .\n# 提交文件到仓库\ngit commit -m \"first commit\"\n# 管理远程仓库\ngit remote add origin <仓库地址>\n# 将本地库的所有内容推送到远程库上\ngit push -u origin master\n```\n---\n#### 参考文档\n1. [Ubuntu 16.04下Github配置](https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/)\n2. [github入门到上传本地项目](https://www.cnblogs.com/specter45/p/github.html)","source":"_posts/Ubuntu16-04-Github配置及使用.md","raw":"---\ntitle: Ubuntu16.04-Github配置及使用\ndate: 2020-08-18 17:50:49\ntags: [\"Ubuntu\", \"Config\", \"Git\"]\ncategories: [\"Ubuntu\", \"Config\"]\n---\n\n#### 一、Git安装\n\n安装命令：\n```\nsudo apt-get install git\n```\n\n<!--more-->\n\n#### 二、Github账号\n\n##### 2.1 注册GitHub账号\n注册地址：[官网](https://github.com/)\n\n##### 2.2 SSH配置\n配置方式参考：Ubuntu 16.04-设置SSH密钥.md\n\n##### 2.3 GitHub配置\n- 去登录github账户，在右上角点击头像找到Settings\n- 点进去后点击左侧栏中的SSH and GPG keys\n- 点击右侧New SSH key\n- 随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来\n- 保存即可\n\n##### 2.4 连接测试\n终端输入以下命令：\n```\n$ ssh -T git@github.com\nHi Jovry-Lee! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n表示github配置完成。\n\n#### 三、配置本地Git个人信息\n    Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。\n##### 3.1 配置全局个人信息\n```\n$ git config --global user.name \"your github name\"\n$ git config --global user.email \"youraddress@youremail.com\"\n```\n\n##### 3.2 配置单个项目个人信息\n    设置单个项目信息\n```\n$ git config user.name \"your github name\"\n$ git config user.email \"youraddress@youremail.com\"\n```\n\n#### 四、上传本地项目到GitHub\n##### 4.1 创建远程代码仓库\n- 点击右上角“＋”旁边的小三角，选择“New repository”；\n- 填写代码仓库信息；\n- 点击“Create repository”。\n\n##### 4.2 设置本地仓库\n```\n#把这个目录变成Git可以管理的仓库\ngit init\n# 文件添加到仓库\ngit add README.md\n# 添加所有文件.\ngit add .\n# 提交文件到仓库\ngit commit -m \"first commit\"\n# 管理远程仓库\ngit remote add origin <仓库地址>\n# 将本地库的所有内容推送到远程库上\ngit push -u origin master\n```\n---\n#### 参考文档\n1. [Ubuntu 16.04下Github配置](https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/)\n2. [github入门到上传本地项目](https://www.cnblogs.com/specter45/p/github.html)","slug":"Ubuntu16-04-Github配置及使用","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabkz002u45g37pgm04fj","content":"<h4 id=\"一、Git安装\"><a href=\"#一、Git安装\" class=\"headerlink\" title=\"一、Git安装\"></a>一、Git安装</h4><p>安装命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h4 id=\"二、Github账号\"><a href=\"#二、Github账号\" class=\"headerlink\" title=\"二、Github账号\"></a>二、Github账号</h4><h5 id=\"2-1-注册GitHub账号\"><a href=\"#2-1-注册GitHub账号\" class=\"headerlink\" title=\"2.1 注册GitHub账号\"></a>2.1 注册GitHub账号</h5><p>注册地址：<a href=\"https://github.com/\">官网</a></p>\n<h5 id=\"2-2-SSH配置\"><a href=\"#2-2-SSH配置\" class=\"headerlink\" title=\"2.2 SSH配置\"></a>2.2 SSH配置</h5><p>配置方式参考：Ubuntu 16.04-设置SSH密钥.md</p>\n<h5 id=\"2-3-GitHub配置\"><a href=\"#2-3-GitHub配置\" class=\"headerlink\" title=\"2.3 GitHub配置\"></a>2.3 GitHub配置</h5><ul>\n<li>去登录github账户，在右上角点击头像找到Settings</li>\n<li>点进去后点击左侧栏中的SSH and GPG keys</li>\n<li>点击右侧New SSH key</li>\n<li>随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来</li>\n<li>保存即可</li>\n</ul>\n<h5 id=\"2-4-连接测试\"><a href=\"#2-4-连接测试\" class=\"headerlink\" title=\"2.4 连接测试\"></a>2.4 连接测试</h5><p>终端输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\">Hi Jovry-Lee! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p>表示github配置完成。</p>\n<h4 id=\"三、配置本地Git个人信息\"><a href=\"#三、配置本地Git个人信息\" class=\"headerlink\" title=\"三、配置本地Git个人信息\"></a>三、配置本地Git个人信息</h4><pre><code>Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。</code></pre>\n<h5 id=\"3-1-配置全局个人信息\"><a href=\"#3-1-配置全局个人信息\" class=\"headerlink\" title=\"3.1 配置全局个人信息\"></a>3.1 配置全局个人信息</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;your github name&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;youraddress@youremail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-配置单个项目个人信息\"><a href=\"#3-2-配置单个项目个人信息\" class=\"headerlink\" title=\"3.2 配置单个项目个人信息\"></a>3.2 配置单个项目个人信息</h5><pre><code>设置单个项目信息</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config user.name &quot;your github name&quot;</span><br><span class=\"line\">$ git config user.email &quot;youraddress@youremail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"四、上传本地项目到GitHub\"><a href=\"#四、上传本地项目到GitHub\" class=\"headerlink\" title=\"四、上传本地项目到GitHub\"></a>四、上传本地项目到GitHub</h4><h5 id=\"4-1-创建远程代码仓库\"><a href=\"#4-1-创建远程代码仓库\" class=\"headerlink\" title=\"4.1 创建远程代码仓库\"></a>4.1 创建远程代码仓库</h5><ul>\n<li>点击右上角“＋”旁边的小三角，选择“New repository”；</li>\n<li>填写代码仓库信息；</li>\n<li>点击“Create repository”。</li>\n</ul>\n<h5 id=\"4-2-设置本地仓库\"><a href=\"#4-2-设置本地仓库\" class=\"headerlink\" title=\"4.2 设置本地仓库\"></a>4.2 设置本地仓库</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#把这个目录变成Git可以管理的仓库</span><br><span class=\"line\">git init</span><br><span class=\"line\"># 文件添加到仓库</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\"># 添加所有文件.</span><br><span class=\"line\">git add .</span><br><span class=\"line\"># 提交文件到仓库</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br><span class=\"line\"># 管理远程仓库</span><br><span class=\"line\">git remote add origin &lt;仓库地址&gt;</span><br><span class=\"line\"># 将本地库的所有内容推送到远程库上</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><ol>\n<li><a href=\"https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/\">Ubuntu 16.04下Github配置</a></li>\n<li><a href=\"https://www.cnblogs.com/specter45/p/github.html\">github入门到上传本地项目</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"一、Git安装\"><a href=\"#一、Git安装\" class=\"headerlink\" title=\"一、Git安装\"></a>一、Git安装</h4><p>安装命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"二、Github账号\"><a href=\"#二、Github账号\" class=\"headerlink\" title=\"二、Github账号\"></a>二、Github账号</h4><h5 id=\"2-1-注册GitHub账号\"><a href=\"#2-1-注册GitHub账号\" class=\"headerlink\" title=\"2.1 注册GitHub账号\"></a>2.1 注册GitHub账号</h5><p>注册地址：<a href=\"https://github.com/\">官网</a></p>\n<h5 id=\"2-2-SSH配置\"><a href=\"#2-2-SSH配置\" class=\"headerlink\" title=\"2.2 SSH配置\"></a>2.2 SSH配置</h5><p>配置方式参考：Ubuntu 16.04-设置SSH密钥.md</p>\n<h5 id=\"2-3-GitHub配置\"><a href=\"#2-3-GitHub配置\" class=\"headerlink\" title=\"2.3 GitHub配置\"></a>2.3 GitHub配置</h5><ul>\n<li>去登录github账户，在右上角点击头像找到Settings</li>\n<li>点进去后点击左侧栏中的SSH and GPG keys</li>\n<li>点击右侧New SSH key</li>\n<li>随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来</li>\n<li>保存即可</li>\n</ul>\n<h5 id=\"2-4-连接测试\"><a href=\"#2-4-连接测试\" class=\"headerlink\" title=\"2.4 连接测试\"></a>2.4 连接测试</h5><p>终端输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\">Hi Jovry-Lee! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p>表示github配置完成。</p>\n<h4 id=\"三、配置本地Git个人信息\"><a href=\"#三、配置本地Git个人信息\" class=\"headerlink\" title=\"三、配置本地Git个人信息\"></a>三、配置本地Git个人信息</h4><pre><code>Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。</code></pre>\n<h5 id=\"3-1-配置全局个人信息\"><a href=\"#3-1-配置全局个人信息\" class=\"headerlink\" title=\"3.1 配置全局个人信息\"></a>3.1 配置全局个人信息</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;your github name&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;youraddress@youremail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-配置单个项目个人信息\"><a href=\"#3-2-配置单个项目个人信息\" class=\"headerlink\" title=\"3.2 配置单个项目个人信息\"></a>3.2 配置单个项目个人信息</h5><pre><code>设置单个项目信息</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config user.name &quot;your github name&quot;</span><br><span class=\"line\">$ git config user.email &quot;youraddress@youremail.com&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"四、上传本地项目到GitHub\"><a href=\"#四、上传本地项目到GitHub\" class=\"headerlink\" title=\"四、上传本地项目到GitHub\"></a>四、上传本地项目到GitHub</h4><h5 id=\"4-1-创建远程代码仓库\"><a href=\"#4-1-创建远程代码仓库\" class=\"headerlink\" title=\"4.1 创建远程代码仓库\"></a>4.1 创建远程代码仓库</h5><ul>\n<li>点击右上角“＋”旁边的小三角，选择“New repository”；</li>\n<li>填写代码仓库信息；</li>\n<li>点击“Create repository”。</li>\n</ul>\n<h5 id=\"4-2-设置本地仓库\"><a href=\"#4-2-设置本地仓库\" class=\"headerlink\" title=\"4.2 设置本地仓库\"></a>4.2 设置本地仓库</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#把这个目录变成Git可以管理的仓库</span><br><span class=\"line\">git init</span><br><span class=\"line\"># 文件添加到仓库</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\"># 添加所有文件.</span><br><span class=\"line\">git add .</span><br><span class=\"line\"># 提交文件到仓库</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br><span class=\"line\"># 管理远程仓库</span><br><span class=\"line\">git remote add origin &lt;仓库地址&gt;</span><br><span class=\"line\"># 将本地库的所有内容推送到远程库上</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><ol>\n<li><a href=\"https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/\">Ubuntu 16.04下Github配置</a></li>\n<li><a href=\"https://www.cnblogs.com/specter45/p/github.html\">github入门到上传本地项目</a></li>\n</ol>"},{"title":"Ubuntu16.04-Nodejs安装","date":"2020-08-21T07:28:42.000Z","_content":"\n\n\n#### 下载 \n\n- ①、下载安装包\n\n  在ubuntu环境下，前往[nodejs官网](https://nodejs.org/en/)，nodejs官网能自动检测自己的系统版本，推荐出合适的nodejs版本。\n\n  <!--more-->\n\n- ②、解压安装包\n\n```bash\n$ tar xvJf node-v12.18.3-linux-x64.tar.xz\n```\n\n- ③、拷贝安装文件到指定路径\n\n```bash\nsudo cp -r node-v12.18.3-linux-x64 /usr/local/\n```\n\n#### 配置\n\n- 修改~/.bashrc文件\n\n```\n#set Node.js\nexport NODE_HOME=/usr/local/node-v12.18.3-linux-x64\nexport PATH=$NODE_HOME/bin:$PATH\n```\n\n- 执行source命令\n\n```\n$ source ~/.bashrc\n```\n\n- 3、添加软连接\n\n```\nln -s /usr/local/node-v12.18.3-linux-x64/bin/node /usr/bin/node\nln -s /usr/local/node-v12.18.3-linux-x64/bin/npm /usr/bin/npm\n```\n\n- 4、查看node版本\n\n```\n$ node -v\nv12.18.3\n$ npm -v\n6.14.6\n```\n\n能查看版本,即表示安装成功.\n\n#### 参考资料\n\n[Ubuntu 16.04环境下nodejs的安装和配置](https://blog.csdn.net/qq_36272282/article/details/88887360)","source":"_posts/Ubuntu16-04-Nodejs安装.md","raw":"---\ntitle: Ubuntu16.04-Nodejs安装\ndate: 2020-08-21 15:28:42\ntags: [\"Ubuntu\",\"Config\",\"Node.js\"]\ncategories: [\"Ubuntu\", \"Config\"]\n---\n\n\n\n#### 下载 \n\n- ①、下载安装包\n\n  在ubuntu环境下，前往[nodejs官网](https://nodejs.org/en/)，nodejs官网能自动检测自己的系统版本，推荐出合适的nodejs版本。\n\n  <!--more-->\n\n- ②、解压安装包\n\n```bash\n$ tar xvJf node-v12.18.3-linux-x64.tar.xz\n```\n\n- ③、拷贝安装文件到指定路径\n\n```bash\nsudo cp -r node-v12.18.3-linux-x64 /usr/local/\n```\n\n#### 配置\n\n- 修改~/.bashrc文件\n\n```\n#set Node.js\nexport NODE_HOME=/usr/local/node-v12.18.3-linux-x64\nexport PATH=$NODE_HOME/bin:$PATH\n```\n\n- 执行source命令\n\n```\n$ source ~/.bashrc\n```\n\n- 3、添加软连接\n\n```\nln -s /usr/local/node-v12.18.3-linux-x64/bin/node /usr/bin/node\nln -s /usr/local/node-v12.18.3-linux-x64/bin/npm /usr/bin/npm\n```\n\n- 4、查看node版本\n\n```\n$ node -v\nv12.18.3\n$ npm -v\n6.14.6\n```\n\n能查看版本,即表示安装成功.\n\n#### 参考资料\n\n[Ubuntu 16.04环境下nodejs的安装和配置](https://blog.csdn.net/qq_36272282/article/details/88887360)","slug":"Ubuntu16-04-Nodejs安装","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabl0002w45g3d5osfmen","content":"<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><ul>\n<li><p>①、下载安装包</p>\n<p>在ubuntu环境下，前往<a href=\"https://nodejs.org/en/\">nodejs官网</a>，nodejs官网能自动检测自己的系统版本，推荐出合适的nodejs版本。</p>\n<a id=\"more\"></a>\n</li>\n<li><p>②、解压安装包</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar xvJf node-v12.18.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>③、拷贝安装文件到指定路径</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp -r node-v12.18.3-linux-x64 /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><ul>\n<li>修改~/.bashrc文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#set Node.js</span><br><span class=\"line\">export NODE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64</span><br><span class=\"line\">export PATH&#x3D;$NODE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行source命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3、添加软连接</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;bin&#x2F;node</span><br><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4、查看node版本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">v12.18.3</span><br><span class=\"line\">$ npm -v</span><br><span class=\"line\">6.14.6</span><br></pre></td></tr></table></figure>\n\n<p>能查看版本,即表示安装成功.</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://blog.csdn.net/qq_36272282/article/details/88887360\">Ubuntu 16.04环境下nodejs的安装和配置</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><ul>\n<li><p>①、下载安装包</p>\n<p>在ubuntu环境下，前往<a href=\"https://nodejs.org/en/\">nodejs官网</a>，nodejs官网能自动检测自己的系统版本，推荐出合适的nodejs版本。</p>","more":"</li>\n<li><p>②、解压安装包</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar xvJf node-v12.18.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>③、拷贝安装文件到指定路径</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo cp -r node-v12.18.3-linux-x64 /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><ul>\n<li>修改~/.bashrc文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#set Node.js</span><br><span class=\"line\">export NODE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64</span><br><span class=\"line\">export PATH&#x3D;$NODE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行source命令</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3、添加软连接</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;bin&#x2F;node</span><br><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4、查看node版本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">v12.18.3</span><br><span class=\"line\">$ npm -v</span><br><span class=\"line\">6.14.6</span><br></pre></td></tr></table></figure>\n\n<p>能查看版本,即表示安装成功.</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://blog.csdn.net/qq_36272282/article/details/88887360\">Ubuntu 16.04环境下nodejs的安装和配置</a></p>"},{"title":"Ubuntu16.04-设置SSH密钥","date":"2020-08-19T07:20:20.000Z","_content":"\n#### 1 简介\nSSH（Secure shell）适用于管理服务器与服务器通信的加密协议。\n\n<!--more-->\n\n#### 2 设置步骤\n##### 2.1 创建RSA密钥对\n```\nssh-keygen\n```\n①、默认情况下，ssh-keygen将会创建一个2048位的RSA密钥对，此时已经足够安全，若有特殊需求，可以选择传入-b 4096标志来创建更大的4096位的密钥。\n\n②、执行命令后，终端将会输出一下内容，按ENTER键将密钥保存到.ssh/主目录的子目录中，或指定备用路径。\n```\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/seven/.ssh/id_rsa):\n```\n③、若在此之前已经生成了ssh密钥对，则可能看到以下提示,此时若选择覆盖磁盘上的密钥，则无法使用以前的密钥进行身份验证（==这是一个无法逆转的破坏性过程==）\n```\n/home/seven/.ssh/id_rsa already exists.\nOverwrite (y/n)?\n```\n④、然后会看到以下输出，此处可以选择输入安全密码，建议使用。密码短语增加了额外的安全层，以防未经授权的用户登录。\n\n##### 2.2 将公钥复制到Ubuntu服务器\n###### 2.2.1 方法一 使用实用程序ssh-copy-id\n使用实用程序ssh-copy-id，只需要指定要连接的远程主机，以及具有ssh访问密码的用户账户即可。\n```\nssh-copy-id username@remote_host\n```\n\n###### 2.2.2 方法二 使用ssh复制公钥\n使用cat命令读取本地计算机上的公钥内容，并通过ssh连接到远程服务器来管理它。（==注：使用cat命令，而不要使用vim去复制，可能会复制出奇怪的字符进去==）\n```\ncat ~/.ssh/id_rsa.pub | ssh username@remote_host \"mkdir -p ~/.ssh && touch ~/.ssh/authorized_keys && chmod -R go= ~/.ssh && cat >> ~/.ssh/authorized_keys\"\n```\n\n###### 2.2.3 方法三 手动复制公钥\n```\ncat ~/.ssh/id_rsa.pub\n```\n复制公钥，再登录服务器，执行以下命令\n```\necho public_key_string >> ~/.ssh/authrized_keys\n```\n其中，public_key_string为复制的公钥\n\n#### 3 使用SSH密钥对Ubuntu服务器进行身份验证\n以上配置完成后，则可以在没有远程账户密码的情况下登录远程主机。\n登录命令：\n```\nssh username@remote_host\n```\n若是在第一次连接此主机，则可能会出现以下内容,这表示当前本地计算机无法识别远程主机，直接输入YES，然后按ENTER继续。\n```\nOutput\nThe authenticity of host '203.0.113.1 (203.0.113.1)' can't be established.\nECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.\nAre you sure you want to continue connecting (yes/no)? yes\n```\n\n若步骤一中创建RSA密钥对时没有提供密码，则可以继续登录。若提供了密码，则需要输入密码。\n\n#### 4 在服务器上禁用密码身份验证\n详情见参考文献1.\n\n\n---\n#### 参考资料\n1. [如何在Ubuntu 16.04上设置SSH密钥](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604)\n\n","source":"_posts/Ubuntu16-04-设置SSH密钥.md","raw":"---\ntitle: Ubuntu16.04-设置SSH密钥\ndate: 2020-08-19 15:20:20\ntags: [\"Ubuntu\",\"Config\", \"SSH\"]\ncategories: [\"Ubuntu\", \"Config\"]\n---\n\n#### 1 简介\nSSH（Secure shell）适用于管理服务器与服务器通信的加密协议。\n\n<!--more-->\n\n#### 2 设置步骤\n##### 2.1 创建RSA密钥对\n```\nssh-keygen\n```\n①、默认情况下，ssh-keygen将会创建一个2048位的RSA密钥对，此时已经足够安全，若有特殊需求，可以选择传入-b 4096标志来创建更大的4096位的密钥。\n\n②、执行命令后，终端将会输出一下内容，按ENTER键将密钥保存到.ssh/主目录的子目录中，或指定备用路径。\n```\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/seven/.ssh/id_rsa):\n```\n③、若在此之前已经生成了ssh密钥对，则可能看到以下提示,此时若选择覆盖磁盘上的密钥，则无法使用以前的密钥进行身份验证（==这是一个无法逆转的破坏性过程==）\n```\n/home/seven/.ssh/id_rsa already exists.\nOverwrite (y/n)?\n```\n④、然后会看到以下输出，此处可以选择输入安全密码，建议使用。密码短语增加了额外的安全层，以防未经授权的用户登录。\n\n##### 2.2 将公钥复制到Ubuntu服务器\n###### 2.2.1 方法一 使用实用程序ssh-copy-id\n使用实用程序ssh-copy-id，只需要指定要连接的远程主机，以及具有ssh访问密码的用户账户即可。\n```\nssh-copy-id username@remote_host\n```\n\n###### 2.2.2 方法二 使用ssh复制公钥\n使用cat命令读取本地计算机上的公钥内容，并通过ssh连接到远程服务器来管理它。（==注：使用cat命令，而不要使用vim去复制，可能会复制出奇怪的字符进去==）\n```\ncat ~/.ssh/id_rsa.pub | ssh username@remote_host \"mkdir -p ~/.ssh && touch ~/.ssh/authorized_keys && chmod -R go= ~/.ssh && cat >> ~/.ssh/authorized_keys\"\n```\n\n###### 2.2.3 方法三 手动复制公钥\n```\ncat ~/.ssh/id_rsa.pub\n```\n复制公钥，再登录服务器，执行以下命令\n```\necho public_key_string >> ~/.ssh/authrized_keys\n```\n其中，public_key_string为复制的公钥\n\n#### 3 使用SSH密钥对Ubuntu服务器进行身份验证\n以上配置完成后，则可以在没有远程账户密码的情况下登录远程主机。\n登录命令：\n```\nssh username@remote_host\n```\n若是在第一次连接此主机，则可能会出现以下内容,这表示当前本地计算机无法识别远程主机，直接输入YES，然后按ENTER继续。\n```\nOutput\nThe authenticity of host '203.0.113.1 (203.0.113.1)' can't be established.\nECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.\nAre you sure you want to continue connecting (yes/no)? yes\n```\n\n若步骤一中创建RSA密钥对时没有提供密码，则可以继续登录。若提供了密码，则需要输入密码。\n\n#### 4 在服务器上禁用密码身份验证\n详情见参考文献1.\n\n\n---\n#### 参考资料\n1. [如何在Ubuntu 16.04上设置SSH密钥](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604)\n\n","slug":"Ubuntu16-04-设置SSH密钥","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabl1002z45g39mg8h8le","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>SSH（Secure shell）适用于管理服务器与服务器通信的加密协议。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"2-设置步骤\"><a href=\"#2-设置步骤\" class=\"headerlink\" title=\"2 设置步骤\"></a>2 设置步骤</h4><h5 id=\"2-1-创建RSA密钥对\"><a href=\"#2-1-创建RSA密钥对\" class=\"headerlink\" title=\"2.1 创建RSA密钥对\"></a>2.1 创建RSA密钥对</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure>\n<p>①、默认情况下，ssh-keygen将会创建一个2048位的RSA密钥对，此时已经足够安全，若有特殊需求，可以选择传入-b 4096标志来创建更大的4096位的密钥。</p>\n<p>②、执行命令后，终端将会输出一下内容，按ENTER键将密钥保存到.ssh/主目录的子目录中，或指定备用路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generating public&#x2F;private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (&#x2F;home&#x2F;seven&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>\n<p>③、若在此之前已经生成了ssh密钥对，则可能看到以下提示,此时若选择覆盖磁盘上的密钥，则无法使用以前的密钥进行身份验证（==这是一个无法逆转的破坏性过程==）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;home&#x2F;seven&#x2F;.ssh&#x2F;id_rsa already exists.</span><br><span class=\"line\">Overwrite (y&#x2F;n)?</span><br></pre></td></tr></table></figure>\n<p>④、然后会看到以下输出，此处可以选择输入安全密码，建议使用。密码短语增加了额外的安全层，以防未经授权的用户登录。</p>\n<h5 id=\"2-2-将公钥复制到Ubuntu服务器\"><a href=\"#2-2-将公钥复制到Ubuntu服务器\" class=\"headerlink\" title=\"2.2 将公钥复制到Ubuntu服务器\"></a>2.2 将公钥复制到Ubuntu服务器</h5><h6 id=\"2-2-1-方法一-使用实用程序ssh-copy-id\"><a href=\"#2-2-1-方法一-使用实用程序ssh-copy-id\" class=\"headerlink\" title=\"2.2.1 方法一 使用实用程序ssh-copy-id\"></a>2.2.1 方法一 使用实用程序ssh-copy-id</h6><p>使用实用程序ssh-copy-id，只需要指定要连接的远程主机，以及具有ssh访问密码的用户账户即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-2-2-方法二-使用ssh复制公钥\"><a href=\"#2-2-2-方法二-使用ssh复制公钥\" class=\"headerlink\" title=\"2.2.2 方法二 使用ssh复制公钥\"></a>2.2.2 方法二 使用ssh复制公钥</h6><p>使用cat命令读取本地计算机上的公钥内容，并通过ssh连接到远程服务器来管理它。（==注：使用cat命令，而不要使用vim去复制，可能会复制出奇怪的字符进去==）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub | ssh username@remote_host &quot;mkdir -p ~&#x2F;.ssh &amp;&amp; touch ~&#x2F;.ssh&#x2F;authorized_keys &amp;&amp; chmod -R go&#x3D; ~&#x2F;.ssh &amp;&amp; cat &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys&quot;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-2-3-方法三-手动复制公钥\"><a href=\"#2-2-3-方法三-手动复制公钥\" class=\"headerlink\" title=\"2.2.3 方法三 手动复制公钥\"></a>2.2.3 方法三 手动复制公钥</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>复制公钥，再登录服务器，执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo public_key_string &gt;&gt; ~&#x2F;.ssh&#x2F;authrized_keys</span><br></pre></td></tr></table></figure>\n<p>其中，public_key_string为复制的公钥</p>\n<h4 id=\"3-使用SSH密钥对Ubuntu服务器进行身份验证\"><a href=\"#3-使用SSH密钥对Ubuntu服务器进行身份验证\" class=\"headerlink\" title=\"3 使用SSH密钥对Ubuntu服务器进行身份验证\"></a>3 使用SSH密钥对Ubuntu服务器进行身份验证</h4><p>以上配置完成后，则可以在没有远程账户密码的情况下登录远程主机。<br>登录命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@remote_host</span><br></pre></td></tr></table></figure>\n<p>若是在第一次连接此主机，则可能会出现以下内容,这表示当前本地计算机无法识别远程主机，直接输入YES，然后按ENTER继续。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">The authenticity of host &#39;203.0.113.1 (203.0.113.1)&#39; can&#39;t be established.</span><br><span class=\"line\">ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes&#x2F;no)? yes</span><br></pre></td></tr></table></figure>\n\n<p>若步骤一中创建RSA密钥对时没有提供密码，则可以继续登录。若提供了密码，则需要输入密码。</p>\n<h4 id=\"4-在服务器上禁用密码身份验证\"><a href=\"#4-在服务器上禁用密码身份验证\" class=\"headerlink\" title=\"4 在服务器上禁用密码身份验证\"></a>4 在服务器上禁用密码身份验证</h4><p>详情见参考文献1.</p>\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604\">如何在Ubuntu 16.04上设置SSH密钥</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>SSH（Secure shell）适用于管理服务器与服务器通信的加密协议。</p>","more":"<h4 id=\"2-设置步骤\"><a href=\"#2-设置步骤\" class=\"headerlink\" title=\"2 设置步骤\"></a>2 设置步骤</h4><h5 id=\"2-1-创建RSA密钥对\"><a href=\"#2-1-创建RSA密钥对\" class=\"headerlink\" title=\"2.1 创建RSA密钥对\"></a>2.1 创建RSA密钥对</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure>\n<p>①、默认情况下，ssh-keygen将会创建一个2048位的RSA密钥对，此时已经足够安全，若有特殊需求，可以选择传入-b 4096标志来创建更大的4096位的密钥。</p>\n<p>②、执行命令后，终端将会输出一下内容，按ENTER键将密钥保存到.ssh/主目录的子目录中，或指定备用路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generating public&#x2F;private rsa key pair.</span><br><span class=\"line\">Enter file in which to save the key (&#x2F;home&#x2F;seven&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>\n<p>③、若在此之前已经生成了ssh密钥对，则可能看到以下提示,此时若选择覆盖磁盘上的密钥，则无法使用以前的密钥进行身份验证（==这是一个无法逆转的破坏性过程==）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;home&#x2F;seven&#x2F;.ssh&#x2F;id_rsa already exists.</span><br><span class=\"line\">Overwrite (y&#x2F;n)?</span><br></pre></td></tr></table></figure>\n<p>④、然后会看到以下输出，此处可以选择输入安全密码，建议使用。密码短语增加了额外的安全层，以防未经授权的用户登录。</p>\n<h5 id=\"2-2-将公钥复制到Ubuntu服务器\"><a href=\"#2-2-将公钥复制到Ubuntu服务器\" class=\"headerlink\" title=\"2.2 将公钥复制到Ubuntu服务器\"></a>2.2 将公钥复制到Ubuntu服务器</h5><h6 id=\"2-2-1-方法一-使用实用程序ssh-copy-id\"><a href=\"#2-2-1-方法一-使用实用程序ssh-copy-id\" class=\"headerlink\" title=\"2.2.1 方法一 使用实用程序ssh-copy-id\"></a>2.2.1 方法一 使用实用程序ssh-copy-id</h6><p>使用实用程序ssh-copy-id，只需要指定要连接的远程主机，以及具有ssh访问密码的用户账户即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-2-2-方法二-使用ssh复制公钥\"><a href=\"#2-2-2-方法二-使用ssh复制公钥\" class=\"headerlink\" title=\"2.2.2 方法二 使用ssh复制公钥\"></a>2.2.2 方法二 使用ssh复制公钥</h6><p>使用cat命令读取本地计算机上的公钥内容，并通过ssh连接到远程服务器来管理它。（==注：使用cat命令，而不要使用vim去复制，可能会复制出奇怪的字符进去==）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub | ssh username@remote_host &quot;mkdir -p ~&#x2F;.ssh &amp;&amp; touch ~&#x2F;.ssh&#x2F;authorized_keys &amp;&amp; chmod -R go&#x3D; ~&#x2F;.ssh &amp;&amp; cat &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys&quot;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-2-3-方法三-手动复制公钥\"><a href=\"#2-2-3-方法三-手动复制公钥\" class=\"headerlink\" title=\"2.2.3 方法三 手动复制公钥\"></a>2.2.3 方法三 手动复制公钥</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>复制公钥，再登录服务器，执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo public_key_string &gt;&gt; ~&#x2F;.ssh&#x2F;authrized_keys</span><br></pre></td></tr></table></figure>\n<p>其中，public_key_string为复制的公钥</p>\n<h4 id=\"3-使用SSH密钥对Ubuntu服务器进行身份验证\"><a href=\"#3-使用SSH密钥对Ubuntu服务器进行身份验证\" class=\"headerlink\" title=\"3 使用SSH密钥对Ubuntu服务器进行身份验证\"></a>3 使用SSH密钥对Ubuntu服务器进行身份验证</h4><p>以上配置完成后，则可以在没有远程账户密码的情况下登录远程主机。<br>登录命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@remote_host</span><br></pre></td></tr></table></figure>\n<p>若是在第一次连接此主机，则可能会出现以下内容,这表示当前本地计算机无法识别远程主机，直接输入YES，然后按ENTER继续。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Output</span><br><span class=\"line\">The authenticity of host &#39;203.0.113.1 (203.0.113.1)&#39; can&#39;t be established.</span><br><span class=\"line\">ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes&#x2F;no)? yes</span><br></pre></td></tr></table></figure>\n\n<p>若步骤一中创建RSA密钥对时没有提供密码，则可以继续登录。若提供了密码，则需要输入密码。</p>\n<h4 id=\"4-在服务器上禁用密码身份验证\"><a href=\"#4-在服务器上禁用密码身份验证\" class=\"headerlink\" title=\"4 在服务器上禁用密码身份验证\"></a>4 在服务器上禁用密码身份验证</h4><p>详情见参考文献1.</p>\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ol>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604\">如何在Ubuntu 16.04上设置SSH密钥</a></li>\n</ol>"},{"title":"WEB-会话管理","date":"2020-09-23T08:18:34.000Z","_content":"\n### １引入\n\n首先，我们需要知道，HTTP是无状态协议，即HTTP协议对于发送过的请求/接收过的响应均不作持久化处理。`HTTP（ HyperText Transfer Protocol）`，顾名思义，超文本传输协议。最开始基本上就是文档的浏览而已，作为服务器，不需要记录谁在某一段时间里都浏览了什么文件；还有就是为了能更快的处理大量事务，确保协议的可伸缩性，特意将其设计的如此简单。\n<!--more-->\n但是随着交互式Web应用兴起，如在线购物网站，需要登录的网站等，就马上面临一个问题，即管理会话，必须记住哪些人登陆了系统，哪些人往自己的购物车加购了，且必须将每个人区分开。因此就引入了Session、Cookie、Token等技术。\n\n### 2 管理会话方法\n\n我们需要知道，会话管理的目的是为了验证用户身份。\n\n#### 2.1 使用session做会话管理\n\n**session是基于cookie实现的会话管理机制**，session存储在服务器端，sessionId会被存储到客户端的cookie中。\n<u>（注：禁用cookie，seesion也将失效。）</u>\n\n##### 2.1.1 管理方式\n\n给所有的用户发一个会话标识（Session id），其实就是一个随机字符串，每个用户的字符串不一样，当用户发起请求时，将该字符串带过来，就能区分谁是谁了。\n\n##### 2.1.2 问题\n\n使用这种管理方式，虽然每个人只需要保存自己的Session id，但服务器需要记住所有用户Session id，这对服务器是很大的开销。并且严重限制了服务器的扩展能力，比如，使用两个机器组成一个集群，某个用户小F，通过机器A登录了系统，其Session is会保存在机器A上，假设下一次请求被转发到机器B，而机器B上没有小F的Session。\n　　\n\n##### 2.1.3 解决方法\n\n- `Session Stick（Session 粘黏）`：让小F的请求一直粘黏在机器A上。但此时若机器A挂了，还是需要转机器B上，无法从根本上解决问题。\n- `Session复制`：把Session id在两台机器上复制，但这样比较麻烦。\n- `将Session统一存储起来`：把Session id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样就不需要复制了，但这种方式可能增加了单点失败的风险，若负责Session的机器挂了，则所有用户都需要重新登陆。\n\n##### 2.1.4 Session的生命周期\n\nSession保存在服务端，为了获取更高的存取速度，服务器一般会把Session放在内存中，每个用户都会有一个独立的Session，如果Session里面的内容太过复杂，当大量的用户访问服务器时，可能会导致内存溢出，所以Session的内容应该适当的精简。\n　　\n当第一次访问服务器时，服务器会创建并维护这个Session。当用户访问一次服务器，无论是否有操作Session，服务器都会认定这个Session活跃了一次，当越来越多的用户访问服务器时，Session就会越来越多。为了防止内存溢出，服务器会把长时间没有活跃的Session删除。这个时间就是Session的过期时间，超过了该时间，Session就会自动失效。\n　　\n\n#### 2.2 使用Token（令牌）做会话管理\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/使用token做令牌管理.png\" alt=\"使用token做令牌管理\" style=\"zoom:80%;\" />\n\n##### 2.2.1 管理方式\n\n对数据做一个签名，比如使用HMAC-SHA256算法，加上一个服务器才知道的密钥，对数据做一个签名，把这个签名和数据一起作为token，由于别人不知道密钥，就无法伪造token。\n　　\n生成的Token服务器不需要保存，当下一次小F请求来的时候，再使用相同的算法进行签名计算，若相同，则判定小F已经登陆过了，并且可以直接取到小F的User id，如果不相同，则数据部分肯定被修改了，就告诉发送者，对不起，没有认证。\n\n（**思想：使用CPU的计算时间换取Session的存储空间**）\n\n##### 2.2.2 问题\n\n若某个用户的token被别人盗取，服务器也会认为这是一个合法的用户（注：Session也存在这个问题），<u>其安全性一般是通过https协议来保证传输的安全性。</u>\n\n##### 2.2.3 Token的有效期\n\nToken的认证机制可以完成自身的验证，根据token的实际应用场景，对token进行存储，比如登录场景，需要进行一系列精细化控制，如权限、token有效性、自身注销、非法用户的拦截操作等。\n\n设置有效期需要从需求和用户体验触发，尽可能寻找一个平衡，保证用户体验的前提下，尽可能短。但若用户在操作时token过期需要重新登陆，体验将会很糟。\n　　\n**为了解决在操作过程中不让用户感受到token失效的问题，通常有以下两种方案**：\n\n- **方案一**：在服务端保存token状态，用户每次操作都会刷新（推迟）token的过期时间（Session就是采用这种策略来保持用户登录状态的）。\n  - 问题：在前后端分离、单页App这些情况下，每秒钟可能发起多个请求，每次都去刷新过期时间会产生非常大的代价。若token持久化到数据库或文件中，代价就更大了。所以通常为了提升效率，减少消耗，会把token的过期时间保存在缓存或内存中。\n\n- **方案二**：使用Refresh Token，可以避免频繁的读写操作。这种方案，服务器不需要刷新token的过期时间，一旦token失效，就反馈给前端，前端使用Refesh token申请一个全新的token继续使用。该种方案中，服务端只需要在客户端请求更新token的时候，对Refresh token的有效性检查，大大减少了更新有效期的操作，也避免了频繁读写。当然Refresh Token也是有有效期的，但这个有效期就可以长一些。如下图所示：\n\n​    ![refresh_token](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/refresh_token.png)\n\n#### 2.3 JWT\n\nJWT（JSON Web Token）是目前最流行的跨域认证解决方案，<u>是一种认证授权机制</u>。\n\n**JWT的原理是**：服务器认证以后，生成一个JSON对象，发回给用户，后续用户需要与服务端通信时，需要发回这个JSON对象。服务器完全只靠这个对象认定用户身份，且为了防止数据被篡改，生成对象时会添加一个签名。\n\n实际JWT的数据结构示例如下：\n\n```\neyJleHAiOjE1OTkwMzIyNzksImtpZCI6M30.eyJkZXZpY2VfaWQiOiI1ZGJhZDkxZTE3OTgwOWVmYTZjYjc1ZmI3MmE2NzRlYyIsInNtX2RldmljZV9pZCI6IiIsImRpZ2l0YWxfZGV2aWNlX2lkIjoiIn0.fob_tbEagrBm3o3kK4qFdPw5tdJQG9uIQeg9ryCnIpk                   \n```\n\n​       \n\n### 3 Session、Cookie、Token的区别\n\n#### 3.1 Cookie\n\nCookie是一个非常具体的东西，<u>指的就是浏览器里面能永久的数据</u>。仅仅是浏览器实现的一种数据存储功能。\n\nCookie由服务器生成，发送给浏览器，浏览器把Cookie以key-value形式保存在某个目录下的文本文件内，下一次请求同一网站时把该Cookie发送给服务器。通过对Cookie的解析，服务器可以识别请发送者的身份。由于Cookie是存在客户端，所以浏览器加入了一些限制确保Cookie不会被恶意使用，同时不会占据太多磁盘空间，所以<u>每个域的Cookie数量是有限的</u>。\n\n*注：Cookie是不可跨域名的，隐私安全机制禁止网站非法获取其他网站的Cookie。*\n\n（一般来说，同一个一级域名下的两个二级域名也不能交互使用Cookie。比如，a.test.com和b.test.com，因为二者的域名不同。若想要test.com下的二级域名都可以使用该Cookie，需要设置CookieDomain参数为.test.com，这样a.test.com和b.test.com就能访问同一个Cookie。）\n\n\n\n**缺陷**：\n\n- Cookie的数量和长度都是有限的\n- 潜在的安全风险：Cookie可能被截取篡改，如果Cookie被拦截，就可能会获取到所有的信息。\n- `用户可能会配置禁用浏览器或客户端设备接收Cookie的能力，因此可能会限制这一功能`。\n- 有些状态不可能保保存在客户端。\n\n\n\n#### 3.2 Session\n\nSession，顾名思义，会话。服务器要知道当前请求是谁发送来的，为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，在客户端每次向服务器发送请求时，都带上这个“身份标识”，服务器就知道这个请求来自谁了。（<u>客户端通常会以Cookie的方式保存SessionId</u>）。\n\n服务器使用Session把用户信息临时存在服务器上，用户离开网站后SessionId会被销毁。这种用户信息存储方式相对于Cookie来说更安全。\n\n**缺陷**：若Web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候Session会丢失。\n\n\n\n#### 3.3 Token\n\n在大多数使用Web API的互联网公司中，token是多用户下处理认证的最佳方式。使用Cpu计算时间换取Session的存储空间。\n\n##### 3.3.1 特点\n\n- 无状态、可扩展\n- 支持移动设备\n- 跨程序调用\n- 安全\n\n\n\n##### 3.3.2 基于Token的身份验证过程\n\n基于Token的身份验证过程如下：\n\n![token身份验证](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/token身份验证.png)\n\n- 用户通过用户名和密码发送请求\n- 程序验证\n- 程序返回一个签名的token给客户端\n- 客户端存储token，并且用于每次发送请求\n- 服务器待验证token并返回数据\n\n------\n\n### 参考资料\n\n[彻底理解session、cookie、token](https://www.cnblogs.com/moyand/p/9047978.html)\n[阿里面试题cookie和session的区别及session的生命周期](https://zhuanlan.zhihu.com/p/80716402)\n[大话Token、Cookie和Session](https://zhuanlan.zhihu.com/p/88185448)\n[还分不清 Cookie、Session、Token、JWT？](https://zhuanlan.zhihu.com/p/164696755)\n[JSON Web Token 入门教程](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)\n[RFC1579（JWT）](https://tools.ietf.org/html/rfc7519)","source":"_posts/WEB-会话管理.md","raw":"---\ntitle: WEB-会话管理\ndate: 2020-09-23 16:18:34\ntags: [\"WEB\",\"SESSION\",\"COOKIE\",\"TOKEN\",\"JWT\"]\ncategories: [\"WEB\"]\n---\n\n### １引入\n\n首先，我们需要知道，HTTP是无状态协议，即HTTP协议对于发送过的请求/接收过的响应均不作持久化处理。`HTTP（ HyperText Transfer Protocol）`，顾名思义，超文本传输协议。最开始基本上就是文档的浏览而已，作为服务器，不需要记录谁在某一段时间里都浏览了什么文件；还有就是为了能更快的处理大量事务，确保协议的可伸缩性，特意将其设计的如此简单。\n<!--more-->\n但是随着交互式Web应用兴起，如在线购物网站，需要登录的网站等，就马上面临一个问题，即管理会话，必须记住哪些人登陆了系统，哪些人往自己的购物车加购了，且必须将每个人区分开。因此就引入了Session、Cookie、Token等技术。\n\n### 2 管理会话方法\n\n我们需要知道，会话管理的目的是为了验证用户身份。\n\n#### 2.1 使用session做会话管理\n\n**session是基于cookie实现的会话管理机制**，session存储在服务器端，sessionId会被存储到客户端的cookie中。\n<u>（注：禁用cookie，seesion也将失效。）</u>\n\n##### 2.1.1 管理方式\n\n给所有的用户发一个会话标识（Session id），其实就是一个随机字符串，每个用户的字符串不一样，当用户发起请求时，将该字符串带过来，就能区分谁是谁了。\n\n##### 2.1.2 问题\n\n使用这种管理方式，虽然每个人只需要保存自己的Session id，但服务器需要记住所有用户Session id，这对服务器是很大的开销。并且严重限制了服务器的扩展能力，比如，使用两个机器组成一个集群，某个用户小F，通过机器A登录了系统，其Session is会保存在机器A上，假设下一次请求被转发到机器B，而机器B上没有小F的Session。\n　　\n\n##### 2.1.3 解决方法\n\n- `Session Stick（Session 粘黏）`：让小F的请求一直粘黏在机器A上。但此时若机器A挂了，还是需要转机器B上，无法从根本上解决问题。\n- `Session复制`：把Session id在两台机器上复制，但这样比较麻烦。\n- `将Session统一存储起来`：把Session id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样就不需要复制了，但这种方式可能增加了单点失败的风险，若负责Session的机器挂了，则所有用户都需要重新登陆。\n\n##### 2.1.4 Session的生命周期\n\nSession保存在服务端，为了获取更高的存取速度，服务器一般会把Session放在内存中，每个用户都会有一个独立的Session，如果Session里面的内容太过复杂，当大量的用户访问服务器时，可能会导致内存溢出，所以Session的内容应该适当的精简。\n　　\n当第一次访问服务器时，服务器会创建并维护这个Session。当用户访问一次服务器，无论是否有操作Session，服务器都会认定这个Session活跃了一次，当越来越多的用户访问服务器时，Session就会越来越多。为了防止内存溢出，服务器会把长时间没有活跃的Session删除。这个时间就是Session的过期时间，超过了该时间，Session就会自动失效。\n　　\n\n#### 2.2 使用Token（令牌）做会话管理\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/使用token做令牌管理.png\" alt=\"使用token做令牌管理\" style=\"zoom:80%;\" />\n\n##### 2.2.1 管理方式\n\n对数据做一个签名，比如使用HMAC-SHA256算法，加上一个服务器才知道的密钥，对数据做一个签名，把这个签名和数据一起作为token，由于别人不知道密钥，就无法伪造token。\n　　\n生成的Token服务器不需要保存，当下一次小F请求来的时候，再使用相同的算法进行签名计算，若相同，则判定小F已经登陆过了，并且可以直接取到小F的User id，如果不相同，则数据部分肯定被修改了，就告诉发送者，对不起，没有认证。\n\n（**思想：使用CPU的计算时间换取Session的存储空间**）\n\n##### 2.2.2 问题\n\n若某个用户的token被别人盗取，服务器也会认为这是一个合法的用户（注：Session也存在这个问题），<u>其安全性一般是通过https协议来保证传输的安全性。</u>\n\n##### 2.2.3 Token的有效期\n\nToken的认证机制可以完成自身的验证，根据token的实际应用场景，对token进行存储，比如登录场景，需要进行一系列精细化控制，如权限、token有效性、自身注销、非法用户的拦截操作等。\n\n设置有效期需要从需求和用户体验触发，尽可能寻找一个平衡，保证用户体验的前提下，尽可能短。但若用户在操作时token过期需要重新登陆，体验将会很糟。\n　　\n**为了解决在操作过程中不让用户感受到token失效的问题，通常有以下两种方案**：\n\n- **方案一**：在服务端保存token状态，用户每次操作都会刷新（推迟）token的过期时间（Session就是采用这种策略来保持用户登录状态的）。\n  - 问题：在前后端分离、单页App这些情况下，每秒钟可能发起多个请求，每次都去刷新过期时间会产生非常大的代价。若token持久化到数据库或文件中，代价就更大了。所以通常为了提升效率，减少消耗，会把token的过期时间保存在缓存或内存中。\n\n- **方案二**：使用Refresh Token，可以避免频繁的读写操作。这种方案，服务器不需要刷新token的过期时间，一旦token失效，就反馈给前端，前端使用Refesh token申请一个全新的token继续使用。该种方案中，服务端只需要在客户端请求更新token的时候，对Refresh token的有效性检查，大大减少了更新有效期的操作，也避免了频繁读写。当然Refresh Token也是有有效期的，但这个有效期就可以长一些。如下图所示：\n\n​    ![refresh_token](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/refresh_token.png)\n\n#### 2.3 JWT\n\nJWT（JSON Web Token）是目前最流行的跨域认证解决方案，<u>是一种认证授权机制</u>。\n\n**JWT的原理是**：服务器认证以后，生成一个JSON对象，发回给用户，后续用户需要与服务端通信时，需要发回这个JSON对象。服务器完全只靠这个对象认定用户身份，且为了防止数据被篡改，生成对象时会添加一个签名。\n\n实际JWT的数据结构示例如下：\n\n```\neyJleHAiOjE1OTkwMzIyNzksImtpZCI6M30.eyJkZXZpY2VfaWQiOiI1ZGJhZDkxZTE3OTgwOWVmYTZjYjc1ZmI3MmE2NzRlYyIsInNtX2RldmljZV9pZCI6IiIsImRpZ2l0YWxfZGV2aWNlX2lkIjoiIn0.fob_tbEagrBm3o3kK4qFdPw5tdJQG9uIQeg9ryCnIpk                   \n```\n\n​       \n\n### 3 Session、Cookie、Token的区别\n\n#### 3.1 Cookie\n\nCookie是一个非常具体的东西，<u>指的就是浏览器里面能永久的数据</u>。仅仅是浏览器实现的一种数据存储功能。\n\nCookie由服务器生成，发送给浏览器，浏览器把Cookie以key-value形式保存在某个目录下的文本文件内，下一次请求同一网站时把该Cookie发送给服务器。通过对Cookie的解析，服务器可以识别请发送者的身份。由于Cookie是存在客户端，所以浏览器加入了一些限制确保Cookie不会被恶意使用，同时不会占据太多磁盘空间，所以<u>每个域的Cookie数量是有限的</u>。\n\n*注：Cookie是不可跨域名的，隐私安全机制禁止网站非法获取其他网站的Cookie。*\n\n（一般来说，同一个一级域名下的两个二级域名也不能交互使用Cookie。比如，a.test.com和b.test.com，因为二者的域名不同。若想要test.com下的二级域名都可以使用该Cookie，需要设置CookieDomain参数为.test.com，这样a.test.com和b.test.com就能访问同一个Cookie。）\n\n\n\n**缺陷**：\n\n- Cookie的数量和长度都是有限的\n- 潜在的安全风险：Cookie可能被截取篡改，如果Cookie被拦截，就可能会获取到所有的信息。\n- `用户可能会配置禁用浏览器或客户端设备接收Cookie的能力，因此可能会限制这一功能`。\n- 有些状态不可能保保存在客户端。\n\n\n\n#### 3.2 Session\n\nSession，顾名思义，会话。服务器要知道当前请求是谁发送来的，为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，在客户端每次向服务器发送请求时，都带上这个“身份标识”，服务器就知道这个请求来自谁了。（<u>客户端通常会以Cookie的方式保存SessionId</u>）。\n\n服务器使用Session把用户信息临时存在服务器上，用户离开网站后SessionId会被销毁。这种用户信息存储方式相对于Cookie来说更安全。\n\n**缺陷**：若Web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候Session会丢失。\n\n\n\n#### 3.3 Token\n\n在大多数使用Web API的互联网公司中，token是多用户下处理认证的最佳方式。使用Cpu计算时间换取Session的存储空间。\n\n##### 3.3.1 特点\n\n- 无状态、可扩展\n- 支持移动设备\n- 跨程序调用\n- 安全\n\n\n\n##### 3.3.2 基于Token的身份验证过程\n\n基于Token的身份验证过程如下：\n\n![token身份验证](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/token身份验证.png)\n\n- 用户通过用户名和密码发送请求\n- 程序验证\n- 程序返回一个签名的token给客户端\n- 客户端存储token，并且用于每次发送请求\n- 服务器待验证token并返回数据\n\n------\n\n### 参考资料\n\n[彻底理解session、cookie、token](https://www.cnblogs.com/moyand/p/9047978.html)\n[阿里面试题cookie和session的区别及session的生命周期](https://zhuanlan.zhihu.com/p/80716402)\n[大话Token、Cookie和Session](https://zhuanlan.zhihu.com/p/88185448)\n[还分不清 Cookie、Session、Token、JWT？](https://zhuanlan.zhihu.com/p/164696755)\n[JSON Web Token 入门教程](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)\n[RFC1579（JWT）](https://tools.ietf.org/html/rfc7519)","slug":"WEB-会话管理","published":1,"updated":"2020-09-23T08:43:45.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabl3003245g303sz6nx8","content":"<h3 id=\"１引入\"><a href=\"#１引入\" class=\"headerlink\" title=\"１引入\"></a>１引入</h3><p>首先，我们需要知道，HTTP是无状态协议，即HTTP协议对于发送过的请求/接收过的响应均不作持久化处理。<code>HTTP（ HyperText Transfer Protocol）</code>，顾名思义，超文本传输协议。最开始基本上就是文档的浏览而已，作为服务器，不需要记录谁在某一段时间里都浏览了什么文件；还有就是为了能更快的处理大量事务，确保协议的可伸缩性，特意将其设计的如此简单。</p>\n<a id=\"more\"></a>\n<p>但是随着交互式Web应用兴起，如在线购物网站，需要登录的网站等，就马上面临一个问题，即管理会话，必须记住哪些人登陆了系统，哪些人往自己的购物车加购了，且必须将每个人区分开。因此就引入了Session、Cookie、Token等技术。</p>\n<h3 id=\"2-管理会话方法\"><a href=\"#2-管理会话方法\" class=\"headerlink\" title=\"2 管理会话方法\"></a>2 管理会话方法</h3><p>我们需要知道，会话管理的目的是为了验证用户身份。</p>\n<h4 id=\"2-1-使用session做会话管理\"><a href=\"#2-1-使用session做会话管理\" class=\"headerlink\" title=\"2.1 使用session做会话管理\"></a>2.1 使用session做会话管理</h4><p><strong>session是基于cookie实现的会话管理机制</strong>，session存储在服务器端，sessionId会被存储到客户端的cookie中。<br><u>（注：禁用cookie，seesion也将失效。）</u></p>\n<h5 id=\"2-1-1-管理方式\"><a href=\"#2-1-1-管理方式\" class=\"headerlink\" title=\"2.1.1 管理方式\"></a>2.1.1 管理方式</h5><p>给所有的用户发一个会话标识（Session id），其实就是一个随机字符串，每个用户的字符串不一样，当用户发起请求时，将该字符串带过来，就能区分谁是谁了。</p>\n<h5 id=\"2-1-2-问题\"><a href=\"#2-1-2-问题\" class=\"headerlink\" title=\"2.1.2 问题\"></a>2.1.2 问题</h5><p>使用这种管理方式，虽然每个人只需要保存自己的Session id，但服务器需要记住所有用户Session id，这对服务器是很大的开销。并且严重限制了服务器的扩展能力，比如，使用两个机器组成一个集群，某个用户小F，通过机器A登录了系统，其Session is会保存在机器A上，假设下一次请求被转发到机器B，而机器B上没有小F的Session。\n　　</p>\n<h5 id=\"2-1-3-解决方法\"><a href=\"#2-1-3-解决方法\" class=\"headerlink\" title=\"2.1.3 解决方法\"></a>2.1.3 解决方法</h5><ul>\n<li><code>Session Stick（Session 粘黏）</code>：让小F的请求一直粘黏在机器A上。但此时若机器A挂了，还是需要转机器B上，无法从根本上解决问题。</li>\n<li><code>Session复制</code>：把Session id在两台机器上复制，但这样比较麻烦。</li>\n<li><code>将Session统一存储起来</code>：把Session id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样就不需要复制了，但这种方式可能增加了单点失败的风险，若负责Session的机器挂了，则所有用户都需要重新登陆。</li>\n</ul>\n<h5 id=\"2-1-4-Session的生命周期\"><a href=\"#2-1-4-Session的生命周期\" class=\"headerlink\" title=\"2.1.4 Session的生命周期\"></a>2.1.4 Session的生命周期</h5><p>Session保存在服务端，为了获取更高的存取速度，服务器一般会把Session放在内存中，每个用户都会有一个独立的Session，如果Session里面的内容太过复杂，当大量的用户访问服务器时，可能会导致内存溢出，所以Session的内容应该适当的精简。<br>　　<br>当第一次访问服务器时，服务器会创建并维护这个Session。当用户访问一次服务器，无论是否有操作Session，服务器都会认定这个Session活跃了一次，当越来越多的用户访问服务器时，Session就会越来越多。为了防止内存溢出，服务器会把长时间没有活跃的Session删除。这个时间就是Session的过期时间，超过了该时间，Session就会自动失效。\n　　</p>\n<h4 id=\"2-2-使用Token（令牌）做会话管理\"><a href=\"#2-2-使用Token（令牌）做会话管理\" class=\"headerlink\" title=\"2.2 使用Token（令牌）做会话管理\"></a>2.2 使用Token（令牌）做会话管理</h4><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/使用token做令牌管理.png\" alt=\"使用token做令牌管理\" style=\"zoom:80%;\" />\n\n<h5 id=\"2-2-1-管理方式\"><a href=\"#2-2-1-管理方式\" class=\"headerlink\" title=\"2.2.1 管理方式\"></a>2.2.1 管理方式</h5><p>对数据做一个签名，比如使用HMAC-SHA256算法，加上一个服务器才知道的密钥，对数据做一个签名，把这个签名和数据一起作为token，由于别人不知道密钥，就无法伪造token。<br>　　<br>生成的Token服务器不需要保存，当下一次小F请求来的时候，再使用相同的算法进行签名计算，若相同，则判定小F已经登陆过了，并且可以直接取到小F的User id，如果不相同，则数据部分肯定被修改了，就告诉发送者，对不起，没有认证。</p>\n<p>（<strong>思想：使用CPU的计算时间换取Session的存储空间</strong>）</p>\n<h5 id=\"2-2-2-问题\"><a href=\"#2-2-2-问题\" class=\"headerlink\" title=\"2.2.2 问题\"></a>2.2.2 问题</h5><p>若某个用户的token被别人盗取，服务器也会认为这是一个合法的用户（注：Session也存在这个问题），<u>其安全性一般是通过https协议来保证传输的安全性。</u></p>\n<h5 id=\"2-2-3-Token的有效期\"><a href=\"#2-2-3-Token的有效期\" class=\"headerlink\" title=\"2.2.3 Token的有效期\"></a>2.2.3 Token的有效期</h5><p>Token的认证机制可以完成自身的验证，根据token的实际应用场景，对token进行存储，比如登录场景，需要进行一系列精细化控制，如权限、token有效性、自身注销、非法用户的拦截操作等。</p>\n<p>设置有效期需要从需求和用户体验触发，尽可能寻找一个平衡，保证用户体验的前提下，尽可能短。但若用户在操作时token过期需要重新登陆，体验将会很糟。<br>　　<br><strong>为了解决在操作过程中不让用户感受到token失效的问题，通常有以下两种方案</strong>：</p>\n<ul>\n<li><p><strong>方案一</strong>：在服务端保存token状态，用户每次操作都会刷新（推迟）token的过期时间（Session就是采用这种策略来保持用户登录状态的）。</p>\n<ul>\n<li>问题：在前后端分离、单页App这些情况下，每秒钟可能发起多个请求，每次都去刷新过期时间会产生非常大的代价。若token持久化到数据库或文件中，代价就更大了。所以通常为了提升效率，减少消耗，会把token的过期时间保存在缓存或内存中。</li>\n</ul>\n</li>\n<li><p><strong>方案二</strong>：使用Refresh Token，可以避免频繁的读写操作。这种方案，服务器不需要刷新token的过期时间，一旦token失效，就反馈给前端，前端使用Refesh token申请一个全新的token继续使用。该种方案中，服务端只需要在客户端请求更新token的时候，对Refresh token的有效性检查，大大减少了更新有效期的操作，也避免了频繁读写。当然Refresh Token也是有有效期的，但这个有效期就可以长一些。如下图所示：</p>\n</li>\n</ul>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/refresh_token.png\" alt=\"refresh_token\"></p>\n<h4 id=\"2-3-JWT\"><a href=\"#2-3-JWT\" class=\"headerlink\" title=\"2.3 JWT\"></a>2.3 JWT</h4><p>JWT（JSON Web Token）是目前最流行的跨域认证解决方案，<u>是一种认证授权机制</u>。</p>\n<p><strong>JWT的原理是</strong>：服务器认证以后，生成一个JSON对象，发回给用户，后续用户需要与服务端通信时，需要发回这个JSON对象。服务器完全只靠这个对象认定用户身份，且为了防止数据被篡改，生成对象时会添加一个签名。</p>\n<p>实际JWT的数据结构示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eyJleHAiOjE1OTkwMzIyNzksImtpZCI6M30.eyJkZXZpY2VfaWQiOiI1ZGJhZDkxZTE3OTgwOWVmYTZjYjc1ZmI3MmE2NzRlYyIsInNtX2RldmljZV9pZCI6IiIsImRpZ2l0YWxfZGV2aWNlX2lkIjoiIn0.fob_tbEagrBm3o3kK4qFdPw5tdJQG9uIQeg9ryCnIpk                   </span><br></pre></td></tr></table></figure>\n\n<p>​       </p>\n<h3 id=\"3-Session、Cookie、Token的区别\"><a href=\"#3-Session、Cookie、Token的区别\" class=\"headerlink\" title=\"3 Session、Cookie、Token的区别\"></a>3 Session、Cookie、Token的区别</h3><h4 id=\"3-1-Cookie\"><a href=\"#3-1-Cookie\" class=\"headerlink\" title=\"3.1 Cookie\"></a>3.1 Cookie</h4><p>Cookie是一个非常具体的东西，<u>指的就是浏览器里面能永久的数据</u>。仅仅是浏览器实现的一种数据存储功能。</p>\n<p>Cookie由服务器生成，发送给浏览器，浏览器把Cookie以key-value形式保存在某个目录下的文本文件内，下一次请求同一网站时把该Cookie发送给服务器。通过对Cookie的解析，服务器可以识别请发送者的身份。由于Cookie是存在客户端，所以浏览器加入了一些限制确保Cookie不会被恶意使用，同时不会占据太多磁盘空间，所以<u>每个域的Cookie数量是有限的</u>。</p>\n<p><em>注：Cookie是不可跨域名的，隐私安全机制禁止网站非法获取其他网站的Cookie。</em></p>\n<p>（一般来说，同一个一级域名下的两个二级域名也不能交互使用Cookie。比如，a.test.com和b.test.com，因为二者的域名不同。若想要test.com下的二级域名都可以使用该Cookie，需要设置CookieDomain参数为.test.com，这样a.test.com和b.test.com就能访问同一个Cookie。）</p>\n<p><strong>缺陷</strong>：</p>\n<ul>\n<li>Cookie的数量和长度都是有限的</li>\n<li>潜在的安全风险：Cookie可能被截取篡改，如果Cookie被拦截，就可能会获取到所有的信息。</li>\n<li><code>用户可能会配置禁用浏览器或客户端设备接收Cookie的能力，因此可能会限制这一功能</code>。</li>\n<li>有些状态不可能保保存在客户端。</li>\n</ul>\n<h4 id=\"3-2-Session\"><a href=\"#3-2-Session\" class=\"headerlink\" title=\"3.2 Session\"></a>3.2 Session</h4><p>Session，顾名思义，会话。服务器要知道当前请求是谁发送来的，为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，在客户端每次向服务器发送请求时，都带上这个“身份标识”，服务器就知道这个请求来自谁了。（<u>客户端通常会以Cookie的方式保存SessionId</u>）。</p>\n<p>服务器使用Session把用户信息临时存在服务器上，用户离开网站后SessionId会被销毁。这种用户信息存储方式相对于Cookie来说更安全。</p>\n<p><strong>缺陷</strong>：若Web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候Session会丢失。</p>\n<h4 id=\"3-3-Token\"><a href=\"#3-3-Token\" class=\"headerlink\" title=\"3.3 Token\"></a>3.3 Token</h4><p>在大多数使用Web API的互联网公司中，token是多用户下处理认证的最佳方式。使用Cpu计算时间换取Session的存储空间。</p>\n<h5 id=\"3-3-1-特点\"><a href=\"#3-3-1-特点\" class=\"headerlink\" title=\"3.3.1 特点\"></a>3.3.1 特点</h5><ul>\n<li>无状态、可扩展</li>\n<li>支持移动设备</li>\n<li>跨程序调用</li>\n<li>安全</li>\n</ul>\n<h5 id=\"3-3-2-基于Token的身份验证过程\"><a href=\"#3-3-2-基于Token的身份验证过程\" class=\"headerlink\" title=\"3.3.2 基于Token的身份验证过程\"></a>3.3.2 基于Token的身份验证过程</h5><p>基于Token的身份验证过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/token%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81.png\" alt=\"token身份验证\"></p>\n<ul>\n<li>用户通过用户名和密码发送请求</li>\n<li>程序验证</li>\n<li>程序返回一个签名的token给客户端</li>\n<li>客户端存储token，并且用于每次发送请求</li>\n<li>服务器待验证token并返回数据</li>\n</ul>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://www.cnblogs.com/moyand/p/9047978.html\">彻底理解session、cookie、token</a><br><a href=\"https://zhuanlan.zhihu.com/p/80716402\">阿里面试题cookie和session的区别及session的生命周期</a><br><a href=\"https://zhuanlan.zhihu.com/p/88185448\">大话Token、Cookie和Session</a><br><a href=\"https://zhuanlan.zhihu.com/p/164696755\">还分不清 Cookie、Session、Token、JWT？</a><br><a href=\"https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\">JSON Web Token 入门教程</a><br><a href=\"https://tools.ietf.org/html/rfc7519\">RFC1579（JWT）</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"１引入\"><a href=\"#１引入\" class=\"headerlink\" title=\"１引入\"></a>１引入</h3><p>首先，我们需要知道，HTTP是无状态协议，即HTTP协议对于发送过的请求/接收过的响应均不作持久化处理。<code>HTTP（ HyperText Transfer Protocol）</code>，顾名思义，超文本传输协议。最开始基本上就是文档的浏览而已，作为服务器，不需要记录谁在某一段时间里都浏览了什么文件；还有就是为了能更快的处理大量事务，确保协议的可伸缩性，特意将其设计的如此简单。</p>","more":"<p>但是随着交互式Web应用兴起，如在线购物网站，需要登录的网站等，就马上面临一个问题，即管理会话，必须记住哪些人登陆了系统，哪些人往自己的购物车加购了，且必须将每个人区分开。因此就引入了Session、Cookie、Token等技术。</p>\n<h3 id=\"2-管理会话方法\"><a href=\"#2-管理会话方法\" class=\"headerlink\" title=\"2 管理会话方法\"></a>2 管理会话方法</h3><p>我们需要知道，会话管理的目的是为了验证用户身份。</p>\n<h4 id=\"2-1-使用session做会话管理\"><a href=\"#2-1-使用session做会话管理\" class=\"headerlink\" title=\"2.1 使用session做会话管理\"></a>2.1 使用session做会话管理</h4><p><strong>session是基于cookie实现的会话管理机制</strong>，session存储在服务器端，sessionId会被存储到客户端的cookie中。<br><u>（注：禁用cookie，seesion也将失效。）</u></p>\n<h5 id=\"2-1-1-管理方式\"><a href=\"#2-1-1-管理方式\" class=\"headerlink\" title=\"2.1.1 管理方式\"></a>2.1.1 管理方式</h5><p>给所有的用户发一个会话标识（Session id），其实就是一个随机字符串，每个用户的字符串不一样，当用户发起请求时，将该字符串带过来，就能区分谁是谁了。</p>\n<h5 id=\"2-1-2-问题\"><a href=\"#2-1-2-问题\" class=\"headerlink\" title=\"2.1.2 问题\"></a>2.1.2 问题</h5><p>使用这种管理方式，虽然每个人只需要保存自己的Session id，但服务器需要记住所有用户Session id，这对服务器是很大的开销。并且严重限制了服务器的扩展能力，比如，使用两个机器组成一个集群，某个用户小F，通过机器A登录了系统，其Session is会保存在机器A上，假设下一次请求被转发到机器B，而机器B上没有小F的Session。\n　　</p>\n<h5 id=\"2-1-3-解决方法\"><a href=\"#2-1-3-解决方法\" class=\"headerlink\" title=\"2.1.3 解决方法\"></a>2.1.3 解决方法</h5><ul>\n<li><code>Session Stick（Session 粘黏）</code>：让小F的请求一直粘黏在机器A上。但此时若机器A挂了，还是需要转机器B上，无法从根本上解决问题。</li>\n<li><code>Session复制</code>：把Session id在两台机器上复制，但这样比较麻烦。</li>\n<li><code>将Session统一存储起来</code>：把Session id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样就不需要复制了，但这种方式可能增加了单点失败的风险，若负责Session的机器挂了，则所有用户都需要重新登陆。</li>\n</ul>\n<h5 id=\"2-1-4-Session的生命周期\"><a href=\"#2-1-4-Session的生命周期\" class=\"headerlink\" title=\"2.1.4 Session的生命周期\"></a>2.1.4 Session的生命周期</h5><p>Session保存在服务端，为了获取更高的存取速度，服务器一般会把Session放在内存中，每个用户都会有一个独立的Session，如果Session里面的内容太过复杂，当大量的用户访问服务器时，可能会导致内存溢出，所以Session的内容应该适当的精简。<br>　　<br>当第一次访问服务器时，服务器会创建并维护这个Session。当用户访问一次服务器，无论是否有操作Session，服务器都会认定这个Session活跃了一次，当越来越多的用户访问服务器时，Session就会越来越多。为了防止内存溢出，服务器会把长时间没有活跃的Session删除。这个时间就是Session的过期时间，超过了该时间，Session就会自动失效。\n　　</p>\n<h4 id=\"2-2-使用Token（令牌）做会话管理\"><a href=\"#2-2-使用Token（令牌）做会话管理\" class=\"headerlink\" title=\"2.2 使用Token（令牌）做会话管理\"></a>2.2 使用Token（令牌）做会话管理</h4><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/使用token做令牌管理.png\" alt=\"使用token做令牌管理\" style=\"zoom:80%;\" />\n\n<h5 id=\"2-2-1-管理方式\"><a href=\"#2-2-1-管理方式\" class=\"headerlink\" title=\"2.2.1 管理方式\"></a>2.2.1 管理方式</h5><p>对数据做一个签名，比如使用HMAC-SHA256算法，加上一个服务器才知道的密钥，对数据做一个签名，把这个签名和数据一起作为token，由于别人不知道密钥，就无法伪造token。<br>　　<br>生成的Token服务器不需要保存，当下一次小F请求来的时候，再使用相同的算法进行签名计算，若相同，则判定小F已经登陆过了，并且可以直接取到小F的User id，如果不相同，则数据部分肯定被修改了，就告诉发送者，对不起，没有认证。</p>\n<p>（<strong>思想：使用CPU的计算时间换取Session的存储空间</strong>）</p>\n<h5 id=\"2-2-2-问题\"><a href=\"#2-2-2-问题\" class=\"headerlink\" title=\"2.2.2 问题\"></a>2.2.2 问题</h5><p>若某个用户的token被别人盗取，服务器也会认为这是一个合法的用户（注：Session也存在这个问题），<u>其安全性一般是通过https协议来保证传输的安全性。</u></p>\n<h5 id=\"2-2-3-Token的有效期\"><a href=\"#2-2-3-Token的有效期\" class=\"headerlink\" title=\"2.2.3 Token的有效期\"></a>2.2.3 Token的有效期</h5><p>Token的认证机制可以完成自身的验证，根据token的实际应用场景，对token进行存储，比如登录场景，需要进行一系列精细化控制，如权限、token有效性、自身注销、非法用户的拦截操作等。</p>\n<p>设置有效期需要从需求和用户体验触发，尽可能寻找一个平衡，保证用户体验的前提下，尽可能短。但若用户在操作时token过期需要重新登陆，体验将会很糟。<br>　　<br><strong>为了解决在操作过程中不让用户感受到token失效的问题，通常有以下两种方案</strong>：</p>\n<ul>\n<li><p><strong>方案一</strong>：在服务端保存token状态，用户每次操作都会刷新（推迟）token的过期时间（Session就是采用这种策略来保持用户登录状态的）。</p>\n<ul>\n<li>问题：在前后端分离、单页App这些情况下，每秒钟可能发起多个请求，每次都去刷新过期时间会产生非常大的代价。若token持久化到数据库或文件中，代价就更大了。所以通常为了提升效率，减少消耗，会把token的过期时间保存在缓存或内存中。</li>\n</ul>\n</li>\n<li><p><strong>方案二</strong>：使用Refresh Token，可以避免频繁的读写操作。这种方案，服务器不需要刷新token的过期时间，一旦token失效，就反馈给前端，前端使用Refesh token申请一个全新的token继续使用。该种方案中，服务端只需要在客户端请求更新token的时候，对Refresh token的有效性检查，大大减少了更新有效期的操作，也避免了频繁读写。当然Refresh Token也是有有效期的，但这个有效期就可以长一些。如下图所示：</p>\n</li>\n</ul>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/refresh_token.png\" alt=\"refresh_token\"></p>\n<h4 id=\"2-3-JWT\"><a href=\"#2-3-JWT\" class=\"headerlink\" title=\"2.3 JWT\"></a>2.3 JWT</h4><p>JWT（JSON Web Token）是目前最流行的跨域认证解决方案，<u>是一种认证授权机制</u>。</p>\n<p><strong>JWT的原理是</strong>：服务器认证以后，生成一个JSON对象，发回给用户，后续用户需要与服务端通信时，需要发回这个JSON对象。服务器完全只靠这个对象认定用户身份，且为了防止数据被篡改，生成对象时会添加一个签名。</p>\n<p>实际JWT的数据结构示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eyJleHAiOjE1OTkwMzIyNzksImtpZCI6M30.eyJkZXZpY2VfaWQiOiI1ZGJhZDkxZTE3OTgwOWVmYTZjYjc1ZmI3MmE2NzRlYyIsInNtX2RldmljZV9pZCI6IiIsImRpZ2l0YWxfZGV2aWNlX2lkIjoiIn0.fob_tbEagrBm3o3kK4qFdPw5tdJQG9uIQeg9ryCnIpk                   </span><br></pre></td></tr></table></figure>\n\n<p>​       </p>\n<h3 id=\"3-Session、Cookie、Token的区别\"><a href=\"#3-Session、Cookie、Token的区别\" class=\"headerlink\" title=\"3 Session、Cookie、Token的区别\"></a>3 Session、Cookie、Token的区别</h3><h4 id=\"3-1-Cookie\"><a href=\"#3-1-Cookie\" class=\"headerlink\" title=\"3.1 Cookie\"></a>3.1 Cookie</h4><p>Cookie是一个非常具体的东西，<u>指的就是浏览器里面能永久的数据</u>。仅仅是浏览器实现的一种数据存储功能。</p>\n<p>Cookie由服务器生成，发送给浏览器，浏览器把Cookie以key-value形式保存在某个目录下的文本文件内，下一次请求同一网站时把该Cookie发送给服务器。通过对Cookie的解析，服务器可以识别请发送者的身份。由于Cookie是存在客户端，所以浏览器加入了一些限制确保Cookie不会被恶意使用，同时不会占据太多磁盘空间，所以<u>每个域的Cookie数量是有限的</u>。</p>\n<p><em>注：Cookie是不可跨域名的，隐私安全机制禁止网站非法获取其他网站的Cookie。</em></p>\n<p>（一般来说，同一个一级域名下的两个二级域名也不能交互使用Cookie。比如，a.test.com和b.test.com，因为二者的域名不同。若想要test.com下的二级域名都可以使用该Cookie，需要设置CookieDomain参数为.test.com，这样a.test.com和b.test.com就能访问同一个Cookie。）</p>\n<p><strong>缺陷</strong>：</p>\n<ul>\n<li>Cookie的数量和长度都是有限的</li>\n<li>潜在的安全风险：Cookie可能被截取篡改，如果Cookie被拦截，就可能会获取到所有的信息。</li>\n<li><code>用户可能会配置禁用浏览器或客户端设备接收Cookie的能力，因此可能会限制这一功能</code>。</li>\n<li>有些状态不可能保保存在客户端。</li>\n</ul>\n<h4 id=\"3-2-Session\"><a href=\"#3-2-Session\" class=\"headerlink\" title=\"3.2 Session\"></a>3.2 Session</h4><p>Session，顾名思义，会话。服务器要知道当前请求是谁发送来的，为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，在客户端每次向服务器发送请求时，都带上这个“身份标识”，服务器就知道这个请求来自谁了。（<u>客户端通常会以Cookie的方式保存SessionId</u>）。</p>\n<p>服务器使用Session把用户信息临时存在服务器上，用户离开网站后SessionId会被销毁。这种用户信息存储方式相对于Cookie来说更安全。</p>\n<p><strong>缺陷</strong>：若Web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候Session会丢失。</p>\n<h4 id=\"3-3-Token\"><a href=\"#3-3-Token\" class=\"headerlink\" title=\"3.3 Token\"></a>3.3 Token</h4><p>在大多数使用Web API的互联网公司中，token是多用户下处理认证的最佳方式。使用Cpu计算时间换取Session的存储空间。</p>\n<h5 id=\"3-3-1-特点\"><a href=\"#3-3-1-特点\" class=\"headerlink\" title=\"3.3.1 特点\"></a>3.3.1 特点</h5><ul>\n<li>无状态、可扩展</li>\n<li>支持移动设备</li>\n<li>跨程序调用</li>\n<li>安全</li>\n</ul>\n<h5 id=\"3-3-2-基于Token的身份验证过程\"><a href=\"#3-3-2-基于Token的身份验证过程\" class=\"headerlink\" title=\"3.3.2 基于Token的身份验证过程\"></a>3.3.2 基于Token的身份验证过程</h5><p>基于Token的身份验证过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/HTTP/token%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81.png\" alt=\"token身份验证\"></p>\n<ul>\n<li>用户通过用户名和密码发送请求</li>\n<li>程序验证</li>\n<li>程序返回一个签名的token给客户端</li>\n<li>客户端存储token，并且用于每次发送请求</li>\n<li>服务器待验证token并返回数据</li>\n</ul>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://www.cnblogs.com/moyand/p/9047978.html\">彻底理解session、cookie、token</a><br><a href=\"https://zhuanlan.zhihu.com/p/80716402\">阿里面试题cookie和session的区别及session的生命周期</a><br><a href=\"https://zhuanlan.zhihu.com/p/88185448\">大话Token、Cookie和Session</a><br><a href=\"https://zhuanlan.zhihu.com/p/164696755\">还分不清 Cookie、Session、Token、JWT？</a><br><a href=\"https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\">JSON Web Token 入门教程</a><br><a href=\"https://tools.ietf.org/html/rfc7519\">RFC1579（JWT）</a></p>"},{"title":"redis设计与实现-单机数据库的实现","date":"2020-09-03T06:29:25.000Z","_content":"\n\n\n### 1 服务器中的数据库\n\nRedis服务器将所有数据库都保存在服务器状态`redis.h/redisServer`结构的`db数组`中，db数组的每个项都是一个`redis.h/redisDb`结构，每个redisDb结构代表了一个数据库。\n\n<!--more-->\n\n```c\nstruct redisServer {\n    // ...\n    // 一个数组，保存着服务器中的所有数据库.\n    redisDb *db;\n    // 总配置的数据库的数量.\n    int dbnum;\n    // ...\n};\n```\n\ndbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。\n\n\n\n### 2 切换数据库\n\n默认情况下，Redis客户端的目标数据库为`0号数据库`，通过`select命令`可切换数据库。\n\n\n\n示例：\n\n```bash\n# 切换到数据库2.\nredis> select 2\n```\n\n\n\n其中`redisClient`结构中的`db属性记录了当前客户端的目标数据库`，该属性是一个指向`redisDb`结构的指针，`redisClient.db`指向`redisServer.db`数组的其中一个元素，`被指向的元素即为目标数据库`。\n\n```c\ntypedef struct redisClient {\n    // ...\n    // 记录客户端当前正在使用的数据库.\n    redisDb *db;\n    // ...\n} redisClient;\n```\n\n\n\n下图为客户端的目标数据库为1号数据库。\n\n![客户端的目标数据库为1号数据库](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-单机数据库的实现/客户端的目标数据库为1号数据库.png)\n\n**问: SELECT命令的实现原理是什么？**\n\n通过修改redisClient.db指针，让它指向服务器中不同数据库，从而实现切换目标数据库的功能。\n\n\n\n### 3 数据库键空间\n\nRedis是一个键值对数据库服务器，服务器中的每个数据库都由一个`redis.h/redisDb`结构表示，其中，`redisDb`结构的`dict`字典保存了数据库中的所有键值对，我们将这个字典称为**键空间（key space）**。\n\n`redis.h/redisDb`结构:\n\n```c\ntypedef struct redisDb {\n    // ...\n    // 数据库键空间，保存着数据库中的所有键值对.\n    dict *dict;\n    // ...\n}redisDb;\n```\n\n\n\n其中，\n\n- 键空间的键就是**数据库的键**，每个键都是一个`字符串对象`；\n- 键空间的值就是**数据库的值**，每个值都可以是`字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象`。\n\n\n\n示例：下图为包含了列表键、哈希表键、字符串键的结构图\n\n![包含了列表键、哈希表键、字符串键的结构图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-单机数据库的实现/包含了列表键、哈希表键、字符串键的结构图.png)\n\n*注：数据库的键空间是一个字典，所以所有针对数据库的操作，实际上都是通过对键空间字典进行操作来实现的。*\n\n\n\n- 添加新键: 添加新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。\n- 删除键: 删除数据库中的一个键，实际上就是在键空间里面删除键所对应额键值对对象。（**键对象和值对象都要删除！**）\n- 更新键: 更新数据库键，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。\n- 对键取值: 取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。\n\n\n\n#### 3.1 其他键空间的操作\n\n除了以上增删改查的操作，还有其他一些命令是通过对键空间进行处理来完成的。\n\n比如说：\n\n- `flushdb`命令: 通过删除键空间中的所有键值对来实现的。\n- `randomkey`命令: 随机返回某个键，也是在键空间中随机返回的。\n- `dbsize`命令: 返回数据库键数量，通过返回键空间中包含的键值对的数量来完成。\n- `exist、rename、keys`等。\n\n\n\n#### 3.2 读写键空间时的维护操作\n\n当时用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操纵，还会执行一些额外的维护操作，比如：\n\n- ①、在读取一个键之后（读写操作都会对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（keyspace_hit）/未命中(keyspace_misses)的次数。通过以下命令可查看其属性。\n\n  ```\n  INFO stats\n  ```\n\n- ②、在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用以下命令可查看键的闲置时间。\n\n  ```\n  object idletime <key>\n  ```\n\n- ③、若服务器在读取一个键时发现该键已过期，那么服务器会先删除这个过期键，然后执行余下的其他操作。\n- ④、若有客户端使用watch命令监视了这个键，那么服务器在对被监视的键进行修改之后，会标记这个键为脏（dirty），从而让事务成武注意到这个键已经被修改过。\n- ⑤、服务器每次修改一个键之后，都会对dity键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。\n- ⑥、若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据通知。\n\n### 4 数据库通知\n\n数据库通知可以让客户端通过订阅给定频道或者模式，来获悉数据库中键的变化，以及数据中命令的执行情况。","source":"_posts/redis设计与实现-单机数据库的实现.md","raw":"---\ntitle: redis设计与实现-单机数据库的实现\ndate: 2020-09-03 14:29:25\ntags: [\"Redis\",\"Note\",\"Redis设计与实现\"]\ncategories: [\"Redis\"]\n---\n\n\n\n### 1 服务器中的数据库\n\nRedis服务器将所有数据库都保存在服务器状态`redis.h/redisServer`结构的`db数组`中，db数组的每个项都是一个`redis.h/redisDb`结构，每个redisDb结构代表了一个数据库。\n\n<!--more-->\n\n```c\nstruct redisServer {\n    // ...\n    // 一个数组，保存着服务器中的所有数据库.\n    redisDb *db;\n    // 总配置的数据库的数量.\n    int dbnum;\n    // ...\n};\n```\n\ndbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。\n\n\n\n### 2 切换数据库\n\n默认情况下，Redis客户端的目标数据库为`0号数据库`，通过`select命令`可切换数据库。\n\n\n\n示例：\n\n```bash\n# 切换到数据库2.\nredis> select 2\n```\n\n\n\n其中`redisClient`结构中的`db属性记录了当前客户端的目标数据库`，该属性是一个指向`redisDb`结构的指针，`redisClient.db`指向`redisServer.db`数组的其中一个元素，`被指向的元素即为目标数据库`。\n\n```c\ntypedef struct redisClient {\n    // ...\n    // 记录客户端当前正在使用的数据库.\n    redisDb *db;\n    // ...\n} redisClient;\n```\n\n\n\n下图为客户端的目标数据库为1号数据库。\n\n![客户端的目标数据库为1号数据库](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-单机数据库的实现/客户端的目标数据库为1号数据库.png)\n\n**问: SELECT命令的实现原理是什么？**\n\n通过修改redisClient.db指针，让它指向服务器中不同数据库，从而实现切换目标数据库的功能。\n\n\n\n### 3 数据库键空间\n\nRedis是一个键值对数据库服务器，服务器中的每个数据库都由一个`redis.h/redisDb`结构表示，其中，`redisDb`结构的`dict`字典保存了数据库中的所有键值对，我们将这个字典称为**键空间（key space）**。\n\n`redis.h/redisDb`结构:\n\n```c\ntypedef struct redisDb {\n    // ...\n    // 数据库键空间，保存着数据库中的所有键值对.\n    dict *dict;\n    // ...\n}redisDb;\n```\n\n\n\n其中，\n\n- 键空间的键就是**数据库的键**，每个键都是一个`字符串对象`；\n- 键空间的值就是**数据库的值**，每个值都可以是`字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象`。\n\n\n\n示例：下图为包含了列表键、哈希表键、字符串键的结构图\n\n![包含了列表键、哈希表键、字符串键的结构图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-单机数据库的实现/包含了列表键、哈希表键、字符串键的结构图.png)\n\n*注：数据库的键空间是一个字典，所以所有针对数据库的操作，实际上都是通过对键空间字典进行操作来实现的。*\n\n\n\n- 添加新键: 添加新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。\n- 删除键: 删除数据库中的一个键，实际上就是在键空间里面删除键所对应额键值对对象。（**键对象和值对象都要删除！**）\n- 更新键: 更新数据库键，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。\n- 对键取值: 取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。\n\n\n\n#### 3.1 其他键空间的操作\n\n除了以上增删改查的操作，还有其他一些命令是通过对键空间进行处理来完成的。\n\n比如说：\n\n- `flushdb`命令: 通过删除键空间中的所有键值对来实现的。\n- `randomkey`命令: 随机返回某个键，也是在键空间中随机返回的。\n- `dbsize`命令: 返回数据库键数量，通过返回键空间中包含的键值对的数量来完成。\n- `exist、rename、keys`等。\n\n\n\n#### 3.2 读写键空间时的维护操作\n\n当时用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操纵，还会执行一些额外的维护操作，比如：\n\n- ①、在读取一个键之后（读写操作都会对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（keyspace_hit）/未命中(keyspace_misses)的次数。通过以下命令可查看其属性。\n\n  ```\n  INFO stats\n  ```\n\n- ②、在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用以下命令可查看键的闲置时间。\n\n  ```\n  object idletime <key>\n  ```\n\n- ③、若服务器在读取一个键时发现该键已过期，那么服务器会先删除这个过期键，然后执行余下的其他操作。\n- ④、若有客户端使用watch命令监视了这个键，那么服务器在对被监视的键进行修改之后，会标记这个键为脏（dirty），从而让事务成武注意到这个键已经被修改过。\n- ⑤、服务器每次修改一个键之后，都会对dity键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。\n- ⑥、若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据通知。\n\n### 4 数据库通知\n\n数据库通知可以让客户端通过订阅给定频道或者模式，来获悉数据库中键的变化，以及数据中命令的执行情况。","slug":"redis设计与实现-单机数据库的实现","published":1,"updated":"2020-09-24T10:12:19.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabl4003645g3ghce4v53","content":"<h3 id=\"1-服务器中的数据库\"><a href=\"#1-服务器中的数据库\" class=\"headerlink\" title=\"1 服务器中的数据库\"></a>1 服务器中的数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态<code>redis.h/redisServer</code>结构的<code>db数组</code>中，db数组的每个项都是一个<code>redis.h/redisDb</code>结构，每个redisDb结构代表了一个数据库。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 一个数组，保存着服务器中的所有数据库.</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">    <span class=\"comment\">// 总配置的数据库的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dbnum;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。</p>\n<h3 id=\"2-切换数据库\"><a href=\"#2-切换数据库\" class=\"headerlink\" title=\"2 切换数据库\"></a>2 切换数据库</h3><p>默认情况下，Redis客户端的目标数据库为<code>0号数据库</code>，通过<code>select命令</code>可切换数据库。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到数据库2.</span></span><br><span class=\"line\">redis&gt; select 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中<code>redisClient</code>结构中的<code>db属性记录了当前客户端的目标数据库</code>，该属性是一个指向<code>redisDb</code>结构的指针，<code>redisClient.db</code>指向<code>redisServer.db</code>数组的其中一个元素，<code>被指向的元素即为目标数据库</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisClient</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录客户端当前正在使用的数据库.</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; redisClient;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>下图为客户端的目标数据库为1号数据库。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%9B%AE%E6%A0%87%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA1%E5%8F%B7%E6%95%B0%E6%8D%AE%E5%BA%93.png\" alt=\"客户端的目标数据库为1号数据库\"></p>\n<p><strong>问: SELECT命令的实现原理是什么？</strong></p>\n<p>通过修改redisClient.db指针，让它指向服务器中不同数据库，从而实现切换目标数据库的功能。</p>\n<h3 id=\"3-数据库键空间\"><a href=\"#3-数据库键空间\" class=\"headerlink\" title=\"3 数据库键空间\"></a>3 数据库键空间</h3><p>Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个<code>redis.h/redisDb</code>结构表示，其中，<code>redisDb</code>结构的<code>dict</code>字典保存了数据库中的所有键值对，我们将这个字典称为<strong>键空间（key space）</strong>。</p>\n<p><code>redis.h/redisDb</code>结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDb</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 数据库键空间，保存着数据库中的所有键值对.</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;redisDb;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中，</p>\n<ul>\n<li>键空间的键就是<strong>数据库的键</strong>，每个键都是一个<code>字符串对象</code>；</li>\n<li>键空间的值就是<strong>数据库的值</strong>，每个值都可以是<code>字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象</code>。</li>\n</ul>\n<p>示例：下图为包含了列表键、哈希表键、字符串键的结构图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%8C%85%E5%90%AB%E4%BA%86%E5%88%97%E8%A1%A8%E9%94%AE%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E9%94%AE%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%94%AE%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.png\" alt=\"包含了列表键、哈希表键、字符串键的结构图\"></p>\n<p><em>注：数据库的键空间是一个字典，所以所有针对数据库的操作，实际上都是通过对键空间字典进行操作来实现的。</em></p>\n<ul>\n<li>添加新键: 添加新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</li>\n<li>删除键: 删除数据库中的一个键，实际上就是在键空间里面删除键所对应额键值对对象。（<strong>键对象和值对象都要删除！</strong>）</li>\n<li>更新键: 更新数据库键，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</li>\n<li>对键取值: 取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</li>\n</ul>\n<h4 id=\"3-1-其他键空间的操作\"><a href=\"#3-1-其他键空间的操作\" class=\"headerlink\" title=\"3.1 其他键空间的操作\"></a>3.1 其他键空间的操作</h4><p>除了以上增删改查的操作，还有其他一些命令是通过对键空间进行处理来完成的。</p>\n<p>比如说：</p>\n<ul>\n<li><code>flushdb</code>命令: 通过删除键空间中的所有键值对来实现的。</li>\n<li><code>randomkey</code>命令: 随机返回某个键，也是在键空间中随机返回的。</li>\n<li><code>dbsize</code>命令: 返回数据库键数量，通过返回键空间中包含的键值对的数量来完成。</li>\n<li><code>exist、rename、keys</code>等。</li>\n</ul>\n<h4 id=\"3-2-读写键空间时的维护操作\"><a href=\"#3-2-读写键空间时的维护操作\" class=\"headerlink\" title=\"3.2 读写键空间时的维护操作\"></a>3.2 读写键空间时的维护操作</h4><p>当时用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操纵，还会执行一些额外的维护操作，比如：</p>\n<ul>\n<li><p>①、在读取一个键之后（读写操作都会对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（keyspace_hit）/未命中(keyspace_misses)的次数。通过以下命令可查看其属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO stats</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>②、在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用以下命令可查看键的闲置时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object idletime &lt;key&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>③、若服务器在读取一个键时发现该键已过期，那么服务器会先删除这个过期键，然后执行余下的其他操作。</p>\n</li>\n<li><p>④、若有客户端使用watch命令监视了这个键，那么服务器在对被监视的键进行修改之后，会标记这个键为脏（dirty），从而让事务成武注意到这个键已经被修改过。</p>\n</li>\n<li><p>⑤、服务器每次修改一个键之后，都会对dity键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</p>\n</li>\n<li><p>⑥、若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据通知。</p>\n</li>\n</ul>\n<h3 id=\"4-数据库通知\"><a href=\"#4-数据库通知\" class=\"headerlink\" title=\"4 数据库通知\"></a>4 数据库通知</h3><p>数据库通知可以让客户端通过订阅给定频道或者模式，来获悉数据库中键的变化，以及数据中命令的执行情况。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-服务器中的数据库\"><a href=\"#1-服务器中的数据库\" class=\"headerlink\" title=\"1 服务器中的数据库\"></a>1 服务器中的数据库</h3><p>Redis服务器将所有数据库都保存在服务器状态<code>redis.h/redisServer</code>结构的<code>db数组</code>中，db数组的每个项都是一个<code>redis.h/redisDb</code>结构，每个redisDb结构代表了一个数据库。</p>","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 一个数组，保存着服务器中的所有数据库.</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">    <span class=\"comment\">// 总配置的数据库的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dbnum;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。</p>\n<h3 id=\"2-切换数据库\"><a href=\"#2-切换数据库\" class=\"headerlink\" title=\"2 切换数据库\"></a>2 切换数据库</h3><p>默认情况下，Redis客户端的目标数据库为<code>0号数据库</code>，通过<code>select命令</code>可切换数据库。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到数据库2.</span></span><br><span class=\"line\">redis&gt; select 2</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中<code>redisClient</code>结构中的<code>db属性记录了当前客户端的目标数据库</code>，该属性是一个指向<code>redisDb</code>结构的指针，<code>redisClient.db</code>指向<code>redisServer.db</code>数组的其中一个元素，<code>被指向的元素即为目标数据库</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisClient</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录客户端当前正在使用的数据库.</span></span><br><span class=\"line\">    redisDb *db;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125; redisClient;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>下图为客户端的目标数据库为1号数据库。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%9B%AE%E6%A0%87%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA1%E5%8F%B7%E6%95%B0%E6%8D%AE%E5%BA%93.png\" alt=\"客户端的目标数据库为1号数据库\"></p>\n<p><strong>问: SELECT命令的实现原理是什么？</strong></p>\n<p>通过修改redisClient.db指针，让它指向服务器中不同数据库，从而实现切换目标数据库的功能。</p>\n<h3 id=\"3-数据库键空间\"><a href=\"#3-数据库键空间\" class=\"headerlink\" title=\"3 数据库键空间\"></a>3 数据库键空间</h3><p>Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个<code>redis.h/redisDb</code>结构表示，其中，<code>redisDb</code>结构的<code>dict</code>字典保存了数据库中的所有键值对，我们将这个字典称为<strong>键空间（key space）</strong>。</p>\n<p><code>redis.h/redisDb</code>结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisDb</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 数据库键空间，保存着数据库中的所有键值对.</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;redisDb;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中，</p>\n<ul>\n<li>键空间的键就是<strong>数据库的键</strong>，每个键都是一个<code>字符串对象</code>；</li>\n<li>键空间的值就是<strong>数据库的值</strong>，每个值都可以是<code>字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象</code>。</li>\n</ul>\n<p>示例：下图为包含了列表键、哈希表键、字符串键的结构图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%8C%85%E5%90%AB%E4%BA%86%E5%88%97%E8%A1%A8%E9%94%AE%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E9%94%AE%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%94%AE%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.png\" alt=\"包含了列表键、哈希表键、字符串键的结构图\"></p>\n<p><em>注：数据库的键空间是一个字典，所以所有针对数据库的操作，实际上都是通过对键空间字典进行操作来实现的。</em></p>\n<ul>\n<li>添加新键: 添加新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</li>\n<li>删除键: 删除数据库中的一个键，实际上就是在键空间里面删除键所对应额键值对对象。（<strong>键对象和值对象都要删除！</strong>）</li>\n<li>更新键: 更新数据库键，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</li>\n<li>对键取值: 取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</li>\n</ul>\n<h4 id=\"3-1-其他键空间的操作\"><a href=\"#3-1-其他键空间的操作\" class=\"headerlink\" title=\"3.1 其他键空间的操作\"></a>3.1 其他键空间的操作</h4><p>除了以上增删改查的操作，还有其他一些命令是通过对键空间进行处理来完成的。</p>\n<p>比如说：</p>\n<ul>\n<li><code>flushdb</code>命令: 通过删除键空间中的所有键值对来实现的。</li>\n<li><code>randomkey</code>命令: 随机返回某个键，也是在键空间中随机返回的。</li>\n<li><code>dbsize</code>命令: 返回数据库键数量，通过返回键空间中包含的键值对的数量来完成。</li>\n<li><code>exist、rename、keys</code>等。</li>\n</ul>\n<h4 id=\"3-2-读写键空间时的维护操作\"><a href=\"#3-2-读写键空间时的维护操作\" class=\"headerlink\" title=\"3.2 读写键空间时的维护操作\"></a>3.2 读写键空间时的维护操作</h4><p>当时用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操纵，还会执行一些额外的维护操作，比如：</p>\n<ul>\n<li><p>①、在读取一个键之后（读写操作都会对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（keyspace_hit）/未命中(keyspace_misses)的次数。通过以下命令可查看其属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO stats</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>②、在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用以下命令可查看键的闲置时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object idletime &lt;key&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>③、若服务器在读取一个键时发现该键已过期，那么服务器会先删除这个过期键，然后执行余下的其他操作。</p>\n</li>\n<li><p>④、若有客户端使用watch命令监视了这个键，那么服务器在对被监视的键进行修改之后，会标记这个键为脏（dirty），从而让事务成武注意到这个键已经被修改过。</p>\n</li>\n<li><p>⑤、服务器每次修改一个键之后，都会对dity键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</p>\n</li>\n<li><p>⑥、若服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据通知。</p>\n</li>\n</ul>\n<h3 id=\"4-数据库通知\"><a href=\"#4-数据库通知\" class=\"headerlink\" title=\"4 数据库通知\"></a>4 数据库通知</h3><p>数据库通知可以让客户端通过订阅给定频道或者模式，来获悉数据库中键的变化，以及数据中命令的执行情况。</p>"},{"title":"MySQL-Explain详解","date":"2020-09-05T03:17:41.000Z","_content":"\n\n\n### 1 简介\n\n`EXPLAIN`命令是`查看查询优化器如何决定执行查询的主要方法`。虽然这个功能有一些局限性，但是它的输出是可以获取的最好信息。在使用EXPLAIN时，MySQL会在查询上设置一个标记，当执行查询时，这个标记会使其返回关于执行计划中每一步的信息，而不是执行它。它会返回一行或多行信息，显示出执行计划中的每一部分和执行次序。\n\n<!--more-->\n\n注意：EXPLAIN只是个近似结果，有时候它是一个很好的近似，但有时候也会相差甚远。\n\n\n\n以下是使用EXPLIAN的一些相关限制：\n\n- 不会告诉你触发器、存储过程或UDF会如何影响查询；\n- 不支持存储过程，尽管可以手动抽取查询并单独的对其进行EXPLAIN操作；\n- 不会告诉你MySQL在查询执行中所作的特定优化；\n- 不会显示关于查询的执行计划的所有信息；\n- 不区分具有相同名字的事物。例如：对于内存排序和临时文件都使用“filesort”，并且对于磁盘上和内存中的临时表都显示“Using temporary”；\n- 可能会出现误导。例如，`对于一个有着很小的limit查询显示全索引扫描`。\n\n\n\n### 1.1 重写非SELECT查询\n\nEXPLAIN只能解释SELECT查询，并不会对存储程序调用、INSERT、UPDATE、DELETE或其他语句做解释。\n\n解决方法：重写非SELECT查询以利用EXPLAIN，\n\n\n\n### 2 用法\n\n```\nEXPLAIN tbl_name # 得出一个表的字段结构。\nEXPLAIN [EXTENDED] SELECT select_options # 给出当前SQL语句相关的一些信息。 \n```\n\n以`virtual_coins表`为例，后续测试均在此表基础上进行验证。\n\n```mysql\nCREATE TABLE `virtual_coins` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',\n  `uid` int(10) NOT NULL DEFAULT '0' COMMENT '用户ID',\n  `type` varchar(20) NOT NULL DEFAULT '' COMMENT '虚拟货币类型',\n  `channel` varchar(20) NOT NULL DEFAULT '' COMMENT '渠道',\n  `total_coins` int(10) NOT NULL DEFAULT '0' COMMENT '当前虚拟货币类型总数',\n  `usable_coins` int(10) NOT NULL DEFAULT '0' COMMENT '当前虚拟货币类型可用数量',\n  `frozen_coins` int(10) NOT NULL DEFAULT '0' COMMENT '当前虚拟货币类型冻结数量',\n  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：1-有效，0-无效（封禁）',\n  `create_time` int(10) NOT NULL DEFAULT '0' COMMENT '创建时间',\n  `update_time` int(10) NOT NULL DEFAULT '0' COMMENT '更新时间',\n  PRIMARY KEY (`id`),\n  KEY `idx_uid_type` (`uid`,`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='虚拟货币快照表'\n```\n\n```mysql\nmysql> explain virtual_coins;\n+--------------+------------------+------+-----+---------+----------------+\n| Field        | Type             | Null | Key | Default | Extra          |\n+--------------+------------------+------+-----+---------+----------------+\n| id           | int(11) unsigned | NO   | PRI | NULL    | auto_increment |\n| uid          | int(10)          | NO   | MUL | 0       |                |\n| type         | varchar(20)      | NO   |     |         |                |\n| channel      | varchar(20)      | NO   |     |         |                |\n| total_coins  | int(10)          | NO   |     | 0       |                |\n| usable_coins | int(10)          | NO   |     | 0       |                |\n| frozen_coins | int(10)          | NO   |     | 0       |                |\n| status       | tinyint(4)       | NO   |     | 1       |                |\n| create_time  | int(10)          | NO   |     | 0       |                |\n| update_time  | int(10)          | NO   |     | 0       |                |\n+--------------+------------------+------+-----+---------+----------------+\n10 rows in set (0.00 sec)\n```\n\n\n```mysql\nmysql> explain select * from virtual_coins where uid=2000034000;\n+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+\n| id | select_type | table         | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |\n+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+\n|  1 | SIMPLE      | virtual_coins | NULL       | ref  | idx_uid_type  | idx_uid_type | 4       | const |    1 |   100.00 | NULL  |\n+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n\n\n### 3 字段值详解\n\n#### 3.1 ID列\n\nid列用于标识select所属的行。若在语句中没有子查询或联合查询，那么只会有唯一的select，于是每一行在这个列中将显示一个1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中位置。\n\n示例：\n\n```\nmysql> explain select uid from (select uid from tuanmei_user) as vc;\n```\n\n| id   | select_type | table         | type  | possible_keys | key          | key_len | ref  | rows  |    Extra    |\n| ---- | ----------- | ------------- | ----- | ------------- | ------------ | ------- | ---- | ----- | :---------: |\n| 1    | PRIMARY     |               | ALL   | NULL          | NULL         | NULL    | NULL | 41171 |    NULL     |\n| 2    | DERIVED     | virtual_coins | index | NULL          | idx_uid_type | 66      | NULL | 41171 | Using index |\n\n#### 3.2 SELECT_TYPE列\n\n查询的类型，主要是`区别简单查询和联合查询、子查询之类的复杂查询`。  \n\n常见的取值：\n\n  - `SIMPLE`\n    它表示简单的 select，不包括 union 和子查询；\n    \n  - `PRIMARY`\n    查询有任何复杂的子查询，则最外层部分标记为 primary；\n    \n  - `SUBQUERY`\n    \n    包含在select列表中的子查询中的select（即，不在from子句中）标记为`subquery`。\n    \n    ```mysql\n    mysql> explain select (select uid from virtual_coins where uid = 2000163293);\n    +----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+\n    | id | select_type | table         | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra          |\n    +----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+\n    |  1 | PRIMARY     | NULL          | NULL       | NULL | NULL          | NULL         | NULL    | NULL  | NULL |     NULL | No tables used |\n    |  2 | SUBQUERY    | virtual_coins | NULL       | ref  | idx_uid_type  | idx_uid_type | 4       | const |    1 |   100.00 | Using index    |\n    +----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+\n    2 rows in set, 1 warning (0.14 sec)\n    ```\n    \n  - `DERIVED`\n\n      表示包含在from子句的子查询中的select，MySQL会递归执行并将结果放到一个临时表中。（测试时，只有在数据量大的情况下，才会出现DERIVED，数据量小的时候是SIMPLE??????）\n\n      ```\n      mysql> explain select uid from (select uid from tuanmei_user) as vc;\n      ```\n\n      | id   | select_type | table         | type  | possible_keys | key          | key_len | ref  | rows  |    Extra    |\n      | ---- | ----------- | ------------- | ----- | ------------- | ------------ | ------- | ---- | ----- | :---------: |\n      | 1    | PRIMARY     |               | ALL   | NULL          | NULL         | NULL    | NULL | 41171 |    NULL     |\n      | 2    | DERIVED     | virtual_coins | index | NULL          | idx_uid_type | 66      | NULL | 41171 | Using index |\n\n  - `UNION`\n    union 语句的第二个或者说是后面那一个select被标记为union。\n    \n    ```mysql\n    mysql> explain select * from virtual_coins where id <100 union select * from virtual_coins where id >= 100;\n    +----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   55 |   100.00 | Using where     |\n    |  2 | UNION        | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   52 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2>    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.44 sec)\n    ```\n    \n  - `DEPENDENT`\n\n      表示select依赖于外层查询中的数据。\n\n  - `UNION RESULT`\n\n      用来从UNION的匿名临时表检索结果的select被标记为UNION RESULT。\n\n#### 3.3 TABLE \n\n所使用的表。\n\n#### 3.4 TYPE\n\n关联类型（访问类型），MySQL决定如何查找表中的行，<u>是较为重要的一个指标</u>。\n\n  - `NULL`\n    \n意味着MySQL能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。\n    \n    ```mysql\n    mysql> explain select 1;\n    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |\n    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |\n    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n    1 row in set, 1 warning (0.11 sec)\n    ```\n    \n  - `system`\n    表仅有一行，是 const 类型的特例。不常见。\n\n  - `const`  \n    常量查询，在整个查询过程中这个表`最多只会有一条匹配的行`，`用到了 primary key 或者unique 索引`。  \n  \n  \n  \n  eg：\n```mysql\n  mysql> explain select * from virtual_coins where id=50;\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n  | id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n  1 row in set, 1 warning (0.00 sec)\n```\n\n\n  - `eq_ref` \n    对于每个来自于前面的表的行组合，从该表中读取一行。 （*个人理解是在联合查询时，使用的条件是 UNIQUE 或 PRIMARY KEY。*）\n```mysql\n  mysql> explain select total_coins from virtual_coins, virtual_coins_logs where virtual_coins.id = virtual_coins_logs.id;\n  +----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+\n  | id | select_type | table              | partitions | type   | possible_keys | key     | key_len | ref                            | rows | filtered | Extra                    |\n  +----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+\n  |  1 | SIMPLE      | virtual_coins      | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                           |   41 |   100.00 | NULL                     |\n  |  1 | SIMPLE      | virtual_coins_logs | NULL       | eq_ref | PRIMARY       | PRIMARY | 8       | fans_economic.virtual_coins.id |    1 |   100.00 | Using where; Using index |\n  +----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+\n  2 rows in set, 1 warning (0.00 sec)\n```\n  - `ref` \n    \n  这是一种索引访问，也叫索引查找，它返回所有匹配某个单个值的行。对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。\n  \n  如果联接只使用键的最左边的前缀，或如果键不是 UNIQUE 或 PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用 ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。\n  \n  - `fulltext`  \n\n  - `ref_or_null`\n    该联接类型如同 ref，但是添加了 MySQL 可以专门搜索包含 NULL 值的行。 在解决子查询中经常使用该联接类型的优化。\n\n  - `index_merge`  \n  - `unique_subquery`  \n  - `index_subquery`  \n  - `range`\n    给定范围内的检索，使用一个索引来检查行。通常发生在在索引列上使用范围查询，如 >，<，in 等时，非索引列是 ALL。\n```mysql\n  mysql> explain select * from virtual_coins where id in (10, 100);\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n  | id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using where |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n  1 row in set, 1 warning (0.00 sec)\n\n  mysql> explain select * from virtual_coins where uid in (10, 100);\n  +----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+\n  | id | select_type | table         | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                 |\n  +----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | range | idx_uid_type  | idx_uid_type | 4       | NULL |    2 |   100.00 | Using index condition |\n  +----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+\n  1 row in set, 1 warning (0.00 sec)\n  \n  mysql> explain select * from virtual_coins_0 where total_coins in (0,10);\n  +----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  | id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n  +----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  |  1 | SIMPLE      | virtual_coins_0 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |\n  +----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  1 row in set, 1 warning (0.00 sec)\n```\n\n  - `index` \n    按索引次序扫描，先读索引，再读实际的行，结果也是全表扫描，主要优点是避免了排序。（索引是排好序的，并且 all 是从硬盘中读的，index 可能不在硬盘上）\n```mysql\n  mysql> explain select * from virtual_coins order by id;\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n  | id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | PRIMARY | 4       | NULL |   41 |   100.00 | NULL  |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n  1 row in set, 1 warning (0.00 sec)\n```\n\n  - `ALL` \n    进行完整的表扫描。性能很差，通常可以增加更多的索引而不要使用 ALL，使得行能基于前面的表中的常数值或列值被检索出。\n```mysql\n  mysql> explain select * from virtual_coins where create_time=111;\n  +----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  | id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n  +----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   41 |    10.00 | Using where |\n  +----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  1 row in set, 1 warning (0.00 sec)\n```\n\n**结果值优先顺序**为：  \n    `NULL > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL`\n\n\n\n一般来说，得保证查询至少达到 range 级别，最好能达到 ref。\n\n#### 3.5 POSSIBLE_KEY列\n\n提示使用哪个索引会在该表中找到行，不太重要。\n\n#### 3.6 KEY列\n\n显示了MySQL决定采用哪个索引来优化对该表的访问。若该索引不在possible_keys中，那么MySQL选用它是处于另外的原因，例如，它可能选择了一个覆盖索引，哪怕没有where条件。\n\n如果是 NULL，表示没有索引被选择。\n\n#### 3.7 KEY_LEN\n\n使用的索引字节数。\n\n#### 3.8 REF\n\n显示了之前的表再key列记录的索引中查找值所用的列或常量。\n\n#### 3.9 ROWS \n\n显示执行查询的行数（而不是返回的行数），数值越大越不好，说明没有用好索引。但对 InnoDB 不太准。\n\n#### 3.10 `EXTRA`  \n\n该列包含的是其他的额外信息。其中常见的重要的值如下：\n\n- `Using index` \n此查询使用了`覆盖索引（Covering Index）`，即通过索引就能返回结果，无需访问表。\n```mysql\nmysql> explain select id from virtual_coins;\n+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+\n| id | select_type | table         | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | idx_uid_type | 66      | NULL |   41 |   100.00 | Using index |\n+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n- `Using where`\n表示 MySQL 服务器从存储引擎收到行后再进行`“后过滤”（Post-filter）`。所谓“后过滤”，就是先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。因为检查是在读取行后才进行的，所以称为“后过滤”。查询中含有 WHERE 子句时较常见。\n```mysql\nmysql> explain select * from virtual_coins where create_time=111;\n+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | virtual_coins | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   41 |    10.00 | Using where |\n+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n- `Using filesort` \n\n  表示MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。MySQL有两种文件排序的算法，两种方法都可以在内存或者磁盘上完成。Using filesort并不会对其进行区分。\n\n  \n\n  例如下面，id 是主键，所以它是索引。当 order by id 时，Extra 是 Using Index，而对别的列进行排序，就是 Using filesort，表示在查询之后，又进行了一次排序。\n\n```mysql\n#  Using index（对索引列排序）:\nmysql> explain select id from virtual_coins order by id;\n+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | PRIMARY | 4       | NULL |   41 |   100.00 | Using index |\n+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\n# Using filesort（对非索引列排序）:\nmysql> explain select * from virtual_coins_0 order by total_coins;\n+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |\n+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+\n|  1 | SIMPLE      | virtual_coins_0 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using filesort |\n+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n- `Using temporary` \n`需要创建临时表存储结果以完成查询`。这种情况通常发生在查询时包含了 `Group By` 和 `Order By` 子句时或者`联合查询`时。\n\n```mysql\nmysql> explain select * from virtual_coins_logs group by uid order by id;\n+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+\n| id | select_type | table              | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra                           |\n+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+\n|  1 | SIMPLE      | virtual_coins_logs | NULL       | index | idx_uid_type_action | idx_uid_type_action | 218     | NULL | 2701 |   100.00 | Using temporary; Using filesort |\n+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n- `range checked for each record (index map:N)`\n\n  表示没有好用的索引，新的索引将在联接的每一行上重新估算。N是显示在possible_keys列中索引的位图，并且是冗余的。\n\n---\n### 总结\n\n- explain 的四个重要字段：`type、key、rows、extra`；\n- 如果 type 的值为 index 或者 ALL，那么说明该 SQL 性能一般，需要优化；\n\n- 如果 key 的值为 NULL，说明该 SQL 没有使用索引，可以考虑在关键字段上增加索引；\n\n- row 的值代表了进行本次查询时，搜索记录的条数，当这个值特别大的时候，说明该 SQL 语句性能差；\n\n- 如果 Extra 字段的值为 Using filesort 或 Using temporary，也是需要优化的，可以通过调整 order by 或者 group by 的字段来实现；\n\n- 联合查询时，一定要多用 explain 来查看查询性能\n\n\n\n------\n\n### 参考资料：\n\n高性能MySQL 第三版","source":"_posts/MySQL-Explain详解.md","raw":"---\ntitle: MySQL-Explain详解\ndate: 2020-09-05 11:17:41\ntags: [\"MySQL\"]\ncategories: [\"MySQL\"]\n---\n\n\n\n### 1 简介\n\n`EXPLAIN`命令是`查看查询优化器如何决定执行查询的主要方法`。虽然这个功能有一些局限性，但是它的输出是可以获取的最好信息。在使用EXPLAIN时，MySQL会在查询上设置一个标记，当执行查询时，这个标记会使其返回关于执行计划中每一步的信息，而不是执行它。它会返回一行或多行信息，显示出执行计划中的每一部分和执行次序。\n\n<!--more-->\n\n注意：EXPLAIN只是个近似结果，有时候它是一个很好的近似，但有时候也会相差甚远。\n\n\n\n以下是使用EXPLIAN的一些相关限制：\n\n- 不会告诉你触发器、存储过程或UDF会如何影响查询；\n- 不支持存储过程，尽管可以手动抽取查询并单独的对其进行EXPLAIN操作；\n- 不会告诉你MySQL在查询执行中所作的特定优化；\n- 不会显示关于查询的执行计划的所有信息；\n- 不区分具有相同名字的事物。例如：对于内存排序和临时文件都使用“filesort”，并且对于磁盘上和内存中的临时表都显示“Using temporary”；\n- 可能会出现误导。例如，`对于一个有着很小的limit查询显示全索引扫描`。\n\n\n\n### 1.1 重写非SELECT查询\n\nEXPLAIN只能解释SELECT查询，并不会对存储程序调用、INSERT、UPDATE、DELETE或其他语句做解释。\n\n解决方法：重写非SELECT查询以利用EXPLAIN，\n\n\n\n### 2 用法\n\n```\nEXPLAIN tbl_name # 得出一个表的字段结构。\nEXPLAIN [EXTENDED] SELECT select_options # 给出当前SQL语句相关的一些信息。 \n```\n\n以`virtual_coins表`为例，后续测试均在此表基础上进行验证。\n\n```mysql\nCREATE TABLE `virtual_coins` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',\n  `uid` int(10) NOT NULL DEFAULT '0' COMMENT '用户ID',\n  `type` varchar(20) NOT NULL DEFAULT '' COMMENT '虚拟货币类型',\n  `channel` varchar(20) NOT NULL DEFAULT '' COMMENT '渠道',\n  `total_coins` int(10) NOT NULL DEFAULT '0' COMMENT '当前虚拟货币类型总数',\n  `usable_coins` int(10) NOT NULL DEFAULT '0' COMMENT '当前虚拟货币类型可用数量',\n  `frozen_coins` int(10) NOT NULL DEFAULT '0' COMMENT '当前虚拟货币类型冻结数量',\n  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：1-有效，0-无效（封禁）',\n  `create_time` int(10) NOT NULL DEFAULT '0' COMMENT '创建时间',\n  `update_time` int(10) NOT NULL DEFAULT '0' COMMENT '更新时间',\n  PRIMARY KEY (`id`),\n  KEY `idx_uid_type` (`uid`,`type`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='虚拟货币快照表'\n```\n\n```mysql\nmysql> explain virtual_coins;\n+--------------+------------------+------+-----+---------+----------------+\n| Field        | Type             | Null | Key | Default | Extra          |\n+--------------+------------------+------+-----+---------+----------------+\n| id           | int(11) unsigned | NO   | PRI | NULL    | auto_increment |\n| uid          | int(10)          | NO   | MUL | 0       |                |\n| type         | varchar(20)      | NO   |     |         |                |\n| channel      | varchar(20)      | NO   |     |         |                |\n| total_coins  | int(10)          | NO   |     | 0       |                |\n| usable_coins | int(10)          | NO   |     | 0       |                |\n| frozen_coins | int(10)          | NO   |     | 0       |                |\n| status       | tinyint(4)       | NO   |     | 1       |                |\n| create_time  | int(10)          | NO   |     | 0       |                |\n| update_time  | int(10)          | NO   |     | 0       |                |\n+--------------+------------------+------+-----+---------+----------------+\n10 rows in set (0.00 sec)\n```\n\n\n```mysql\nmysql> explain select * from virtual_coins where uid=2000034000;\n+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+\n| id | select_type | table         | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |\n+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+\n|  1 | SIMPLE      | virtual_coins | NULL       | ref  | idx_uid_type  | idx_uid_type | 4       | const |    1 |   100.00 | NULL  |\n+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n\n\n### 3 字段值详解\n\n#### 3.1 ID列\n\nid列用于标识select所属的行。若在语句中没有子查询或联合查询，那么只会有唯一的select，于是每一行在这个列中将显示一个1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中位置。\n\n示例：\n\n```\nmysql> explain select uid from (select uid from tuanmei_user) as vc;\n```\n\n| id   | select_type | table         | type  | possible_keys | key          | key_len | ref  | rows  |    Extra    |\n| ---- | ----------- | ------------- | ----- | ------------- | ------------ | ------- | ---- | ----- | :---------: |\n| 1    | PRIMARY     |               | ALL   | NULL          | NULL         | NULL    | NULL | 41171 |    NULL     |\n| 2    | DERIVED     | virtual_coins | index | NULL          | idx_uid_type | 66      | NULL | 41171 | Using index |\n\n#### 3.2 SELECT_TYPE列\n\n查询的类型，主要是`区别简单查询和联合查询、子查询之类的复杂查询`。  \n\n常见的取值：\n\n  - `SIMPLE`\n    它表示简单的 select，不包括 union 和子查询；\n    \n  - `PRIMARY`\n    查询有任何复杂的子查询，则最外层部分标记为 primary；\n    \n  - `SUBQUERY`\n    \n    包含在select列表中的子查询中的select（即，不在from子句中）标记为`subquery`。\n    \n    ```mysql\n    mysql> explain select (select uid from virtual_coins where uid = 2000163293);\n    +----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+\n    | id | select_type | table         | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra          |\n    +----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+\n    |  1 | PRIMARY     | NULL          | NULL       | NULL | NULL          | NULL         | NULL    | NULL  | NULL |     NULL | No tables used |\n    |  2 | SUBQUERY    | virtual_coins | NULL       | ref  | idx_uid_type  | idx_uid_type | 4       | const |    1 |   100.00 | Using index    |\n    +----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+\n    2 rows in set, 1 warning (0.14 sec)\n    ```\n    \n  - `DERIVED`\n\n      表示包含在from子句的子查询中的select，MySQL会递归执行并将结果放到一个临时表中。（测试时，只有在数据量大的情况下，才会出现DERIVED，数据量小的时候是SIMPLE??????）\n\n      ```\n      mysql> explain select uid from (select uid from tuanmei_user) as vc;\n      ```\n\n      | id   | select_type | table         | type  | possible_keys | key          | key_len | ref  | rows  |    Extra    |\n      | ---- | ----------- | ------------- | ----- | ------------- | ------------ | ------- | ---- | ----- | :---------: |\n      | 1    | PRIMARY     |               | ALL   | NULL          | NULL         | NULL    | NULL | 41171 |    NULL     |\n      | 2    | DERIVED     | virtual_coins | index | NULL          | idx_uid_type | 66      | NULL | 41171 | Using index |\n\n  - `UNION`\n    union 语句的第二个或者说是后面那一个select被标记为union。\n    \n    ```mysql\n    mysql> explain select * from virtual_coins where id <100 union select * from virtual_coins where id >= 100;\n    +----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   55 |   100.00 | Using where     |\n    |  2 | UNION        | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   52 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2>    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.44 sec)\n    ```\n    \n  - `DEPENDENT`\n\n      表示select依赖于外层查询中的数据。\n\n  - `UNION RESULT`\n\n      用来从UNION的匿名临时表检索结果的select被标记为UNION RESULT。\n\n#### 3.3 TABLE \n\n所使用的表。\n\n#### 3.4 TYPE\n\n关联类型（访问类型），MySQL决定如何查找表中的行，<u>是较为重要的一个指标</u>。\n\n  - `NULL`\n    \n意味着MySQL能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。\n    \n    ```mysql\n    mysql> explain select 1;\n    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |\n    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n    |  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |\n    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n    1 row in set, 1 warning (0.11 sec)\n    ```\n    \n  - `system`\n    表仅有一行，是 const 类型的特例。不常见。\n\n  - `const`  \n    常量查询，在整个查询过程中这个表`最多只会有一条匹配的行`，`用到了 primary key 或者unique 索引`。  \n  \n  \n  \n  eg：\n```mysql\n  mysql> explain select * from virtual_coins where id=50;\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n  | id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n  1 row in set, 1 warning (0.00 sec)\n```\n\n\n  - `eq_ref` \n    对于每个来自于前面的表的行组合，从该表中读取一行。 （*个人理解是在联合查询时，使用的条件是 UNIQUE 或 PRIMARY KEY。*）\n```mysql\n  mysql> explain select total_coins from virtual_coins, virtual_coins_logs where virtual_coins.id = virtual_coins_logs.id;\n  +----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+\n  | id | select_type | table              | partitions | type   | possible_keys | key     | key_len | ref                            | rows | filtered | Extra                    |\n  +----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+\n  |  1 | SIMPLE      | virtual_coins      | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                           |   41 |   100.00 | NULL                     |\n  |  1 | SIMPLE      | virtual_coins_logs | NULL       | eq_ref | PRIMARY       | PRIMARY | 8       | fans_economic.virtual_coins.id |    1 |   100.00 | Using where; Using index |\n  +----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+\n  2 rows in set, 1 warning (0.00 sec)\n```\n  - `ref` \n    \n  这是一种索引访问，也叫索引查找，它返回所有匹配某个单个值的行。对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。\n  \n  如果联接只使用键的最左边的前缀，或如果键不是 UNIQUE 或 PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用 ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。\n  \n  - `fulltext`  \n\n  - `ref_or_null`\n    该联接类型如同 ref，但是添加了 MySQL 可以专门搜索包含 NULL 值的行。 在解决子查询中经常使用该联接类型的优化。\n\n  - `index_merge`  \n  - `unique_subquery`  \n  - `index_subquery`  \n  - `range`\n    给定范围内的检索，使用一个索引来检查行。通常发生在在索引列上使用范围查询，如 >，<，in 等时，非索引列是 ALL。\n```mysql\n  mysql> explain select * from virtual_coins where id in (10, 100);\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n  | id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using where |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n  1 row in set, 1 warning (0.00 sec)\n\n  mysql> explain select * from virtual_coins where uid in (10, 100);\n  +----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+\n  | id | select_type | table         | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                 |\n  +----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | range | idx_uid_type  | idx_uid_type | 4       | NULL |    2 |   100.00 | Using index condition |\n  +----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+\n  1 row in set, 1 warning (0.00 sec)\n  \n  mysql> explain select * from virtual_coins_0 where total_coins in (0,10);\n  +----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  | id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n  +----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  |  1 | SIMPLE      | virtual_coins_0 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |\n  +----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  1 row in set, 1 warning (0.00 sec)\n```\n\n  - `index` \n    按索引次序扫描，先读索引，再读实际的行，结果也是全表扫描，主要优点是避免了排序。（索引是排好序的，并且 all 是从硬盘中读的，index 可能不在硬盘上）\n```mysql\n  mysql> explain select * from virtual_coins order by id;\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n  | id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | PRIMARY | 4       | NULL |   41 |   100.00 | NULL  |\n  +----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+\n  1 row in set, 1 warning (0.00 sec)\n```\n\n  - `ALL` \n    进行完整的表扫描。性能很差，通常可以增加更多的索引而不要使用 ALL，使得行能基于前面的表中的常数值或列值被检索出。\n```mysql\n  mysql> explain select * from virtual_coins where create_time=111;\n  +----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  | id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n  +----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  |  1 | SIMPLE      | virtual_coins | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   41 |    10.00 | Using where |\n  +----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n  1 row in set, 1 warning (0.00 sec)\n```\n\n**结果值优先顺序**为：  \n    `NULL > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL`\n\n\n\n一般来说，得保证查询至少达到 range 级别，最好能达到 ref。\n\n#### 3.5 POSSIBLE_KEY列\n\n提示使用哪个索引会在该表中找到行，不太重要。\n\n#### 3.6 KEY列\n\n显示了MySQL决定采用哪个索引来优化对该表的访问。若该索引不在possible_keys中，那么MySQL选用它是处于另外的原因，例如，它可能选择了一个覆盖索引，哪怕没有where条件。\n\n如果是 NULL，表示没有索引被选择。\n\n#### 3.7 KEY_LEN\n\n使用的索引字节数。\n\n#### 3.8 REF\n\n显示了之前的表再key列记录的索引中查找值所用的列或常量。\n\n#### 3.9 ROWS \n\n显示执行查询的行数（而不是返回的行数），数值越大越不好，说明没有用好索引。但对 InnoDB 不太准。\n\n#### 3.10 `EXTRA`  \n\n该列包含的是其他的额外信息。其中常见的重要的值如下：\n\n- `Using index` \n此查询使用了`覆盖索引（Covering Index）`，即通过索引就能返回结果，无需访问表。\n```mysql\nmysql> explain select id from virtual_coins;\n+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+\n| id | select_type | table         | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | idx_uid_type | 66      | NULL |   41 |   100.00 | Using index |\n+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n- `Using where`\n表示 MySQL 服务器从存储引擎收到行后再进行`“后过滤”（Post-filter）`。所谓“后过滤”，就是先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。因为检查是在读取行后才进行的，所以称为“后过滤”。查询中含有 WHERE 子句时较常见。\n```mysql\nmysql> explain select * from virtual_coins where create_time=111;\n+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | virtual_coins | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   41 |    10.00 | Using where |\n+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n- `Using filesort` \n\n  表示MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。MySQL有两种文件排序的算法，两种方法都可以在内存或者磁盘上完成。Using filesort并不会对其进行区分。\n\n  \n\n  例如下面，id 是主键，所以它是索引。当 order by id 时，Extra 是 Using Index，而对别的列进行排序，就是 Using filesort，表示在查询之后，又进行了一次排序。\n\n```mysql\n#  Using index（对索引列排序）:\nmysql> explain select id from virtual_coins order by id;\n+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | PRIMARY | 4       | NULL |   41 |   100.00 | Using index |\n+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\n# Using filesort（对非索引列排序）:\nmysql> explain select * from virtual_coins_0 order by total_coins;\n+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+\n| id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |\n+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+\n|  1 | SIMPLE      | virtual_coins_0 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using filesort |\n+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n- `Using temporary` \n`需要创建临时表存储结果以完成查询`。这种情况通常发生在查询时包含了 `Group By` 和 `Order By` 子句时或者`联合查询`时。\n\n```mysql\nmysql> explain select * from virtual_coins_logs group by uid order by id;\n+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+\n| id | select_type | table              | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra                           |\n+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+\n|  1 | SIMPLE      | virtual_coins_logs | NULL       | index | idx_uid_type_action | idx_uid_type_action | 218     | NULL | 2701 |   100.00 | Using temporary; Using filesort |\n+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n- `range checked for each record (index map:N)`\n\n  表示没有好用的索引，新的索引将在联接的每一行上重新估算。N是显示在possible_keys列中索引的位图，并且是冗余的。\n\n---\n### 总结\n\n- explain 的四个重要字段：`type、key、rows、extra`；\n- 如果 type 的值为 index 或者 ALL，那么说明该 SQL 性能一般，需要优化；\n\n- 如果 key 的值为 NULL，说明该 SQL 没有使用索引，可以考虑在关键字段上增加索引；\n\n- row 的值代表了进行本次查询时，搜索记录的条数，当这个值特别大的时候，说明该 SQL 语句性能差；\n\n- 如果 Extra 字段的值为 Using filesort 或 Using temporary，也是需要优化的，可以通过调整 order by 或者 group by 的字段来实现；\n\n- 联合查询时，一定要多用 explain 来查看查询性能\n\n\n\n------\n\n### 参考资料：\n\n高性能MySQL 第三版","slug":"MySQL-Explain详解","published":1,"updated":"2020-09-07T02:17:33.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabmv005u45g369w2euj9","content":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h3><p><code>EXPLAIN</code>命令是<code>查看查询优化器如何决定执行查询的主要方法</code>。虽然这个功能有一些局限性，但是它的输出是可以获取的最好信息。在使用EXPLAIN时，MySQL会在查询上设置一个标记，当执行查询时，这个标记会使其返回关于执行计划中每一步的信息，而不是执行它。它会返回一行或多行信息，显示出执行计划中的每一部分和执行次序。</p>\n<a id=\"more\"></a>\n\n<p>注意：EXPLAIN只是个近似结果，有时候它是一个很好的近似，但有时候也会相差甚远。</p>\n<p>以下是使用EXPLIAN的一些相关限制：</p>\n<ul>\n<li>不会告诉你触发器、存储过程或UDF会如何影响查询；</li>\n<li>不支持存储过程，尽管可以手动抽取查询并单独的对其进行EXPLAIN操作；</li>\n<li>不会告诉你MySQL在查询执行中所作的特定优化；</li>\n<li>不会显示关于查询的执行计划的所有信息；</li>\n<li>不区分具有相同名字的事物。例如：对于内存排序和临时文件都使用“filesort”，并且对于磁盘上和内存中的临时表都显示“Using temporary”；</li>\n<li>可能会出现误导。例如，<code>对于一个有着很小的limit查询显示全索引扫描</code>。</li>\n</ul>\n<h3 id=\"1-1-重写非SELECT查询\"><a href=\"#1-1-重写非SELECT查询\" class=\"headerlink\" title=\"1.1 重写非SELECT查询\"></a>1.1 重写非SELECT查询</h3><p>EXPLAIN只能解释SELECT查询，并不会对存储程序调用、INSERT、UPDATE、DELETE或其他语句做解释。</p>\n<p>解决方法：重写非SELECT查询以利用EXPLAIN，</p>\n<h3 id=\"2-用法\"><a href=\"#2-用法\" class=\"headerlink\" title=\"2 用法\"></a>2 用法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN tbl_name # 得出一个表的字段结构。</span><br><span class=\"line\">EXPLAIN [EXTENDED] SELECT select_options # 给出当前SQL语句相关的一些信息。 </span><br></pre></td></tr></table></figure>\n\n<p>以<code>virtual_coins表</code>为例，后续测试均在此表基础上进行验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE &#96;virtual_coins&#96; (</span><br><span class=\"line\">  &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,</span><br><span class=\"line\">  &#96;uid&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;用户ID&#39;,</span><br><span class=\"line\">  &#96;type&#96; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;虚拟货币类型&#39;,</span><br><span class=\"line\">  &#96;channel&#96; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;渠道&#39;,</span><br><span class=\"line\">  &#96;total_coins&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;当前虚拟货币类型总数&#39;,</span><br><span class=\"line\">  &#96;usable_coins&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;当前虚拟货币类型可用数量&#39;,</span><br><span class=\"line\">  &#96;frozen_coins&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;当前虚拟货币类型冻结数量&#39;,</span><br><span class=\"line\">  &#96;status&#96; tinyint(4) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;状态：1-有效，0-无效（封禁）&#39;,</span><br><span class=\"line\">  &#96;create_time&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;创建时间&#39;,</span><br><span class=\"line\">  &#96;update_time&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;更新时间&#39;,</span><br><span class=\"line\">  PRIMARY KEY (&#96;id&#96;),</span><br><span class=\"line\">  KEY &#96;idx_uid_type&#96; (&#96;uid&#96;,&#96;type&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;虚拟货币快照表&#39;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain virtual_coins;</span><br><span class=\"line\">+--------------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">| Field        | Type             | Null | Key | Default | Extra          |</span><br><span class=\"line\">+--------------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">| id           | int(11) unsigned | NO   | PRI | NULL    | auto_increment |</span><br><span class=\"line\">| uid          | int(10)          | NO   | MUL | 0       |                |</span><br><span class=\"line\">| type         | varchar(20)      | NO   |     |         |                |</span><br><span class=\"line\">| channel      | varchar(20)      | NO   |     |         |                |</span><br><span class=\"line\">| total_coins  | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">| usable_coins | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">| frozen_coins | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">| status       | tinyint(4)       | NO   |     | 1       |                |</span><br><span class=\"line\">| create_time  | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">| update_time  | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">+--------------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where uid&#x3D;2000034000;</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | ref  | idx_uid_type  | idx_uid_type | 4       | const |    1 |   100.00 | NULL  |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-字段值详解\"><a href=\"#3-字段值详解\" class=\"headerlink\" title=\"3 字段值详解\"></a>3 字段值详解</h3><h4 id=\"3-1-ID列\"><a href=\"#3-1-ID列\" class=\"headerlink\" title=\"3.1 ID列\"></a>3.1 ID列</h4><p>id列用于标识select所属的行。若在语句中没有子查询或联合查询，那么只会有唯一的select，于是每一行在这个列中将显示一个1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中位置。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select uid from (select uid from tuanmei_user) as vc;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n<th>rows</th>\n<th align=\"center\">Extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>PRIMARY</td>\n<td></td>\n<td>ALL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>41171</td>\n<td align=\"center\">NULL</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DERIVED</td>\n<td>virtual_coins</td>\n<td>index</td>\n<td>NULL</td>\n<td>idx_uid_type</td>\n<td>66</td>\n<td>NULL</td>\n<td>41171</td>\n<td align=\"center\">Using index</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-2-SELECT-TYPE列\"><a href=\"#3-2-SELECT-TYPE列\" class=\"headerlink\" title=\"3.2 SELECT_TYPE列\"></a>3.2 SELECT_TYPE列</h4><p>查询的类型，主要是<code>区别简单查询和联合查询、子查询之类的复杂查询</code>。  </p>\n<p>常见的取值：</p>\n<ul>\n<li><p><code>SIMPLE</code><br>它表示简单的 select，不包括 union 和子查询；</p>\n</li>\n<li><p><code>PRIMARY</code><br>查询有任何复杂的子查询，则最外层部分标记为 primary；</p>\n</li>\n<li><p><code>SUBQUERY</code></p>\n<p>包含在select列表中的子查询中的select（即，不在from子句中）标记为<code>subquery</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select (select uid from virtual_coins where uid &#x3D; 2000163293);</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra          |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+</span><br><span class=\"line\">|  1 | PRIMARY     | NULL          | NULL       | NULL | NULL          | NULL         | NULL    | NULL  | NULL |     NULL | No tables used |</span><br><span class=\"line\">|  2 | SUBQUERY    | virtual_coins | NULL       | ref  | idx_uid_type  | idx_uid_type | 4       | const |    1 |   100.00 | Using index    |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+</span><br><span class=\"line\">2 rows in set, 1 warning (0.14 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>DERIVED</code></p>\n<p>  表示包含在from子句的子查询中的select，MySQL会递归执行并将结果放到一个临时表中。（测试时，只有在数据量大的情况下，才会出现DERIVED，数据量小的时候是SIMPLE??????）</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select uid from (select uid from tuanmei_user) as vc;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n<th>rows</th>\n<th align=\"center\">Extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>PRIMARY</td>\n<td></td>\n<td>ALL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>41171</td>\n<td align=\"center\">NULL</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DERIVED</td>\n<td>virtual_coins</td>\n<td>index</td>\n<td>NULL</td>\n<td>idx_uid_type</td>\n<td>66</td>\n<td>NULL</td>\n<td>41171</td>\n<td align=\"center\">Using index</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><code>UNION</code><br>union 语句的第二个或者说是后面那一个select被标记为union。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where id &lt;100 union select * from virtual_coins where id &gt;&#x3D; 100;</span><br><span class=\"line\">+----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class=\"line\">| id | select_type  | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |</span><br><span class=\"line\">+----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class=\"line\">|  1 | PRIMARY      | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   55 |   100.00 | Using where     |</span><br><span class=\"line\">|  2 | UNION        | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   52 |   100.00 | Using where     |</span><br><span class=\"line\">| NULL | UNION RESULT | &lt;union1,2&gt;    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class=\"line\">+----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class=\"line\">3 rows in set, 1 warning (0.44 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>DEPENDENT</code></p>\n<p>  表示select依赖于外层查询中的数据。</p>\n</li>\n<li><p><code>UNION RESULT</code></p>\n<p>  用来从UNION的匿名临时表检索结果的select被标记为UNION RESULT。</p>\n</li>\n</ul>\n<h4 id=\"3-3-TABLE\"><a href=\"#3-3-TABLE\" class=\"headerlink\" title=\"3.3 TABLE\"></a>3.3 TABLE</h4><p>所使用的表。</p>\n<h4 id=\"3-4-TYPE\"><a href=\"#3-4-TYPE\" class=\"headerlink\" title=\"3.4 TYPE\"></a>3.4 TYPE</h4><p>关联类型（访问类型），MySQL决定如何查找表中的行，<u>是较为重要的一个指标</u>。</p>\n<ul>\n<li><code>NULL</code></li>\n</ul>\n<p>意味着MySQL能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select 1;</span><br><span class=\"line\">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class=\"line\">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class=\"line\">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.11 sec)</span><br></pre></td></tr></table></figure></code></pre>\n<ul>\n<li><p><code>system</code><br>表仅有一行，是 const 类型的特例。不常见。</p>\n</li>\n<li><p><code>const</code><br>常量查询，在整个查询过程中这个表<code>最多只会有一条匹配的行</code>，<code>用到了 primary key 或者unique 索引</code>。  </p>\n</li>\n</ul>\n<p>  eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where id&#x3D;50;</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><p><code>eq_ref</code><br>对于每个来自于前面的表的行组合，从该表中读取一行。 （<em>个人理解是在联合查询时，使用的条件是 UNIQUE 或 PRIMARY KEY。</em>）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select total_coins from virtual_coins, virtual_coins_logs where virtual_coins.id &#x3D; virtual_coins_logs.id;</span><br><span class=\"line\">+----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+</span><br><span class=\"line\">| id | select_type | table              | partitions | type   | possible_keys | key     | key_len | ref                            | rows | filtered | Extra                    |</span><br><span class=\"line\">+----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins      | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                           |   41 |   100.00 | NULL                     |</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins_logs | NULL       | eq_ref | PRIMARY       | PRIMARY | 8       | fans_economic.virtual_coins.id |    1 |   100.00 | Using where; Using index |</span><br><span class=\"line\">+----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+</span><br><span class=\"line\">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>ref</code> </p>\n<p>这是一种索引访问，也叫索引查找，它返回所有匹配某个单个值的行。对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。</p>\n<p>如果联接只使用键的最左边的前缀，或如果键不是 UNIQUE 或 PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用 ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。</p>\n</li>\n<li><p><code>fulltext</code>  </p>\n</li>\n<li><p><code>ref_or_null</code><br>该联接类型如同 ref，但是添加了 MySQL 可以专门搜索包含 NULL 值的行。 在解决子查询中经常使用该联接类型的优化。</p>\n</li>\n<li><p><code>index_merge</code>  </p>\n</li>\n<li><p><code>unique_subquery</code>  </p>\n</li>\n<li><p><code>index_subquery</code>  </p>\n</li>\n<li><p><code>range</code><br>给定范围内的检索，使用一个索引来检查行。通常发生在在索引列上使用范围查询，如 &gt;，&lt;，in 等时，非索引列是 ALL。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where id in (10, 100);</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using where |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select * from virtual_coins where uid in (10, 100);</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                 |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | range | idx_uid_type  | idx_uid_type | 4       | NULL |    2 |   100.00 | Using index condition |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select * from virtual_coins_0 where total_coins in (0,10);</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins_0 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>index</code><br>按索引次序扫描，先读索引，再读实际的行，结果也是全表扫描，主要优点是避免了排序。（索引是排好序的，并且 all 是从硬盘中读的，index 可能不在硬盘上）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins order by id;</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | PRIMARY | 4       | NULL |   41 |   100.00 | NULL  |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>ALL</code><br>进行完整的表扫描。性能很差，通常可以增加更多的索引而不要使用 ALL，使得行能基于前面的表中的常数值或列值被检索出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where create_time&#x3D;111;</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   41 |    10.00 | Using where |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>结果值优先顺序</strong>为：<br>    <code>NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code></p>\n<p>一般来说，得保证查询至少达到 range 级别，最好能达到 ref。</p>\n<h4 id=\"3-5-POSSIBLE-KEY列\"><a href=\"#3-5-POSSIBLE-KEY列\" class=\"headerlink\" title=\"3.5 POSSIBLE_KEY列\"></a>3.5 POSSIBLE_KEY列</h4><p>提示使用哪个索引会在该表中找到行，不太重要。</p>\n<h4 id=\"3-6-KEY列\"><a href=\"#3-6-KEY列\" class=\"headerlink\" title=\"3.6 KEY列\"></a>3.6 KEY列</h4><p>显示了MySQL决定采用哪个索引来优化对该表的访问。若该索引不在possible_keys中，那么MySQL选用它是处于另外的原因，例如，它可能选择了一个覆盖索引，哪怕没有where条件。</p>\n<p>如果是 NULL，表示没有索引被选择。</p>\n<h4 id=\"3-7-KEY-LEN\"><a href=\"#3-7-KEY-LEN\" class=\"headerlink\" title=\"3.7 KEY_LEN\"></a>3.7 KEY_LEN</h4><p>使用的索引字节数。</p>\n<h4 id=\"3-8-REF\"><a href=\"#3-8-REF\" class=\"headerlink\" title=\"3.8 REF\"></a>3.8 REF</h4><p>显示了之前的表再key列记录的索引中查找值所用的列或常量。</p>\n<h4 id=\"3-9-ROWS\"><a href=\"#3-9-ROWS\" class=\"headerlink\" title=\"3.9 ROWS\"></a>3.9 ROWS</h4><p>显示执行查询的行数（而不是返回的行数），数值越大越不好，说明没有用好索引。但对 InnoDB 不太准。</p>\n<h4 id=\"3-10-EXTRA\"><a href=\"#3-10-EXTRA\" class=\"headerlink\" title=\"3.10 EXTRA\"></a>3.10 <code>EXTRA</code></h4><p>该列包含的是其他的额外信息。其中常见的重要的值如下：</p>\n<ul>\n<li><p><code>Using index</code><br>此查询使用了<code>覆盖索引（Covering Index）</code>，即通过索引就能返回结果，无需访问表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select id from virtual_coins;</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | idx_uid_type | 66      | NULL |   41 |   100.00 | Using index |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Using where</code><br>表示 MySQL 服务器从存储引擎收到行后再进行<code>“后过滤”（Post-filter）</code>。所谓“后过滤”，就是先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。因为检查是在读取行后才进行的，所以称为“后过滤”。查询中含有 WHERE 子句时较常见。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where create_time&#x3D;111;</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   41 |    10.00 | Using where |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Using filesort</code> </p>\n<p>表示MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。MySQL有两种文件排序的算法，两种方法都可以在内存或者磁盘上完成。Using filesort并不会对其进行区分。</p>\n</li>\n</ul>\n<p>  例如下面，id 是主键，所以它是索引。当 order by id 时，Extra 是 Using Index，而对别的列进行排序，就是 Using filesort，表示在查询之后，又进行了一次排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  Using index（对索引列排序）:</span><br><span class=\"line\">mysql&gt; explain select id from virtual_coins order by id;</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | PRIMARY | 4       | NULL |   41 |   100.00 | Using index |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"># Using filesort（对非索引列排序）:</span><br><span class=\"line\">mysql&gt; explain select * from virtual_coins_0 order by total_coins;</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">| id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins_0 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using filesort |</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Using temporary</code><br><code>需要创建临时表存储结果以完成查询</code>。这种情况通常发生在查询时包含了 <code>Group By</code> 和 <code>Order By</code> 子句时或者<code>联合查询</code>时。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins_logs group by uid order by id;</span><br><span class=\"line\">+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+</span><br><span class=\"line\">| id | select_type | table              | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra                           |</span><br><span class=\"line\">+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins_logs | NULL       | index | idx_uid_type_action | idx_uid_type_action | 218     | NULL | 2701 |   100.00 | Using temporary; Using filesort |</span><br><span class=\"line\">+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>range checked for each record (index map:N)</code></p>\n<p>表示没有好用的索引，新的索引将在联接的每一行上重新估算。N是显示在possible_keys列中索引的位图，并且是冗余的。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>explain 的四个重要字段：<code>type、key、rows、extra</code>；</p>\n</li>\n<li><p>如果 type 的值为 index 或者 ALL，那么说明该 SQL 性能一般，需要优化；</p>\n</li>\n<li><p>如果 key 的值为 NULL，说明该 SQL 没有使用索引，可以考虑在关键字段上增加索引；</p>\n</li>\n<li><p>row 的值代表了进行本次查询时，搜索记录的条数，当这个值特别大的时候，说明该 SQL 语句性能差；</p>\n</li>\n<li><p>如果 Extra 字段的值为 Using filesort 或 Using temporary，也是需要优化的，可以通过调整 order by 或者 group by 的字段来实现；</p>\n</li>\n<li><p>联合查询时，一定要多用 explain 来查看查询性能</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>高性能MySQL 第三版</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h3><p><code>EXPLAIN</code>命令是<code>查看查询优化器如何决定执行查询的主要方法</code>。虽然这个功能有一些局限性，但是它的输出是可以获取的最好信息。在使用EXPLAIN时，MySQL会在查询上设置一个标记，当执行查询时，这个标记会使其返回关于执行计划中每一步的信息，而不是执行它。它会返回一行或多行信息，显示出执行计划中的每一部分和执行次序。</p>","more":"<p>注意：EXPLAIN只是个近似结果，有时候它是一个很好的近似，但有时候也会相差甚远。</p>\n<p>以下是使用EXPLIAN的一些相关限制：</p>\n<ul>\n<li>不会告诉你触发器、存储过程或UDF会如何影响查询；</li>\n<li>不支持存储过程，尽管可以手动抽取查询并单独的对其进行EXPLAIN操作；</li>\n<li>不会告诉你MySQL在查询执行中所作的特定优化；</li>\n<li>不会显示关于查询的执行计划的所有信息；</li>\n<li>不区分具有相同名字的事物。例如：对于内存排序和临时文件都使用“filesort”，并且对于磁盘上和内存中的临时表都显示“Using temporary”；</li>\n<li>可能会出现误导。例如，<code>对于一个有着很小的limit查询显示全索引扫描</code>。</li>\n</ul>\n<h3 id=\"1-1-重写非SELECT查询\"><a href=\"#1-1-重写非SELECT查询\" class=\"headerlink\" title=\"1.1 重写非SELECT查询\"></a>1.1 重写非SELECT查询</h3><p>EXPLAIN只能解释SELECT查询，并不会对存储程序调用、INSERT、UPDATE、DELETE或其他语句做解释。</p>\n<p>解决方法：重写非SELECT查询以利用EXPLAIN，</p>\n<h3 id=\"2-用法\"><a href=\"#2-用法\" class=\"headerlink\" title=\"2 用法\"></a>2 用法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN tbl_name # 得出一个表的字段结构。</span><br><span class=\"line\">EXPLAIN [EXTENDED] SELECT select_options # 给出当前SQL语句相关的一些信息。 </span><br></pre></td></tr></table></figure>\n\n<p>以<code>virtual_coins表</code>为例，后续测试均在此表基础上进行验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE &#96;virtual_coins&#96; (</span><br><span class=\"line\">  &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,</span><br><span class=\"line\">  &#96;uid&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;用户ID&#39;,</span><br><span class=\"line\">  &#96;type&#96; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;虚拟货币类型&#39;,</span><br><span class=\"line\">  &#96;channel&#96; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;渠道&#39;,</span><br><span class=\"line\">  &#96;total_coins&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;当前虚拟货币类型总数&#39;,</span><br><span class=\"line\">  &#96;usable_coins&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;当前虚拟货币类型可用数量&#39;,</span><br><span class=\"line\">  &#96;frozen_coins&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;当前虚拟货币类型冻结数量&#39;,</span><br><span class=\"line\">  &#96;status&#96; tinyint(4) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;状态：1-有效，0-无效（封禁）&#39;,</span><br><span class=\"line\">  &#96;create_time&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;创建时间&#39;,</span><br><span class=\"line\">  &#96;update_time&#96; int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;更新时间&#39;,</span><br><span class=\"line\">  PRIMARY KEY (&#96;id&#96;),</span><br><span class=\"line\">  KEY &#96;idx_uid_type&#96; (&#96;uid&#96;,&#96;type&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;虚拟货币快照表&#39;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain virtual_coins;</span><br><span class=\"line\">+--------------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">| Field        | Type             | Null | Key | Default | Extra          |</span><br><span class=\"line\">+--------------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">| id           | int(11) unsigned | NO   | PRI | NULL    | auto_increment |</span><br><span class=\"line\">| uid          | int(10)          | NO   | MUL | 0       |                |</span><br><span class=\"line\">| type         | varchar(20)      | NO   |     |         |                |</span><br><span class=\"line\">| channel      | varchar(20)      | NO   |     |         |                |</span><br><span class=\"line\">| total_coins  | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">| usable_coins | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">| frozen_coins | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">| status       | tinyint(4)       | NO   |     | 1       |                |</span><br><span class=\"line\">| create_time  | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">| update_time  | int(10)          | NO   |     | 0       |                |</span><br><span class=\"line\">+--------------+------------------+------+-----+---------+----------------+</span><br><span class=\"line\">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where uid&#x3D;2000034000;</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | ref  | idx_uid_type  | idx_uid_type | 4       | const |    1 |   100.00 | NULL  |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-字段值详解\"><a href=\"#3-字段值详解\" class=\"headerlink\" title=\"3 字段值详解\"></a>3 字段值详解</h3><h4 id=\"3-1-ID列\"><a href=\"#3-1-ID列\" class=\"headerlink\" title=\"3.1 ID列\"></a>3.1 ID列</h4><p>id列用于标识select所属的行。若在语句中没有子查询或联合查询，那么只会有唯一的select，于是每一行在这个列中将显示一个1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中位置。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select uid from (select uid from tuanmei_user) as vc;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n<th>rows</th>\n<th align=\"center\">Extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>PRIMARY</td>\n<td></td>\n<td>ALL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>41171</td>\n<td align=\"center\">NULL</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DERIVED</td>\n<td>virtual_coins</td>\n<td>index</td>\n<td>NULL</td>\n<td>idx_uid_type</td>\n<td>66</td>\n<td>NULL</td>\n<td>41171</td>\n<td align=\"center\">Using index</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-2-SELECT-TYPE列\"><a href=\"#3-2-SELECT-TYPE列\" class=\"headerlink\" title=\"3.2 SELECT_TYPE列\"></a>3.2 SELECT_TYPE列</h4><p>查询的类型，主要是<code>区别简单查询和联合查询、子查询之类的复杂查询</code>。  </p>\n<p>常见的取值：</p>\n<ul>\n<li><p><code>SIMPLE</code><br>它表示简单的 select，不包括 union 和子查询；</p>\n</li>\n<li><p><code>PRIMARY</code><br>查询有任何复杂的子查询，则最外层部分标记为 primary；</p>\n</li>\n<li><p><code>SUBQUERY</code></p>\n<p>包含在select列表中的子查询中的select（即，不在from子句中）标记为<code>subquery</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select (select uid from virtual_coins where uid &#x3D; 2000163293);</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra          |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+</span><br><span class=\"line\">|  1 | PRIMARY     | NULL          | NULL       | NULL | NULL          | NULL         | NULL    | NULL  | NULL |     NULL | No tables used |</span><br><span class=\"line\">|  2 | SUBQUERY    | virtual_coins | NULL       | ref  | idx_uid_type  | idx_uid_type | 4       | const |    1 |   100.00 | Using index    |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+--------------+---------+-------+------+----------+----------------+</span><br><span class=\"line\">2 rows in set, 1 warning (0.14 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>DERIVED</code></p>\n<p>  表示包含在from子句的子查询中的select，MySQL会递归执行并将结果放到一个临时表中。（测试时，只有在数据量大的情况下，才会出现DERIVED，数据量小的时候是SIMPLE??????）</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select uid from (select uid from tuanmei_user) as vc;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n<th>rows</th>\n<th align=\"center\">Extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>PRIMARY</td>\n<td></td>\n<td>ALL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>41171</td>\n<td align=\"center\">NULL</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DERIVED</td>\n<td>virtual_coins</td>\n<td>index</td>\n<td>NULL</td>\n<td>idx_uid_type</td>\n<td>66</td>\n<td>NULL</td>\n<td>41171</td>\n<td align=\"center\">Using index</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><code>UNION</code><br>union 语句的第二个或者说是后面那一个select被标记为union。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where id &lt;100 union select * from virtual_coins where id &gt;&#x3D; 100;</span><br><span class=\"line\">+----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class=\"line\">| id | select_type  | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |</span><br><span class=\"line\">+----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class=\"line\">|  1 | PRIMARY      | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   55 |   100.00 | Using where     |</span><br><span class=\"line\">|  2 | UNION        | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   52 |   100.00 | Using where     |</span><br><span class=\"line\">| NULL | UNION RESULT | &lt;union1,2&gt;    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class=\"line\">+----+--------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class=\"line\">3 rows in set, 1 warning (0.44 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>DEPENDENT</code></p>\n<p>  表示select依赖于外层查询中的数据。</p>\n</li>\n<li><p><code>UNION RESULT</code></p>\n<p>  用来从UNION的匿名临时表检索结果的select被标记为UNION RESULT。</p>\n</li>\n</ul>\n<h4 id=\"3-3-TABLE\"><a href=\"#3-3-TABLE\" class=\"headerlink\" title=\"3.3 TABLE\"></a>3.3 TABLE</h4><p>所使用的表。</p>\n<h4 id=\"3-4-TYPE\"><a href=\"#3-4-TYPE\" class=\"headerlink\" title=\"3.4 TYPE\"></a>3.4 TYPE</h4><p>关联类型（访问类型），MySQL决定如何查找表中的行，<u>是较为重要的一个指标</u>。</p>\n<ul>\n<li><code>NULL</code></li>\n</ul>\n<p>意味着MySQL能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select 1;</span><br><span class=\"line\">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class=\"line\">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class=\"line\">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.11 sec)</span><br></pre></td></tr></table></figure></code></pre>\n<ul>\n<li><p><code>system</code><br>表仅有一行，是 const 类型的特例。不常见。</p>\n</li>\n<li><p><code>const</code><br>常量查询，在整个查询过程中这个表<code>最多只会有一条匹配的行</code>，<code>用到了 primary key 或者unique 索引</code>。  </p>\n</li>\n</ul>\n<p>  eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where id&#x3D;50;</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><p><code>eq_ref</code><br>对于每个来自于前面的表的行组合，从该表中读取一行。 （<em>个人理解是在联合查询时，使用的条件是 UNIQUE 或 PRIMARY KEY。</em>）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select total_coins from virtual_coins, virtual_coins_logs where virtual_coins.id &#x3D; virtual_coins_logs.id;</span><br><span class=\"line\">+----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+</span><br><span class=\"line\">| id | select_type | table              | partitions | type   | possible_keys | key     | key_len | ref                            | rows | filtered | Extra                    |</span><br><span class=\"line\">+----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins      | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                           |   41 |   100.00 | NULL                     |</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins_logs | NULL       | eq_ref | PRIMARY       | PRIMARY | 8       | fans_economic.virtual_coins.id |    1 |   100.00 | Using where; Using index |</span><br><span class=\"line\">+----+-------------+--------------------+------------+--------+---------------+---------+---------+--------------------------------+------+----------+--------------------------+</span><br><span class=\"line\">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>ref</code> </p>\n<p>这是一种索引访问，也叫索引查找，它返回所有匹配某个单个值的行。对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。</p>\n<p>如果联接只使用键的最左边的前缀，或如果键不是 UNIQUE 或 PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用 ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。</p>\n</li>\n<li><p><code>fulltext</code>  </p>\n</li>\n<li><p><code>ref_or_null</code><br>该联接类型如同 ref，但是添加了 MySQL 可以专门搜索包含 NULL 值的行。 在解决子查询中经常使用该联接类型的优化。</p>\n</li>\n<li><p><code>index_merge</code>  </p>\n</li>\n<li><p><code>unique_subquery</code>  </p>\n</li>\n<li><p><code>index_subquery</code>  </p>\n</li>\n<li><p><code>range</code><br>给定范围内的检索，使用一个索引来检查行。通常发生在在索引列上使用范围查询，如 &gt;，&lt;，in 等时，非索引列是 ALL。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where id in (10, 100);</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using where |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select * from virtual_coins where uid in (10, 100);</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                 |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | range | idx_uid_type  | idx_uid_type | 4       | NULL |    2 |   100.00 | Using index condition |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select * from virtual_coins_0 where total_coins in (0,10);</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins_0 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>index</code><br>按索引次序扫描，先读索引，再读实际的行，结果也是全表扫描，主要优点是避免了排序。（索引是排好序的，并且 all 是从硬盘中读的，index 可能不在硬盘上）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins order by id;</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | PRIMARY | 4       | NULL |   41 |   100.00 | NULL  |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>ALL</code><br>进行完整的表扫描。性能很差，通常可以增加更多的索引而不要使用 ALL，使得行能基于前面的表中的常数值或列值被检索出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where create_time&#x3D;111;</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   41 |    10.00 | Using where |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>结果值优先顺序</strong>为：<br>    <code>NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code></p>\n<p>一般来说，得保证查询至少达到 range 级别，最好能达到 ref。</p>\n<h4 id=\"3-5-POSSIBLE-KEY列\"><a href=\"#3-5-POSSIBLE-KEY列\" class=\"headerlink\" title=\"3.5 POSSIBLE_KEY列\"></a>3.5 POSSIBLE_KEY列</h4><p>提示使用哪个索引会在该表中找到行，不太重要。</p>\n<h4 id=\"3-6-KEY列\"><a href=\"#3-6-KEY列\" class=\"headerlink\" title=\"3.6 KEY列\"></a>3.6 KEY列</h4><p>显示了MySQL决定采用哪个索引来优化对该表的访问。若该索引不在possible_keys中，那么MySQL选用它是处于另外的原因，例如，它可能选择了一个覆盖索引，哪怕没有where条件。</p>\n<p>如果是 NULL，表示没有索引被选择。</p>\n<h4 id=\"3-7-KEY-LEN\"><a href=\"#3-7-KEY-LEN\" class=\"headerlink\" title=\"3.7 KEY_LEN\"></a>3.7 KEY_LEN</h4><p>使用的索引字节数。</p>\n<h4 id=\"3-8-REF\"><a href=\"#3-8-REF\" class=\"headerlink\" title=\"3.8 REF\"></a>3.8 REF</h4><p>显示了之前的表再key列记录的索引中查找值所用的列或常量。</p>\n<h4 id=\"3-9-ROWS\"><a href=\"#3-9-ROWS\" class=\"headerlink\" title=\"3.9 ROWS\"></a>3.9 ROWS</h4><p>显示执行查询的行数（而不是返回的行数），数值越大越不好，说明没有用好索引。但对 InnoDB 不太准。</p>\n<h4 id=\"3-10-EXTRA\"><a href=\"#3-10-EXTRA\" class=\"headerlink\" title=\"3.10 EXTRA\"></a>3.10 <code>EXTRA</code></h4><p>该列包含的是其他的额外信息。其中常见的重要的值如下：</p>\n<ul>\n<li><p><code>Using index</code><br>此查询使用了<code>覆盖索引（Covering Index）</code>，即通过索引就能返回结果，无需访问表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select id from virtual_coins;</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | idx_uid_type | 66      | NULL |   41 |   100.00 | Using index |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+--------------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Using where</code><br>表示 MySQL 服务器从存储引擎收到行后再进行<code>“后过滤”（Post-filter）</code>。所谓“后过滤”，就是先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。因为检查是在读取行后才进行的，所以称为“后过滤”。查询中含有 WHERE 子句时较常见。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins where create_time&#x3D;111;</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   41 |    10.00 | Using where |</span><br><span class=\"line\">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Using filesort</code> </p>\n<p>表示MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。MySQL有两种文件排序的算法，两种方法都可以在内存或者磁盘上完成。Using filesort并不会对其进行区分。</p>\n</li>\n</ul>\n<p>  例如下面，id 是主键，所以它是索引。当 order by id 时，Extra 是 Using Index，而对别的列进行排序，就是 Using filesort，表示在查询之后，又进行了一次排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  Using index（对索引列排序）:</span><br><span class=\"line\">mysql&gt; explain select id from virtual_coins order by id;</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">| id | select_type | table         | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins | NULL       | index | NULL          | PRIMARY | 4       | NULL |   41 |   100.00 | Using index |</span><br><span class=\"line\">+----+-------------+---------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"># Using filesort（对非索引列排序）:</span><br><span class=\"line\">mysql&gt; explain select * from virtual_coins_0 order by total_coins;</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">| id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins_0 | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using filesort |</span><br><span class=\"line\">+----+-------------+-----------------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Using temporary</code><br><code>需要创建临时表存储结果以完成查询</code>。这种情况通常发生在查询时包含了 <code>Group By</code> 和 <code>Order By</code> 子句时或者<code>联合查询</code>时。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from virtual_coins_logs group by uid order by id;</span><br><span class=\"line\">+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+</span><br><span class=\"line\">| id | select_type | table              | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra                           |</span><br><span class=\"line\">+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+</span><br><span class=\"line\">|  1 | SIMPLE      | virtual_coins_logs | NULL       | index | idx_uid_type_action | idx_uid_type_action | 218     | NULL | 2701 |   100.00 | Using temporary; Using filesort |</span><br><span class=\"line\">+----+-------------+--------------------+------------+-------+---------------------+---------------------+---------+------+------+----------+---------------------------------+</span><br><span class=\"line\">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>range checked for each record (index map:N)</code></p>\n<p>表示没有好用的索引，新的索引将在联接的每一行上重新估算。N是显示在possible_keys列中索引的位图，并且是冗余的。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>explain 的四个重要字段：<code>type、key、rows、extra</code>；</p>\n</li>\n<li><p>如果 type 的值为 index 或者 ALL，那么说明该 SQL 性能一般，需要优化；</p>\n</li>\n<li><p>如果 key 的值为 NULL，说明该 SQL 没有使用索引，可以考虑在关键字段上增加索引；</p>\n</li>\n<li><p>row 的值代表了进行本次查询时，搜索记录的条数，当这个值特别大的时候，说明该 SQL 语句性能差；</p>\n</li>\n<li><p>如果 Extra 字段的值为 Using filesort 或 Using temporary，也是需要优化的，可以通过调整 order by 或者 group by 的字段来实现；</p>\n</li>\n<li><p>联合查询时，一定要多用 explain 来查看查询性能</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>高性能MySQL 第三版</p>"},{"title":"MySQL-InnoDB事务的实现","date":"2020-09-22T13:38:43.000Z","_content":"\n### 1 简介\n\n事务隔离性由`锁`来实现。原子性，一致性，持久性通过数据库的`redo log`和`undo log`来实现.\n\n<!--more-->\n\n- `redo log(重做日志)`： <u>用于保证事务的原子性和持久性</u>。redo恢复提交事务修改的页操作，通常是`物理日志`，记录的是页的物理修改操作。\n- `undo log(撤销日志)`： <u>用于保证事务的一致性</u>。undo回滚行记录到某个特定版本，是`逻辑日志`。根据每行记录进行记录。\n\nInnoDB是事务的存储引擎，通过`Force Log at Commit机制`实现事务的持久性。即<u>当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的提交操作完成才算完成</u>。这里的日志指重做日志，在InnoDB存储引擎中,包括redo log和undo log。\n\n\n### 2 redo log\n\n**redo log用来保证事务的持久性**。其组成包含以下两个部分:\n\n- `redo log buffer(重做日志缓冲)`：保存在内存中，属于掉电易失的.\n- `redo log file(重做日志文件)`：保存在磁盘中，属于持久的.\n\nredo log基本上都是顺序写，<u>在数据库运行时不需要对redo log的文件进行读取操作</u>。\n\n为了确保每次日志都写入`redo log file`中，在每次将`redo log buffer`写入文件后，InnoDB存储引擎都需要调用一次**fsync操作**。\n\n(*注：重做日志文件打开并没有使用O_DIRECT选项，因此`redo log buffer`中的数据会先写入文件系统缓存．为了保证重做日志写入磁盘,必须进行一次fsync操作．其中fsync的效率取决于磁盘的性能,因此磁盘的性能决定了事务提交的性能，即数据库的性能*)\n\n\n参数`innodb_flush_log_at_trx_commit`用于控制redo log刷新到磁盘的策略。该参数可设置的为包括:\n- 0：表示事务提交时不进行写入重做日志操作，仅在master thread中每1秒进行一次fsync操作。\n- 1：表示事务提交时必须调用一次fsync操作。（默认）\n- 2：表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。\n\n注：<u>设置`innodb_flush_log_at_trx_commit`为0或2可以提高事务的性能，但这种方式丧失了事务的ACID特性.</u>\n\n\n\n#### 2.1 扩展: 二进制日志(Bin log)\n\nMySQL数据库中还有一种二进制日志(binlog)，用来进行`POINT-IN-TIME(PIT)`的恢复及`主从复制(Replication)`环境的建立.\n\n\n\n##### 2.1.1 Bin log与Redo log的区别?\n\n- 日志产生的地方不同.\n  - `Redo log是在InnoDB存储引擎层产生`.\n  - `Bin log是在MySQL数据库的上层（服务层）产生的`，Binlog不仅是针对InnoDB存储引擎，MySQL数据库中任何存储引擎对于数据库的更改都会产生二进制日志.\n- 日志记录的内容形式不同.\n  - `Bin log是一种逻辑日志`，<u>记录的是对应SQL语句</u>.\n  - `InnoDB的Redo log时物理格式的日志`，<u>记录的时对于每个页的修改</u>.\n- 日志写入磁盘的时间点不同.\n  - Bin log只在事务提交完成后进行**一次写入**，且对于每一个事务，仅包含对应事务的一个日志（`即一个事务对应一个binlog日志`）。\n  - InnoDB的Redo log是在事务进行中**不断的被写入**，因此日志不是随事务提交顺序写入的。其记录的是物理操作日志，因此每个事务对应多个日志条目，且是并发的，并非在事务提交时写入，故其在文件中记录的顺序并非是事务开始的顺序。*T1、*T2、*T3表示的是事务提交时的日志。\n  \n\n如下图所示:\n![日志写入磁盘的时间点不同](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/日志写入磁盘的时间点不同.png)\n\n#### 2.2 Log block\n\n`在InnoDB存储引擎中，重做日志都是以512字节进行存储的`。其<u>`redo log buffer`、`redo log file`都是以`块（block）`的方式进行保存的，称之为**重做日志块（redo log block）**，每块大小为512字节。</u>\n\n若一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储，由于重做日志快的大小和磁盘扇区大小一样，都是512字节，因此重做日志的写入可以保证原子性，不需要double write技术。\n\n\n\n`重做日志块缓存的结构`如下：\n![重做日志块缓存的结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/重做日志块缓存的结构.png)\n\n\n\n`LOG_BLOCK_FIRST_REC_GROUP示例`：\n![LOG_BLOCK_FIRST_REC_GROUP](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/LOG_BLOCK_FIRST_REC_GROUP.png)\n\n#### 2.3 Log group\n\n`Log group`为**重做日志组**，<u>其中有多个redo log file</u>。虽然源码中一直有log group的镜像功能，但在ha_innobase.cc文件中禁止了该功能。**因此InnoDB存储引擎实际只有一个log group。**（Log group是一个逻辑上的概念，并没有一个实际存储的物理文件来表示log group信息。）\n\n\n\nRedo log file中存储的是Log buffer中保存的log block，因此Redo log file也是根据块的方式进行物理存储的管理，每个块的大小也是512字节。在InnoDB存储引擎运行过程，log buffer根据一定的规则将内存中的log block刷新到磁盘。\n\n**具体刷盘规则**如下：\n- `事务提交时。`\n- `当log buffer中有一半的内存空间已经被使用时。`\n- `log checkpoint时`。\n  \n\n<u>**写入Redo log file的方式**是`Append（追加）`，当一个文件被写满时，会接着写入下一个文件，其使用方式为：**round-robin（轮询调度算法）**。</u>\n\nRedo log file中除了保存log buffer刷新到磁盘的log block，还保存了2KB大小的其他信息，因此对redo log file的写入并不是完全顺序的。针对log group中第一个redo log file，其前2KB的部分保存了4个512字节大小的块。（注：只有每个log group的第一个redo log file中才有2KB的其他信息。其余redo log file仅保留这些空间，但不保存。）\n\n`Log group与Redo log file的关系图`如下：\n\n![Log group与Redo log file的关系图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Log group与Redo log file的关系图.png)\n\n\n\n#### 2.4 重做日志格式\n\n不同的数据库操作会有对应的重做日志格式。<u>InnoDB存储引擎的存储管理是基于页的，所以重做日志格式也是基于页的</u>。虽然有不同的重做日志格式，但他们有着通用的头部格式，如下图所示：\n\n![重做日志格式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/重做日志格式.png)\n\n\n\n对于页上记录的`插入`和`删除`操作，其格式如下：\n\n![页上记录的插入和删除操作格式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/页上记录的插入和删除操作格式.png)\n\n#### 2.5 LSN（日志序列号）\n\n在InnoDB存储引擎中，LSN占用8个字节，并且单调递增，其表示的含义有：\n- 重做日志写入的总量\n  - LSN记录的是重做日志的总量，其单位为字节。\n- Checkpoint的位置\n- 页的版本\n  - 在每个页的头部，有一个FIL_PAGE_LSN，记录了该页的LSN。在页中，LSN表示该页最后刷新时LSN的大小。因为重做日志记录的是每个页的日志，因此页中的LSN用来判断页是否需要进行恢复操作。\n\n\n\n`示例`：\n\n页P1的LSN为10000，而数据库启动时，InnoDB检测到写入重做日志中的LSN为13000，并且该事务已经提交，那么数据需要进行恢复操作，将重做日志应用到P1页中。同样的对于重做日志中LSN小于P1页的LSN，不需要进行重做，因为P1页中LSN表示页已经被刷新到该位置.\n\n通过`SHOW ENGINE INNODB STATUS`查看LSN的情况：\n\n```mysql\nmysql> show engine innodb status\\g;\n...\n---\nLOG\n---\nLog sequence number 11795911\nLog flushed up to   11795911\nPages flushed up to 11795911\nLast checkpoint at  11795902\n0 pending log flushes, 0 pending chkp writes\n10 log i/o's done, 0.00 log i/o's/second\n...\n1 row in set (0.00 sec)\n```\n\n其中：\n\n- `Log sequence number`：表示当前LSN\n- `Log flushed up to`：表示刷新到重做日志文件的LSN.\n- `Last checkpoint at`：表示刷新到磁盘的LSN\n\n其中以上三个参数可能是不同的，因为在一个事务中从日志缓冲刷新到重做日志文件并不只是在事务提交时发生，每秒都会有从日志缓冲刷新到重做日志文件的动作。\n\n\n\n#### 2.6 恢复\n\nInnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试进行恢复操作。由于checkpoint表示已经刷新到磁盘上的LSN，因此在恢复过程中仅需恢复checkpoint开始的日志部分。\n\n`示例`：\n\n![恢复的例子](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/恢复的例子.png)\n\n### 3 undo log\n\n#### 3.1 基本概念\n\n**undo log的作用**：\n\n- `帮助事务回滚`；\n- `MVCC功能`．\n\n\n\n##### 3.1.1 undo log帮助事务回滚\n\n在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。当用户执行事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。\n\nredo存放在重做日志文件中，而undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment）。<u>undo段位于共享表空间内</u>。\n\n**undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子**。当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。\n\n- `对于每个INSERT，InnoDB存储引擎会完成一个DELETE`；\n- `对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE,将修改前的行放回去`。\n\n\n\n##### 3.1.2 undo log用于MVCC\n\n除了回滚操作，undo的另一个作用是MVCC，即在InnoDB存储引擎中的MVCC的是通过undo来完成的。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此**实现非锁定读取**。\n\n*注：undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。*\n\n\n\n#### 3.2 undo存储管理\n\nInnoDB存储引擎对undo的管理同样采用段的方式。InnoDB存储引擎有`rollback segment`，每个回滚段中记录了1024个`undo log segment`，而在每个undo log segment段中进行undo页的申请。共享表空间偏移量为5的页（0，5）记录了所有`rollback segment header`所在的页，这个页的类型为`FIL_PAGE_TYPE_SYS`。\n\n从InnoDB1.2版本开始，可通过参数对rollback segment做进一步设置。其中包含：\n\n- `innodb_undo_directory`：用于设置rollback segment文件所在路径，默认值为＂．＂，表示当前InnoDB存储引擎的目录。\n- `innodb_undo_logs`：用于设置rollback segment的个数，默认值为128.\n- `innodb_undo_tabklespaces`：用于设置构成rollback segment文件的数量，这样rollback segment可以较为平均地分不到多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件。如下所示：\n\n```mysql\nmysql> show variables like 'innodb_undo%';\n+--------------------------+-------+\n| Variable_name            | Value |\n+--------------------------+-------+\n| innodb_undo_directory    | ./    |\n| innodb_undo_log_truncate | OFF   |\n| innodb_undo_logs         | 128   |\n| innodb_undo_tablespaces  | 0     |\n+--------------------------+-------+\n4 rows in set (0.03 sec)\n\nmysql> show variables like 'datadir';\n+---------------+-----------------+\n| Variable_name | Value           |\n+---------------+-----------------+\n| datadir       | /var/lib/mysql/ |\n+---------------+-----------------+\n1 row in set (0.00 sec)\n\nmysql> system ls -lh /var/lib/mysql/undo*;\nls: error initializing month strings\nls: cannot access '/var/lib/mysql/undo*': Permission denied\n```\n\n<u>注：事务在undo log segment分配页并写入undo log的这个过程同样需要写入重做日志。</u>\n\n\n\n**Q1：当事务提交时，InnoDB存储引擎会做什么操作？**\n\n当事务提交时，InooDB会做以下两种操作：\n\n- ①、将undo log放入链表中，以供之后的purge操作\n- ②、判断undo log所在的页是否可以重用，若可以分配给下个事务使用。\n\n\n\n**Q2：为什么事务提交后并不能马上删除undo log及undo log所在的页？**\n\n因为此时可能还有其他事务需要通过undo log来的到行记录之前的版本。当事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。\n\n由于事务提交时，可能并不能马上释放页，在大量更新删除操作的情况下会非常浪费存储空间。因此InnoDB存储引擎在设计中对undo页也可以重用。其**具体重用方式如下**：\n\n- ①、当事务提交时，首先将undo log放入链表中。\n- ②、判断undo页的使用空间是否小于3/4，若是，则表示undo页可以被重用，之后新的undo log记录可能存放在当前undo log的后面。\n\n注：<u>存放undo log链表是以记录进行组织的，而undo页可能存放着不同事务的undo log，因此purge操作需要设计磁盘的离散读取操作，是一个比较缓慢的过程。</u>\n\n\n\n可以通过`SHOW ENGINE INNODB STATUS`来查看链表中undo log的数量，如：\n\n```mysql\nmysql> show engine innodb status\\g;\n...\n------------\nTRANSACTIONS\n------------\nTrx id counter 1795\nPurge done for trx's n:o < 0 undo n:o < 0 state: running but idle\nHistory list length 0\nLIST OF TRANSACTIONS FOR EACH SESSION:\n---TRANSACTION 422058470606688, not started\n0 lock struct(s), heap size 1136, 0 row lock(s)\n...\n```\n\n其中`History list length`表示undo log的数量，这里为0．purge操作会减少该值，然而由于undo log所在的页可以被重用，因此即使操作发生，History list length的值也可能不为0。\n\n\n\n#### 3.3 undo log格式\n\n在InnoDB存储引擎中，undo log分为：\n\n- ①、`insert undo log` \n- ②、`update undo log`\n\n\n\n##### 3.3.1 Insert undo log\n\n**Insert undo log**是指在`insert`操作中产生的undo log。因为insert操作记录，只针对事务本身可见，对其他事务不可见（这是事务隔离性的要求），所以<u>insert undo log可以在事务提交后直接删除。不需要进行purge操作。</u>\n\n**Insert undo log的格式**如下：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Insert-undo-log.png\" alt=\"Insert-undo-log\" style=\"zoom: 67%;\" />\n\n##### 3.3.2 Update undo log\n\n**Update undo log**记录的是对`delete`和`update`操作产生的undo log。该<u>undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</u>\n\nUpdate undo log相对于Insert Undo log记录的内容更多，所需占用的空间更大。其结构如下图所示：\n\n![Update-undo-log](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Update-undo-log.png)\n\nType_cmpl，其可能的值包括：\n\n- ①、12：`TRX_UNDO_UPD_EXIST_REC`更新non-delete-mark的记录\n- ②、13：`TRX_UNDO_UPD_DEL_REC`将delete的记录标记为not delete\n- ③、14：`TRX_UNDO_DEL_MARK_REC`将记录标记为delete\n\nUpdate_vector信息表示update操作发生改变的列。每个修改的列信息都要记录到undo log中，对于不同的undo log类型，可能还需要记录对索引列所做的修改。\n\n\n\n#### 3.4  查看Undo 信息\n\nOracle和Microsoft SQL Server数据库都是由内部的数据字典来观察当前undo的信息。InnoSQL对information_schema进行了扩展，添加了两张数据字典表，方便查看undo信息。涉及的字典表为：\n\n- ①、`INNODB_TRX_ROLLBACK_SEGMENT`：查看rollback segment\n- ②、`INNODB_TRX_UNDO`：查看记录事务对应undo log\n\n\n\nINNODB_TRX_ROLLBACK_SEGMENT 其表结构如下所示（*执行书上的命令时发现字典不存在...？？？？？？*）\n\n```mysql\nmysql> desc INNODB_TRX_ROLLBACK_SEGMENT;\nERROR 1146 (42S02): Table 'sys.INNODB_TRX_ROLLBACK_SEGMENT' doesn't exist\n```\n\n\n\n按照书中演示的使用INNODB_TRX_UNDO表\n\n- ①、创建测试表\n\n\n```mysql\nmysql> create table t(a int,b varchar(32), primary key(a), key(b))engine=innodb;\nQuery OK, 0 rows affected (0.09 sec)\n```\n\n②、插入一条记录，并尝试通过`INNODB_TRX_UNDO`观察该事务的undo log的情况\n\n```mysql\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t select 1, '1';\nQuery OK, 1 row affected (0.01 sec)\nRecords: 1  Duplicates: 0  Warnings: 0\n\nmysql> select * from information_schema.INNODB_TRX_UNDO\\G;\nERROR 1109 (42S02): Unknown table 'INNODB_TRX_UNDO' in information_schema\n```\n\n阿西吧，此时发现该字典表也不存在....?????????\n\n\n\nDelete操作并不直接删除记录，而只是将记录标记为已删除，也就是将记录的delete flag设置为1。而记录最终的删除是在purge操作中完成的。\n\nUpdate操作实际分为两步：\n\n- ①、首先将原主键记录标记为已删除，因此需产生一个类型为TRX_UNDO_DEL_MARK_REC的undo log。\n- ②、然后插入一条新的记录，因此需要产生一个类型为TRX_UNDO_INSERT_REC的undo log。\n\n\n\n### 4 Purge\n\n**Purge用于最终完成delete和update操作**，<u>这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即处理</u>。其操作示例如下图所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/undo-log与history列表的关系.png\" alt=\"undo-log与history列表的关系\" style=\"zoom:67%;\" />\n\nInnodb提供了一个全局动态参数用于控制purge操作：\n\n- ①、`innodb_purge_batch_size`：用于设置每次purge操作需要清理的undo page数量，默认值为300。推荐采用默认值。\n- ②、`innodb_max_purge_lag`：用于控制history list的长度，若长度大于该参数，其会延缓”DML“的操作。该参数默认值为0，表示不对history list做任何限制。当大于0时，就会延缓DML的操作，其延缓单位为毫秒，延缓算法为：\n\n```\ndelay = ((length(history_list) - innodb_max_purge_lag) * 10) - 5\n```\n\n注：delay的对象是行，而不是一个DML操作，即假设update操作5行数据时，总延时时间为5*delay。\n\n- ③、`innodb_max_purge_lag_delay`：要求版本大于InooDB1.2版本，用于控制delay的最大毫秒数。即当计算的delay值大于此参数时，将delay设置为此参数，避免由于purge操作缓慢导致其他SQL线程出现无限制的等待。\n\n\n\n### 5 Group Commit\n\n**Group commit**操作<u>用于提高磁盘fsync的效率，即一次fsync操作可以刷新确保多个事务日志被写入文件。</u>\n\n对于InnoDB存储引擎，事务提交时会进行两个阶段的操作：\n\n- ①、修改内存中事务对应的信息，并将日志写入重做日志缓冲。\n- ②、调用`fsync`将去把日志都从重做日志缓冲写入磁盘。\n\n其中第②步较慢，因此存储引擎需要和磁盘打交道。对于在执行第②段操作时，其他的事务可以进行第一段操作，然后将多个事务的重做日志通过一次fsync刷新到磁盘，大大减少磁盘的压力，提高数据库性能。对于Insert和update较为明显的操作，Group Commit的效果尤为明显。\n\n\n\n**Q3：在InnoDB1.2版本以后，在开启二进制日志后，InnoDB的Group Commit功能会实现，导致性能下降，其原因为？**\n\n导致这个问题的原因在于开启二进制日志后，为了保证存储引擎层中的事务和二进制日志的一致性，二者之前使用两阶段事务，其步骤如下：\n\n- ①、当事务提交时，InnoDB存储引擎进行prepare操作。\n\n- ②、Mysql数据库上层写二进制日志。（一旦这一步提交，就确保了事务的提交，即使在第③步中发生了宕机。）（这一步由参数`sync_binlog`控制）\n\n- ③、InnoDB存储引擎层将日志写入重做日志文件。（这一步的`fsync`由参数`innodb_flush_log_at_trx_commit`控制）\n\n- - a、修改内存中事务对应的信息，并将日志写入重做日志缓冲。\n  - b、调用fsync将确保日志都从重做日志缓冲写入磁盘。\n\n*注：每个步骤都需要fsync操作才能保证上下两层数据的一致性。*\n\n\n\n其整体过程如下：\n\n![开启二进制日志后InnoDB存储引擎的提交过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/开启二进制日志后InnoDB存储引擎的提交过程.png)\n\n为了保证二进制日志的写入顺序与InnoDB层的事务提交顺序一致，Mysql数据库内部使用了`prepare_commit_mutex`锁，当开启这个锁后，步骤③中的a将不可以在其他事务中执行步骤b，从而导致了Group Commit失效。\n\n\n\n**Q4：如何解决Q3的问题？**\n\nMysql5.6采用了`Binary Log Group Commit（BLGC）`的方式<u>将事务提交的过程采用三段式提交方式</u>，如下图所示：\n\n![BLGC](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/BLGC.png)\n\n当有一组事务在今次那个Commit阶段时，其他新事物可以进行Flush阶段，从而使Group Commit不断生效。\n\n\n\nInnoDB提供了一些参数用于控制Bin log提交：\n\n①、`binlog_max_flush_quenue_time`：用于控制Flush阶段中等待的时间，即使之前一组事务完成提交，当前一组事务也不马上进入Sync阶段，而是至少等待一端时间，这样做的好处是Group Commit的事务数量更过，缺点是可能会导致事务的响应时间变量。默认值为0，且不建议修改。\n\n\n\n------\n\n### 参考资料\n\n- MySQL技术内幕+InnoDB存储引擎第2版(7.2节)\n- [SHOW ENGINE INNODB STATUS \\G之Pages flushed up to的理解](http://blog.itpub.net/30221425/viewspace-2154670/)","source":"_posts/MySQL-InnoDB事务的实现.md","raw":"---\ntitle: MySQL-InnoDB事务的实现\ndate: 2020-09-22 21:38:43\ntags: [\"MySQL\",\"InnoDB\"]\ncategories: [\"MySQL\",\"InnoDB\"]\n---\n\n### 1 简介\n\n事务隔离性由`锁`来实现。原子性，一致性，持久性通过数据库的`redo log`和`undo log`来实现.\n\n<!--more-->\n\n- `redo log(重做日志)`： <u>用于保证事务的原子性和持久性</u>。redo恢复提交事务修改的页操作，通常是`物理日志`，记录的是页的物理修改操作。\n- `undo log(撤销日志)`： <u>用于保证事务的一致性</u>。undo回滚行记录到某个特定版本，是`逻辑日志`。根据每行记录进行记录。\n\nInnoDB是事务的存储引擎，通过`Force Log at Commit机制`实现事务的持久性。即<u>当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的提交操作完成才算完成</u>。这里的日志指重做日志，在InnoDB存储引擎中,包括redo log和undo log。\n\n\n### 2 redo log\n\n**redo log用来保证事务的持久性**。其组成包含以下两个部分:\n\n- `redo log buffer(重做日志缓冲)`：保存在内存中，属于掉电易失的.\n- `redo log file(重做日志文件)`：保存在磁盘中，属于持久的.\n\nredo log基本上都是顺序写，<u>在数据库运行时不需要对redo log的文件进行读取操作</u>。\n\n为了确保每次日志都写入`redo log file`中，在每次将`redo log buffer`写入文件后，InnoDB存储引擎都需要调用一次**fsync操作**。\n\n(*注：重做日志文件打开并没有使用O_DIRECT选项，因此`redo log buffer`中的数据会先写入文件系统缓存．为了保证重做日志写入磁盘,必须进行一次fsync操作．其中fsync的效率取决于磁盘的性能,因此磁盘的性能决定了事务提交的性能，即数据库的性能*)\n\n\n参数`innodb_flush_log_at_trx_commit`用于控制redo log刷新到磁盘的策略。该参数可设置的为包括:\n- 0：表示事务提交时不进行写入重做日志操作，仅在master thread中每1秒进行一次fsync操作。\n- 1：表示事务提交时必须调用一次fsync操作。（默认）\n- 2：表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。\n\n注：<u>设置`innodb_flush_log_at_trx_commit`为0或2可以提高事务的性能，但这种方式丧失了事务的ACID特性.</u>\n\n\n\n#### 2.1 扩展: 二进制日志(Bin log)\n\nMySQL数据库中还有一种二进制日志(binlog)，用来进行`POINT-IN-TIME(PIT)`的恢复及`主从复制(Replication)`环境的建立.\n\n\n\n##### 2.1.1 Bin log与Redo log的区别?\n\n- 日志产生的地方不同.\n  - `Redo log是在InnoDB存储引擎层产生`.\n  - `Bin log是在MySQL数据库的上层（服务层）产生的`，Binlog不仅是针对InnoDB存储引擎，MySQL数据库中任何存储引擎对于数据库的更改都会产生二进制日志.\n- 日志记录的内容形式不同.\n  - `Bin log是一种逻辑日志`，<u>记录的是对应SQL语句</u>.\n  - `InnoDB的Redo log时物理格式的日志`，<u>记录的时对于每个页的修改</u>.\n- 日志写入磁盘的时间点不同.\n  - Bin log只在事务提交完成后进行**一次写入**，且对于每一个事务，仅包含对应事务的一个日志（`即一个事务对应一个binlog日志`）。\n  - InnoDB的Redo log是在事务进行中**不断的被写入**，因此日志不是随事务提交顺序写入的。其记录的是物理操作日志，因此每个事务对应多个日志条目，且是并发的，并非在事务提交时写入，故其在文件中记录的顺序并非是事务开始的顺序。*T1、*T2、*T3表示的是事务提交时的日志。\n  \n\n如下图所示:\n![日志写入磁盘的时间点不同](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/日志写入磁盘的时间点不同.png)\n\n#### 2.2 Log block\n\n`在InnoDB存储引擎中，重做日志都是以512字节进行存储的`。其<u>`redo log buffer`、`redo log file`都是以`块（block）`的方式进行保存的，称之为**重做日志块（redo log block）**，每块大小为512字节。</u>\n\n若一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储，由于重做日志快的大小和磁盘扇区大小一样，都是512字节，因此重做日志的写入可以保证原子性，不需要double write技术。\n\n\n\n`重做日志块缓存的结构`如下：\n![重做日志块缓存的结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/重做日志块缓存的结构.png)\n\n\n\n`LOG_BLOCK_FIRST_REC_GROUP示例`：\n![LOG_BLOCK_FIRST_REC_GROUP](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/LOG_BLOCK_FIRST_REC_GROUP.png)\n\n#### 2.3 Log group\n\n`Log group`为**重做日志组**，<u>其中有多个redo log file</u>。虽然源码中一直有log group的镜像功能，但在ha_innobase.cc文件中禁止了该功能。**因此InnoDB存储引擎实际只有一个log group。**（Log group是一个逻辑上的概念，并没有一个实际存储的物理文件来表示log group信息。）\n\n\n\nRedo log file中存储的是Log buffer中保存的log block，因此Redo log file也是根据块的方式进行物理存储的管理，每个块的大小也是512字节。在InnoDB存储引擎运行过程，log buffer根据一定的规则将内存中的log block刷新到磁盘。\n\n**具体刷盘规则**如下：\n- `事务提交时。`\n- `当log buffer中有一半的内存空间已经被使用时。`\n- `log checkpoint时`。\n  \n\n<u>**写入Redo log file的方式**是`Append（追加）`，当一个文件被写满时，会接着写入下一个文件，其使用方式为：**round-robin（轮询调度算法）**。</u>\n\nRedo log file中除了保存log buffer刷新到磁盘的log block，还保存了2KB大小的其他信息，因此对redo log file的写入并不是完全顺序的。针对log group中第一个redo log file，其前2KB的部分保存了4个512字节大小的块。（注：只有每个log group的第一个redo log file中才有2KB的其他信息。其余redo log file仅保留这些空间，但不保存。）\n\n`Log group与Redo log file的关系图`如下：\n\n![Log group与Redo log file的关系图](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Log group与Redo log file的关系图.png)\n\n\n\n#### 2.4 重做日志格式\n\n不同的数据库操作会有对应的重做日志格式。<u>InnoDB存储引擎的存储管理是基于页的，所以重做日志格式也是基于页的</u>。虽然有不同的重做日志格式，但他们有着通用的头部格式，如下图所示：\n\n![重做日志格式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/重做日志格式.png)\n\n\n\n对于页上记录的`插入`和`删除`操作，其格式如下：\n\n![页上记录的插入和删除操作格式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/页上记录的插入和删除操作格式.png)\n\n#### 2.5 LSN（日志序列号）\n\n在InnoDB存储引擎中，LSN占用8个字节，并且单调递增，其表示的含义有：\n- 重做日志写入的总量\n  - LSN记录的是重做日志的总量，其单位为字节。\n- Checkpoint的位置\n- 页的版本\n  - 在每个页的头部，有一个FIL_PAGE_LSN，记录了该页的LSN。在页中，LSN表示该页最后刷新时LSN的大小。因为重做日志记录的是每个页的日志，因此页中的LSN用来判断页是否需要进行恢复操作。\n\n\n\n`示例`：\n\n页P1的LSN为10000，而数据库启动时，InnoDB检测到写入重做日志中的LSN为13000，并且该事务已经提交，那么数据需要进行恢复操作，将重做日志应用到P1页中。同样的对于重做日志中LSN小于P1页的LSN，不需要进行重做，因为P1页中LSN表示页已经被刷新到该位置.\n\n通过`SHOW ENGINE INNODB STATUS`查看LSN的情况：\n\n```mysql\nmysql> show engine innodb status\\g;\n...\n---\nLOG\n---\nLog sequence number 11795911\nLog flushed up to   11795911\nPages flushed up to 11795911\nLast checkpoint at  11795902\n0 pending log flushes, 0 pending chkp writes\n10 log i/o's done, 0.00 log i/o's/second\n...\n1 row in set (0.00 sec)\n```\n\n其中：\n\n- `Log sequence number`：表示当前LSN\n- `Log flushed up to`：表示刷新到重做日志文件的LSN.\n- `Last checkpoint at`：表示刷新到磁盘的LSN\n\n其中以上三个参数可能是不同的，因为在一个事务中从日志缓冲刷新到重做日志文件并不只是在事务提交时发生，每秒都会有从日志缓冲刷新到重做日志文件的动作。\n\n\n\n#### 2.6 恢复\n\nInnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试进行恢复操作。由于checkpoint表示已经刷新到磁盘上的LSN，因此在恢复过程中仅需恢复checkpoint开始的日志部分。\n\n`示例`：\n\n![恢复的例子](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/恢复的例子.png)\n\n### 3 undo log\n\n#### 3.1 基本概念\n\n**undo log的作用**：\n\n- `帮助事务回滚`；\n- `MVCC功能`．\n\n\n\n##### 3.1.1 undo log帮助事务回滚\n\n在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。当用户执行事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。\n\nredo存放在重做日志文件中，而undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment）。<u>undo段位于共享表空间内</u>。\n\n**undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子**。当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。\n\n- `对于每个INSERT，InnoDB存储引擎会完成一个DELETE`；\n- `对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE,将修改前的行放回去`。\n\n\n\n##### 3.1.2 undo log用于MVCC\n\n除了回滚操作，undo的另一个作用是MVCC，即在InnoDB存储引擎中的MVCC的是通过undo来完成的。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此**实现非锁定读取**。\n\n*注：undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。*\n\n\n\n#### 3.2 undo存储管理\n\nInnoDB存储引擎对undo的管理同样采用段的方式。InnoDB存储引擎有`rollback segment`，每个回滚段中记录了1024个`undo log segment`，而在每个undo log segment段中进行undo页的申请。共享表空间偏移量为5的页（0，5）记录了所有`rollback segment header`所在的页，这个页的类型为`FIL_PAGE_TYPE_SYS`。\n\n从InnoDB1.2版本开始，可通过参数对rollback segment做进一步设置。其中包含：\n\n- `innodb_undo_directory`：用于设置rollback segment文件所在路径，默认值为＂．＂，表示当前InnoDB存储引擎的目录。\n- `innodb_undo_logs`：用于设置rollback segment的个数，默认值为128.\n- `innodb_undo_tabklespaces`：用于设置构成rollback segment文件的数量，这样rollback segment可以较为平均地分不到多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件。如下所示：\n\n```mysql\nmysql> show variables like 'innodb_undo%';\n+--------------------------+-------+\n| Variable_name            | Value |\n+--------------------------+-------+\n| innodb_undo_directory    | ./    |\n| innodb_undo_log_truncate | OFF   |\n| innodb_undo_logs         | 128   |\n| innodb_undo_tablespaces  | 0     |\n+--------------------------+-------+\n4 rows in set (0.03 sec)\n\nmysql> show variables like 'datadir';\n+---------------+-----------------+\n| Variable_name | Value           |\n+---------------+-----------------+\n| datadir       | /var/lib/mysql/ |\n+---------------+-----------------+\n1 row in set (0.00 sec)\n\nmysql> system ls -lh /var/lib/mysql/undo*;\nls: error initializing month strings\nls: cannot access '/var/lib/mysql/undo*': Permission denied\n```\n\n<u>注：事务在undo log segment分配页并写入undo log的这个过程同样需要写入重做日志。</u>\n\n\n\n**Q1：当事务提交时，InnoDB存储引擎会做什么操作？**\n\n当事务提交时，InooDB会做以下两种操作：\n\n- ①、将undo log放入链表中，以供之后的purge操作\n- ②、判断undo log所在的页是否可以重用，若可以分配给下个事务使用。\n\n\n\n**Q2：为什么事务提交后并不能马上删除undo log及undo log所在的页？**\n\n因为此时可能还有其他事务需要通过undo log来的到行记录之前的版本。当事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。\n\n由于事务提交时，可能并不能马上释放页，在大量更新删除操作的情况下会非常浪费存储空间。因此InnoDB存储引擎在设计中对undo页也可以重用。其**具体重用方式如下**：\n\n- ①、当事务提交时，首先将undo log放入链表中。\n- ②、判断undo页的使用空间是否小于3/4，若是，则表示undo页可以被重用，之后新的undo log记录可能存放在当前undo log的后面。\n\n注：<u>存放undo log链表是以记录进行组织的，而undo页可能存放着不同事务的undo log，因此purge操作需要设计磁盘的离散读取操作，是一个比较缓慢的过程。</u>\n\n\n\n可以通过`SHOW ENGINE INNODB STATUS`来查看链表中undo log的数量，如：\n\n```mysql\nmysql> show engine innodb status\\g;\n...\n------------\nTRANSACTIONS\n------------\nTrx id counter 1795\nPurge done for trx's n:o < 0 undo n:o < 0 state: running but idle\nHistory list length 0\nLIST OF TRANSACTIONS FOR EACH SESSION:\n---TRANSACTION 422058470606688, not started\n0 lock struct(s), heap size 1136, 0 row lock(s)\n...\n```\n\n其中`History list length`表示undo log的数量，这里为0．purge操作会减少该值，然而由于undo log所在的页可以被重用，因此即使操作发生，History list length的值也可能不为0。\n\n\n\n#### 3.3 undo log格式\n\n在InnoDB存储引擎中，undo log分为：\n\n- ①、`insert undo log` \n- ②、`update undo log`\n\n\n\n##### 3.3.1 Insert undo log\n\n**Insert undo log**是指在`insert`操作中产生的undo log。因为insert操作记录，只针对事务本身可见，对其他事务不可见（这是事务隔离性的要求），所以<u>insert undo log可以在事务提交后直接删除。不需要进行purge操作。</u>\n\n**Insert undo log的格式**如下：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Insert-undo-log.png\" alt=\"Insert-undo-log\" style=\"zoom: 67%;\" />\n\n##### 3.3.2 Update undo log\n\n**Update undo log**记录的是对`delete`和`update`操作产生的undo log。该<u>undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</u>\n\nUpdate undo log相对于Insert Undo log记录的内容更多，所需占用的空间更大。其结构如下图所示：\n\n![Update-undo-log](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Update-undo-log.png)\n\nType_cmpl，其可能的值包括：\n\n- ①、12：`TRX_UNDO_UPD_EXIST_REC`更新non-delete-mark的记录\n- ②、13：`TRX_UNDO_UPD_DEL_REC`将delete的记录标记为not delete\n- ③、14：`TRX_UNDO_DEL_MARK_REC`将记录标记为delete\n\nUpdate_vector信息表示update操作发生改变的列。每个修改的列信息都要记录到undo log中，对于不同的undo log类型，可能还需要记录对索引列所做的修改。\n\n\n\n#### 3.4  查看Undo 信息\n\nOracle和Microsoft SQL Server数据库都是由内部的数据字典来观察当前undo的信息。InnoSQL对information_schema进行了扩展，添加了两张数据字典表，方便查看undo信息。涉及的字典表为：\n\n- ①、`INNODB_TRX_ROLLBACK_SEGMENT`：查看rollback segment\n- ②、`INNODB_TRX_UNDO`：查看记录事务对应undo log\n\n\n\nINNODB_TRX_ROLLBACK_SEGMENT 其表结构如下所示（*执行书上的命令时发现字典不存在...？？？？？？*）\n\n```mysql\nmysql> desc INNODB_TRX_ROLLBACK_SEGMENT;\nERROR 1146 (42S02): Table 'sys.INNODB_TRX_ROLLBACK_SEGMENT' doesn't exist\n```\n\n\n\n按照书中演示的使用INNODB_TRX_UNDO表\n\n- ①、创建测试表\n\n\n```mysql\nmysql> create table t(a int,b varchar(32), primary key(a), key(b))engine=innodb;\nQuery OK, 0 rows affected (0.09 sec)\n```\n\n②、插入一条记录，并尝试通过`INNODB_TRX_UNDO`观察该事务的undo log的情况\n\n```mysql\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t select 1, '1';\nQuery OK, 1 row affected (0.01 sec)\nRecords: 1  Duplicates: 0  Warnings: 0\n\nmysql> select * from information_schema.INNODB_TRX_UNDO\\G;\nERROR 1109 (42S02): Unknown table 'INNODB_TRX_UNDO' in information_schema\n```\n\n阿西吧，此时发现该字典表也不存在....?????????\n\n\n\nDelete操作并不直接删除记录，而只是将记录标记为已删除，也就是将记录的delete flag设置为1。而记录最终的删除是在purge操作中完成的。\n\nUpdate操作实际分为两步：\n\n- ①、首先将原主键记录标记为已删除，因此需产生一个类型为TRX_UNDO_DEL_MARK_REC的undo log。\n- ②、然后插入一条新的记录，因此需要产生一个类型为TRX_UNDO_INSERT_REC的undo log。\n\n\n\n### 4 Purge\n\n**Purge用于最终完成delete和update操作**，<u>这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即处理</u>。其操作示例如下图所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/undo-log与history列表的关系.png\" alt=\"undo-log与history列表的关系\" style=\"zoom:67%;\" />\n\nInnodb提供了一个全局动态参数用于控制purge操作：\n\n- ①、`innodb_purge_batch_size`：用于设置每次purge操作需要清理的undo page数量，默认值为300。推荐采用默认值。\n- ②、`innodb_max_purge_lag`：用于控制history list的长度，若长度大于该参数，其会延缓”DML“的操作。该参数默认值为0，表示不对history list做任何限制。当大于0时，就会延缓DML的操作，其延缓单位为毫秒，延缓算法为：\n\n```\ndelay = ((length(history_list) - innodb_max_purge_lag) * 10) - 5\n```\n\n注：delay的对象是行，而不是一个DML操作，即假设update操作5行数据时，总延时时间为5*delay。\n\n- ③、`innodb_max_purge_lag_delay`：要求版本大于InooDB1.2版本，用于控制delay的最大毫秒数。即当计算的delay值大于此参数时，将delay设置为此参数，避免由于purge操作缓慢导致其他SQL线程出现无限制的等待。\n\n\n\n### 5 Group Commit\n\n**Group commit**操作<u>用于提高磁盘fsync的效率，即一次fsync操作可以刷新确保多个事务日志被写入文件。</u>\n\n对于InnoDB存储引擎，事务提交时会进行两个阶段的操作：\n\n- ①、修改内存中事务对应的信息，并将日志写入重做日志缓冲。\n- ②、调用`fsync`将去把日志都从重做日志缓冲写入磁盘。\n\n其中第②步较慢，因此存储引擎需要和磁盘打交道。对于在执行第②段操作时，其他的事务可以进行第一段操作，然后将多个事务的重做日志通过一次fsync刷新到磁盘，大大减少磁盘的压力，提高数据库性能。对于Insert和update较为明显的操作，Group Commit的效果尤为明显。\n\n\n\n**Q3：在InnoDB1.2版本以后，在开启二进制日志后，InnoDB的Group Commit功能会实现，导致性能下降，其原因为？**\n\n导致这个问题的原因在于开启二进制日志后，为了保证存储引擎层中的事务和二进制日志的一致性，二者之前使用两阶段事务，其步骤如下：\n\n- ①、当事务提交时，InnoDB存储引擎进行prepare操作。\n\n- ②、Mysql数据库上层写二进制日志。（一旦这一步提交，就确保了事务的提交，即使在第③步中发生了宕机。）（这一步由参数`sync_binlog`控制）\n\n- ③、InnoDB存储引擎层将日志写入重做日志文件。（这一步的`fsync`由参数`innodb_flush_log_at_trx_commit`控制）\n\n- - a、修改内存中事务对应的信息，并将日志写入重做日志缓冲。\n  - b、调用fsync将确保日志都从重做日志缓冲写入磁盘。\n\n*注：每个步骤都需要fsync操作才能保证上下两层数据的一致性。*\n\n\n\n其整体过程如下：\n\n![开启二进制日志后InnoDB存储引擎的提交过程](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/开启二进制日志后InnoDB存储引擎的提交过程.png)\n\n为了保证二进制日志的写入顺序与InnoDB层的事务提交顺序一致，Mysql数据库内部使用了`prepare_commit_mutex`锁，当开启这个锁后，步骤③中的a将不可以在其他事务中执行步骤b，从而导致了Group Commit失效。\n\n\n\n**Q4：如何解决Q3的问题？**\n\nMysql5.6采用了`Binary Log Group Commit（BLGC）`的方式<u>将事务提交的过程采用三段式提交方式</u>，如下图所示：\n\n![BLGC](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/BLGC.png)\n\n当有一组事务在今次那个Commit阶段时，其他新事物可以进行Flush阶段，从而使Group Commit不断生效。\n\n\n\nInnoDB提供了一些参数用于控制Bin log提交：\n\n①、`binlog_max_flush_quenue_time`：用于控制Flush阶段中等待的时间，即使之前一组事务完成提交，当前一组事务也不马上进入Sync阶段，而是至少等待一端时间，这样做的好处是Group Commit的事务数量更过，缺点是可能会导致事务的响应时间变量。默认值为0，且不建议修改。\n\n\n\n------\n\n### 参考资料\n\n- MySQL技术内幕+InnoDB存储引擎第2版(7.2节)\n- [SHOW ENGINE INNODB STATUS \\G之Pages flushed up to的理解](http://blog.itpub.net/30221425/viewspace-2154670/)","slug":"MySQL-InnoDB事务的实现","published":1,"updated":"2020-09-23T07:10:50.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabmw005v45g34qnvddp8","content":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h3><p>事务隔离性由<code>锁</code>来实现。原子性，一致性，持久性通过数据库的<code>redo log</code>和<code>undo log</code>来实现.</p>\n<a id=\"more\"></a>\n\n<ul>\n<li><code>redo log(重做日志)</code>： <u>用于保证事务的原子性和持久性</u>。redo恢复提交事务修改的页操作，通常是<code>物理日志</code>，记录的是页的物理修改操作。</li>\n<li><code>undo log(撤销日志)</code>： <u>用于保证事务的一致性</u>。undo回滚行记录到某个特定版本，是<code>逻辑日志</code>。根据每行记录进行记录。</li>\n</ul>\n<p>InnoDB是事务的存储引擎，通过<code>Force Log at Commit机制</code>实现事务的持久性。即<u>当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的提交操作完成才算完成</u>。这里的日志指重做日志，在InnoDB存储引擎中,包括redo log和undo log。</p>\n<h3 id=\"2-redo-log\"><a href=\"#2-redo-log\" class=\"headerlink\" title=\"2 redo log\"></a>2 redo log</h3><p><strong>redo log用来保证事务的持久性</strong>。其组成包含以下两个部分:</p>\n<ul>\n<li><code>redo log buffer(重做日志缓冲)</code>：保存在内存中，属于掉电易失的.</li>\n<li><code>redo log file(重做日志文件)</code>：保存在磁盘中，属于持久的.</li>\n</ul>\n<p>redo log基本上都是顺序写，<u>在数据库运行时不需要对redo log的文件进行读取操作</u>。</p>\n<p>为了确保每次日志都写入<code>redo log file</code>中，在每次将<code>redo log buffer</code>写入文件后，InnoDB存储引擎都需要调用一次<strong>fsync操作</strong>。</p>\n<p>(<em>注：重做日志文件打开并没有使用O_DIRECT选项，因此<code>redo log buffer</code>中的数据会先写入文件系统缓存．为了保证重做日志写入磁盘,必须进行一次fsync操作．其中fsync的效率取决于磁盘的性能,因此磁盘的性能决定了事务提交的性能，即数据库的性能</em>)</p>\n<p>参数<code>innodb_flush_log_at_trx_commit</code>用于控制redo log刷新到磁盘的策略。该参数可设置的为包括:</p>\n<ul>\n<li>0：表示事务提交时不进行写入重做日志操作，仅在master thread中每1秒进行一次fsync操作。</li>\n<li>1：表示事务提交时必须调用一次fsync操作。（默认）</li>\n<li>2：表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。</li>\n</ul>\n<p>注：<u>设置<code>innodb_flush_log_at_trx_commit</code>为0或2可以提高事务的性能，但这种方式丧失了事务的ACID特性.</u></p>\n<h4 id=\"2-1-扩展-二进制日志-Bin-log\"><a href=\"#2-1-扩展-二进制日志-Bin-log\" class=\"headerlink\" title=\"2.1 扩展: 二进制日志(Bin log)\"></a>2.1 扩展: 二进制日志(Bin log)</h4><p>MySQL数据库中还有一种二进制日志(binlog)，用来进行<code>POINT-IN-TIME(PIT)</code>的恢复及<code>主从复制(Replication)</code>环境的建立.</p>\n<h5 id=\"2-1-1-Bin-log与Redo-log的区别\"><a href=\"#2-1-1-Bin-log与Redo-log的区别\" class=\"headerlink\" title=\"2.1.1 Bin log与Redo log的区别?\"></a>2.1.1 Bin log与Redo log的区别?</h5><ul>\n<li>日志产生的地方不同.<ul>\n<li><code>Redo log是在InnoDB存储引擎层产生</code>.</li>\n<li><code>Bin log是在MySQL数据库的上层（服务层）产生的</code>，Binlog不仅是针对InnoDB存储引擎，MySQL数据库中任何存储引擎对于数据库的更改都会产生二进制日志.</li>\n</ul>\n</li>\n<li>日志记录的内容形式不同.<ul>\n<li><code>Bin log是一种逻辑日志</code>，<u>记录的是对应SQL语句</u>.</li>\n<li><code>InnoDB的Redo log时物理格式的日志</code>，<u>记录的时对于每个页的修改</u>.</li>\n</ul>\n</li>\n<li>日志写入磁盘的时间点不同.<ul>\n<li>Bin log只在事务提交完成后进行<strong>一次写入</strong>，且对于每一个事务，仅包含对应事务的一个日志（<code>即一个事务对应一个binlog日志</code>）。</li>\n<li>InnoDB的Redo log是在事务进行中<strong>不断的被写入</strong>，因此日志不是随事务提交顺序写入的。其记录的是物理操作日志，因此每个事务对应多个日志条目，且是并发的，并非在事务提交时写入，故其在文件中记录的顺序并非是事务开始的顺序。<em>T1、</em>T2、*T3表示的是事务提交时的日志。</li>\n</ul>\n</li>\n</ul>\n<p>如下图所示:<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9%E4%B8%8D%E5%90%8C.png\" alt=\"日志写入磁盘的时间点不同\"></p>\n<h4 id=\"2-2-Log-block\"><a href=\"#2-2-Log-block\" class=\"headerlink\" title=\"2.2 Log block\"></a>2.2 Log block</h4><p><code>在InnoDB存储引擎中，重做日志都是以512字节进行存储的</code>。其<u><code>redo log buffer</code>、<code>redo log file</code>都是以<code>块（block）</code>的方式进行保存的，称之为<strong>重做日志块（redo log block）</strong>，每块大小为512字节。</u></p>\n<p>若一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储，由于重做日志快的大小和磁盘扇区大小一样，都是512字节，因此重做日志的写入可以保证原子性，不需要double write技术。</p>\n<p><code>重做日志块缓存的结构</code>如下：<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E5%9D%97%E7%BC%93%E5%AD%98%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"重做日志块缓存的结构\"></p>\n<p><code>LOG_BLOCK_FIRST_REC_GROUP示例</code>：<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/LOG_BLOCK_FIRST_REC_GROUP.png\" alt=\"LOG_BLOCK_FIRST_REC_GROUP\"></p>\n<h4 id=\"2-3-Log-group\"><a href=\"#2-3-Log-group\" class=\"headerlink\" title=\"2.3 Log group\"></a>2.3 Log group</h4><p><code>Log group</code>为<strong>重做日志组</strong>，<u>其中有多个redo log file</u>。虽然源码中一直有log group的镜像功能，但在ha_innobase.cc文件中禁止了该功能。<strong>因此InnoDB存储引擎实际只有一个log group。</strong>（Log group是一个逻辑上的概念，并没有一个实际存储的物理文件来表示log group信息。）</p>\n<p>Redo log file中存储的是Log buffer中保存的log block，因此Redo log file也是根据块的方式进行物理存储的管理，每个块的大小也是512字节。在InnoDB存储引擎运行过程，log buffer根据一定的规则将内存中的log block刷新到磁盘。</p>\n<p><strong>具体刷盘规则</strong>如下：</p>\n<ul>\n<li><code>事务提交时。</code></li>\n<li><code>当log buffer中有一半的内存空间已经被使用时。</code></li>\n<li><code>log checkpoint时</code>。</li>\n</ul>\n<p><u><strong>写入Redo log file的方式</strong>是<code>Append（追加）</code>，当一个文件被写满时，会接着写入下一个文件，其使用方式为：<strong>round-robin（轮询调度算法）</strong>。</u></p>\n<p>Redo log file中除了保存log buffer刷新到磁盘的log block，还保存了2KB大小的其他信息，因此对redo log file的写入并不是完全顺序的。针对log group中第一个redo log file，其前2KB的部分保存了4个512字节大小的块。（注：只有每个log group的第一个redo log file中才有2KB的其他信息。其余redo log file仅保留这些空间，但不保存。）</p>\n<p><code>Log group与Redo log file的关系图</code>如下：</p>\n<p>![Log group与Redo log file的关系图](<a href=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/Log\">https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Log</a> group与Redo log file的关系图.png)</p>\n<h4 id=\"2-4-重做日志格式\"><a href=\"#2-4-重做日志格式\" class=\"headerlink\" title=\"2.4 重做日志格式\"></a>2.4 重做日志格式</h4><p>不同的数据库操作会有对应的重做日志格式。<u>InnoDB存储引擎的存储管理是基于页的，所以重做日志格式也是基于页的</u>。虽然有不同的重做日志格式，但他们有着通用的头部格式，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F.png\" alt=\"重做日志格式\"></p>\n<p>对于页上记录的<code>插入</code>和<code>删除</code>操作，其格式如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E9%A1%B5%E4%B8%8A%E8%AE%B0%E5%BD%95%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%A0%BC%E5%BC%8F.png\" alt=\"页上记录的插入和删除操作格式\"></p>\n<h4 id=\"2-5-LSN（日志序列号）\"><a href=\"#2-5-LSN（日志序列号）\" class=\"headerlink\" title=\"2.5 LSN（日志序列号）\"></a>2.5 LSN（日志序列号）</h4><p>在InnoDB存储引擎中，LSN占用8个字节，并且单调递增，其表示的含义有：</p>\n<ul>\n<li>重做日志写入的总量<ul>\n<li>LSN记录的是重做日志的总量，其单位为字节。</li>\n</ul>\n</li>\n<li>Checkpoint的位置</li>\n<li>页的版本<ul>\n<li>在每个页的头部，有一个FIL_PAGE_LSN，记录了该页的LSN。在页中，LSN表示该页最后刷新时LSN的大小。因为重做日志记录的是每个页的日志，因此页中的LSN用来判断页是否需要进行恢复操作。</li>\n</ul>\n</li>\n</ul>\n<p><code>示例</code>：</p>\n<p>页P1的LSN为10000，而数据库启动时，InnoDB检测到写入重做日志中的LSN为13000，并且该事务已经提交，那么数据需要进行恢复操作，将重做日志应用到P1页中。同样的对于重做日志中LSN小于P1页的LSN，不需要进行重做，因为P1页中LSN表示页已经被刷新到该位置.</p>\n<p>通过<code>SHOW ENGINE INNODB STATUS</code>查看LSN的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engine innodb status\\g;</span><br><span class=\"line\">...</span><br><span class=\"line\">---</span><br><span class=\"line\">LOG</span><br><span class=\"line\">---</span><br><span class=\"line\">Log sequence number 11795911</span><br><span class=\"line\">Log flushed up to   11795911</span><br><span class=\"line\">Pages flushed up to 11795911</span><br><span class=\"line\">Last checkpoint at  11795902</span><br><span class=\"line\">0 pending log flushes, 0 pending chkp writes</span><br><span class=\"line\">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class=\"line\">...</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li><code>Log sequence number</code>：表示当前LSN</li>\n<li><code>Log flushed up to</code>：表示刷新到重做日志文件的LSN.</li>\n<li><code>Last checkpoint at</code>：表示刷新到磁盘的LSN</li>\n</ul>\n<p>其中以上三个参数可能是不同的，因为在一个事务中从日志缓冲刷新到重做日志文件并不只是在事务提交时发生，每秒都会有从日志缓冲刷新到重做日志文件的动作。</p>\n<h4 id=\"2-6-恢复\"><a href=\"#2-6-恢复\" class=\"headerlink\" title=\"2.6 恢复\"></a>2.6 恢复</h4><p>InnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试进行恢复操作。由于checkpoint表示已经刷新到磁盘上的LSN，因此在恢复过程中仅需恢复checkpoint开始的日志部分。</p>\n<p><code>示例</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%81%A2%E5%A4%8D%E7%9A%84%E4%BE%8B%E5%AD%90.png\" alt=\"恢复的例子\"></p>\n<h3 id=\"3-undo-log\"><a href=\"#3-undo-log\" class=\"headerlink\" title=\"3 undo log\"></a>3 undo log</h3><h4 id=\"3-1-基本概念\"><a href=\"#3-1-基本概念\" class=\"headerlink\" title=\"3.1 基本概念\"></a>3.1 基本概念</h4><p><strong>undo log的作用</strong>：</p>\n<ul>\n<li><code>帮助事务回滚</code>；</li>\n<li><code>MVCC功能</code>．</li>\n</ul>\n<h5 id=\"3-1-1-undo-log帮助事务回滚\"><a href=\"#3-1-1-undo-log帮助事务回滚\" class=\"headerlink\" title=\"3.1.1 undo log帮助事务回滚\"></a>3.1.1 undo log帮助事务回滚</h5><p>在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。当用户执行事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。</p>\n<p>redo存放在重做日志文件中，而undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment）。<u>undo段位于共享表空间内</u>。</p>\n<p><strong>undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子</strong>。当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。</p>\n<ul>\n<li><code>对于每个INSERT，InnoDB存储引擎会完成一个DELETE</code>；</li>\n<li><code>对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE,将修改前的行放回去</code>。</li>\n</ul>\n<h5 id=\"3-1-2-undo-log用于MVCC\"><a href=\"#3-1-2-undo-log用于MVCC\" class=\"headerlink\" title=\"3.1.2 undo log用于MVCC\"></a>3.1.2 undo log用于MVCC</h5><p>除了回滚操作，undo的另一个作用是MVCC，即在InnoDB存储引擎中的MVCC的是通过undo来完成的。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此<strong>实现非锁定读取</strong>。</p>\n<p><em>注：undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</em></p>\n<h4 id=\"3-2-undo存储管理\"><a href=\"#3-2-undo存储管理\" class=\"headerlink\" title=\"3.2 undo存储管理\"></a>3.2 undo存储管理</h4><p>InnoDB存储引擎对undo的管理同样采用段的方式。InnoDB存储引擎有<code>rollback segment</code>，每个回滚段中记录了1024个<code>undo log segment</code>，而在每个undo log segment段中进行undo页的申请。共享表空间偏移量为5的页（0，5）记录了所有<code>rollback segment header</code>所在的页，这个页的类型为<code>FIL_PAGE_TYPE_SYS</code>。</p>\n<p>从InnoDB1.2版本开始，可通过参数对rollback segment做进一步设置。其中包含：</p>\n<ul>\n<li><code>innodb_undo_directory</code>：用于设置rollback segment文件所在路径，默认值为＂．＂，表示当前InnoDB存储引擎的目录。</li>\n<li><code>innodb_undo_logs</code>：用于设置rollback segment的个数，默认值为128.</li>\n<li><code>innodb_undo_tabklespaces</code>：用于设置构成rollback segment文件的数量，这样rollback segment可以较为平均地分不到多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件。如下所示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;innodb_undo%&#39;;</span><br><span class=\"line\">+--------------------------+-------+</span><br><span class=\"line\">| Variable_name            | Value |</span><br><span class=\"line\">+--------------------------+-------+</span><br><span class=\"line\">| innodb_undo_directory    | .&#x2F;    |</span><br><span class=\"line\">| innodb_undo_log_truncate | OFF   |</span><br><span class=\"line\">| innodb_undo_logs         | 128   |</span><br><span class=\"line\">| innodb_undo_tablespaces  | 0     |</span><br><span class=\"line\">+--------------------------+-------+</span><br><span class=\"line\">4 rows in set (0.03 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show variables like &#39;datadir&#39;;</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">| Variable_name | Value           |</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; system ls -lh &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;undo*;</span><br><span class=\"line\">ls: error initializing month strings</span><br><span class=\"line\">ls: cannot access &#39;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;undo*&#39;: Permission denied</span><br></pre></td></tr></table></figure>\n\n<p><u>注：事务在undo log segment分配页并写入undo log的这个过程同样需要写入重做日志。</u></p>\n<p><strong>Q1：当事务提交时，InnoDB存储引擎会做什么操作？</strong></p>\n<p>当事务提交时，InooDB会做以下两种操作：</p>\n<ul>\n<li>①、将undo log放入链表中，以供之后的purge操作</li>\n<li>②、判断undo log所在的页是否可以重用，若可以分配给下个事务使用。</li>\n</ul>\n<p><strong>Q2：为什么事务提交后并不能马上删除undo log及undo log所在的页？</strong></p>\n<p>因为此时可能还有其他事务需要通过undo log来的到行记录之前的版本。当事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。</p>\n<p>由于事务提交时，可能并不能马上释放页，在大量更新删除操作的情况下会非常浪费存储空间。因此InnoDB存储引擎在设计中对undo页也可以重用。其<strong>具体重用方式如下</strong>：</p>\n<ul>\n<li>①、当事务提交时，首先将undo log放入链表中。</li>\n<li>②、判断undo页的使用空间是否小于3/4，若是，则表示undo页可以被重用，之后新的undo log记录可能存放在当前undo log的后面。</li>\n</ul>\n<p>注：<u>存放undo log链表是以记录进行组织的，而undo页可能存放着不同事务的undo log，因此purge操作需要设计磁盘的离散读取操作，是一个比较缓慢的过程。</u></p>\n<p>可以通过<code>SHOW ENGINE INNODB STATUS</code>来查看链表中undo log的数量，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engine innodb status\\g;</span><br><span class=\"line\">...</span><br><span class=\"line\">------------</span><br><span class=\"line\">TRANSACTIONS</span><br><span class=\"line\">------------</span><br><span class=\"line\">Trx id counter 1795</span><br><span class=\"line\">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class=\"line\">History list length 0</span><br><span class=\"line\">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class=\"line\">---TRANSACTION 422058470606688, not started</span><br><span class=\"line\">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>History list length</code>表示undo log的数量，这里为0．purge操作会减少该值，然而由于undo log所在的页可以被重用，因此即使操作发生，History list length的值也可能不为0。</p>\n<h4 id=\"3-3-undo-log格式\"><a href=\"#3-3-undo-log格式\" class=\"headerlink\" title=\"3.3 undo log格式\"></a>3.3 undo log格式</h4><p>在InnoDB存储引擎中，undo log分为：</p>\n<ul>\n<li>①、<code>insert undo log</code> </li>\n<li>②、<code>update undo log</code></li>\n</ul>\n<h5 id=\"3-3-1-Insert-undo-log\"><a href=\"#3-3-1-Insert-undo-log\" class=\"headerlink\" title=\"3.3.1 Insert undo log\"></a>3.3.1 Insert undo log</h5><p><strong>Insert undo log</strong>是指在<code>insert</code>操作中产生的undo log。因为insert操作记录，只针对事务本身可见，对其他事务不可见（这是事务隔离性的要求），所以<u>insert undo log可以在事务提交后直接删除。不需要进行purge操作。</u></p>\n<p><strong>Insert undo log的格式</strong>如下：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Insert-undo-log.png\" alt=\"Insert-undo-log\" style=\"zoom: 67%;\" />\n\n<h5 id=\"3-3-2-Update-undo-log\"><a href=\"#3-3-2-Update-undo-log\" class=\"headerlink\" title=\"3.3.2 Update undo log\"></a>3.3.2 Update undo log</h5><p><strong>Update undo log</strong>记录的是对<code>delete</code>和<code>update</code>操作产生的undo log。该<u>undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</u></p>\n<p>Update undo log相对于Insert Undo log记录的内容更多，所需占用的空间更大。其结构如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/Update-undo-log.png\" alt=\"Update-undo-log\"></p>\n<p>Type_cmpl，其可能的值包括：</p>\n<ul>\n<li>①、12：<code>TRX_UNDO_UPD_EXIST_REC</code>更新non-delete-mark的记录</li>\n<li>②、13：<code>TRX_UNDO_UPD_DEL_REC</code>将delete的记录标记为not delete</li>\n<li>③、14：<code>TRX_UNDO_DEL_MARK_REC</code>将记录标记为delete</li>\n</ul>\n<p>Update_vector信息表示update操作发生改变的列。每个修改的列信息都要记录到undo log中，对于不同的undo log类型，可能还需要记录对索引列所做的修改。</p>\n<h4 id=\"3-4-查看Undo-信息\"><a href=\"#3-4-查看Undo-信息\" class=\"headerlink\" title=\"3.4  查看Undo 信息\"></a>3.4  查看Undo 信息</h4><p>Oracle和Microsoft SQL Server数据库都是由内部的数据字典来观察当前undo的信息。InnoSQL对information_schema进行了扩展，添加了两张数据字典表，方便查看undo信息。涉及的字典表为：</p>\n<ul>\n<li>①、<code>INNODB_TRX_ROLLBACK_SEGMENT</code>：查看rollback segment</li>\n<li>②、<code>INNODB_TRX_UNDO</code>：查看记录事务对应undo log</li>\n</ul>\n<p>INNODB_TRX_ROLLBACK_SEGMENT 其表结构如下所示（<em>执行书上的命令时发现字典不存在…？？？？？？</em>）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; desc INNODB_TRX_ROLLBACK_SEGMENT;</span><br><span class=\"line\">ERROR 1146 (42S02): Table &#39;sys.INNODB_TRX_ROLLBACK_SEGMENT&#39; doesn&#39;t exist</span><br></pre></td></tr></table></figure>\n\n\n\n<p>按照书中演示的使用INNODB_TRX_UNDO表</p>\n<ul>\n<li>①、创建测试表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table t(a int,b varchar(32), primary key(a), key(b))engine&#x3D;innodb;</span><br><span class=\"line\">Query OK, 0 rows affected (0.09 sec)</span><br></pre></td></tr></table></figure>\n\n<p>②、插入一条记录，并尝试通过<code>INNODB_TRX_UNDO</code>观察该事务的undo log的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t select 1, &#39;1&#39;;</span><br><span class=\"line\">Query OK, 1 row affected (0.01 sec)</span><br><span class=\"line\">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from information_schema.INNODB_TRX_UNDO\\G;</span><br><span class=\"line\">ERROR 1109 (42S02): Unknown table &#39;INNODB_TRX_UNDO&#39; in information_schema</span><br></pre></td></tr></table></figure>\n\n<p>阿西吧，此时发现该字典表也不存在….?????????</p>\n<p>Delete操作并不直接删除记录，而只是将记录标记为已删除，也就是将记录的delete flag设置为1。而记录最终的删除是在purge操作中完成的。</p>\n<p>Update操作实际分为两步：</p>\n<ul>\n<li>①、首先将原主键记录标记为已删除，因此需产生一个类型为TRX_UNDO_DEL_MARK_REC的undo log。</li>\n<li>②、然后插入一条新的记录，因此需要产生一个类型为TRX_UNDO_INSERT_REC的undo log。</li>\n</ul>\n<h3 id=\"4-Purge\"><a href=\"#4-Purge\" class=\"headerlink\" title=\"4 Purge\"></a>4 Purge</h3><p><strong>Purge用于最终完成delete和update操作</strong>，<u>这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即处理</u>。其操作示例如下图所示：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/undo-log与history列表的关系.png\" alt=\"undo-log与history列表的关系\" style=\"zoom:67%;\" />\n\n<p>Innodb提供了一个全局动态参数用于控制purge操作：</p>\n<ul>\n<li>①、<code>innodb_purge_batch_size</code>：用于设置每次purge操作需要清理的undo page数量，默认值为300。推荐采用默认值。</li>\n<li>②、<code>innodb_max_purge_lag</code>：用于控制history list的长度，若长度大于该参数，其会延缓”DML“的操作。该参数默认值为0，表示不对history list做任何限制。当大于0时，就会延缓DML的操作，其延缓单位为毫秒，延缓算法为：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delay &#x3D; ((length(history_list) - innodb_max_purge_lag) * 10) - 5</span><br></pre></td></tr></table></figure>\n\n<p>注：delay的对象是行，而不是一个DML操作，即假设update操作5行数据时，总延时时间为5*delay。</p>\n<ul>\n<li>③、<code>innodb_max_purge_lag_delay</code>：要求版本大于InooDB1.2版本，用于控制delay的最大毫秒数。即当计算的delay值大于此参数时，将delay设置为此参数，避免由于purge操作缓慢导致其他SQL线程出现无限制的等待。</li>\n</ul>\n<h3 id=\"5-Group-Commit\"><a href=\"#5-Group-Commit\" class=\"headerlink\" title=\"5 Group Commit\"></a>5 Group Commit</h3><p><strong>Group commit</strong>操作<u>用于提高磁盘fsync的效率，即一次fsync操作可以刷新确保多个事务日志被写入文件。</u></p>\n<p>对于InnoDB存储引擎，事务提交时会进行两个阶段的操作：</p>\n<ul>\n<li>①、修改内存中事务对应的信息，并将日志写入重做日志缓冲。</li>\n<li>②、调用<code>fsync</code>将去把日志都从重做日志缓冲写入磁盘。</li>\n</ul>\n<p>其中第②步较慢，因此存储引擎需要和磁盘打交道。对于在执行第②段操作时，其他的事务可以进行第一段操作，然后将多个事务的重做日志通过一次fsync刷新到磁盘，大大减少磁盘的压力，提高数据库性能。对于Insert和update较为明显的操作，Group Commit的效果尤为明显。</p>\n<p><strong>Q3：在InnoDB1.2版本以后，在开启二进制日志后，InnoDB的Group Commit功能会实现，导致性能下降，其原因为？</strong></p>\n<p>导致这个问题的原因在于开启二进制日志后，为了保证存储引擎层中的事务和二进制日志的一致性，二者之前使用两阶段事务，其步骤如下：</p>\n<ul>\n<li><p>①、当事务提交时，InnoDB存储引擎进行prepare操作。</p>\n</li>\n<li><p>②、Mysql数据库上层写二进制日志。（一旦这一步提交，就确保了事务的提交，即使在第③步中发生了宕机。）（这一步由参数<code>sync_binlog</code>控制）</p>\n</li>\n<li><p>③、InnoDB存储引擎层将日志写入重做日志文件。（这一步的<code>fsync</code>由参数<code>innodb_flush_log_at_trx_commit</code>控制）</p>\n</li>\n<li><ul>\n<li>a、修改内存中事务对应的信息，并将日志写入重做日志缓冲。</li>\n<li>b、调用fsync将确保日志都从重做日志缓冲写入磁盘。</li>\n</ul>\n</li>\n</ul>\n<p><em>注：每个步骤都需要fsync操作才能保证上下两层数据的一致性。</em></p>\n<p>其整体过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%BC%80%E5%90%AF%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E5%90%8EInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B.png\" alt=\"开启二进制日志后InnoDB存储引擎的提交过程\"></p>\n<p>为了保证二进制日志的写入顺序与InnoDB层的事务提交顺序一致，Mysql数据库内部使用了<code>prepare_commit_mutex</code>锁，当开启这个锁后，步骤③中的a将不可以在其他事务中执行步骤b，从而导致了Group Commit失效。</p>\n<p><strong>Q4：如何解决Q3的问题？</strong></p>\n<p>Mysql5.6采用了<code>Binary Log Group Commit（BLGC）</code>的方式<u>将事务提交的过程采用三段式提交方式</u>，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/BLGC.png\" alt=\"BLGC\"></p>\n<p>当有一组事务在今次那个Commit阶段时，其他新事物可以进行Flush阶段，从而使Group Commit不断生效。</p>\n<p>InnoDB提供了一些参数用于控制Bin log提交：</p>\n<p>①、<code>binlog_max_flush_quenue_time</code>：用于控制Flush阶段中等待的时间，即使之前一组事务完成提交，当前一组事务也不马上进入Sync阶段，而是至少等待一端时间，这样做的好处是Group Commit的事务数量更过，缺点是可能会导致事务的响应时间变量。默认值为0，且不建议修改。</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>MySQL技术内幕+InnoDB存储引擎第2版(7.2节)</li>\n<li><a href=\"http://blog.itpub.net/30221425/viewspace-2154670/\">SHOW ENGINE INNODB STATUS \\G之Pages flushed up to的理解</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h3><p>事务隔离性由<code>锁</code>来实现。原子性，一致性，持久性通过数据库的<code>redo log</code>和<code>undo log</code>来实现.</p>","more":"<ul>\n<li><code>redo log(重做日志)</code>： <u>用于保证事务的原子性和持久性</u>。redo恢复提交事务修改的页操作，通常是<code>物理日志</code>，记录的是页的物理修改操作。</li>\n<li><code>undo log(撤销日志)</code>： <u>用于保证事务的一致性</u>。undo回滚行记录到某个特定版本，是<code>逻辑日志</code>。根据每行记录进行记录。</li>\n</ul>\n<p>InnoDB是事务的存储引擎，通过<code>Force Log at Commit机制</code>实现事务的持久性。即<u>当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的提交操作完成才算完成</u>。这里的日志指重做日志，在InnoDB存储引擎中,包括redo log和undo log。</p>\n<h3 id=\"2-redo-log\"><a href=\"#2-redo-log\" class=\"headerlink\" title=\"2 redo log\"></a>2 redo log</h3><p><strong>redo log用来保证事务的持久性</strong>。其组成包含以下两个部分:</p>\n<ul>\n<li><code>redo log buffer(重做日志缓冲)</code>：保存在内存中，属于掉电易失的.</li>\n<li><code>redo log file(重做日志文件)</code>：保存在磁盘中，属于持久的.</li>\n</ul>\n<p>redo log基本上都是顺序写，<u>在数据库运行时不需要对redo log的文件进行读取操作</u>。</p>\n<p>为了确保每次日志都写入<code>redo log file</code>中，在每次将<code>redo log buffer</code>写入文件后，InnoDB存储引擎都需要调用一次<strong>fsync操作</strong>。</p>\n<p>(<em>注：重做日志文件打开并没有使用O_DIRECT选项，因此<code>redo log buffer</code>中的数据会先写入文件系统缓存．为了保证重做日志写入磁盘,必须进行一次fsync操作．其中fsync的效率取决于磁盘的性能,因此磁盘的性能决定了事务提交的性能，即数据库的性能</em>)</p>\n<p>参数<code>innodb_flush_log_at_trx_commit</code>用于控制redo log刷新到磁盘的策略。该参数可设置的为包括:</p>\n<ul>\n<li>0：表示事务提交时不进行写入重做日志操作，仅在master thread中每1秒进行一次fsync操作。</li>\n<li>1：表示事务提交时必须调用一次fsync操作。（默认）</li>\n<li>2：表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。</li>\n</ul>\n<p>注：<u>设置<code>innodb_flush_log_at_trx_commit</code>为0或2可以提高事务的性能，但这种方式丧失了事务的ACID特性.</u></p>\n<h4 id=\"2-1-扩展-二进制日志-Bin-log\"><a href=\"#2-1-扩展-二进制日志-Bin-log\" class=\"headerlink\" title=\"2.1 扩展: 二进制日志(Bin log)\"></a>2.1 扩展: 二进制日志(Bin log)</h4><p>MySQL数据库中还有一种二进制日志(binlog)，用来进行<code>POINT-IN-TIME(PIT)</code>的恢复及<code>主从复制(Replication)</code>环境的建立.</p>\n<h5 id=\"2-1-1-Bin-log与Redo-log的区别\"><a href=\"#2-1-1-Bin-log与Redo-log的区别\" class=\"headerlink\" title=\"2.1.1 Bin log与Redo log的区别?\"></a>2.1.1 Bin log与Redo log的区别?</h5><ul>\n<li>日志产生的地方不同.<ul>\n<li><code>Redo log是在InnoDB存储引擎层产生</code>.</li>\n<li><code>Bin log是在MySQL数据库的上层（服务层）产生的</code>，Binlog不仅是针对InnoDB存储引擎，MySQL数据库中任何存储引擎对于数据库的更改都会产生二进制日志.</li>\n</ul>\n</li>\n<li>日志记录的内容形式不同.<ul>\n<li><code>Bin log是一种逻辑日志</code>，<u>记录的是对应SQL语句</u>.</li>\n<li><code>InnoDB的Redo log时物理格式的日志</code>，<u>记录的时对于每个页的修改</u>.</li>\n</ul>\n</li>\n<li>日志写入磁盘的时间点不同.<ul>\n<li>Bin log只在事务提交完成后进行<strong>一次写入</strong>，且对于每一个事务，仅包含对应事务的一个日志（<code>即一个事务对应一个binlog日志</code>）。</li>\n<li>InnoDB的Redo log是在事务进行中<strong>不断的被写入</strong>，因此日志不是随事务提交顺序写入的。其记录的是物理操作日志，因此每个事务对应多个日志条目，且是并发的，并非在事务提交时写入，故其在文件中记录的顺序并非是事务开始的顺序。<em>T1、</em>T2、*T3表示的是事务提交时的日志。</li>\n</ul>\n</li>\n</ul>\n<p>如下图所示:<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9%E4%B8%8D%E5%90%8C.png\" alt=\"日志写入磁盘的时间点不同\"></p>\n<h4 id=\"2-2-Log-block\"><a href=\"#2-2-Log-block\" class=\"headerlink\" title=\"2.2 Log block\"></a>2.2 Log block</h4><p><code>在InnoDB存储引擎中，重做日志都是以512字节进行存储的</code>。其<u><code>redo log buffer</code>、<code>redo log file</code>都是以<code>块（block）</code>的方式进行保存的，称之为<strong>重做日志块（redo log block）</strong>，每块大小为512字节。</u></p>\n<p>若一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储，由于重做日志快的大小和磁盘扇区大小一样，都是512字节，因此重做日志的写入可以保证原子性，不需要double write技术。</p>\n<p><code>重做日志块缓存的结构</code>如下：<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E5%9D%97%E7%BC%93%E5%AD%98%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"重做日志块缓存的结构\"></p>\n<p><code>LOG_BLOCK_FIRST_REC_GROUP示例</code>：<br><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/LOG_BLOCK_FIRST_REC_GROUP.png\" alt=\"LOG_BLOCK_FIRST_REC_GROUP\"></p>\n<h4 id=\"2-3-Log-group\"><a href=\"#2-3-Log-group\" class=\"headerlink\" title=\"2.3 Log group\"></a>2.3 Log group</h4><p><code>Log group</code>为<strong>重做日志组</strong>，<u>其中有多个redo log file</u>。虽然源码中一直有log group的镜像功能，但在ha_innobase.cc文件中禁止了该功能。<strong>因此InnoDB存储引擎实际只有一个log group。</strong>（Log group是一个逻辑上的概念，并没有一个实际存储的物理文件来表示log group信息。）</p>\n<p>Redo log file中存储的是Log buffer中保存的log block，因此Redo log file也是根据块的方式进行物理存储的管理，每个块的大小也是512字节。在InnoDB存储引擎运行过程，log buffer根据一定的规则将内存中的log block刷新到磁盘。</p>\n<p><strong>具体刷盘规则</strong>如下：</p>\n<ul>\n<li><code>事务提交时。</code></li>\n<li><code>当log buffer中有一半的内存空间已经被使用时。</code></li>\n<li><code>log checkpoint时</code>。</li>\n</ul>\n<p><u><strong>写入Redo log file的方式</strong>是<code>Append（追加）</code>，当一个文件被写满时，会接着写入下一个文件，其使用方式为：<strong>round-robin（轮询调度算法）</strong>。</u></p>\n<p>Redo log file中除了保存log buffer刷新到磁盘的log block，还保存了2KB大小的其他信息，因此对redo log file的写入并不是完全顺序的。针对log group中第一个redo log file，其前2KB的部分保存了4个512字节大小的块。（注：只有每个log group的第一个redo log file中才有2KB的其他信息。其余redo log file仅保留这些空间，但不保存。）</p>\n<p><code>Log group与Redo log file的关系图</code>如下：</p>\n<p>![Log group与Redo log file的关系图](<a href=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/Log\">https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Log</a> group与Redo log file的关系图.png)</p>\n<h4 id=\"2-4-重做日志格式\"><a href=\"#2-4-重做日志格式\" class=\"headerlink\" title=\"2.4 重做日志格式\"></a>2.4 重做日志格式</h4><p>不同的数据库操作会有对应的重做日志格式。<u>InnoDB存储引擎的存储管理是基于页的，所以重做日志格式也是基于页的</u>。虽然有不同的重做日志格式，但他们有着通用的头部格式，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F.png\" alt=\"重做日志格式\"></p>\n<p>对于页上记录的<code>插入</code>和<code>删除</code>操作，其格式如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E9%A1%B5%E4%B8%8A%E8%AE%B0%E5%BD%95%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%A0%BC%E5%BC%8F.png\" alt=\"页上记录的插入和删除操作格式\"></p>\n<h4 id=\"2-5-LSN（日志序列号）\"><a href=\"#2-5-LSN（日志序列号）\" class=\"headerlink\" title=\"2.5 LSN（日志序列号）\"></a>2.5 LSN（日志序列号）</h4><p>在InnoDB存储引擎中，LSN占用8个字节，并且单调递增，其表示的含义有：</p>\n<ul>\n<li>重做日志写入的总量<ul>\n<li>LSN记录的是重做日志的总量，其单位为字节。</li>\n</ul>\n</li>\n<li>Checkpoint的位置</li>\n<li>页的版本<ul>\n<li>在每个页的头部，有一个FIL_PAGE_LSN，记录了该页的LSN。在页中，LSN表示该页最后刷新时LSN的大小。因为重做日志记录的是每个页的日志，因此页中的LSN用来判断页是否需要进行恢复操作。</li>\n</ul>\n</li>\n</ul>\n<p><code>示例</code>：</p>\n<p>页P1的LSN为10000，而数据库启动时，InnoDB检测到写入重做日志中的LSN为13000，并且该事务已经提交，那么数据需要进行恢复操作，将重做日志应用到P1页中。同样的对于重做日志中LSN小于P1页的LSN，不需要进行重做，因为P1页中LSN表示页已经被刷新到该位置.</p>\n<p>通过<code>SHOW ENGINE INNODB STATUS</code>查看LSN的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engine innodb status\\g;</span><br><span class=\"line\">...</span><br><span class=\"line\">---</span><br><span class=\"line\">LOG</span><br><span class=\"line\">---</span><br><span class=\"line\">Log sequence number 11795911</span><br><span class=\"line\">Log flushed up to   11795911</span><br><span class=\"line\">Pages flushed up to 11795911</span><br><span class=\"line\">Last checkpoint at  11795902</span><br><span class=\"line\">0 pending log flushes, 0 pending chkp writes</span><br><span class=\"line\">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class=\"line\">...</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li><code>Log sequence number</code>：表示当前LSN</li>\n<li><code>Log flushed up to</code>：表示刷新到重做日志文件的LSN.</li>\n<li><code>Last checkpoint at</code>：表示刷新到磁盘的LSN</li>\n</ul>\n<p>其中以上三个参数可能是不同的，因为在一个事务中从日志缓冲刷新到重做日志文件并不只是在事务提交时发生，每秒都会有从日志缓冲刷新到重做日志文件的动作。</p>\n<h4 id=\"2-6-恢复\"><a href=\"#2-6-恢复\" class=\"headerlink\" title=\"2.6 恢复\"></a>2.6 恢复</h4><p>InnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试进行恢复操作。由于checkpoint表示已经刷新到磁盘上的LSN，因此在恢复过程中仅需恢复checkpoint开始的日志部分。</p>\n<p><code>示例</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%81%A2%E5%A4%8D%E7%9A%84%E4%BE%8B%E5%AD%90.png\" alt=\"恢复的例子\"></p>\n<h3 id=\"3-undo-log\"><a href=\"#3-undo-log\" class=\"headerlink\" title=\"3 undo log\"></a>3 undo log</h3><h4 id=\"3-1-基本概念\"><a href=\"#3-1-基本概念\" class=\"headerlink\" title=\"3.1 基本概念\"></a>3.1 基本概念</h4><p><strong>undo log的作用</strong>：</p>\n<ul>\n<li><code>帮助事务回滚</code>；</li>\n<li><code>MVCC功能</code>．</li>\n</ul>\n<h5 id=\"3-1-1-undo-log帮助事务回滚\"><a href=\"#3-1-1-undo-log帮助事务回滚\" class=\"headerlink\" title=\"3.1.1 undo log帮助事务回滚\"></a>3.1.1 undo log帮助事务回滚</h5><p>在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。当用户执行事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。</p>\n<p>redo存放在重做日志文件中，而undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment）。<u>undo段位于共享表空间内</u>。</p>\n<p><strong>undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子</strong>。当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。</p>\n<ul>\n<li><code>对于每个INSERT，InnoDB存储引擎会完成一个DELETE</code>；</li>\n<li><code>对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE,将修改前的行放回去</code>。</li>\n</ul>\n<h5 id=\"3-1-2-undo-log用于MVCC\"><a href=\"#3-1-2-undo-log用于MVCC\" class=\"headerlink\" title=\"3.1.2 undo log用于MVCC\"></a>3.1.2 undo log用于MVCC</h5><p>除了回滚操作，undo的另一个作用是MVCC，即在InnoDB存储引擎中的MVCC的是通过undo来完成的。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此<strong>实现非锁定读取</strong>。</p>\n<p><em>注：undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</em></p>\n<h4 id=\"3-2-undo存储管理\"><a href=\"#3-2-undo存储管理\" class=\"headerlink\" title=\"3.2 undo存储管理\"></a>3.2 undo存储管理</h4><p>InnoDB存储引擎对undo的管理同样采用段的方式。InnoDB存储引擎有<code>rollback segment</code>，每个回滚段中记录了1024个<code>undo log segment</code>，而在每个undo log segment段中进行undo页的申请。共享表空间偏移量为5的页（0，5）记录了所有<code>rollback segment header</code>所在的页，这个页的类型为<code>FIL_PAGE_TYPE_SYS</code>。</p>\n<p>从InnoDB1.2版本开始，可通过参数对rollback segment做进一步设置。其中包含：</p>\n<ul>\n<li><code>innodb_undo_directory</code>：用于设置rollback segment文件所在路径，默认值为＂．＂，表示当前InnoDB存储引擎的目录。</li>\n<li><code>innodb_undo_logs</code>：用于设置rollback segment的个数，默认值为128.</li>\n<li><code>innodb_undo_tabklespaces</code>：用于设置构成rollback segment文件的数量，这样rollback segment可以较为平均地分不到多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件。如下所示：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;innodb_undo%&#39;;</span><br><span class=\"line\">+--------------------------+-------+</span><br><span class=\"line\">| Variable_name            | Value |</span><br><span class=\"line\">+--------------------------+-------+</span><br><span class=\"line\">| innodb_undo_directory    | .&#x2F;    |</span><br><span class=\"line\">| innodb_undo_log_truncate | OFF   |</span><br><span class=\"line\">| innodb_undo_logs         | 128   |</span><br><span class=\"line\">| innodb_undo_tablespaces  | 0     |</span><br><span class=\"line\">+--------------------------+-------+</span><br><span class=\"line\">4 rows in set (0.03 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show variables like &#39;datadir&#39;;</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">| Variable_name | Value           |</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; system ls -lh &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;undo*;</span><br><span class=\"line\">ls: error initializing month strings</span><br><span class=\"line\">ls: cannot access &#39;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;undo*&#39;: Permission denied</span><br></pre></td></tr></table></figure>\n\n<p><u>注：事务在undo log segment分配页并写入undo log的这个过程同样需要写入重做日志。</u></p>\n<p><strong>Q1：当事务提交时，InnoDB存储引擎会做什么操作？</strong></p>\n<p>当事务提交时，InooDB会做以下两种操作：</p>\n<ul>\n<li>①、将undo log放入链表中，以供之后的purge操作</li>\n<li>②、判断undo log所在的页是否可以重用，若可以分配给下个事务使用。</li>\n</ul>\n<p><strong>Q2：为什么事务提交后并不能马上删除undo log及undo log所在的页？</strong></p>\n<p>因为此时可能还有其他事务需要通过undo log来的到行记录之前的版本。当事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在页由purge线程来判断。</p>\n<p>由于事务提交时，可能并不能马上释放页，在大量更新删除操作的情况下会非常浪费存储空间。因此InnoDB存储引擎在设计中对undo页也可以重用。其<strong>具体重用方式如下</strong>：</p>\n<ul>\n<li>①、当事务提交时，首先将undo log放入链表中。</li>\n<li>②、判断undo页的使用空间是否小于3/4，若是，则表示undo页可以被重用，之后新的undo log记录可能存放在当前undo log的后面。</li>\n</ul>\n<p>注：<u>存放undo log链表是以记录进行组织的，而undo页可能存放着不同事务的undo log，因此purge操作需要设计磁盘的离散读取操作，是一个比较缓慢的过程。</u></p>\n<p>可以通过<code>SHOW ENGINE INNODB STATUS</code>来查看链表中undo log的数量，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engine innodb status\\g;</span><br><span class=\"line\">...</span><br><span class=\"line\">------------</span><br><span class=\"line\">TRANSACTIONS</span><br><span class=\"line\">------------</span><br><span class=\"line\">Trx id counter 1795</span><br><span class=\"line\">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class=\"line\">History list length 0</span><br><span class=\"line\">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class=\"line\">---TRANSACTION 422058470606688, not started</span><br><span class=\"line\">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>History list length</code>表示undo log的数量，这里为0．purge操作会减少该值，然而由于undo log所在的页可以被重用，因此即使操作发生，History list length的值也可能不为0。</p>\n<h4 id=\"3-3-undo-log格式\"><a href=\"#3-3-undo-log格式\" class=\"headerlink\" title=\"3.3 undo log格式\"></a>3.3 undo log格式</h4><p>在InnoDB存储引擎中，undo log分为：</p>\n<ul>\n<li>①、<code>insert undo log</code> </li>\n<li>②、<code>update undo log</code></li>\n</ul>\n<h5 id=\"3-3-1-Insert-undo-log\"><a href=\"#3-3-1-Insert-undo-log\" class=\"headerlink\" title=\"3.3.1 Insert undo log\"></a>3.3.1 Insert undo log</h5><p><strong>Insert undo log</strong>是指在<code>insert</code>操作中产生的undo log。因为insert操作记录，只针对事务本身可见，对其他事务不可见（这是事务隔离性的要求），所以<u>insert undo log可以在事务提交后直接删除。不需要进行purge操作。</u></p>\n<p><strong>Insert undo log的格式</strong>如下：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/Insert-undo-log.png\" alt=\"Insert-undo-log\" style=\"zoom: 67%;\" />\n\n<h5 id=\"3-3-2-Update-undo-log\"><a href=\"#3-3-2-Update-undo-log\" class=\"headerlink\" title=\"3.3.2 Update undo log\"></a>3.3.2 Update undo log</h5><p><strong>Update undo log</strong>记录的是对<code>delete</code>和<code>update</code>操作产生的undo log。该<u>undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</u></p>\n<p>Update undo log相对于Insert Undo log记录的内容更多，所需占用的空间更大。其结构如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/Update-undo-log.png\" alt=\"Update-undo-log\"></p>\n<p>Type_cmpl，其可能的值包括：</p>\n<ul>\n<li>①、12：<code>TRX_UNDO_UPD_EXIST_REC</code>更新non-delete-mark的记录</li>\n<li>②、13：<code>TRX_UNDO_UPD_DEL_REC</code>将delete的记录标记为not delete</li>\n<li>③、14：<code>TRX_UNDO_DEL_MARK_REC</code>将记录标记为delete</li>\n</ul>\n<p>Update_vector信息表示update操作发生改变的列。每个修改的列信息都要记录到undo log中，对于不同的undo log类型，可能还需要记录对索引列所做的修改。</p>\n<h4 id=\"3-4-查看Undo-信息\"><a href=\"#3-4-查看Undo-信息\" class=\"headerlink\" title=\"3.4  查看Undo 信息\"></a>3.4  查看Undo 信息</h4><p>Oracle和Microsoft SQL Server数据库都是由内部的数据字典来观察当前undo的信息。InnoSQL对information_schema进行了扩展，添加了两张数据字典表，方便查看undo信息。涉及的字典表为：</p>\n<ul>\n<li>①、<code>INNODB_TRX_ROLLBACK_SEGMENT</code>：查看rollback segment</li>\n<li>②、<code>INNODB_TRX_UNDO</code>：查看记录事务对应undo log</li>\n</ul>\n<p>INNODB_TRX_ROLLBACK_SEGMENT 其表结构如下所示（<em>执行书上的命令时发现字典不存在…？？？？？？</em>）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; desc INNODB_TRX_ROLLBACK_SEGMENT;</span><br><span class=\"line\">ERROR 1146 (42S02): Table &#39;sys.INNODB_TRX_ROLLBACK_SEGMENT&#39; doesn&#39;t exist</span><br></pre></td></tr></table></figure>\n\n\n\n<p>按照书中演示的使用INNODB_TRX_UNDO表</p>\n<ul>\n<li>①、创建测试表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table t(a int,b varchar(32), primary key(a), key(b))engine&#x3D;innodb;</span><br><span class=\"line\">Query OK, 0 rows affected (0.09 sec)</span><br></pre></td></tr></table></figure>\n\n<p>②、插入一条记录，并尝试通过<code>INNODB_TRX_UNDO</code>观察该事务的undo log的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t select 1, &#39;1&#39;;</span><br><span class=\"line\">Query OK, 1 row affected (0.01 sec)</span><br><span class=\"line\">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from information_schema.INNODB_TRX_UNDO\\G;</span><br><span class=\"line\">ERROR 1109 (42S02): Unknown table &#39;INNODB_TRX_UNDO&#39; in information_schema</span><br></pre></td></tr></table></figure>\n\n<p>阿西吧，此时发现该字典表也不存在….?????????</p>\n<p>Delete操作并不直接删除记录，而只是将记录标记为已删除，也就是将记录的delete flag设置为1。而记录最终的删除是在purge操作中完成的。</p>\n<p>Update操作实际分为两步：</p>\n<ul>\n<li>①、首先将原主键记录标记为已删除，因此需产生一个类型为TRX_UNDO_DEL_MARK_REC的undo log。</li>\n<li>②、然后插入一条新的记录，因此需要产生一个类型为TRX_UNDO_INSERT_REC的undo log。</li>\n</ul>\n<h3 id=\"4-Purge\"><a href=\"#4-Purge\" class=\"headerlink\" title=\"4 Purge\"></a>4 Purge</h3><p><strong>Purge用于最终完成delete和update操作</strong>，<u>这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即处理</u>。其操作示例如下图所示：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB事务的实现/undo-log与history列表的关系.png\" alt=\"undo-log与history列表的关系\" style=\"zoom:67%;\" />\n\n<p>Innodb提供了一个全局动态参数用于控制purge操作：</p>\n<ul>\n<li>①、<code>innodb_purge_batch_size</code>：用于设置每次purge操作需要清理的undo page数量，默认值为300。推荐采用默认值。</li>\n<li>②、<code>innodb_max_purge_lag</code>：用于控制history list的长度，若长度大于该参数，其会延缓”DML“的操作。该参数默认值为0，表示不对history list做任何限制。当大于0时，就会延缓DML的操作，其延缓单位为毫秒，延缓算法为：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delay &#x3D; ((length(history_list) - innodb_max_purge_lag) * 10) - 5</span><br></pre></td></tr></table></figure>\n\n<p>注：delay的对象是行，而不是一个DML操作，即假设update操作5行数据时，总延时时间为5*delay。</p>\n<ul>\n<li>③、<code>innodb_max_purge_lag_delay</code>：要求版本大于InooDB1.2版本，用于控制delay的最大毫秒数。即当计算的delay值大于此参数时，将delay设置为此参数，避免由于purge操作缓慢导致其他SQL线程出现无限制的等待。</li>\n</ul>\n<h3 id=\"5-Group-Commit\"><a href=\"#5-Group-Commit\" class=\"headerlink\" title=\"5 Group Commit\"></a>5 Group Commit</h3><p><strong>Group commit</strong>操作<u>用于提高磁盘fsync的效率，即一次fsync操作可以刷新确保多个事务日志被写入文件。</u></p>\n<p>对于InnoDB存储引擎，事务提交时会进行两个阶段的操作：</p>\n<ul>\n<li>①、修改内存中事务对应的信息，并将日志写入重做日志缓冲。</li>\n<li>②、调用<code>fsync</code>将去把日志都从重做日志缓冲写入磁盘。</li>\n</ul>\n<p>其中第②步较慢，因此存储引擎需要和磁盘打交道。对于在执行第②段操作时，其他的事务可以进行第一段操作，然后将多个事务的重做日志通过一次fsync刷新到磁盘，大大减少磁盘的压力，提高数据库性能。对于Insert和update较为明显的操作，Group Commit的效果尤为明显。</p>\n<p><strong>Q3：在InnoDB1.2版本以后，在开启二进制日志后，InnoDB的Group Commit功能会实现，导致性能下降，其原因为？</strong></p>\n<p>导致这个问题的原因在于开启二进制日志后，为了保证存储引擎层中的事务和二进制日志的一致性，二者之前使用两阶段事务，其步骤如下：</p>\n<ul>\n<li><p>①、当事务提交时，InnoDB存储引擎进行prepare操作。</p>\n</li>\n<li><p>②、Mysql数据库上层写二进制日志。（一旦这一步提交，就确保了事务的提交，即使在第③步中发生了宕机。）（这一步由参数<code>sync_binlog</code>控制）</p>\n</li>\n<li><p>③、InnoDB存储引擎层将日志写入重做日志文件。（这一步的<code>fsync</code>由参数<code>innodb_flush_log_at_trx_commit</code>控制）</p>\n</li>\n<li><ul>\n<li>a、修改内存中事务对应的信息，并将日志写入重做日志缓冲。</li>\n<li>b、调用fsync将确保日志都从重做日志缓冲写入磁盘。</li>\n</ul>\n</li>\n</ul>\n<p><em>注：每个步骤都需要fsync操作才能保证上下两层数据的一致性。</em></p>\n<p>其整体过程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%BC%80%E5%90%AF%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E5%90%8EInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B.png\" alt=\"开启二进制日志后InnoDB存储引擎的提交过程\"></p>\n<p>为了保证二进制日志的写入顺序与InnoDB层的事务提交顺序一致，Mysql数据库内部使用了<code>prepare_commit_mutex</code>锁，当开启这个锁后，步骤③中的a将不可以在其他事务中执行步骤b，从而导致了Group Commit失效。</p>\n<p><strong>Q4：如何解决Q3的问题？</strong></p>\n<p>Mysql5.6采用了<code>Binary Log Group Commit（BLGC）</code>的方式<u>将事务提交的过程采用三段式提交方式</u>，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-InnoDB%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/BLGC.png\" alt=\"BLGC\"></p>\n<p>当有一组事务在今次那个Commit阶段时，其他新事物可以进行Flush阶段，从而使Group Commit不断生效。</p>\n<p>InnoDB提供了一些参数用于控制Bin log提交：</p>\n<p>①、<code>binlog_max_flush_quenue_time</code>：用于控制Flush阶段中等待的时间，即使之前一组事务完成提交，当前一组事务也不马上进入Sync阶段，而是至少等待一端时间，这样做的好处是Group Commit的事务数量更过，缺点是可能会导致事务的响应时间变量。默认值为0，且不建议修改。</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li>MySQL技术内幕+InnoDB存储引擎第2版(7.2节)</li>\n<li><a href=\"http://blog.itpub.net/30221425/viewspace-2154670/\">SHOW ENGINE INNODB STATUS \\G之Pages flushed up to的理解</a></li>\n</ul>"},{"title":"MySQL-并发控制","date":"2020-09-10T08:54:48.000Z","_content":"\n无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题．通常并发控制是采用`锁的方式`来防止数据不一致．\n\n锁是数据库系统区别于文件系统的一个关键特性．`锁机制用于管理对共享资源（临界资源）的并发访问`．\n\n<!--more-->\n\n#### 1、读写锁\n\n在处理并发读和并发写时，可以通过实现一个由两种类型的锁组成的锁系统来解决，分别是：  \n- ①、共享锁（shared lock）——读锁， 多个客户在同一时刻读取同一个资源，而互不干扰。\n- ②、排它锁（exclusive lock）——写锁， 写锁会阻塞其他的写锁和读锁。\n\n\n\n#### 2、锁粒度\n\n一种提高共享资源并发性的方式就是让锁定对象更具有选择性．尽量只锁定需要修改的部分数据，而不是所有的资源．更理想的方式是只对对修改的数据片进行精确锁定．`任何时候，在给定的资源上，锁定的数据量越少，并发度越高．`\n\n问题是，加锁需要消耗资源．因此需要寻求一种策略，`在锁的开销和数据安全性之间做平衡，这就是锁策略`．\n\n\n\n每种数据库及相同数据库下不同引擎的锁策略都不同，例如：\n\n- MySQL的`MyISAM存储引擎，其锁是表锁设计`．在并发情况下的读没有问题，但是并发写时性能就会差一些．\n- 对于Microsoft SQL Server数据库，2005版本之前是采用的页锁，相对于MyISAM引擎来说，并发性有所提高，但是对于热点数据页的并发问题，仍然无能为力．2005版本之后，通过支持乐观并发和悲观并发，在乐观并发下开始支持行级锁（其实现方式与InnoDB存储引擎完全不同）．\n- InnoDB引擎锁的实现与Oracle数据库类似，提供`一致性非锁定读，行级锁支持`．\n\n\n\nMysql提供了多钟锁策略，每种Mysql`存储引擎都可以实现自己的锁策略和锁粒度`。\n锁定的资源越少，系统并发程度越高，但加锁消耗的资源越大（获得锁，检查锁，释放锁等操作）。\n\n\n\n##### 2.1、表锁（table lock）\n\n表锁是Mysql中最基本的锁策略，并且是开销最小的锁策略。它将会锁定整张表。其写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁请求队列的前面．\n\n某些情况下，Mysql自身会使用表锁实现目的，并忽略存储引擎的锁机制．例如，ALTER TABLE之类的语句使用的表锁。\n\n\n\n##### 2.2、行级锁（row lock）\n\n行级锁可以最大程度地支持并发处理，但同时也带来了最大锁开销。`行级锁在存储引擎层实现的`。\n\n\n\n#### 3、InnoDB的锁类型\n\n每种Mysql存储引擎都可以实现自己的锁策略和锁粒度，InnoDB作为MySQL的默认引擎，拥有７种类型的锁用于并发控制．\n\n\n\nInnoDB共有七种类型的锁：\n\n- ①、`共享锁/排它锁（Shared and Exclusive Locks）`\n- ②、`意向锁（Intention Locks）`\n- ③、`记录锁（Record Locks）`\n- ④、`间隙锁（Gap Locks）`\n- ⑤、`临键锁（Next-key Locks）`\n- ⑥、`插入意向锁（Insert Intention Locks）`\n- ⑦、`自增锁（Auto-inc Locks）`\n\n\n\n注：InnoDB的行锁是实现在索引上的，而不是物理行记录上，即如果没有命中索引，也无法使用行锁，将要退化为表锁。\n\n\n\n##### 3.1 共享锁/排它锁（Shared and Exclusive Locks）\n\n在InnoDB里实现了`标准的行级锁(row-level locking)`，共享/排它锁：  \n (1)事务拿到某一行记录的共享S锁，才可以读取这一行；  \n (2)事务拿到某一行记录的排它X锁，才可以修改或者删除这一行；\n\n其兼容互斥表如下：\n\n|      | S    | X    |\n| ---- | ---- | ---- |\n| S    | 兼容 | 互斥 |\n| X    | 互斥 | 互斥 |\n\n即：\n- ①、多个事务可以拿到一把S锁，读读可以并行；\n- ②、而只有一个事务可以拿到X锁，写写/读写必须互斥；\n\n`共享/排它锁的潜在问题是，不能充分的并行，解决思路是数据多版本控制（MVCC）。`\n\n\n\n##### 3.2 自增锁（Auto-inc Locks）\n\n在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现的方式称为AUTO-INC locking。\n\n通过以下命令查看表的自增长计数器的值：\n\n```mysql\nselect max(auto_inc_col) from <table_name> for update\n```\n\n\n\n`自增锁是一种特殊的表级别锁（table-level lock）`，专门针对事务插入`AUTO_INCREMENT`类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。（**注：自增锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放**）\n\n*在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。*\n\n\n\nInnoDB提供了`innodb_autoinc_lock_mode`配置，可以调节与改变该锁的模式与行为。\n一共提供了三种模式可供选择：  \n\n- 0：`traditonal` （每次都会产生表锁）  \n- 1：`consecutive` （默认．会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入）  \n- 2：`interleaved` （不会锁表，来一个处理一个，并发最高）  \n\n\n\nmysql不支持直接设置该变量，会抛出以下异常：\n\n```\nmysql> set innodb_autoinc_lock_mode = 1;\nERROR 1238 (HY000): Variable 'innodb_autoinc_lock_mode' is a read only variable\n```\n\n\n\n修改方式：修改mysqld配置文件的方式（Ubuntu16.04版本中，该配置文件路径为：`/etc/mysql/mysql.conf.d/mysqld.cnf`）：    \n在[mysqld]下添加配置项，例如：  \n\n```tex /etc/mysql/mysql.conf.d/mysqld.cnf\ninnodb_autoinc_lock_mode = 0\n```\n然后重启mysql服务\n\n```\nsudo service mysql restart\n```\n\n\n\n示例：\n\n```mysql\nMySQL，InnoDB，默认的隔离级别(RR)，假设有数据表：\nt_id_incr(id AUTO_INCREMENT, name);\n \n数据表中有数据：\n1, shenjian\n2, zhangsan\n3, lisi\n\n按以下顺序执行，对于事务Ｂ会阻塞吗？\n\nA:set autocommit = 0;\nA:start transaction;\nA:insert into t_id_incr(name) values('ooo');\n\tB:set autocommit = 0;\n\tB:start transaction;\n\tB:insert into t_id_incr(name) values('xxx');\nA:insert into t_id_incr(name) values('xoo');\nA:select * from t_id_incr;\n```\n<u>该示例，将innodb_autoinc_lock_mode修改为0,1,2任何一个值，事务B依旧均没有阻塞？？？？这是正常的吗？？？？</u>\n\n\n\n##### 3.3 意向锁（Intention Locks）\n\nInnoDB支持多粒度锁(multiple granularity locking)，它允许行级锁与表级锁共存．因此InnoDB支持一个额外的锁方式，即意向锁（Intention Lock）．\n\n\n\n意向锁是将锁定的对象分为多个层次，意味着事务希望在更细的粒度上进行加锁．例如：`需要对页上的记录ｒ进行上Ｘ锁，那么分别需要对数据库Ａ，表，页上意向锁IX，最后低记录ｒ上Ｘ锁．所起中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成．`\n\n\n\n实际上，InnoDB支持的意向锁设计简练，即为表锁．是为了在一个事务中揭示下一行将被请求的锁类型． \n\nInnoDB意向锁的特点：\n- ①、意向锁是一个表级别的锁（table-level locking）;\n\n- ②、意向锁又分为：\n    - **意向共享锁**（Intention share lock, IS）, 它预示着事务有意向对表中某些行加共享S锁。\n    - **意向排它锁**（Intention exclusive lock, IX）,它预示着，事务有意向对表中某些行加排它锁。\n    例如：\n    ```mysql\n    select ... lock in share mode // 要设置IS锁；\n    select ... for update // 要设置IX锁\n    ```\n    \n- 意向锁协议\n    - 事务要获得某些行的S锁，必须获得表的IS锁；\n    - 事务要获得某些行的X锁，必须获得表的IX锁；\n\n- `由于意向锁仅仅表明意向，它其实是比较弱的锁，意向锁之间并不相互互斥，而是可以并行`。\n\n- `但是意向锁会和共享锁/排他锁互斥`， 其兼容互斥表如下：\n  \n    |      | IS   | IX   | S    | X    |\n    | ---- | ---- | ---- | ---- | ---- |\n    | IS   | 兼容 | 兼容 | 兼容 | 互斥 |\n    | IX   | 兼容 | 兼容 | 互斥 | 互斥 |\n    | S    | 兼容 | 互斥 | 兼容 | 互斥 |\n    | X    | 互斥 | 互斥 | 互斥 | 互斥 |\n\n\n\n##### 3.4 插入意向锁（Insert Intention Locks）\n\n插入意向锁是间隙锁（Gap Locks）的一种（实施在索引上的），他是专门针对insert操作的。\n\n特点：\n多个事务，在同一索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。\n（官网原文：Insert Intention Lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap.）\n\n示例：\n\n```\n在MySQL，InnoDB，RR下：\nt(id unique PK, name);\n \n数据表中有数据：\n10, shenjian\n20, zhangsan\n30, lisi\n \n事务A先执行，在10与20两条记录中插入了一行，还未提交：\ninsert into t values(11, xxx);\n \n事务B后执行，也在10与20两条记录中插入了一行：\ninsert into t values(12, ooo);\n \n(1)会使用什么锁？\n(2)事务B会不会被阻塞呢？\n```\n虽然事务隔离级别是RR，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：\n- 使用的是插入意向锁\n- 并不会阻塞事务B\n\n\n\n##### 3.5 记录锁（Record Locks）\n\n记录锁，它封锁索引记录。  \n例如：\n\n```\nselect * from t where id=1 for update;\n```\n该示例会在id=1的索引记录上加锁，以阻止其他事务插入、更新、删除id=1的这一行。\n\n注：以下语句为快照读（SnapShot Read）\n```\nselect * from t where id=1;\n```\n\n\n\n##### 3.6 间隙锁（Gap Locks）\n\n间隙锁，它封锁索引记录中的间隔（*不包含记录本身*），或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。\n\n```\n例子，InnoDB，RR隔离级别下：\nt(id PK, name KEY, sex, flag);\n \n表中有四条记录：\n1, shenjian, m, A\n3, zhangsan, m, A\n5, lisi, m, A\n9, wangwu, f, B\n \n这个SQL语句\nselect * from t \n    where id between 8 and 15 \n    for update;\n会封锁区间，以阻止其他事务id=10的记录插入\n```\n\n<u>间隙锁的作用是为了阻止多个事务将记录插入到同一个范围内，而这会导致Phantom Problem（幻象问题，MySQL定义的是不可重复读）问题的产生．</u>\n\n`显式关闭间隙锁的方法`：\n\n- 将事务的隔离级别设置为READ COMMITTED.\n- 将参数innodb_locks_unsafe_for_binlog设置为１．\n\n\n\n`删除不存在的记录，获取到的是共享间隙锁．`\n\n\n\n##### 3.7 临键锁（Next-Key Locks）\n\n临键锁，`是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。`InnoDB存储引擎默认**对于行的查询都是采用临键锁的算法**．\n（临键锁会封锁索引记录本身，以及索引记录之前的区间）。\n\n`如果一个Session（会话）占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。`\n（官方文档原文：If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.）\n\n\n\n例如：一个索引有10, 11, 13, 20这四个值，那么该索引可能被Next-Key Locking的区间为：\n\n```\n(-infinity, 10]\n(10, 11]\n(11, 13]\n(13, 20]\n(20, +infinity]\n```\n\n\n\n其实除了Next-Key Locking外，还有一种`Previous-key Locking`技术，那么可锁定的区间是：\n\n```\n(-infinity, 10)\n[10, 11)\n[11, 13)\n[13, 20)\n[20, +infinity)\n```\n\n\n\n- 当查询的索引含有唯一属性时\n\n  - 等值查询的情况：InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身．\n  - 范围查询的情况：InnoDB存储引擎会使用Next-Key Lock．\n\n  \n\n  示例：\n\n```mysql\n１．创建测试表\ncreate table t (a int primary key);\n\n２．写入测试数据\ninsert into t select 1;\ninsert into t select 2;\ninsert into t select 5;\n\n３．等值查询的情况．\nA: set autocommit=0;\nA: begin;\nA: select * from t where a=5 for update;\n\tB: set autocommit=0;\n\tB: insert into t select 4; // 成功，执行时并未发生阻塞．\nA: commit;\n\tB: commit;\n\n４．进行范围查询的情况．\nA: set autocommit=0;\nA: begin;\nA: select * from t where a>2 for update; // 范围查询时，对(2,+infinity)范围添加了Ｘ锁．\n\tB: set autocommit=0;\n\tB: insert into t select 4; // 失败，执行是发生阻塞．\nA: commit;\n\tB: commit;\nstatus\n```\n\n- `当查询的索引为辅助索引，InnoDB存储引擎将会对辅助索引使用Next-Key Locking技术加锁，并且对辅助索引的下一个键值加上Gap Locks，同时对聚集索引，添加Record Locking．`\n\n```mysql\n１．创建测试表\ncreate table z (a int, b int, primary key(a), key(b));\n\n２．写入测试数据\ninsert into z select 1, 1;\ninsert into z select 3, 1;\ninsert into z select 5, 3;\ninsert into z select 7, 6;\ninsert into z select 10, 8;\n\n３．两个事务按以下顺序执行：\nA: set autocommit=0;\nA: begin;\nA: select * from z where b = 3 for update; // 对于辅助索引：(1,3]添加临键锁；(3,6)添加间隙锁；对于聚簇索引a=5添加记录锁．\n\tB: set autocommit=0;\n\tB: select * from z where a = 5 lock in share mode; // 阻塞．\n\tB: insert into z select 4, 2;　// 阻塞，ａ=4没问题，但是b=2被临键锁锁定．\n\tB: insert into z select 6, 5;　// 阻塞，a=6没问题，但是ｂ=5被间隙锁锁定．\n```\n\n临键锁的目的，也是为了避免幻读，如果把事务的隔离级别降为RC，临键锁则也会失效。\n\n\n\n3.7.1 Phantom Problem(幻象问题，不可重复读)\n\n`Phantom Problem(幻读)是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行．`\n\n在默认的事务隔离级别（READ REPEATABLE）下，InnoDB采用`Next-Key Locking机制`来避免Phantom Problem.\n\n\n\n注意：<u>MySQL官方文档中，将`不可重复读`的问题定义为Phantom Problem，即幻象问题．</u>\n\n\n\n#### 4 InnoDB一致性读\n\nInnoDB提供了两种一致性读，分别是：\n\n- 一致性非锁定读（Consistent nonlocking read）\n- 一致性锁定读（Consistent locking read）\n\n\n\n##### 4.1 一致性非锁定读\n\n一致性非锁定读是指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间数据库中的行数据．若读取的行正在执行DELETE或UPDATE操作，这时`读取操作不会因此去等待行上的锁释放．而是去读取行的一个快照`．\n\n如下图所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/InnoDB存储引擎非锁定的一致性读.png\" alt=\"InnoDB存储引擎非锁定的一致性读\" style=\"zoom:80%;\" />  \n\n\n\n`什么是快照数据呢？`\n\n快照数据是指行的之前版本的数据，该`实现是通过undo段来完成的`．而undo段用来在事务中回滚数据，因此，快照数据本身是没有任何开销的．此外，读快照数据是不需要上锁的．\n\n\n\n需要注意的是，并不是所有的隔离级别都是采用一致性非锁定读．实际上`只有在READ COMMITTED和REPEATABLE READ（默认隔离级别）隔离级别下，ＩnnoDB采用一致性非锁定读`．但是他们的快照数据定义却不相同．\n\n- READ COMMITTED：总是读取最新的一份快照数据．\n- REPEATABLE READ：总是读取最老的（事务最开始的那份）一份快照数据．\n\n\n\n##### 4.2 一致性锁定读\n\n对于默认的隔离级别REPEATABLE READ模式下，如果想要显示的通过加锁的方式保证数据的一致性，InnoDB提供了一种加锁操作．如下：\n\n```mysql\nselect ... for update // 对读取行记录加一个Ｘ（排他）锁\nselect ... lock in share mode　// 对读取行记录加一个Ｓ（共享）锁\n```\n\n注：使用以上两种方式显示加锁，需要加上`begin`, `start transaction`或`set autocommit=0`的操作．\n\n\n\n<u>对于一致性非锁定读，使用`select ... for update`方式无效．仍然以快照读的方式运行．</u>\n\n\n\n#### 5 死锁\n\n##### 5.1 死锁的概念\n\n死锁是`指来两个或者两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象．`\n\n\n\n`解决死锁的办法`：\n\n- 超时：该方法是最简单的方法，即当两个事务相互等待时，当其中一个等待时间超过设置的某一阈值，将其中一个事务进行回滚，另一个等待的事务继续进行．\n  - 问题：仅通过超时回滚的方式，若超时的事务权重占比较大（如事务操作更新了很多行，占用较多的undo log），回滚该事务可能相对另一个事务占用的时间更多．\n- 死锁检测：当前数据库普遍采用`Wait-For Gragh（等待图）的方式来进行死锁检测`．InnoDB即采用该方式．\n\n\n\n###### 5.1.1 Wait-For Gragh（等待图）\n\nWait-For Gragh要求数据库通过使用以下两种信息链表构造出一张图，若图中存在回路，就表示存在死锁，因此资源间相互发生等待．\n\n- `锁的信息链表`\n- `事务等待链表`\n\n*注：Wait-For Gragh中箭头（T1->T2）指向表示事务T1等待事务T2所占用的资源．*\n\n\n\nWait-For Gragh是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时会判断是否存在回路，若存在死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务．\n\n\n\n`示例`：当前事务和锁的状态如下图所示．\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/事务和锁等待信息.png\" alt=\"事务和锁等待信息\" style=\"zoom:80%;\" />\n\n其wait-for gragh如下，可见（t1, t2）存在回路，因此存在死锁．\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/wait-for-gragh.png\" alt=\"wait-for-gragh\" style=\"zoom:67%;\" />\n\n\n\n##### 5.2 死锁的示例\n\n后续示例均在以下表中操作\n\n```mysql\n# 1. 建表\nCREATE TABLE `t` (\n  `a` int(11) NOT NULL,\n  PRIMARY KEY (`a`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n\n# 2. 构建测试数据\n+-----+\n|  a  |\n+-----+\n|  1  |\n|  2  |\n|  4  |\n|  5  |\n|  11 |\n+-----+\n```\n\n\n\n###### 5.2.1 AB-BA情况\n\nAB-BA情况，是最经典的死锁情况，即Ａ等待Ｂ，Ｂ在等待Ａ．\n\n```mysql\nA: begin;\nA: sselect * from t where a=1 for update;\n\tB: begin;\n\tB: select * from t where a=2 for update;\nA: select * from t where a=2 for update; # 阻塞\n\tB: select * from t where a=1 for update; # 发生死锁.\n\tERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\nA: 获取锁，返回结果．\n```\n\n发现死锁后，InnoDB存储引擎会马上回滚一个事务，另一个阻塞事务将继续进行．\n\n\n\n###### 5.2.2 共享锁/排他锁死锁\n\n当前事务持有待插入记录的下一个记录的Ｘ锁，但在等待队列中存在一个Ｓ锁的请求，则可能发生死锁．\n\n```　mysql\nA: begin;\n\tB: begin;\nA: select * from t where a=4 for update; # 对ａ=4持有一个排他锁．\n\tB: select * from t where a<=4 lock in share mode; # 等待对a<=4的记录获取一个Ｓ锁．\nA: insert into t values(3);　# 发生死锁，回滚undo log记录大的事务．\nERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\n\tB: 获得锁，返回结果．\n```\n\n```tex\n+-----+     +-----+  \n| a=4 |     | a=3 |\n+-----+     +-----+\n| A:X |     | B:S |\n| B:S |\n+-----+\n \n     Ｂ等待Ａ释放a=4的排他锁\nA<--------------------------B\n -------------------------->\n \t A等待B释放a=3的共享锁\n```\n\n注：以上示例与AB-BA死锁处理方式不同，此处选择回滚undo log记录大的事务．(为什么呢？？？？？？？？)\n\n\n\n###### 5.2.3 并发间隙锁的死锁\n\n```MYSQL\n# 1. 准备测试数据，准备一个大的间隙的数据．\ninsert into t values(11);\n\n# 2. 开始测试．\nA: begin;\nA: delete from t where a=7; #　删除一个不存在的记录，获取(5, 11)共享间隙锁．\n\tB: begin;\n\tB: delete from t where a=8; #　删除一个不存在的记录，获取(5, 11)共享间隙锁．\nA: insert into t values(9); # 插入数据，希望获得（5, 11)的排他间隙锁，于是会阻塞．\n\tB: insert into t values(10);　# 插入数据，也希望获得（5, 11)的排他间隙锁，此时出现死锁．\n\tERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\nA: 由于事务Ｂ出现死锁，回滚，因此Ａ插入成功．\n```\n\n\n\n通过`show engine innodb status`命令查看死锁情况，可知，该死锁确实是由于locks gap导致的．\n\n\n\n---\n\n#### 参考文档\n\n①、[InnoDB，select为啥会阻塞insert？](https://mp.weixin.qq.com/s/y_f2qrZvZe_F4_HPnwVjOw) \n②、[InnoDB并发插入，居然使用意向锁？](https://mp.weixin.qq.com/s/iViStnwUyypwTkQHWDIR_w) \n③、[插入InnoDB自增列，居然是表锁？](https://mp.weixin.qq.com/s/kOMSD_Satu9v9ciZVvNw8Q) \n④、[InnoDB并发如此高，原因竟然在这？](https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ)  \n⑤、MySQL技术内幕+InnoDB存储引擎\n⑥、高性能ＭySQL 第三版\n\n","source":"_posts/MySQL-并发控制.md","raw":"---\ntitle: MySQL-并发控制\ndate: 2020-09-10 16:54:48\ntags: [\"MySQL\",\"锁\",\"高性能MySQL\",\"死锁\",\"一致性非锁定读\"]\ncategories: [\"MySQL\"]\n---\n\n无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题．通常并发控制是采用`锁的方式`来防止数据不一致．\n\n锁是数据库系统区别于文件系统的一个关键特性．`锁机制用于管理对共享资源（临界资源）的并发访问`．\n\n<!--more-->\n\n#### 1、读写锁\n\n在处理并发读和并发写时，可以通过实现一个由两种类型的锁组成的锁系统来解决，分别是：  \n- ①、共享锁（shared lock）——读锁， 多个客户在同一时刻读取同一个资源，而互不干扰。\n- ②、排它锁（exclusive lock）——写锁， 写锁会阻塞其他的写锁和读锁。\n\n\n\n#### 2、锁粒度\n\n一种提高共享资源并发性的方式就是让锁定对象更具有选择性．尽量只锁定需要修改的部分数据，而不是所有的资源．更理想的方式是只对对修改的数据片进行精确锁定．`任何时候，在给定的资源上，锁定的数据量越少，并发度越高．`\n\n问题是，加锁需要消耗资源．因此需要寻求一种策略，`在锁的开销和数据安全性之间做平衡，这就是锁策略`．\n\n\n\n每种数据库及相同数据库下不同引擎的锁策略都不同，例如：\n\n- MySQL的`MyISAM存储引擎，其锁是表锁设计`．在并发情况下的读没有问题，但是并发写时性能就会差一些．\n- 对于Microsoft SQL Server数据库，2005版本之前是采用的页锁，相对于MyISAM引擎来说，并发性有所提高，但是对于热点数据页的并发问题，仍然无能为力．2005版本之后，通过支持乐观并发和悲观并发，在乐观并发下开始支持行级锁（其实现方式与InnoDB存储引擎完全不同）．\n- InnoDB引擎锁的实现与Oracle数据库类似，提供`一致性非锁定读，行级锁支持`．\n\n\n\nMysql提供了多钟锁策略，每种Mysql`存储引擎都可以实现自己的锁策略和锁粒度`。\n锁定的资源越少，系统并发程度越高，但加锁消耗的资源越大（获得锁，检查锁，释放锁等操作）。\n\n\n\n##### 2.1、表锁（table lock）\n\n表锁是Mysql中最基本的锁策略，并且是开销最小的锁策略。它将会锁定整张表。其写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁请求队列的前面．\n\n某些情况下，Mysql自身会使用表锁实现目的，并忽略存储引擎的锁机制．例如，ALTER TABLE之类的语句使用的表锁。\n\n\n\n##### 2.2、行级锁（row lock）\n\n行级锁可以最大程度地支持并发处理，但同时也带来了最大锁开销。`行级锁在存储引擎层实现的`。\n\n\n\n#### 3、InnoDB的锁类型\n\n每种Mysql存储引擎都可以实现自己的锁策略和锁粒度，InnoDB作为MySQL的默认引擎，拥有７种类型的锁用于并发控制．\n\n\n\nInnoDB共有七种类型的锁：\n\n- ①、`共享锁/排它锁（Shared and Exclusive Locks）`\n- ②、`意向锁（Intention Locks）`\n- ③、`记录锁（Record Locks）`\n- ④、`间隙锁（Gap Locks）`\n- ⑤、`临键锁（Next-key Locks）`\n- ⑥、`插入意向锁（Insert Intention Locks）`\n- ⑦、`自增锁（Auto-inc Locks）`\n\n\n\n注：InnoDB的行锁是实现在索引上的，而不是物理行记录上，即如果没有命中索引，也无法使用行锁，将要退化为表锁。\n\n\n\n##### 3.1 共享锁/排它锁（Shared and Exclusive Locks）\n\n在InnoDB里实现了`标准的行级锁(row-level locking)`，共享/排它锁：  \n (1)事务拿到某一行记录的共享S锁，才可以读取这一行；  \n (2)事务拿到某一行记录的排它X锁，才可以修改或者删除这一行；\n\n其兼容互斥表如下：\n\n|      | S    | X    |\n| ---- | ---- | ---- |\n| S    | 兼容 | 互斥 |\n| X    | 互斥 | 互斥 |\n\n即：\n- ①、多个事务可以拿到一把S锁，读读可以并行；\n- ②、而只有一个事务可以拿到X锁，写写/读写必须互斥；\n\n`共享/排它锁的潜在问题是，不能充分的并行，解决思路是数据多版本控制（MVCC）。`\n\n\n\n##### 3.2 自增锁（Auto-inc Locks）\n\n在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现的方式称为AUTO-INC locking。\n\n通过以下命令查看表的自增长计数器的值：\n\n```mysql\nselect max(auto_inc_col) from <table_name> for update\n```\n\n\n\n`自增锁是一种特殊的表级别锁（table-level lock）`，专门针对事务插入`AUTO_INCREMENT`类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。（**注：自增锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放**）\n\n*在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。*\n\n\n\nInnoDB提供了`innodb_autoinc_lock_mode`配置，可以调节与改变该锁的模式与行为。\n一共提供了三种模式可供选择：  \n\n- 0：`traditonal` （每次都会产生表锁）  \n- 1：`consecutive` （默认．会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入）  \n- 2：`interleaved` （不会锁表，来一个处理一个，并发最高）  \n\n\n\nmysql不支持直接设置该变量，会抛出以下异常：\n\n```\nmysql> set innodb_autoinc_lock_mode = 1;\nERROR 1238 (HY000): Variable 'innodb_autoinc_lock_mode' is a read only variable\n```\n\n\n\n修改方式：修改mysqld配置文件的方式（Ubuntu16.04版本中，该配置文件路径为：`/etc/mysql/mysql.conf.d/mysqld.cnf`）：    \n在[mysqld]下添加配置项，例如：  \n\n```tex /etc/mysql/mysql.conf.d/mysqld.cnf\ninnodb_autoinc_lock_mode = 0\n```\n然后重启mysql服务\n\n```\nsudo service mysql restart\n```\n\n\n\n示例：\n\n```mysql\nMySQL，InnoDB，默认的隔离级别(RR)，假设有数据表：\nt_id_incr(id AUTO_INCREMENT, name);\n \n数据表中有数据：\n1, shenjian\n2, zhangsan\n3, lisi\n\n按以下顺序执行，对于事务Ｂ会阻塞吗？\n\nA:set autocommit = 0;\nA:start transaction;\nA:insert into t_id_incr(name) values('ooo');\n\tB:set autocommit = 0;\n\tB:start transaction;\n\tB:insert into t_id_incr(name) values('xxx');\nA:insert into t_id_incr(name) values('xoo');\nA:select * from t_id_incr;\n```\n<u>该示例，将innodb_autoinc_lock_mode修改为0,1,2任何一个值，事务B依旧均没有阻塞？？？？这是正常的吗？？？？</u>\n\n\n\n##### 3.3 意向锁（Intention Locks）\n\nInnoDB支持多粒度锁(multiple granularity locking)，它允许行级锁与表级锁共存．因此InnoDB支持一个额外的锁方式，即意向锁（Intention Lock）．\n\n\n\n意向锁是将锁定的对象分为多个层次，意味着事务希望在更细的粒度上进行加锁．例如：`需要对页上的记录ｒ进行上Ｘ锁，那么分别需要对数据库Ａ，表，页上意向锁IX，最后低记录ｒ上Ｘ锁．所起中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成．`\n\n\n\n实际上，InnoDB支持的意向锁设计简练，即为表锁．是为了在一个事务中揭示下一行将被请求的锁类型． \n\nInnoDB意向锁的特点：\n- ①、意向锁是一个表级别的锁（table-level locking）;\n\n- ②、意向锁又分为：\n    - **意向共享锁**（Intention share lock, IS）, 它预示着事务有意向对表中某些行加共享S锁。\n    - **意向排它锁**（Intention exclusive lock, IX）,它预示着，事务有意向对表中某些行加排它锁。\n    例如：\n    ```mysql\n    select ... lock in share mode // 要设置IS锁；\n    select ... for update // 要设置IX锁\n    ```\n    \n- 意向锁协议\n    - 事务要获得某些行的S锁，必须获得表的IS锁；\n    - 事务要获得某些行的X锁，必须获得表的IX锁；\n\n- `由于意向锁仅仅表明意向，它其实是比较弱的锁，意向锁之间并不相互互斥，而是可以并行`。\n\n- `但是意向锁会和共享锁/排他锁互斥`， 其兼容互斥表如下：\n  \n    |      | IS   | IX   | S    | X    |\n    | ---- | ---- | ---- | ---- | ---- |\n    | IS   | 兼容 | 兼容 | 兼容 | 互斥 |\n    | IX   | 兼容 | 兼容 | 互斥 | 互斥 |\n    | S    | 兼容 | 互斥 | 兼容 | 互斥 |\n    | X    | 互斥 | 互斥 | 互斥 | 互斥 |\n\n\n\n##### 3.4 插入意向锁（Insert Intention Locks）\n\n插入意向锁是间隙锁（Gap Locks）的一种（实施在索引上的），他是专门针对insert操作的。\n\n特点：\n多个事务，在同一索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。\n（官网原文：Insert Intention Lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap.）\n\n示例：\n\n```\n在MySQL，InnoDB，RR下：\nt(id unique PK, name);\n \n数据表中有数据：\n10, shenjian\n20, zhangsan\n30, lisi\n \n事务A先执行，在10与20两条记录中插入了一行，还未提交：\ninsert into t values(11, xxx);\n \n事务B后执行，也在10与20两条记录中插入了一行：\ninsert into t values(12, ooo);\n \n(1)会使用什么锁？\n(2)事务B会不会被阻塞呢？\n```\n虽然事务隔离级别是RR，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：\n- 使用的是插入意向锁\n- 并不会阻塞事务B\n\n\n\n##### 3.5 记录锁（Record Locks）\n\n记录锁，它封锁索引记录。  \n例如：\n\n```\nselect * from t where id=1 for update;\n```\n该示例会在id=1的索引记录上加锁，以阻止其他事务插入、更新、删除id=1的这一行。\n\n注：以下语句为快照读（SnapShot Read）\n```\nselect * from t where id=1;\n```\n\n\n\n##### 3.6 间隙锁（Gap Locks）\n\n间隙锁，它封锁索引记录中的间隔（*不包含记录本身*），或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。\n\n```\n例子，InnoDB，RR隔离级别下：\nt(id PK, name KEY, sex, flag);\n \n表中有四条记录：\n1, shenjian, m, A\n3, zhangsan, m, A\n5, lisi, m, A\n9, wangwu, f, B\n \n这个SQL语句\nselect * from t \n    where id between 8 and 15 \n    for update;\n会封锁区间，以阻止其他事务id=10的记录插入\n```\n\n<u>间隙锁的作用是为了阻止多个事务将记录插入到同一个范围内，而这会导致Phantom Problem（幻象问题，MySQL定义的是不可重复读）问题的产生．</u>\n\n`显式关闭间隙锁的方法`：\n\n- 将事务的隔离级别设置为READ COMMITTED.\n- 将参数innodb_locks_unsafe_for_binlog设置为１．\n\n\n\n`删除不存在的记录，获取到的是共享间隙锁．`\n\n\n\n##### 3.7 临键锁（Next-Key Locks）\n\n临键锁，`是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。`InnoDB存储引擎默认**对于行的查询都是采用临键锁的算法**．\n（临键锁会封锁索引记录本身，以及索引记录之前的区间）。\n\n`如果一个Session（会话）占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。`\n（官方文档原文：If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.）\n\n\n\n例如：一个索引有10, 11, 13, 20这四个值，那么该索引可能被Next-Key Locking的区间为：\n\n```\n(-infinity, 10]\n(10, 11]\n(11, 13]\n(13, 20]\n(20, +infinity]\n```\n\n\n\n其实除了Next-Key Locking外，还有一种`Previous-key Locking`技术，那么可锁定的区间是：\n\n```\n(-infinity, 10)\n[10, 11)\n[11, 13)\n[13, 20)\n[20, +infinity)\n```\n\n\n\n- 当查询的索引含有唯一属性时\n\n  - 等值查询的情况：InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身．\n  - 范围查询的情况：InnoDB存储引擎会使用Next-Key Lock．\n\n  \n\n  示例：\n\n```mysql\n１．创建测试表\ncreate table t (a int primary key);\n\n２．写入测试数据\ninsert into t select 1;\ninsert into t select 2;\ninsert into t select 5;\n\n３．等值查询的情况．\nA: set autocommit=0;\nA: begin;\nA: select * from t where a=5 for update;\n\tB: set autocommit=0;\n\tB: insert into t select 4; // 成功，执行时并未发生阻塞．\nA: commit;\n\tB: commit;\n\n４．进行范围查询的情况．\nA: set autocommit=0;\nA: begin;\nA: select * from t where a>2 for update; // 范围查询时，对(2,+infinity)范围添加了Ｘ锁．\n\tB: set autocommit=0;\n\tB: insert into t select 4; // 失败，执行是发生阻塞．\nA: commit;\n\tB: commit;\nstatus\n```\n\n- `当查询的索引为辅助索引，InnoDB存储引擎将会对辅助索引使用Next-Key Locking技术加锁，并且对辅助索引的下一个键值加上Gap Locks，同时对聚集索引，添加Record Locking．`\n\n```mysql\n１．创建测试表\ncreate table z (a int, b int, primary key(a), key(b));\n\n２．写入测试数据\ninsert into z select 1, 1;\ninsert into z select 3, 1;\ninsert into z select 5, 3;\ninsert into z select 7, 6;\ninsert into z select 10, 8;\n\n３．两个事务按以下顺序执行：\nA: set autocommit=0;\nA: begin;\nA: select * from z where b = 3 for update; // 对于辅助索引：(1,3]添加临键锁；(3,6)添加间隙锁；对于聚簇索引a=5添加记录锁．\n\tB: set autocommit=0;\n\tB: select * from z where a = 5 lock in share mode; // 阻塞．\n\tB: insert into z select 4, 2;　// 阻塞，ａ=4没问题，但是b=2被临键锁锁定．\n\tB: insert into z select 6, 5;　// 阻塞，a=6没问题，但是ｂ=5被间隙锁锁定．\n```\n\n临键锁的目的，也是为了避免幻读，如果把事务的隔离级别降为RC，临键锁则也会失效。\n\n\n\n3.7.1 Phantom Problem(幻象问题，不可重复读)\n\n`Phantom Problem(幻读)是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行．`\n\n在默认的事务隔离级别（READ REPEATABLE）下，InnoDB采用`Next-Key Locking机制`来避免Phantom Problem.\n\n\n\n注意：<u>MySQL官方文档中，将`不可重复读`的问题定义为Phantom Problem，即幻象问题．</u>\n\n\n\n#### 4 InnoDB一致性读\n\nInnoDB提供了两种一致性读，分别是：\n\n- 一致性非锁定读（Consistent nonlocking read）\n- 一致性锁定读（Consistent locking read）\n\n\n\n##### 4.1 一致性非锁定读\n\n一致性非锁定读是指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间数据库中的行数据．若读取的行正在执行DELETE或UPDATE操作，这时`读取操作不会因此去等待行上的锁释放．而是去读取行的一个快照`．\n\n如下图所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/InnoDB存储引擎非锁定的一致性读.png\" alt=\"InnoDB存储引擎非锁定的一致性读\" style=\"zoom:80%;\" />  \n\n\n\n`什么是快照数据呢？`\n\n快照数据是指行的之前版本的数据，该`实现是通过undo段来完成的`．而undo段用来在事务中回滚数据，因此，快照数据本身是没有任何开销的．此外，读快照数据是不需要上锁的．\n\n\n\n需要注意的是，并不是所有的隔离级别都是采用一致性非锁定读．实际上`只有在READ COMMITTED和REPEATABLE READ（默认隔离级别）隔离级别下，ＩnnoDB采用一致性非锁定读`．但是他们的快照数据定义却不相同．\n\n- READ COMMITTED：总是读取最新的一份快照数据．\n- REPEATABLE READ：总是读取最老的（事务最开始的那份）一份快照数据．\n\n\n\n##### 4.2 一致性锁定读\n\n对于默认的隔离级别REPEATABLE READ模式下，如果想要显示的通过加锁的方式保证数据的一致性，InnoDB提供了一种加锁操作．如下：\n\n```mysql\nselect ... for update // 对读取行记录加一个Ｘ（排他）锁\nselect ... lock in share mode　// 对读取行记录加一个Ｓ（共享）锁\n```\n\n注：使用以上两种方式显示加锁，需要加上`begin`, `start transaction`或`set autocommit=0`的操作．\n\n\n\n<u>对于一致性非锁定读，使用`select ... for update`方式无效．仍然以快照读的方式运行．</u>\n\n\n\n#### 5 死锁\n\n##### 5.1 死锁的概念\n\n死锁是`指来两个或者两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象．`\n\n\n\n`解决死锁的办法`：\n\n- 超时：该方法是最简单的方法，即当两个事务相互等待时，当其中一个等待时间超过设置的某一阈值，将其中一个事务进行回滚，另一个等待的事务继续进行．\n  - 问题：仅通过超时回滚的方式，若超时的事务权重占比较大（如事务操作更新了很多行，占用较多的undo log），回滚该事务可能相对另一个事务占用的时间更多．\n- 死锁检测：当前数据库普遍采用`Wait-For Gragh（等待图）的方式来进行死锁检测`．InnoDB即采用该方式．\n\n\n\n###### 5.1.1 Wait-For Gragh（等待图）\n\nWait-For Gragh要求数据库通过使用以下两种信息链表构造出一张图，若图中存在回路，就表示存在死锁，因此资源间相互发生等待．\n\n- `锁的信息链表`\n- `事务等待链表`\n\n*注：Wait-For Gragh中箭头（T1->T2）指向表示事务T1等待事务T2所占用的资源．*\n\n\n\nWait-For Gragh是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时会判断是否存在回路，若存在死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务．\n\n\n\n`示例`：当前事务和锁的状态如下图所示．\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/事务和锁等待信息.png\" alt=\"事务和锁等待信息\" style=\"zoom:80%;\" />\n\n其wait-for gragh如下，可见（t1, t2）存在回路，因此存在死锁．\n\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/wait-for-gragh.png\" alt=\"wait-for-gragh\" style=\"zoom:67%;\" />\n\n\n\n##### 5.2 死锁的示例\n\n后续示例均在以下表中操作\n\n```mysql\n# 1. 建表\nCREATE TABLE `t` (\n  `a` int(11) NOT NULL,\n  PRIMARY KEY (`a`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n\n# 2. 构建测试数据\n+-----+\n|  a  |\n+-----+\n|  1  |\n|  2  |\n|  4  |\n|  5  |\n|  11 |\n+-----+\n```\n\n\n\n###### 5.2.1 AB-BA情况\n\nAB-BA情况，是最经典的死锁情况，即Ａ等待Ｂ，Ｂ在等待Ａ．\n\n```mysql\nA: begin;\nA: sselect * from t where a=1 for update;\n\tB: begin;\n\tB: select * from t where a=2 for update;\nA: select * from t where a=2 for update; # 阻塞\n\tB: select * from t where a=1 for update; # 发生死锁.\n\tERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\nA: 获取锁，返回结果．\n```\n\n发现死锁后，InnoDB存储引擎会马上回滚一个事务，另一个阻塞事务将继续进行．\n\n\n\n###### 5.2.2 共享锁/排他锁死锁\n\n当前事务持有待插入记录的下一个记录的Ｘ锁，但在等待队列中存在一个Ｓ锁的请求，则可能发生死锁．\n\n```　mysql\nA: begin;\n\tB: begin;\nA: select * from t where a=4 for update; # 对ａ=4持有一个排他锁．\n\tB: select * from t where a<=4 lock in share mode; # 等待对a<=4的记录获取一个Ｓ锁．\nA: insert into t values(3);　# 发生死锁，回滚undo log记录大的事务．\nERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\n\tB: 获得锁，返回结果．\n```\n\n```tex\n+-----+     +-----+  \n| a=4 |     | a=3 |\n+-----+     +-----+\n| A:X |     | B:S |\n| B:S |\n+-----+\n \n     Ｂ等待Ａ释放a=4的排他锁\nA<--------------------------B\n -------------------------->\n \t A等待B释放a=3的共享锁\n```\n\n注：以上示例与AB-BA死锁处理方式不同，此处选择回滚undo log记录大的事务．(为什么呢？？？？？？？？)\n\n\n\n###### 5.2.3 并发间隙锁的死锁\n\n```MYSQL\n# 1. 准备测试数据，准备一个大的间隙的数据．\ninsert into t values(11);\n\n# 2. 开始测试．\nA: begin;\nA: delete from t where a=7; #　删除一个不存在的记录，获取(5, 11)共享间隙锁．\n\tB: begin;\n\tB: delete from t where a=8; #　删除一个不存在的记录，获取(5, 11)共享间隙锁．\nA: insert into t values(9); # 插入数据，希望获得（5, 11)的排他间隙锁，于是会阻塞．\n\tB: insert into t values(10);　# 插入数据，也希望获得（5, 11)的排他间隙锁，此时出现死锁．\n\tERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\nA: 由于事务Ｂ出现死锁，回滚，因此Ａ插入成功．\n```\n\n\n\n通过`show engine innodb status`命令查看死锁情况，可知，该死锁确实是由于locks gap导致的．\n\n\n\n---\n\n#### 参考文档\n\n①、[InnoDB，select为啥会阻塞insert？](https://mp.weixin.qq.com/s/y_f2qrZvZe_F4_HPnwVjOw) \n②、[InnoDB并发插入，居然使用意向锁？](https://mp.weixin.qq.com/s/iViStnwUyypwTkQHWDIR_w) \n③、[插入InnoDB自增列，居然是表锁？](https://mp.weixin.qq.com/s/kOMSD_Satu9v9ciZVvNw8Q) \n④、[InnoDB并发如此高，原因竟然在这？](https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ)  \n⑤、MySQL技术内幕+InnoDB存储引擎\n⑥、高性能ＭySQL 第三版\n\n","slug":"MySQL-并发控制","published":1,"updated":"2020-09-24T10:18:58.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabmz005x45g3a6gi9z9i","content":"<p>无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题．通常并发控制是采用<code>锁的方式</code>来防止数据不一致．</p>\n<p>锁是数据库系统区别于文件系统的一个关键特性．<code>锁机制用于管理对共享资源（临界资源）的并发访问</code>．</p>\n<a id=\"more\"></a>\n\n<h4 id=\"1、读写锁\"><a href=\"#1、读写锁\" class=\"headerlink\" title=\"1、读写锁\"></a>1、读写锁</h4><p>在处理并发读和并发写时，可以通过实现一个由两种类型的锁组成的锁系统来解决，分别是：  </p>\n<ul>\n<li>①、共享锁（shared lock）——读锁， 多个客户在同一时刻读取同一个资源，而互不干扰。</li>\n<li>②、排它锁（exclusive lock）——写锁， 写锁会阻塞其他的写锁和读锁。</li>\n</ul>\n<h4 id=\"2、锁粒度\"><a href=\"#2、锁粒度\" class=\"headerlink\" title=\"2、锁粒度\"></a>2、锁粒度</h4><p>一种提高共享资源并发性的方式就是让锁定对象更具有选择性．尽量只锁定需要修改的部分数据，而不是所有的资源．更理想的方式是只对对修改的数据片进行精确锁定．<code>任何时候，在给定的资源上，锁定的数据量越少，并发度越高．</code></p>\n<p>问题是，加锁需要消耗资源．因此需要寻求一种策略，<code>在锁的开销和数据安全性之间做平衡，这就是锁策略</code>．</p>\n<p>每种数据库及相同数据库下不同引擎的锁策略都不同，例如：</p>\n<ul>\n<li>MySQL的<code>MyISAM存储引擎，其锁是表锁设计</code>．在并发情况下的读没有问题，但是并发写时性能就会差一些．</li>\n<li>对于Microsoft SQL Server数据库，2005版本之前是采用的页锁，相对于MyISAM引擎来说，并发性有所提高，但是对于热点数据页的并发问题，仍然无能为力．2005版本之后，通过支持乐观并发和悲观并发，在乐观并发下开始支持行级锁（其实现方式与InnoDB存储引擎完全不同）．</li>\n<li>InnoDB引擎锁的实现与Oracle数据库类似，提供<code>一致性非锁定读，行级锁支持</code>．</li>\n</ul>\n<p>Mysql提供了多钟锁策略，每种Mysql<code>存储引擎都可以实现自己的锁策略和锁粒度</code>。<br>锁定的资源越少，系统并发程度越高，但加锁消耗的资源越大（获得锁，检查锁，释放锁等操作）。</p>\n<h5 id=\"2-1、表锁（table-lock）\"><a href=\"#2-1、表锁（table-lock）\" class=\"headerlink\" title=\"2.1、表锁（table lock）\"></a>2.1、表锁（table lock）</h5><p>表锁是Mysql中最基本的锁策略，并且是开销最小的锁策略。它将会锁定整张表。其写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁请求队列的前面．</p>\n<p>某些情况下，Mysql自身会使用表锁实现目的，并忽略存储引擎的锁机制．例如，ALTER TABLE之类的语句使用的表锁。</p>\n<h5 id=\"2-2、行级锁（row-lock）\"><a href=\"#2-2、行级锁（row-lock）\" class=\"headerlink\" title=\"2.2、行级锁（row lock）\"></a>2.2、行级锁（row lock）</h5><p>行级锁可以最大程度地支持并发处理，但同时也带来了最大锁开销。<code>行级锁在存储引擎层实现的</code>。</p>\n<h4 id=\"3、InnoDB的锁类型\"><a href=\"#3、InnoDB的锁类型\" class=\"headerlink\" title=\"3、InnoDB的锁类型\"></a>3、InnoDB的锁类型</h4><p>每种Mysql存储引擎都可以实现自己的锁策略和锁粒度，InnoDB作为MySQL的默认引擎，拥有７种类型的锁用于并发控制．</p>\n<p>InnoDB共有七种类型的锁：</p>\n<ul>\n<li>①、<code>共享锁/排它锁（Shared and Exclusive Locks）</code></li>\n<li>②、<code>意向锁（Intention Locks）</code></li>\n<li>③、<code>记录锁（Record Locks）</code></li>\n<li>④、<code>间隙锁（Gap Locks）</code></li>\n<li>⑤、<code>临键锁（Next-key Locks）</code></li>\n<li>⑥、<code>插入意向锁（Insert Intention Locks）</code></li>\n<li>⑦、<code>自增锁（Auto-inc Locks）</code></li>\n</ul>\n<p>注：InnoDB的行锁是实现在索引上的，而不是物理行记录上，即如果没有命中索引，也无法使用行锁，将要退化为表锁。</p>\n<h5 id=\"3-1-共享锁-排它锁（Shared-and-Exclusive-Locks）\"><a href=\"#3-1-共享锁-排它锁（Shared-and-Exclusive-Locks）\" class=\"headerlink\" title=\"3.1 共享锁/排它锁（Shared and Exclusive Locks）\"></a>3.1 共享锁/排它锁（Shared and Exclusive Locks）</h5><p>在InnoDB里实现了<code>标准的行级锁(row-level locking)</code>，共享/排它锁：<br> (1)事务拿到某一行记录的共享S锁，才可以读取这一行；<br> (2)事务拿到某一行记录的排它X锁，才可以修改或者删除这一行；</p>\n<p>其兼容互斥表如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>S</th>\n<th>X</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S</td>\n<td>兼容</td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>X</td>\n<td>互斥</td>\n<td>互斥</td>\n</tr>\n</tbody></table>\n<p>即：</p>\n<ul>\n<li>①、多个事务可以拿到一把S锁，读读可以并行；</li>\n<li>②、而只有一个事务可以拿到X锁，写写/读写必须互斥；</li>\n</ul>\n<p><code>共享/排它锁的潜在问题是，不能充分的并行，解决思路是数据多版本控制（MVCC）。</code></p>\n<h5 id=\"3-2-自增锁（Auto-inc-Locks）\"><a href=\"#3-2-自增锁（Auto-inc-Locks）\" class=\"headerlink\" title=\"3.2 自增锁（Auto-inc Locks）\"></a>3.2 自增锁（Auto-inc Locks）</h5><p>在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现的方式称为AUTO-INC locking。</p>\n<p>通过以下命令查看表的自增长计数器的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select max(auto_inc_col) from &lt;table_name&gt; for update</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>自增锁是一种特殊的表级别锁（table-level lock）</code>，专门针对事务插入<code>AUTO_INCREMENT</code>类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。（<strong>注：自增锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放</strong>）</p>\n<p><em>在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。</em></p>\n<p>InnoDB提供了<code>innodb_autoinc_lock_mode</code>配置，可以调节与改变该锁的模式与行为。<br>一共提供了三种模式可供选择：  </p>\n<ul>\n<li>0：<code>traditonal</code> （每次都会产生表锁）  </li>\n<li>1：<code>consecutive</code> （默认．会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入）  </li>\n<li>2：<code>interleaved</code> （不会锁表，来一个处理一个，并发最高）  </li>\n</ul>\n<p>mysql不支持直接设置该变量，会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set innodb_autoinc_lock_mode &#x3D; 1;</span><br><span class=\"line\">ERROR 1238 (HY000): Variable &#39;innodb_autoinc_lock_mode&#39; is a read only variable</span><br></pre></td></tr></table></figure>\n\n\n\n<p>修改方式：修改mysqld配置文件的方式（Ubuntu16.04版本中，该配置文件路径为：<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>）：<br>在[mysqld]下添加配置项，例如：  </p>\n<figure class=\"highlight tex\"><figcaption><span>/etc/mysql/mysql.conf.d/mysqld.cnf</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_autoinc_lock_mode = 0</span><br></pre></td></tr></table></figure>\n<p>然后重启mysql服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service mysql restart</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MySQL，InnoDB，默认的隔离级别(RR)，假设有数据表：</span><br><span class=\"line\">t_id_incr(id AUTO_INCREMENT, name);</span><br><span class=\"line\"> </span><br><span class=\"line\">数据表中有数据：</span><br><span class=\"line\">1, shenjian</span><br><span class=\"line\">2, zhangsan</span><br><span class=\"line\">3, lisi</span><br><span class=\"line\"></span><br><span class=\"line\">按以下顺序执行，对于事务Ｂ会阻塞吗？</span><br><span class=\"line\"></span><br><span class=\"line\">A:set autocommit &#x3D; 0;</span><br><span class=\"line\">A:start transaction;</span><br><span class=\"line\">A:insert into t_id_incr(name) values(&#39;ooo&#39;);</span><br><span class=\"line\">\tB:set autocommit &#x3D; 0;</span><br><span class=\"line\">\tB:start transaction;</span><br><span class=\"line\">\tB:insert into t_id_incr(name) values(&#39;xxx&#39;);</span><br><span class=\"line\">A:insert into t_id_incr(name) values(&#39;xoo&#39;);</span><br><span class=\"line\">A:select * from t_id_incr;</span><br></pre></td></tr></table></figure>\n<p><u>该示例，将innodb_autoinc_lock_mode修改为0,1,2任何一个值，事务B依旧均没有阻塞？？？？这是正常的吗？？？？</u></p>\n<h5 id=\"3-3-意向锁（Intention-Locks）\"><a href=\"#3-3-意向锁（Intention-Locks）\" class=\"headerlink\" title=\"3.3 意向锁（Intention Locks）\"></a>3.3 意向锁（Intention Locks）</h5><p>InnoDB支持多粒度锁(multiple granularity locking)，它允许行级锁与表级锁共存．因此InnoDB支持一个额外的锁方式，即意向锁（Intention Lock）．</p>\n<p>意向锁是将锁定的对象分为多个层次，意味着事务希望在更细的粒度上进行加锁．例如：<code>需要对页上的记录ｒ进行上Ｘ锁，那么分别需要对数据库Ａ，表，页上意向锁IX，最后低记录ｒ上Ｘ锁．所起中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成．</code></p>\n<p>实际上，InnoDB支持的意向锁设计简练，即为表锁．是为了在一个事务中揭示下一行将被请求的锁类型． </p>\n<p>InnoDB意向锁的特点：</p>\n<ul>\n<li><p>①、意向锁是一个表级别的锁（table-level locking）;</p>\n</li>\n<li><p>②、意向锁又分为：</p>\n<ul>\n<li><strong>意向共享锁</strong>（Intention share lock, IS）, 它预示着事务有意向对表中某些行加共享S锁。</li>\n<li><strong>意向排它锁</strong>（Intention exclusive lock, IX）,它预示着，事务有意向对表中某些行加排它锁。<br>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ... lock in share mode &#x2F;&#x2F; 要设置IS锁；</span><br><span class=\"line\">select ... for update &#x2F;&#x2F; 要设置IX锁</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>意向锁协议</p>\n<ul>\n<li>事务要获得某些行的S锁，必须获得表的IS锁；</li>\n<li>事务要获得某些行的X锁，必须获得表的IX锁；</li>\n</ul>\n</li>\n<li><p><code>由于意向锁仅仅表明意向，它其实是比较弱的锁，意向锁之间并不相互互斥，而是可以并行</code>。</p>\n</li>\n<li><p><code>但是意向锁会和共享锁/排他锁互斥</code>， 其兼容互斥表如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IS</th>\n<th>IX</th>\n<th>S</th>\n<th>X</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IS</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>IX</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>互斥</td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>S</td>\n<td>兼容</td>\n<td>互斥</td>\n<td>兼容</td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>X</td>\n<td>互斥</td>\n<td>互斥</td>\n<td>互斥</td>\n<td>互斥</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h5 id=\"3-4-插入意向锁（Insert-Intention-Locks）\"><a href=\"#3-4-插入意向锁（Insert-Intention-Locks）\" class=\"headerlink\" title=\"3.4 插入意向锁（Insert Intention Locks）\"></a>3.4 插入意向锁（Insert Intention Locks）</h5><p>插入意向锁是间隙锁（Gap Locks）的一种（实施在索引上的），他是专门针对insert操作的。</p>\n<p>特点：<br>多个事务，在同一索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。<br>（官网原文：Insert Intention Lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap.）</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在MySQL，InnoDB，RR下：</span><br><span class=\"line\">t(id unique PK, name);</span><br><span class=\"line\"> </span><br><span class=\"line\">数据表中有数据：</span><br><span class=\"line\">10, shenjian</span><br><span class=\"line\">20, zhangsan</span><br><span class=\"line\">30, lisi</span><br><span class=\"line\"> </span><br><span class=\"line\">事务A先执行，在10与20两条记录中插入了一行，还未提交：</span><br><span class=\"line\">insert into t values(11, xxx);</span><br><span class=\"line\"> </span><br><span class=\"line\">事务B后执行，也在10与20两条记录中插入了一行：</span><br><span class=\"line\">insert into t values(12, ooo);</span><br><span class=\"line\"> </span><br><span class=\"line\">(1)会使用什么锁？</span><br><span class=\"line\">(2)事务B会不会被阻塞呢？</span><br></pre></td></tr></table></figure>\n<p>虽然事务隔离级别是RR，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：</p>\n<ul>\n<li>使用的是插入意向锁</li>\n<li>并不会阻塞事务B</li>\n</ul>\n<h5 id=\"3-5-记录锁（Record-Locks）\"><a href=\"#3-5-记录锁（Record-Locks）\" class=\"headerlink\" title=\"3.5 记录锁（Record Locks）\"></a>3.5 记录锁（Record Locks）</h5><p>记录锁，它封锁索引记录。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from t where id&#x3D;1 for update;</span><br></pre></td></tr></table></figure>\n<p>该示例会在id=1的索引记录上加锁，以阻止其他事务插入、更新、删除id=1的这一行。</p>\n<p>注：以下语句为快照读（SnapShot Read）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from t where id&#x3D;1;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3-6-间隙锁（Gap-Locks）\"><a href=\"#3-6-间隙锁（Gap-Locks）\" class=\"headerlink\" title=\"3.6 间隙锁（Gap Locks）\"></a>3.6 间隙锁（Gap Locks）</h5><p>间隙锁，它封锁索引记录中的间隔（<em>不包含记录本身</em>），或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子，InnoDB，RR隔离级别下：</span><br><span class=\"line\">t(id PK, name KEY, sex, flag);</span><br><span class=\"line\"> </span><br><span class=\"line\">表中有四条记录：</span><br><span class=\"line\">1, shenjian, m, A</span><br><span class=\"line\">3, zhangsan, m, A</span><br><span class=\"line\">5, lisi, m, A</span><br><span class=\"line\">9, wangwu, f, B</span><br><span class=\"line\"> </span><br><span class=\"line\">这个SQL语句</span><br><span class=\"line\">select * from t </span><br><span class=\"line\">    where id between 8 and 15 </span><br><span class=\"line\">    for update;</span><br><span class=\"line\">会封锁区间，以阻止其他事务id&#x3D;10的记录插入</span><br></pre></td></tr></table></figure>\n\n<p><u>间隙锁的作用是为了阻止多个事务将记录插入到同一个范围内，而这会导致Phantom Problem（幻象问题，MySQL定义的是不可重复读）问题的产生．</u></p>\n<p><code>显式关闭间隙锁的方法</code>：</p>\n<ul>\n<li>将事务的隔离级别设置为READ COMMITTED.</li>\n<li>将参数innodb_locks_unsafe_for_binlog设置为１．</li>\n</ul>\n<p><code>删除不存在的记录，获取到的是共享间隙锁．</code></p>\n<h5 id=\"3-7-临键锁（Next-Key-Locks）\"><a href=\"#3-7-临键锁（Next-Key-Locks）\" class=\"headerlink\" title=\"3.7 临键锁（Next-Key Locks）\"></a>3.7 临键锁（Next-Key Locks）</h5><p>临键锁，<code>是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。</code>InnoDB存储引擎默认<strong>对于行的查询都是采用临键锁的算法</strong>．<br>（临键锁会封锁索引记录本身，以及索引记录之前的区间）。</p>\n<p><code>如果一个Session（会话）占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。</code><br>（官方文档原文：If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.）</p>\n<p>例如：一个索引有10, 11, 13, 20这四个值，那么该索引可能被Next-Key Locking的区间为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(-infinity, 10]</span><br><span class=\"line\">(10, 11]</span><br><span class=\"line\">(11, 13]</span><br><span class=\"line\">(13, 20]</span><br><span class=\"line\">(20, +infinity]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其实除了Next-Key Locking外，还有一种<code>Previous-key Locking</code>技术，那么可锁定的区间是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(-infinity, 10)</span><br><span class=\"line\">[10, 11)</span><br><span class=\"line\">[11, 13)</span><br><span class=\"line\">[13, 20)</span><br><span class=\"line\">[20, +infinity)</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>当查询的索引含有唯一属性时</p>\n<ul>\n<li>等值查询的情况：InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身．</li>\n<li>范围查询的情况：InnoDB存储引擎会使用Next-Key Lock．</li>\n</ul>\n</li>\n</ul>\n<p>  示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">１．创建测试表</span><br><span class=\"line\">create table t (a int primary key);</span><br><span class=\"line\"></span><br><span class=\"line\">２．写入测试数据</span><br><span class=\"line\">insert into t select 1;</span><br><span class=\"line\">insert into t select 2;</span><br><span class=\"line\">insert into t select 5;</span><br><span class=\"line\"></span><br><span class=\"line\">３．等值查询的情况．</span><br><span class=\"line\">A: set autocommit&#x3D;0;</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: select * from t where a&#x3D;5 for update;</span><br><span class=\"line\">\tB: set autocommit&#x3D;0;</span><br><span class=\"line\">\tB: insert into t select 4; &#x2F;&#x2F; 成功，执行时并未发生阻塞．</span><br><span class=\"line\">A: commit;</span><br><span class=\"line\">\tB: commit;</span><br><span class=\"line\"></span><br><span class=\"line\">４．进行范围查询的情况．</span><br><span class=\"line\">A: set autocommit&#x3D;0;</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: select * from t where a&gt;2 for update; &#x2F;&#x2F; 范围查询时，对(2,+infinity)范围添加了Ｘ锁．</span><br><span class=\"line\">\tB: set autocommit&#x3D;0;</span><br><span class=\"line\">\tB: insert into t select 4; &#x2F;&#x2F; 失败，执行是发生阻塞．</span><br><span class=\"line\">A: commit;</span><br><span class=\"line\">\tB: commit;</span><br><span class=\"line\">status</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>当查询的索引为辅助索引，InnoDB存储引擎将会对辅助索引使用Next-Key Locking技术加锁，并且对辅助索引的下一个键值加上Gap Locks，同时对聚集索引，添加Record Locking．</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">１．创建测试表</span><br><span class=\"line\">create table z (a int, b int, primary key(a), key(b));</span><br><span class=\"line\"></span><br><span class=\"line\">２．写入测试数据</span><br><span class=\"line\">insert into z select 1, 1;</span><br><span class=\"line\">insert into z select 3, 1;</span><br><span class=\"line\">insert into z select 5, 3;</span><br><span class=\"line\">insert into z select 7, 6;</span><br><span class=\"line\">insert into z select 10, 8;</span><br><span class=\"line\"></span><br><span class=\"line\">３．两个事务按以下顺序执行：</span><br><span class=\"line\">A: set autocommit&#x3D;0;</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: select * from z where b &#x3D; 3 for update; &#x2F;&#x2F; 对于辅助索引：(1,3]添加临键锁；(3,6)添加间隙锁；对于聚簇索引a&#x3D;5添加记录锁．</span><br><span class=\"line\">\tB: set autocommit&#x3D;0;</span><br><span class=\"line\">\tB: select * from z where a &#x3D; 5 lock in share mode; &#x2F;&#x2F; 阻塞．</span><br><span class=\"line\">\tB: insert into z select 4, 2;　&#x2F;&#x2F; 阻塞，ａ&#x3D;4没问题，但是b&#x3D;2被临键锁锁定．</span><br><span class=\"line\">\tB: insert into z select 6, 5;　&#x2F;&#x2F; 阻塞，a&#x3D;6没问题，但是ｂ&#x3D;5被间隙锁锁定．</span><br></pre></td></tr></table></figure>\n\n<p>临键锁的目的，也是为了避免幻读，如果把事务的隔离级别降为RC，临键锁则也会失效。</p>\n<p>3.7.1 Phantom Problem(幻象问题，不可重复读)</p>\n<p><code>Phantom Problem(幻读)是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行．</code></p>\n<p>在默认的事务隔离级别（READ REPEATABLE）下，InnoDB采用<code>Next-Key Locking机制</code>来避免Phantom Problem.</p>\n<p>注意：<u>MySQL官方文档中，将<code>不可重复读</code>的问题定义为Phantom Problem，即幻象问题．</u></p>\n<h4 id=\"4-InnoDB一致性读\"><a href=\"#4-InnoDB一致性读\" class=\"headerlink\" title=\"4 InnoDB一致性读\"></a>4 InnoDB一致性读</h4><p>InnoDB提供了两种一致性读，分别是：</p>\n<ul>\n<li>一致性非锁定读（Consistent nonlocking read）</li>\n<li>一致性锁定读（Consistent locking read）</li>\n</ul>\n<h5 id=\"4-1-一致性非锁定读\"><a href=\"#4-1-一致性非锁定读\" class=\"headerlink\" title=\"4.1 一致性非锁定读\"></a>4.1 一致性非锁定读</h5><p>一致性非锁定读是指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间数据库中的行数据．若读取的行正在执行DELETE或UPDATE操作，这时<code>读取操作不会因此去等待行上的锁释放．而是去读取行的一个快照</code>．</p>\n<p>如下图所示：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/InnoDB存储引擎非锁定的一致性读.png\" alt=\"InnoDB存储引擎非锁定的一致性读\" style=\"zoom:80%;\" />  \n\n\n\n<p><code>什么是快照数据呢？</code></p>\n<p>快照数据是指行的之前版本的数据，该<code>实现是通过undo段来完成的</code>．而undo段用来在事务中回滚数据，因此，快照数据本身是没有任何开销的．此外，读快照数据是不需要上锁的．</p>\n<p>需要注意的是，并不是所有的隔离级别都是采用一致性非锁定读．实际上<code>只有在READ COMMITTED和REPEATABLE READ（默认隔离级别）隔离级别下，ＩnnoDB采用一致性非锁定读</code>．但是他们的快照数据定义却不相同．</p>\n<ul>\n<li>READ COMMITTED：总是读取最新的一份快照数据．</li>\n<li>REPEATABLE READ：总是读取最老的（事务最开始的那份）一份快照数据．</li>\n</ul>\n<h5 id=\"4-2-一致性锁定读\"><a href=\"#4-2-一致性锁定读\" class=\"headerlink\" title=\"4.2 一致性锁定读\"></a>4.2 一致性锁定读</h5><p>对于默认的隔离级别REPEATABLE READ模式下，如果想要显示的通过加锁的方式保证数据的一致性，InnoDB提供了一种加锁操作．如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ... for update &#x2F;&#x2F; 对读取行记录加一个Ｘ（排他）锁</span><br><span class=\"line\">select ... lock in share mode　&#x2F;&#x2F; 对读取行记录加一个Ｓ（共享）锁</span><br></pre></td></tr></table></figure>\n\n<p>注：使用以上两种方式显示加锁，需要加上<code>begin</code>, <code>start transaction</code>或<code>set autocommit=0</code>的操作．</p>\n<p><u>对于一致性非锁定读，使用<code>select ... for update</code>方式无效．仍然以快照读的方式运行．</u></p>\n<h4 id=\"5-死锁\"><a href=\"#5-死锁\" class=\"headerlink\" title=\"5 死锁\"></a>5 死锁</h4><h5 id=\"5-1-死锁的概念\"><a href=\"#5-1-死锁的概念\" class=\"headerlink\" title=\"5.1 死锁的概念\"></a>5.1 死锁的概念</h5><p>死锁是<code>指来两个或者两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象．</code></p>\n<p><code>解决死锁的办法</code>：</p>\n<ul>\n<li>超时：该方法是最简单的方法，即当两个事务相互等待时，当其中一个等待时间超过设置的某一阈值，将其中一个事务进行回滚，另一个等待的事务继续进行．<ul>\n<li>问题：仅通过超时回滚的方式，若超时的事务权重占比较大（如事务操作更新了很多行，占用较多的undo log），回滚该事务可能相对另一个事务占用的时间更多．</li>\n</ul>\n</li>\n<li>死锁检测：当前数据库普遍采用<code>Wait-For Gragh（等待图）的方式来进行死锁检测</code>．InnoDB即采用该方式．</li>\n</ul>\n<h6 id=\"5-1-1-Wait-For-Gragh（等待图）\"><a href=\"#5-1-1-Wait-For-Gragh（等待图）\" class=\"headerlink\" title=\"5.1.1 Wait-For Gragh（等待图）\"></a>5.1.1 Wait-For Gragh（等待图）</h6><p>Wait-For Gragh要求数据库通过使用以下两种信息链表构造出一张图，若图中存在回路，就表示存在死锁，因此资源间相互发生等待．</p>\n<ul>\n<li><code>锁的信息链表</code></li>\n<li><code>事务等待链表</code></li>\n</ul>\n<p><em>注：Wait-For Gragh中箭头（T1-&gt;T2）指向表示事务T1等待事务T2所占用的资源．</em></p>\n<p>Wait-For Gragh是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时会判断是否存在回路，若存在死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务．</p>\n<p><code>示例</code>：当前事务和锁的状态如下图所示．</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/事务和锁等待信息.png\" alt=\"事务和锁等待信息\" style=\"zoom:80%;\" />\n\n<p>其wait-for gragh如下，可见（t1, t2）存在回路，因此存在死锁．</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/wait-for-gragh.png\" alt=\"wait-for-gragh\" style=\"zoom:67%;\" />\n\n\n\n<h5 id=\"5-2-死锁的示例\"><a href=\"#5-2-死锁的示例\" class=\"headerlink\" title=\"5.2 死锁的示例\"></a>5.2 死锁的示例</h5><p>后续示例均在以下表中操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1. 建表</span><br><span class=\"line\">CREATE TABLE &#96;t&#96; (</span><br><span class=\"line\">  &#96;a&#96; int(11) NOT NULL,</span><br><span class=\"line\">  PRIMARY KEY (&#96;a&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 构建测试数据</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">|  a  |</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">|  1  |</span><br><span class=\"line\">|  2  |</span><br><span class=\"line\">|  4  |</span><br><span class=\"line\">|  5  |</span><br><span class=\"line\">|  11 |</span><br><span class=\"line\">+-----+</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"5-2-1-AB-BA情况\"><a href=\"#5-2-1-AB-BA情况\" class=\"headerlink\" title=\"5.2.1 AB-BA情况\"></a>5.2.1 AB-BA情况</h6><p>AB-BA情况，是最经典的死锁情况，即Ａ等待Ｂ，Ｂ在等待Ａ．</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: begin;</span><br><span class=\"line\">A: sselect * from t where a&#x3D;1 for update;</span><br><span class=\"line\">\tB: begin;</span><br><span class=\"line\">\tB: select * from t where a&#x3D;2 for update;</span><br><span class=\"line\">A: select * from t where a&#x3D;2 for update; # 阻塞</span><br><span class=\"line\">\tB: select * from t where a&#x3D;1 for update; # 发生死锁.</span><br><span class=\"line\">\tERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class=\"line\">A: 获取锁，返回结果．</span><br></pre></td></tr></table></figure>\n\n<p>发现死锁后，InnoDB存储引擎会马上回滚一个事务，另一个阻塞事务将继续进行．</p>\n<h6 id=\"5-2-2-共享锁-排他锁死锁\"><a href=\"#5-2-2-共享锁-排他锁死锁\" class=\"headerlink\" title=\"5.2.2 共享锁/排他锁死锁\"></a>5.2.2 共享锁/排他锁死锁</h6><p>当前事务持有待插入记录的下一个记录的Ｘ锁，但在等待队列中存在一个Ｓ锁的请求，则可能发生死锁．</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: begin;</span><br><span class=\"line\">\tB: begin;</span><br><span class=\"line\">A: select * from t where a&#x3D;4 for update; # 对ａ&#x3D;4持有一个排他锁．</span><br><span class=\"line\">\tB: select * from t where a&lt;&#x3D;4 lock in share mode; # 等待对a&lt;&#x3D;4的记录获取一个Ｓ锁．</span><br><span class=\"line\">A: insert into t values(3);　# 发生死锁，回滚undo log记录大的事务．</span><br><span class=\"line\">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class=\"line\">\tB: 获得锁，返回结果．</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----+     +-----+  </span><br><span class=\"line\">| a=4 |     | a=3 |</span><br><span class=\"line\">+-----+     +-----+</span><br><span class=\"line\">| A:X |     | B:S |</span><br><span class=\"line\">| B:S |</span><br><span class=\"line\">+-----+</span><br><span class=\"line\"> </span><br><span class=\"line\">     Ｂ等待Ａ释放a=4的排他锁</span><br><span class=\"line\">A&lt;--------------------------B</span><br><span class=\"line\"> --------------------------&gt;</span><br><span class=\"line\"> \t A等待B释放a=3的共享锁</span><br></pre></td></tr></table></figure>\n\n<p>注：以上示例与AB-BA死锁处理方式不同，此处选择回滚undo log记录大的事务．(为什么呢？？？？？？？？)</p>\n<h6 id=\"5-2-3-并发间隙锁的死锁\"><a href=\"#5-2-3-并发间隙锁的死锁\" class=\"headerlink\" title=\"5.2.3 并发间隙锁的死锁\"></a>5.2.3 并发间隙锁的死锁</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1. 准备测试数据，准备一个大的间隙的数据．</span><br><span class=\"line\">insert into t values(11);</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 开始测试．</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: delete from t where a&#x3D;7; #　删除一个不存在的记录，获取(5, 11)共享间隙锁．</span><br><span class=\"line\">\tB: begin;</span><br><span class=\"line\">\tB: delete from t where a&#x3D;8; #　删除一个不存在的记录，获取(5, 11)共享间隙锁．</span><br><span class=\"line\">A: insert into t values(9); # 插入数据，希望获得（5, 11)的排他间隙锁，于是会阻塞．</span><br><span class=\"line\">\tB: insert into t values(10);　# 插入数据，也希望获得（5, 11)的排他间隙锁，此时出现死锁．</span><br><span class=\"line\">\tERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class=\"line\">A: 由于事务Ｂ出现死锁，回滚，因此Ａ插入成功．</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过<code>show engine innodb status</code>命令查看死锁情况，可知，该死锁确实是由于locks gap导致的．</p>\n<hr>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><p>①、<a href=\"https://mp.weixin.qq.com/s/y_f2qrZvZe_F4_HPnwVjOw\">InnoDB，select为啥会阻塞insert？</a><br>②、<a href=\"https://mp.weixin.qq.com/s/iViStnwUyypwTkQHWDIR_w\">InnoDB并发插入，居然使用意向锁？</a><br>③、<a href=\"https://mp.weixin.qq.com/s/kOMSD_Satu9v9ciZVvNw8Q\">插入InnoDB自增列，居然是表锁？</a><br>④、<a href=\"https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ\">InnoDB并发如此高，原因竟然在这？</a><br>⑤、MySQL技术内幕+InnoDB存储引擎<br>⑥、高性能ＭySQL 第三版</p>\n","site":{"data":{}},"excerpt":"<p>无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题．通常并发控制是采用<code>锁的方式</code>来防止数据不一致．</p>\n<p>锁是数据库系统区别于文件系统的一个关键特性．<code>锁机制用于管理对共享资源（临界资源）的并发访问</code>．</p>","more":"<h4 id=\"1、读写锁\"><a href=\"#1、读写锁\" class=\"headerlink\" title=\"1、读写锁\"></a>1、读写锁</h4><p>在处理并发读和并发写时，可以通过实现一个由两种类型的锁组成的锁系统来解决，分别是：  </p>\n<ul>\n<li>①、共享锁（shared lock）——读锁， 多个客户在同一时刻读取同一个资源，而互不干扰。</li>\n<li>②、排它锁（exclusive lock）——写锁， 写锁会阻塞其他的写锁和读锁。</li>\n</ul>\n<h4 id=\"2、锁粒度\"><a href=\"#2、锁粒度\" class=\"headerlink\" title=\"2、锁粒度\"></a>2、锁粒度</h4><p>一种提高共享资源并发性的方式就是让锁定对象更具有选择性．尽量只锁定需要修改的部分数据，而不是所有的资源．更理想的方式是只对对修改的数据片进行精确锁定．<code>任何时候，在给定的资源上，锁定的数据量越少，并发度越高．</code></p>\n<p>问题是，加锁需要消耗资源．因此需要寻求一种策略，<code>在锁的开销和数据安全性之间做平衡，这就是锁策略</code>．</p>\n<p>每种数据库及相同数据库下不同引擎的锁策略都不同，例如：</p>\n<ul>\n<li>MySQL的<code>MyISAM存储引擎，其锁是表锁设计</code>．在并发情况下的读没有问题，但是并发写时性能就会差一些．</li>\n<li>对于Microsoft SQL Server数据库，2005版本之前是采用的页锁，相对于MyISAM引擎来说，并发性有所提高，但是对于热点数据页的并发问题，仍然无能为力．2005版本之后，通过支持乐观并发和悲观并发，在乐观并发下开始支持行级锁（其实现方式与InnoDB存储引擎完全不同）．</li>\n<li>InnoDB引擎锁的实现与Oracle数据库类似，提供<code>一致性非锁定读，行级锁支持</code>．</li>\n</ul>\n<p>Mysql提供了多钟锁策略，每种Mysql<code>存储引擎都可以实现自己的锁策略和锁粒度</code>。<br>锁定的资源越少，系统并发程度越高，但加锁消耗的资源越大（获得锁，检查锁，释放锁等操作）。</p>\n<h5 id=\"2-1、表锁（table-lock）\"><a href=\"#2-1、表锁（table-lock）\" class=\"headerlink\" title=\"2.1、表锁（table lock）\"></a>2.1、表锁（table lock）</h5><p>表锁是Mysql中最基本的锁策略，并且是开销最小的锁策略。它将会锁定整张表。其写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁请求队列的前面．</p>\n<p>某些情况下，Mysql自身会使用表锁实现目的，并忽略存储引擎的锁机制．例如，ALTER TABLE之类的语句使用的表锁。</p>\n<h5 id=\"2-2、行级锁（row-lock）\"><a href=\"#2-2、行级锁（row-lock）\" class=\"headerlink\" title=\"2.2、行级锁（row lock）\"></a>2.2、行级锁（row lock）</h5><p>行级锁可以最大程度地支持并发处理，但同时也带来了最大锁开销。<code>行级锁在存储引擎层实现的</code>。</p>\n<h4 id=\"3、InnoDB的锁类型\"><a href=\"#3、InnoDB的锁类型\" class=\"headerlink\" title=\"3、InnoDB的锁类型\"></a>3、InnoDB的锁类型</h4><p>每种Mysql存储引擎都可以实现自己的锁策略和锁粒度，InnoDB作为MySQL的默认引擎，拥有７种类型的锁用于并发控制．</p>\n<p>InnoDB共有七种类型的锁：</p>\n<ul>\n<li>①、<code>共享锁/排它锁（Shared and Exclusive Locks）</code></li>\n<li>②、<code>意向锁（Intention Locks）</code></li>\n<li>③、<code>记录锁（Record Locks）</code></li>\n<li>④、<code>间隙锁（Gap Locks）</code></li>\n<li>⑤、<code>临键锁（Next-key Locks）</code></li>\n<li>⑥、<code>插入意向锁（Insert Intention Locks）</code></li>\n<li>⑦、<code>自增锁（Auto-inc Locks）</code></li>\n</ul>\n<p>注：InnoDB的行锁是实现在索引上的，而不是物理行记录上，即如果没有命中索引，也无法使用行锁，将要退化为表锁。</p>\n<h5 id=\"3-1-共享锁-排它锁（Shared-and-Exclusive-Locks）\"><a href=\"#3-1-共享锁-排它锁（Shared-and-Exclusive-Locks）\" class=\"headerlink\" title=\"3.1 共享锁/排它锁（Shared and Exclusive Locks）\"></a>3.1 共享锁/排它锁（Shared and Exclusive Locks）</h5><p>在InnoDB里实现了<code>标准的行级锁(row-level locking)</code>，共享/排它锁：<br> (1)事务拿到某一行记录的共享S锁，才可以读取这一行；<br> (2)事务拿到某一行记录的排它X锁，才可以修改或者删除这一行；</p>\n<p>其兼容互斥表如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>S</th>\n<th>X</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S</td>\n<td>兼容</td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>X</td>\n<td>互斥</td>\n<td>互斥</td>\n</tr>\n</tbody></table>\n<p>即：</p>\n<ul>\n<li>①、多个事务可以拿到一把S锁，读读可以并行；</li>\n<li>②、而只有一个事务可以拿到X锁，写写/读写必须互斥；</li>\n</ul>\n<p><code>共享/排它锁的潜在问题是，不能充分的并行，解决思路是数据多版本控制（MVCC）。</code></p>\n<h5 id=\"3-2-自增锁（Auto-inc-Locks）\"><a href=\"#3-2-自增锁（Auto-inc-Locks）\" class=\"headerlink\" title=\"3.2 自增锁（Auto-inc Locks）\"></a>3.2 自增锁（Auto-inc Locks）</h5><p>在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化。插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现的方式称为AUTO-INC locking。</p>\n<p>通过以下命令查看表的自增长计数器的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select max(auto_inc_col) from &lt;table_name&gt; for update</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>自增锁是一种特殊的表级别锁（table-level lock）</code>，专门针对事务插入<code>AUTO_INCREMENT</code>类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。（<strong>注：自增锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放</strong>）</p>\n<p><em>在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。</em></p>\n<p>InnoDB提供了<code>innodb_autoinc_lock_mode</code>配置，可以调节与改变该锁的模式与行为。<br>一共提供了三种模式可供选择：  </p>\n<ul>\n<li>0：<code>traditonal</code> （每次都会产生表锁）  </li>\n<li>1：<code>consecutive</code> （默认．会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入）  </li>\n<li>2：<code>interleaved</code> （不会锁表，来一个处理一个，并发最高）  </li>\n</ul>\n<p>mysql不支持直接设置该变量，会抛出以下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set innodb_autoinc_lock_mode &#x3D; 1;</span><br><span class=\"line\">ERROR 1238 (HY000): Variable &#39;innodb_autoinc_lock_mode&#39; is a read only variable</span><br></pre></td></tr></table></figure>\n\n\n\n<p>修改方式：修改mysqld配置文件的方式（Ubuntu16.04版本中，该配置文件路径为：<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>）：<br>在[mysqld]下添加配置项，例如：  </p>\n<figure class=\"highlight tex\"><figcaption><span>/etc/mysql/mysql.conf.d/mysqld.cnf</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_autoinc_lock_mode = 0</span><br></pre></td></tr></table></figure>\n<p>然后重启mysql服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service mysql restart</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MySQL，InnoDB，默认的隔离级别(RR)，假设有数据表：</span><br><span class=\"line\">t_id_incr(id AUTO_INCREMENT, name);</span><br><span class=\"line\"> </span><br><span class=\"line\">数据表中有数据：</span><br><span class=\"line\">1, shenjian</span><br><span class=\"line\">2, zhangsan</span><br><span class=\"line\">3, lisi</span><br><span class=\"line\"></span><br><span class=\"line\">按以下顺序执行，对于事务Ｂ会阻塞吗？</span><br><span class=\"line\"></span><br><span class=\"line\">A:set autocommit &#x3D; 0;</span><br><span class=\"line\">A:start transaction;</span><br><span class=\"line\">A:insert into t_id_incr(name) values(&#39;ooo&#39;);</span><br><span class=\"line\">\tB:set autocommit &#x3D; 0;</span><br><span class=\"line\">\tB:start transaction;</span><br><span class=\"line\">\tB:insert into t_id_incr(name) values(&#39;xxx&#39;);</span><br><span class=\"line\">A:insert into t_id_incr(name) values(&#39;xoo&#39;);</span><br><span class=\"line\">A:select * from t_id_incr;</span><br></pre></td></tr></table></figure>\n<p><u>该示例，将innodb_autoinc_lock_mode修改为0,1,2任何一个值，事务B依旧均没有阻塞？？？？这是正常的吗？？？？</u></p>\n<h5 id=\"3-3-意向锁（Intention-Locks）\"><a href=\"#3-3-意向锁（Intention-Locks）\" class=\"headerlink\" title=\"3.3 意向锁（Intention Locks）\"></a>3.3 意向锁（Intention Locks）</h5><p>InnoDB支持多粒度锁(multiple granularity locking)，它允许行级锁与表级锁共存．因此InnoDB支持一个额外的锁方式，即意向锁（Intention Lock）．</p>\n<p>意向锁是将锁定的对象分为多个层次，意味着事务希望在更细的粒度上进行加锁．例如：<code>需要对页上的记录ｒ进行上Ｘ锁，那么分别需要对数据库Ａ，表，页上意向锁IX，最后低记录ｒ上Ｘ锁．所起中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成．</code></p>\n<p>实际上，InnoDB支持的意向锁设计简练，即为表锁．是为了在一个事务中揭示下一行将被请求的锁类型． </p>\n<p>InnoDB意向锁的特点：</p>\n<ul>\n<li><p>①、意向锁是一个表级别的锁（table-level locking）;</p>\n</li>\n<li><p>②、意向锁又分为：</p>\n<ul>\n<li><strong>意向共享锁</strong>（Intention share lock, IS）, 它预示着事务有意向对表中某些行加共享S锁。</li>\n<li><strong>意向排它锁</strong>（Intention exclusive lock, IX）,它预示着，事务有意向对表中某些行加排它锁。<br>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ... lock in share mode &#x2F;&#x2F; 要设置IS锁；</span><br><span class=\"line\">select ... for update &#x2F;&#x2F; 要设置IX锁</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>意向锁协议</p>\n<ul>\n<li>事务要获得某些行的S锁，必须获得表的IS锁；</li>\n<li>事务要获得某些行的X锁，必须获得表的IX锁；</li>\n</ul>\n</li>\n<li><p><code>由于意向锁仅仅表明意向，它其实是比较弱的锁，意向锁之间并不相互互斥，而是可以并行</code>。</p>\n</li>\n<li><p><code>但是意向锁会和共享锁/排他锁互斥</code>， 其兼容互斥表如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IS</th>\n<th>IX</th>\n<th>S</th>\n<th>X</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IS</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>IX</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>互斥</td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>S</td>\n<td>兼容</td>\n<td>互斥</td>\n<td>兼容</td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>X</td>\n<td>互斥</td>\n<td>互斥</td>\n<td>互斥</td>\n<td>互斥</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h5 id=\"3-4-插入意向锁（Insert-Intention-Locks）\"><a href=\"#3-4-插入意向锁（Insert-Intention-Locks）\" class=\"headerlink\" title=\"3.4 插入意向锁（Insert Intention Locks）\"></a>3.4 插入意向锁（Insert Intention Locks）</h5><p>插入意向锁是间隙锁（Gap Locks）的一种（实施在索引上的），他是专门针对insert操作的。</p>\n<p>特点：<br>多个事务，在同一索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。<br>（官网原文：Insert Intention Lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap.）</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在MySQL，InnoDB，RR下：</span><br><span class=\"line\">t(id unique PK, name);</span><br><span class=\"line\"> </span><br><span class=\"line\">数据表中有数据：</span><br><span class=\"line\">10, shenjian</span><br><span class=\"line\">20, zhangsan</span><br><span class=\"line\">30, lisi</span><br><span class=\"line\"> </span><br><span class=\"line\">事务A先执行，在10与20两条记录中插入了一行，还未提交：</span><br><span class=\"line\">insert into t values(11, xxx);</span><br><span class=\"line\"> </span><br><span class=\"line\">事务B后执行，也在10与20两条记录中插入了一行：</span><br><span class=\"line\">insert into t values(12, ooo);</span><br><span class=\"line\"> </span><br><span class=\"line\">(1)会使用什么锁？</span><br><span class=\"line\">(2)事务B会不会被阻塞呢？</span><br></pre></td></tr></table></figure>\n<p>虽然事务隔离级别是RR，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：</p>\n<ul>\n<li>使用的是插入意向锁</li>\n<li>并不会阻塞事务B</li>\n</ul>\n<h5 id=\"3-5-记录锁（Record-Locks）\"><a href=\"#3-5-记录锁（Record-Locks）\" class=\"headerlink\" title=\"3.5 记录锁（Record Locks）\"></a>3.5 记录锁（Record Locks）</h5><p>记录锁，它封锁索引记录。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from t where id&#x3D;1 for update;</span><br></pre></td></tr></table></figure>\n<p>该示例会在id=1的索引记录上加锁，以阻止其他事务插入、更新、删除id=1的这一行。</p>\n<p>注：以下语句为快照读（SnapShot Read）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from t where id&#x3D;1;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3-6-间隙锁（Gap-Locks）\"><a href=\"#3-6-间隙锁（Gap-Locks）\" class=\"headerlink\" title=\"3.6 间隙锁（Gap Locks）\"></a>3.6 间隙锁（Gap Locks）</h5><p>间隙锁，它封锁索引记录中的间隔（<em>不包含记录本身</em>），或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子，InnoDB，RR隔离级别下：</span><br><span class=\"line\">t(id PK, name KEY, sex, flag);</span><br><span class=\"line\"> </span><br><span class=\"line\">表中有四条记录：</span><br><span class=\"line\">1, shenjian, m, A</span><br><span class=\"line\">3, zhangsan, m, A</span><br><span class=\"line\">5, lisi, m, A</span><br><span class=\"line\">9, wangwu, f, B</span><br><span class=\"line\"> </span><br><span class=\"line\">这个SQL语句</span><br><span class=\"line\">select * from t </span><br><span class=\"line\">    where id between 8 and 15 </span><br><span class=\"line\">    for update;</span><br><span class=\"line\">会封锁区间，以阻止其他事务id&#x3D;10的记录插入</span><br></pre></td></tr></table></figure>\n\n<p><u>间隙锁的作用是为了阻止多个事务将记录插入到同一个范围内，而这会导致Phantom Problem（幻象问题，MySQL定义的是不可重复读）问题的产生．</u></p>\n<p><code>显式关闭间隙锁的方法</code>：</p>\n<ul>\n<li>将事务的隔离级别设置为READ COMMITTED.</li>\n<li>将参数innodb_locks_unsafe_for_binlog设置为１．</li>\n</ul>\n<p><code>删除不存在的记录，获取到的是共享间隙锁．</code></p>\n<h5 id=\"3-7-临键锁（Next-Key-Locks）\"><a href=\"#3-7-临键锁（Next-Key-Locks）\" class=\"headerlink\" title=\"3.7 临键锁（Next-Key Locks）\"></a>3.7 临键锁（Next-Key Locks）</h5><p>临键锁，<code>是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。</code>InnoDB存储引擎默认<strong>对于行的查询都是采用临键锁的算法</strong>．<br>（临键锁会封锁索引记录本身，以及索引记录之前的区间）。</p>\n<p><code>如果一个Session（会话）占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。</code><br>（官方文档原文：If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.）</p>\n<p>例如：一个索引有10, 11, 13, 20这四个值，那么该索引可能被Next-Key Locking的区间为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(-infinity, 10]</span><br><span class=\"line\">(10, 11]</span><br><span class=\"line\">(11, 13]</span><br><span class=\"line\">(13, 20]</span><br><span class=\"line\">(20, +infinity]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其实除了Next-Key Locking外，还有一种<code>Previous-key Locking</code>技术，那么可锁定的区间是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(-infinity, 10)</span><br><span class=\"line\">[10, 11)</span><br><span class=\"line\">[11, 13)</span><br><span class=\"line\">[13, 20)</span><br><span class=\"line\">[20, +infinity)</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>当查询的索引含有唯一属性时</p>\n<ul>\n<li>等值查询的情况：InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身．</li>\n<li>范围查询的情况：InnoDB存储引擎会使用Next-Key Lock．</li>\n</ul>\n</li>\n</ul>\n<p>  示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">１．创建测试表</span><br><span class=\"line\">create table t (a int primary key);</span><br><span class=\"line\"></span><br><span class=\"line\">２．写入测试数据</span><br><span class=\"line\">insert into t select 1;</span><br><span class=\"line\">insert into t select 2;</span><br><span class=\"line\">insert into t select 5;</span><br><span class=\"line\"></span><br><span class=\"line\">３．等值查询的情况．</span><br><span class=\"line\">A: set autocommit&#x3D;0;</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: select * from t where a&#x3D;5 for update;</span><br><span class=\"line\">\tB: set autocommit&#x3D;0;</span><br><span class=\"line\">\tB: insert into t select 4; &#x2F;&#x2F; 成功，执行时并未发生阻塞．</span><br><span class=\"line\">A: commit;</span><br><span class=\"line\">\tB: commit;</span><br><span class=\"line\"></span><br><span class=\"line\">４．进行范围查询的情况．</span><br><span class=\"line\">A: set autocommit&#x3D;0;</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: select * from t where a&gt;2 for update; &#x2F;&#x2F; 范围查询时，对(2,+infinity)范围添加了Ｘ锁．</span><br><span class=\"line\">\tB: set autocommit&#x3D;0;</span><br><span class=\"line\">\tB: insert into t select 4; &#x2F;&#x2F; 失败，执行是发生阻塞．</span><br><span class=\"line\">A: commit;</span><br><span class=\"line\">\tB: commit;</span><br><span class=\"line\">status</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>当查询的索引为辅助索引，InnoDB存储引擎将会对辅助索引使用Next-Key Locking技术加锁，并且对辅助索引的下一个键值加上Gap Locks，同时对聚集索引，添加Record Locking．</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">１．创建测试表</span><br><span class=\"line\">create table z (a int, b int, primary key(a), key(b));</span><br><span class=\"line\"></span><br><span class=\"line\">２．写入测试数据</span><br><span class=\"line\">insert into z select 1, 1;</span><br><span class=\"line\">insert into z select 3, 1;</span><br><span class=\"line\">insert into z select 5, 3;</span><br><span class=\"line\">insert into z select 7, 6;</span><br><span class=\"line\">insert into z select 10, 8;</span><br><span class=\"line\"></span><br><span class=\"line\">３．两个事务按以下顺序执行：</span><br><span class=\"line\">A: set autocommit&#x3D;0;</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: select * from z where b &#x3D; 3 for update; &#x2F;&#x2F; 对于辅助索引：(1,3]添加临键锁；(3,6)添加间隙锁；对于聚簇索引a&#x3D;5添加记录锁．</span><br><span class=\"line\">\tB: set autocommit&#x3D;0;</span><br><span class=\"line\">\tB: select * from z where a &#x3D; 5 lock in share mode; &#x2F;&#x2F; 阻塞．</span><br><span class=\"line\">\tB: insert into z select 4, 2;　&#x2F;&#x2F; 阻塞，ａ&#x3D;4没问题，但是b&#x3D;2被临键锁锁定．</span><br><span class=\"line\">\tB: insert into z select 6, 5;　&#x2F;&#x2F; 阻塞，a&#x3D;6没问题，但是ｂ&#x3D;5被间隙锁锁定．</span><br></pre></td></tr></table></figure>\n\n<p>临键锁的目的，也是为了避免幻读，如果把事务的隔离级别降为RC，临键锁则也会失效。</p>\n<p>3.7.1 Phantom Problem(幻象问题，不可重复读)</p>\n<p><code>Phantom Problem(幻读)是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行．</code></p>\n<p>在默认的事务隔离级别（READ REPEATABLE）下，InnoDB采用<code>Next-Key Locking机制</code>来避免Phantom Problem.</p>\n<p>注意：<u>MySQL官方文档中，将<code>不可重复读</code>的问题定义为Phantom Problem，即幻象问题．</u></p>\n<h4 id=\"4-InnoDB一致性读\"><a href=\"#4-InnoDB一致性读\" class=\"headerlink\" title=\"4 InnoDB一致性读\"></a>4 InnoDB一致性读</h4><p>InnoDB提供了两种一致性读，分别是：</p>\n<ul>\n<li>一致性非锁定读（Consistent nonlocking read）</li>\n<li>一致性锁定读（Consistent locking read）</li>\n</ul>\n<h5 id=\"4-1-一致性非锁定读\"><a href=\"#4-1-一致性非锁定读\" class=\"headerlink\" title=\"4.1 一致性非锁定读\"></a>4.1 一致性非锁定读</h5><p>一致性非锁定读是指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间数据库中的行数据．若读取的行正在执行DELETE或UPDATE操作，这时<code>读取操作不会因此去等待行上的锁释放．而是去读取行的一个快照</code>．</p>\n<p>如下图所示：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/InnoDB存储引擎非锁定的一致性读.png\" alt=\"InnoDB存储引擎非锁定的一致性读\" style=\"zoom:80%;\" />  \n\n\n\n<p><code>什么是快照数据呢？</code></p>\n<p>快照数据是指行的之前版本的数据，该<code>实现是通过undo段来完成的</code>．而undo段用来在事务中回滚数据，因此，快照数据本身是没有任何开销的．此外，读快照数据是不需要上锁的．</p>\n<p>需要注意的是，并不是所有的隔离级别都是采用一致性非锁定读．实际上<code>只有在READ COMMITTED和REPEATABLE READ（默认隔离级别）隔离级别下，ＩnnoDB采用一致性非锁定读</code>．但是他们的快照数据定义却不相同．</p>\n<ul>\n<li>READ COMMITTED：总是读取最新的一份快照数据．</li>\n<li>REPEATABLE READ：总是读取最老的（事务最开始的那份）一份快照数据．</li>\n</ul>\n<h5 id=\"4-2-一致性锁定读\"><a href=\"#4-2-一致性锁定读\" class=\"headerlink\" title=\"4.2 一致性锁定读\"></a>4.2 一致性锁定读</h5><p>对于默认的隔离级别REPEATABLE READ模式下，如果想要显示的通过加锁的方式保证数据的一致性，InnoDB提供了一种加锁操作．如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ... for update &#x2F;&#x2F; 对读取行记录加一个Ｘ（排他）锁</span><br><span class=\"line\">select ... lock in share mode　&#x2F;&#x2F; 对读取行记录加一个Ｓ（共享）锁</span><br></pre></td></tr></table></figure>\n\n<p>注：使用以上两种方式显示加锁，需要加上<code>begin</code>, <code>start transaction</code>或<code>set autocommit=0</code>的操作．</p>\n<p><u>对于一致性非锁定读，使用<code>select ... for update</code>方式无效．仍然以快照读的方式运行．</u></p>\n<h4 id=\"5-死锁\"><a href=\"#5-死锁\" class=\"headerlink\" title=\"5 死锁\"></a>5 死锁</h4><h5 id=\"5-1-死锁的概念\"><a href=\"#5-1-死锁的概念\" class=\"headerlink\" title=\"5.1 死锁的概念\"></a>5.1 死锁的概念</h5><p>死锁是<code>指来两个或者两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象．</code></p>\n<p><code>解决死锁的办法</code>：</p>\n<ul>\n<li>超时：该方法是最简单的方法，即当两个事务相互等待时，当其中一个等待时间超过设置的某一阈值，将其中一个事务进行回滚，另一个等待的事务继续进行．<ul>\n<li>问题：仅通过超时回滚的方式，若超时的事务权重占比较大（如事务操作更新了很多行，占用较多的undo log），回滚该事务可能相对另一个事务占用的时间更多．</li>\n</ul>\n</li>\n<li>死锁检测：当前数据库普遍采用<code>Wait-For Gragh（等待图）的方式来进行死锁检测</code>．InnoDB即采用该方式．</li>\n</ul>\n<h6 id=\"5-1-1-Wait-For-Gragh（等待图）\"><a href=\"#5-1-1-Wait-For-Gragh（等待图）\" class=\"headerlink\" title=\"5.1.1 Wait-For Gragh（等待图）\"></a>5.1.1 Wait-For Gragh（等待图）</h6><p>Wait-For Gragh要求数据库通过使用以下两种信息链表构造出一张图，若图中存在回路，就表示存在死锁，因此资源间相互发生等待．</p>\n<ul>\n<li><code>锁的信息链表</code></li>\n<li><code>事务等待链表</code></li>\n</ul>\n<p><em>注：Wait-For Gragh中箭头（T1-&gt;T2）指向表示事务T1等待事务T2所占用的资源．</em></p>\n<p>Wait-For Gragh是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时会判断是否存在回路，若存在死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务．</p>\n<p><code>示例</code>：当前事务和锁的状态如下图所示．</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/事务和锁等待信息.png\" alt=\"事务和锁等待信息\" style=\"zoom:80%;\" />\n\n<p>其wait-for gragh如下，可见（t1, t2）存在回路，因此存在死锁．</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/MySQL-并发控制/wait-for-gragh.png\" alt=\"wait-for-gragh\" style=\"zoom:67%;\" />\n\n\n\n<h5 id=\"5-2-死锁的示例\"><a href=\"#5-2-死锁的示例\" class=\"headerlink\" title=\"5.2 死锁的示例\"></a>5.2 死锁的示例</h5><p>后续示例均在以下表中操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1. 建表</span><br><span class=\"line\">CREATE TABLE &#96;t&#96; (</span><br><span class=\"line\">  &#96;a&#96; int(11) NOT NULL,</span><br><span class=\"line\">  PRIMARY KEY (&#96;a&#96;)</span><br><span class=\"line\">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 构建测试数据</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">|  a  |</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">|  1  |</span><br><span class=\"line\">|  2  |</span><br><span class=\"line\">|  4  |</span><br><span class=\"line\">|  5  |</span><br><span class=\"line\">|  11 |</span><br><span class=\"line\">+-----+</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"5-2-1-AB-BA情况\"><a href=\"#5-2-1-AB-BA情况\" class=\"headerlink\" title=\"5.2.1 AB-BA情况\"></a>5.2.1 AB-BA情况</h6><p>AB-BA情况，是最经典的死锁情况，即Ａ等待Ｂ，Ｂ在等待Ａ．</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: begin;</span><br><span class=\"line\">A: sselect * from t where a&#x3D;1 for update;</span><br><span class=\"line\">\tB: begin;</span><br><span class=\"line\">\tB: select * from t where a&#x3D;2 for update;</span><br><span class=\"line\">A: select * from t where a&#x3D;2 for update; # 阻塞</span><br><span class=\"line\">\tB: select * from t where a&#x3D;1 for update; # 发生死锁.</span><br><span class=\"line\">\tERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class=\"line\">A: 获取锁，返回结果．</span><br></pre></td></tr></table></figure>\n\n<p>发现死锁后，InnoDB存储引擎会马上回滚一个事务，另一个阻塞事务将继续进行．</p>\n<h6 id=\"5-2-2-共享锁-排他锁死锁\"><a href=\"#5-2-2-共享锁-排他锁死锁\" class=\"headerlink\" title=\"5.2.2 共享锁/排他锁死锁\"></a>5.2.2 共享锁/排他锁死锁</h6><p>当前事务持有待插入记录的下一个记录的Ｘ锁，但在等待队列中存在一个Ｓ锁的请求，则可能发生死锁．</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: begin;</span><br><span class=\"line\">\tB: begin;</span><br><span class=\"line\">A: select * from t where a&#x3D;4 for update; # 对ａ&#x3D;4持有一个排他锁．</span><br><span class=\"line\">\tB: select * from t where a&lt;&#x3D;4 lock in share mode; # 等待对a&lt;&#x3D;4的记录获取一个Ｓ锁．</span><br><span class=\"line\">A: insert into t values(3);　# 发生死锁，回滚undo log记录大的事务．</span><br><span class=\"line\">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class=\"line\">\tB: 获得锁，返回结果．</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----+     +-----+  </span><br><span class=\"line\">| a=4 |     | a=3 |</span><br><span class=\"line\">+-----+     +-----+</span><br><span class=\"line\">| A:X |     | B:S |</span><br><span class=\"line\">| B:S |</span><br><span class=\"line\">+-----+</span><br><span class=\"line\"> </span><br><span class=\"line\">     Ｂ等待Ａ释放a=4的排他锁</span><br><span class=\"line\">A&lt;--------------------------B</span><br><span class=\"line\"> --------------------------&gt;</span><br><span class=\"line\"> \t A等待B释放a=3的共享锁</span><br></pre></td></tr></table></figure>\n\n<p>注：以上示例与AB-BA死锁处理方式不同，此处选择回滚undo log记录大的事务．(为什么呢？？？？？？？？)</p>\n<h6 id=\"5-2-3-并发间隙锁的死锁\"><a href=\"#5-2-3-并发间隙锁的死锁\" class=\"headerlink\" title=\"5.2.3 并发间隙锁的死锁\"></a>5.2.3 并发间隙锁的死锁</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1. 准备测试数据，准备一个大的间隙的数据．</span><br><span class=\"line\">insert into t values(11);</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 开始测试．</span><br><span class=\"line\">A: begin;</span><br><span class=\"line\">A: delete from t where a&#x3D;7; #　删除一个不存在的记录，获取(5, 11)共享间隙锁．</span><br><span class=\"line\">\tB: begin;</span><br><span class=\"line\">\tB: delete from t where a&#x3D;8; #　删除一个不存在的记录，获取(5, 11)共享间隙锁．</span><br><span class=\"line\">A: insert into t values(9); # 插入数据，希望获得（5, 11)的排他间隙锁，于是会阻塞．</span><br><span class=\"line\">\tB: insert into t values(10);　# 插入数据，也希望获得（5, 11)的排他间隙锁，此时出现死锁．</span><br><span class=\"line\">\tERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class=\"line\">A: 由于事务Ｂ出现死锁，回滚，因此Ａ插入成功．</span><br></pre></td></tr></table></figure>\n\n\n\n<p>通过<code>show engine innodb status</code>命令查看死锁情况，可知，该死锁确实是由于locks gap导致的．</p>\n<hr>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><p>①、<a href=\"https://mp.weixin.qq.com/s/y_f2qrZvZe_F4_HPnwVjOw\">InnoDB，select为啥会阻塞insert？</a><br>②、<a href=\"https://mp.weixin.qq.com/s/iViStnwUyypwTkQHWDIR_w\">InnoDB并发插入，居然使用意向锁？</a><br>③、<a href=\"https://mp.weixin.qq.com/s/kOMSD_Satu9v9ciZVvNw8Q\">插入InnoDB自增列，居然是表锁？</a><br>④、<a href=\"https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ\">InnoDB并发如此高，原因竟然在这？</a><br>⑤、MySQL技术内幕+InnoDB存储引擎<br>⑥、高性能ＭySQL 第三版</p>"},{"title":"PHP7内核-FPM","date":"2020-08-21T10:15:16.000Z","_content":"\n\n\n### 1 概述\nFPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其<u>核心功能是进程管理</u>。  \nFastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。<u>注：FastCGI只是一种协议</u>。\n\n<!--more-->\n\nPHP处理Http请求过程：`PHP接收请求`、`解析协议`，`处理完成返回请求`。  \n在网络应用场景下，PHP实现了FastCGI协议，然后与web服务器配合实现了http的处理，web服务器处理http请求，然后将解析的结果通过FastCGI协议转发给处理程序，处理程序处理完成后将结果返回给web服务器，web服务器再返回给用户，如下图所示：\n![fastcgi](https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4)\n\n<u>PHP实现了FastCGI协议的解析，但未具体实现网络处理</u>，一般的处理模型：`多进程`，`多线程`。\n\n- **多进程模型**：主进程只负责管理子进程，而基本的网络事件由各个子进程处理，例如：nginx、fpm。\n- **多线程模型**：与多进程类似，只是它是线程粒度，这种模式通常由主线程监听、接收请求，然后交给子线程处理，例如：memcache。有的也用多进程的那种模式——主线程只负责管理子线程，各个子线程负责监听、接收、处理请求，例如：memcache使用udp协议的情况。\n\n*进程拥有独立的地址空间及资源，而线程没有，线程之间共享进程的地址空间及资源，所以在资源管理上多进程模型比较简单，而多线程模型需考虑不同线程之间的资源冲突，及线程安全。*\n\n### 2 基本实现\nFPM是一个`多进程模型`，它由`一个master进程`和`多个worker进程`组成。master会创建一个socket，但不会接口处理进程，而是由fork出的worker进程处理接收请求和处理。\n\n- **master进程**：master进程的主要工作是管理worker进程，负责fork或kill掉worker进程。\n- **worker进程**：worker进程的主要工作是处理请求，其生命周期为：`accept请求->解析FastCGI->执行相应脚本->关闭请求->等待新的请求`。  \n*注：Fpm为阻塞式模型，即一个进程只会同时链接一个请求。（目的是为了简化PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突）*\n\n**FPM的实现概括**：创建一个master进程，在master进程中创建并监听socket， 然后fork出多个子进程，这些子进程各自accept请求，有请求达到后开始读取请求数据，读取完成后开始处理然后返回。<u>（子进程启动后阻塞在accept上，直到有请求到达，且子进程同时只能响应一个请求。）</u>\n\nFPM的master进程与worker进程之间不会直接进行通信，master通过`共享内存`获取worker进程的信息（worker当前状态、已处理请求数等），当master进程要kill一个worker进程则通过`发信号的方式`通知worker进程（**master进程管理woker进程通过发信号的方式**）。\n\n<u>FPM可以监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程。</u>\n![worker_pool](https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd)\n\n在`php-fpm.conf`（php-fpm.conf路径：`/etc/php/7.1/fpm/php-fpm.conf`）中通过[pool name]声明一个worker pool：  \n（php-fpm.conf文件中include了多个pool配置，相关配置在（`/etc/php/7.1/fpm/pool.d/*.conf`））\n\n```\n[web1]\nlisten = 127.0.0.1:9000\n...\n\n[web2]\nlisten = 127.0.0.1:9001\n...\n```\n\n启动fpm后查看进程：ps -aux|grep fpm\n```\nroot     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (/usr/local/php7/etc/php-fpm.conf)\nnobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1\nnobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1\nnobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2\nnobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2\n```\n\n**具体实现**：\n`worker pool`通过`fpm_worker_pool_s`这个结构表示，多个`worker pool`组成一个**单链表**:\n\n```c\nstruct fpm_worker_pool_s {\n    struct fpm_worker_pool_s *next; //指向下一个worker pool\n    struct fpm_worker_pool_config_s *config; //conf配置:pm、max_children、start_servers...\n    int listening_socket; //监听的套接字\n    ...\n\n    struct fpm_child_s *children; // 当前pool的worker链表，每一个worker对应一个fpm_child_s结构\n    int running_children; //当前pool的worker运行总数\n    int idle_spawn_rate;\n    int warn_max_children;\n\n    struct fpm_scoreboard_s *scoreboard; //记录worker的运行信息，比如空闲、忙碌worker数\n    ...\n}\n```\n\n#### 2.1 FPM的初始化\nFpm在启动后首先会进行`SAPI的注册操作`，接着会进入PHP生命周期的`module startup`阶段，在这个阶段会调用各个扩展定义的MINT钩子函数，然后进行一系列的初始化操作，最后master，worker进程进入不同的处理环节。\n\n<u>fpm的启动流程：</u>\n\n```c\n//sapi/fpm/fpm/fpm_main.c\nint main(int argc, char *argv[])\n{\n    ...\n    //注册SAPI:将全局变量sapi_module设置为cgi_sapi_module\n    sapi_startup(&cgi_sapi_module);\n    ...\n    //执行php_module_starup()\n    if (cgi_sapi_module.startup(&cgi_sapi_module) == FAILURE) {\n        return FPM_EXIT_SOFTWARE;\n    }\n    ...\n    //初始化\n    if(0 > fpm_init(...)){\n        ...\n    }\n    ...\n    fpm_is_running = 1;\n\n    fcgi_fd = fpm_run(&max_requests);//后面都是worker进程的操作，master进程不会走到下面\n    parent = 0;\n    ...\n}\n```\n`fpm_init()`主要有以下几个关键操作：\n\n- fpm_conf_init_main():  解析php-fpm.conf配置文件.\n解析`php-fpm.conf`配置文件，分配worker pool内存结构并保存到全局变量中：fpm_worker_all_pools，各worker pool配置解析到`fpm_worker_pool_s->config`中，以下为config中的几个常用配置：\n```c\nstruct fpm_worker_pool_config_s {\n\tchar *name; // pool名称，即配置：[pool name]\n\tchar *user; // Fpm的启动用户：配置：user\n\tchar *group; // 配置：group\n\tchar *listen_address; // 监听的地址，配置：listen\n\t...\n\tint pm; // 进程模型：static、dynamic、ondemand\n\tint pm_max_children; // 最大worker进程数\n\tint pm_start_servers; // 启动时初始化的worker数\n\tint pm_min_spare_servers; // 最小空闲worker数\n\tint pm_max_spare_servers; // 最大空闲worker数\n\tint pm_process_idle_timeout; // worker空闲时间\n\tint pm_max_requests; // worker处理的最多请求数，超多这个值worker将被kill\n    ...\n};\n```\n\n- fpm_scoreboard_init_main():  分配用于记录worker进行运行信息的共享内存.\n分配用于`记录worker进程运行信息的共享内存`。按照worker pool的最大worker进程数分配，每个worker pool分配一个**fpm_scoreboard_s**结构，pool下对应的每个worker进程分配一个**fpm_scoreboard_proc_s**结构，各结构的对应关系如下图。\n![worker_pool_struct](https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738)\n\n- fpm_signals_init_mian():  mataer进行创建管道及注册信号管理worker进程.\n```c\nstatic int sp[2];\n\nint fpm_signals_init_main()\n{\n    struct sigaction act;\n\n    //创建一个全双工管道，该管道不是用于master与worker进程通信的，只在master进程中使用。\n    if (0 > socketpair(AF_UNIX, SOCK_STREAM, 0, sp)) {\n        return -1;\n    }\n    //注册信号处理handler\n    act.sa_handler = sig_handler;\n    sigfillset(&act.sa_mask);\n    if (0 > sigaction(SIGTERM,  &act, 0) ||\n        0 > sigaction(SIGINT,   &act, 0) ||\n        0 > sigaction(SIGUSR1,  &act, 0) ||\n        0 > sigaction(SIGUSR2,  &act, 0) ||\n        0 > sigaction(SIGCHLD,  &act, 0) ||\n        0 > sigaction(SIGQUIT,  &act, 0)) {\n        return -1;\n    }\n    return 0;\n}\n```\n通过**socketpair()**创建一个管道，此管道只在master进程中使用。另外设置master的信号处理handler，当master收到SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT这些信号时将调用sig_handler()处理：\n```c\nstatic void sig_handler(int signo)\n{\n    static const char sig_chars[NSIG + 1] = {\n        [SIGTERM] = 'T',\n        [SIGINT]  = 'I',\n        [SIGUSR1] = '1',\n        [SIGUSR2] = '2',\n        [SIGQUIT] = 'Q',\n        [SIGCHLD] = 'C'\n    };\n    char s;\n    ...\n    s = sig_chars[signo];\n    //将信号通知写入管道sp[1]端\n    write(sp[1], &s, sizeof(s));\n    ...\n}\n```\n\n- fpm_sockets_init_main():  创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。\n- fpm_event_init_main():  启动master的事件管理.\n启动master的事件管理，fpm实现了一个事件管理器用于管理IO、定时事件，其中IO事件通过kqueue、epoll、poll、select等管理，定时事件就是定时器，一定时间后触发某个事件。\n\n\n\n在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将fork子进程，启动进程管理器，另外master进程将不会再返回，只有各worker进程会返回，也就是说fpm_run()之后的操作均是worker进程的。\n\n```c\nint fpm_run(int *max_requests)\n{\n    struct fpm_worker_pool_s *wp;\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        //调用fpm_children_make() fork子进程\n        is_parent = fpm_children_create_initial(wp);\n        \n        if (!is_parent) {\n            goto run_child;\n        }\n    }\n    //master进程将进入event循环，不再往下走\n    fpm_event_loop(0);\n\nrun_child: //只有worker进程会到这里\n\n    *max_requests = fpm_globals.max_requests;\n    return fpm_globals.listening_socket; //返回监听的套接字\n}\n```\n\n在fork后worker进程返回了监听的套接字继续main()后面的处理，而master将永远阻塞在fpm_event_loop().\n\n\n#### 2.2 worker-请求处理\nfpm_run()执行后将fork出worker进程，worker进程返回main()中继续向下执行，后面的流程就是worker进程不断accept请求，然后执行PHP脚本并返回。整体流程如下：\n- **等待请求**： worker进程阻塞在fcgi_accept_request()等待请求。\n- **解析请求**： fastcgi请求到达后被worker接收，然后开始接受并解析请求数据，直到request数据完全到达。\n- **请求初始化**：执行php_request_startup(), 此阶段会调用每个扩展的PHP_RINI_FUNCTION();\n- **编译、执行**：php_execute_script()完成PHP脚本的编译、执行。\n- **关闭请求**：请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。\n```c\nint main(int argc, char *argv[])\n{\n    ...\n    fcgi_fd = fpm_run(&max_requests);\n    parent = 0;\n\n    //初始化fastcgi请求\n    request = fpm_init_request(fcgi_fd);\n    \n    //worker进程将阻塞在这，等待请求\n    while (EXPECTED(fcgi_accept_request(request) >= 0)) {\n        SG(server_context) = (void *) request;\n        init_request_info();\n        \n        //请求开始\n        if (UNEXPECTED(php_request_startup() == FAILURE)) {\n            ...\n        }\n        ...\n\n        fpm_request_executing();\n        //编译、执行PHP脚本\n        php_execute_script(&file_handle);\n        ...\n        //请求结束\n        php_request_shutdown((void *) 0);\n        ...\n    }\n    ...\n    //worker进程退出\n    php_module_shutdown();\n    ...\n}\n```\nworker进程一次请求的处理被划分为5个阶段：\n\n- **FPM_REQUEST_ACCEPTING**: 等待请求阶段\n- **FPM_REQUEST_READING_HEADERS**: 读取fastcgi请求header阶段\n- **FPM_REQUEST_INFO**: 获取请求信息阶段，此阶段是将请求的method、query stirng、request uri等信息保存到各worker进程的fpm_scoreboard_proc_s结构中，此操作需要加锁，因为master进程也会操作此结构\n- **FPM_REQUEST_EXECUTING**: 执行请求阶段\n- **FPM_REQUEST_END**: 没有使用\n- **FPM_REQUEST_FINISHED**: 请求处理完成  \nworker处理到各个阶段时将会把当前阶段更新到==fpm_scoreboard_proc_s->request_stage==，master进程正是通过这个标识判断worker进程是否空闲的。\n\n#### 2.3 master-进程管理\n<u>master进程管理woker进程管理方式:</u>\n\n- **static**  \nworker进程数固定不变。在启动时master按照pm.max_children配置fork出相应数量的worker进程。\n- **dynamic**  \n动态进程管理。 \n    - 首先fpm启动时按照pm.start_servers初始化一定数量的worker（*默认情况为：pm.min_spare_servers + (max_spare_servers - min_spare_servers) / 2*）。\n    - 运行期间若master发现空闲的worker数低于pm.min_spare_servers(最小空闲数)配置数（请求较多，worker处理不过来）则会fork进程，但总worker数不能超过pm.max_children(最大进程数)；\n    - 若空闲worker数超过pm.max_spare_servers(最大空闲数)（空闲worker数过多），则kill掉一些wokrer，避免占用资源过多。\n```\npm.start_servers: 初始worker数\npm.min_spare_servers: 最小空闲worker数量\npm.max_spare_servers: 最大空闲worker数量\npm.max_children: 最大worker数\n```\n- **ondemand**  \n在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。\n```\npm.max_children: 最大worker数\npm.process_idle_timeout: 空闲超时时间\n```\n\n\n\nmaster整体的处理，其进程管理主要依赖注册的几个事件：\n\n```c\nvoid fpm_event_loop(int err)\n{\n    //创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]\n    //当sp[0]可读时将回调fpm_got_signal()\n    fpm_event_set(&signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &fpm_got_signal, NULL);\n    fpm_event_add(&signal_fd_event, 0);\n\n    //如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查\n    if (fpm_globals.heartbeat > 0) {\n        fpm_pctl_heartbeat(NULL, 0, NULL);\n    }\n    //定时触发进程管理\n    fpm_pctl_perform_idle_server_maintenance_heartbeat(NULL, 0, NULL);\n    \n    //进入事件循环，master进程将阻塞在此\n    while (1) {\n        ...\n        //等待IO事件\n        ret = module->wait(fpm_event_queue_fd, timeout);\n        ...\n        //检查定时器事件\n        ...\n    }\n}\n```\n##### 2.3.1. sp[1]管道可读事件：\n在fpm_init()阶段master曾创建了一个全双工的管道：`sp`，然后在这里创建了一个sp[0]可读的事件，当sp[0]可读时将交由fpm_got_signal()处理，向sp[1]写数据时sp[0]才会可读，那么什么时机会向sp[1]写数据呢？前面已经提到了：当master收到注册的那几种信号时会写入sp[1]端，这个时候将触发sp[0]可读事件。\n![master_event_1](https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec)\n信号用途：\n\n- SIGINT/SIGTERM/SIGQUIT:**退出fpm**，在master收到退出信号后将向所有的worker进程发送退出信号，然后master退出.\n- SIGUSR1:**重新加载日志文件**，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果fpm不重新加载将无法继续写入日志，这个时候就需要向master发送一个USR1的信号\n- SIGUSR2:**重启fpm**，首先master也是会向所有的worker进程发送退出信号，然后master会调用execvp()重新启动fpm，最后旧的master退出\n- SIGCHLD:这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用wait或者waitpid函数查询子进程退出状态后子进程才告终止，fpm中当worker进程因为异常原因(比如coredump了)退出而非master主动杀掉时master将受到此信号，这个时候父进程将调用waitpid()查下子进程的退出，然后检查下是不是需要重新fork新的worker\n\n##### 2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():\n这是进程管理实现的主要事件，master启动了一个定时器，每隔**1s**触发一次，主要用于dynamic、ondemand模式下的worker管理，master会定时检查各worker pool的worker进程数，通过此定时器实现worker数量的控制\n\n```\nstatic void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)\n{\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        struct fpm_child_s *last_idle_child = NULL; //空闲时间最久的worker\n        int idle = 0; //空闲worker数\n        int active = 0; //忙碌worker数\n        \n        for (child = wp->children; child; child = child->next) {\n            //根据worker进程的fpm_scoreboard_proc_s->request_stage判断\n            if (fpm_request_is_idle(child)) {\n                //找空闲时间最久的worker\n                ...\n                idle++;\n            }else{\n                active++;\n            }\n        }\n        ...\n        //ondemand模式\n        if (wp->config->pm == PM_STYLE_ONDEMAND) {\n            if (!last_idle_child) continue;\n\n            fpm_request_last_activity(last_idle_child, &last);\n            fpm_clock_get(&now);\n            if (last.tv_sec < now.tv_sec - wp->config->pm_process_idle_timeout) {\n                //如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker\n                last_idle_child->idle_kill = 1;\n                fpm_pctl_kill(last_idle_child->pid, FPM_PCTL_QUIT);\n            } \n            continue;\n        }\n        //dynamic\n        if (wp->config->pm != PM_STYLE_DYNAMIC) continue;\n        if (idle > wp->config->pm_max_spare_servers && last_idle_child) {\n            //空闲worker太多了，杀掉\n            last_idle_child->idle_kill = 1;\n            fpm_pctl_kill(last_idle_child->pid, FPM_PCTL_QUIT);\n            wp->idle_spawn_rate = 1;\n            continue;\n        }\n        if (idle < wp->config->pm_min_spare_servers) {\n            //空闲worker太少了，如果总worker数未达到max数则fork\n            ...\n        }\n    }\n}\n```\n##### 2.3.3 fpm_pctl_heartbeat():\n这个事件是用于限制worker处理单个请求最大耗时的，php-fpm.conf中有一个request_terminate_timeout的配置项，如果worker处理一个请求的总时长超过了这个值那么master将会向此worker进程发送kill -TERM信号杀掉worker进程，此配置单位为秒，默认值为0表示关闭此机制，另外fpm打印的slow log也是在这里完成的。\n```\nstatic void fpm_pctl_check_request_timeout(struct timeval *now)\n{   \n    struct fpm_worker_pool_s *wp;\n\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        int terminate_timeout = wp->config->request_terminate_timeout;\n        int slowlog_timeout = wp->config->request_slowlog_timeout;\n        struct fpm_child_s *child;\n\n        if (terminate_timeout || slowlog_timeout) { \n            for (child = wp->children; child; child = child->next) {\n                //检查当前当前worker处理的请求是否超时\n                fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);\n            }\n        }\n    }\n}\n```\n注：*ondemand模式下master监听的新请求到达的事件，因为ondemand模式下fpm启动时是不会预创建worker的，有请求时才会生成子进程，所以请求到达时需要通知master进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()。*\n\n\n\n\n---\n参考文档：  \n1、php内核剖析： http://www.php.cn/manual/view/32905.html  \n2、php7-integernal：https://github.com/pangudashu/php7-internal","source":"_posts/PHP7内核-FPM.md","raw":"---\ntitle: PHP7内核-FPM\ndate: 2020-08-21 18:15:16\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n\n\n### 1 概述\nFPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其<u>核心功能是进程管理</u>。  \nFastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。<u>注：FastCGI只是一种协议</u>。\n\n<!--more-->\n\nPHP处理Http请求过程：`PHP接收请求`、`解析协议`，`处理完成返回请求`。  \n在网络应用场景下，PHP实现了FastCGI协议，然后与web服务器配合实现了http的处理，web服务器处理http请求，然后将解析的结果通过FastCGI协议转发给处理程序，处理程序处理完成后将结果返回给web服务器，web服务器再返回给用户，如下图所示：\n![fastcgi](https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4)\n\n<u>PHP实现了FastCGI协议的解析，但未具体实现网络处理</u>，一般的处理模型：`多进程`，`多线程`。\n\n- **多进程模型**：主进程只负责管理子进程，而基本的网络事件由各个子进程处理，例如：nginx、fpm。\n- **多线程模型**：与多进程类似，只是它是线程粒度，这种模式通常由主线程监听、接收请求，然后交给子线程处理，例如：memcache。有的也用多进程的那种模式——主线程只负责管理子线程，各个子线程负责监听、接收、处理请求，例如：memcache使用udp协议的情况。\n\n*进程拥有独立的地址空间及资源，而线程没有，线程之间共享进程的地址空间及资源，所以在资源管理上多进程模型比较简单，而多线程模型需考虑不同线程之间的资源冲突，及线程安全。*\n\n### 2 基本实现\nFPM是一个`多进程模型`，它由`一个master进程`和`多个worker进程`组成。master会创建一个socket，但不会接口处理进程，而是由fork出的worker进程处理接收请求和处理。\n\n- **master进程**：master进程的主要工作是管理worker进程，负责fork或kill掉worker进程。\n- **worker进程**：worker进程的主要工作是处理请求，其生命周期为：`accept请求->解析FastCGI->执行相应脚本->关闭请求->等待新的请求`。  \n*注：Fpm为阻塞式模型，即一个进程只会同时链接一个请求。（目的是为了简化PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突）*\n\n**FPM的实现概括**：创建一个master进程，在master进程中创建并监听socket， 然后fork出多个子进程，这些子进程各自accept请求，有请求达到后开始读取请求数据，读取完成后开始处理然后返回。<u>（子进程启动后阻塞在accept上，直到有请求到达，且子进程同时只能响应一个请求。）</u>\n\nFPM的master进程与worker进程之间不会直接进行通信，master通过`共享内存`获取worker进程的信息（worker当前状态、已处理请求数等），当master进程要kill一个worker进程则通过`发信号的方式`通知worker进程（**master进程管理woker进程通过发信号的方式**）。\n\n<u>FPM可以监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程。</u>\n![worker_pool](https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd)\n\n在`php-fpm.conf`（php-fpm.conf路径：`/etc/php/7.1/fpm/php-fpm.conf`）中通过[pool name]声明一个worker pool：  \n（php-fpm.conf文件中include了多个pool配置，相关配置在（`/etc/php/7.1/fpm/pool.d/*.conf`））\n\n```\n[web1]\nlisten = 127.0.0.1:9000\n...\n\n[web2]\nlisten = 127.0.0.1:9001\n...\n```\n\n启动fpm后查看进程：ps -aux|grep fpm\n```\nroot     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (/usr/local/php7/etc/php-fpm.conf)\nnobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1\nnobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1\nnobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2\nnobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2\n```\n\n**具体实现**：\n`worker pool`通过`fpm_worker_pool_s`这个结构表示，多个`worker pool`组成一个**单链表**:\n\n```c\nstruct fpm_worker_pool_s {\n    struct fpm_worker_pool_s *next; //指向下一个worker pool\n    struct fpm_worker_pool_config_s *config; //conf配置:pm、max_children、start_servers...\n    int listening_socket; //监听的套接字\n    ...\n\n    struct fpm_child_s *children; // 当前pool的worker链表，每一个worker对应一个fpm_child_s结构\n    int running_children; //当前pool的worker运行总数\n    int idle_spawn_rate;\n    int warn_max_children;\n\n    struct fpm_scoreboard_s *scoreboard; //记录worker的运行信息，比如空闲、忙碌worker数\n    ...\n}\n```\n\n#### 2.1 FPM的初始化\nFpm在启动后首先会进行`SAPI的注册操作`，接着会进入PHP生命周期的`module startup`阶段，在这个阶段会调用各个扩展定义的MINT钩子函数，然后进行一系列的初始化操作，最后master，worker进程进入不同的处理环节。\n\n<u>fpm的启动流程：</u>\n\n```c\n//sapi/fpm/fpm/fpm_main.c\nint main(int argc, char *argv[])\n{\n    ...\n    //注册SAPI:将全局变量sapi_module设置为cgi_sapi_module\n    sapi_startup(&cgi_sapi_module);\n    ...\n    //执行php_module_starup()\n    if (cgi_sapi_module.startup(&cgi_sapi_module) == FAILURE) {\n        return FPM_EXIT_SOFTWARE;\n    }\n    ...\n    //初始化\n    if(0 > fpm_init(...)){\n        ...\n    }\n    ...\n    fpm_is_running = 1;\n\n    fcgi_fd = fpm_run(&max_requests);//后面都是worker进程的操作，master进程不会走到下面\n    parent = 0;\n    ...\n}\n```\n`fpm_init()`主要有以下几个关键操作：\n\n- fpm_conf_init_main():  解析php-fpm.conf配置文件.\n解析`php-fpm.conf`配置文件，分配worker pool内存结构并保存到全局变量中：fpm_worker_all_pools，各worker pool配置解析到`fpm_worker_pool_s->config`中，以下为config中的几个常用配置：\n```c\nstruct fpm_worker_pool_config_s {\n\tchar *name; // pool名称，即配置：[pool name]\n\tchar *user; // Fpm的启动用户：配置：user\n\tchar *group; // 配置：group\n\tchar *listen_address; // 监听的地址，配置：listen\n\t...\n\tint pm; // 进程模型：static、dynamic、ondemand\n\tint pm_max_children; // 最大worker进程数\n\tint pm_start_servers; // 启动时初始化的worker数\n\tint pm_min_spare_servers; // 最小空闲worker数\n\tint pm_max_spare_servers; // 最大空闲worker数\n\tint pm_process_idle_timeout; // worker空闲时间\n\tint pm_max_requests; // worker处理的最多请求数，超多这个值worker将被kill\n    ...\n};\n```\n\n- fpm_scoreboard_init_main():  分配用于记录worker进行运行信息的共享内存.\n分配用于`记录worker进程运行信息的共享内存`。按照worker pool的最大worker进程数分配，每个worker pool分配一个**fpm_scoreboard_s**结构，pool下对应的每个worker进程分配一个**fpm_scoreboard_proc_s**结构，各结构的对应关系如下图。\n![worker_pool_struct](https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738)\n\n- fpm_signals_init_mian():  mataer进行创建管道及注册信号管理worker进程.\n```c\nstatic int sp[2];\n\nint fpm_signals_init_main()\n{\n    struct sigaction act;\n\n    //创建一个全双工管道，该管道不是用于master与worker进程通信的，只在master进程中使用。\n    if (0 > socketpair(AF_UNIX, SOCK_STREAM, 0, sp)) {\n        return -1;\n    }\n    //注册信号处理handler\n    act.sa_handler = sig_handler;\n    sigfillset(&act.sa_mask);\n    if (0 > sigaction(SIGTERM,  &act, 0) ||\n        0 > sigaction(SIGINT,   &act, 0) ||\n        0 > sigaction(SIGUSR1,  &act, 0) ||\n        0 > sigaction(SIGUSR2,  &act, 0) ||\n        0 > sigaction(SIGCHLD,  &act, 0) ||\n        0 > sigaction(SIGQUIT,  &act, 0)) {\n        return -1;\n    }\n    return 0;\n}\n```\n通过**socketpair()**创建一个管道，此管道只在master进程中使用。另外设置master的信号处理handler，当master收到SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT这些信号时将调用sig_handler()处理：\n```c\nstatic void sig_handler(int signo)\n{\n    static const char sig_chars[NSIG + 1] = {\n        [SIGTERM] = 'T',\n        [SIGINT]  = 'I',\n        [SIGUSR1] = '1',\n        [SIGUSR2] = '2',\n        [SIGQUIT] = 'Q',\n        [SIGCHLD] = 'C'\n    };\n    char s;\n    ...\n    s = sig_chars[signo];\n    //将信号通知写入管道sp[1]端\n    write(sp[1], &s, sizeof(s));\n    ...\n}\n```\n\n- fpm_sockets_init_main():  创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。\n- fpm_event_init_main():  启动master的事件管理.\n启动master的事件管理，fpm实现了一个事件管理器用于管理IO、定时事件，其中IO事件通过kqueue、epoll、poll、select等管理，定时事件就是定时器，一定时间后触发某个事件。\n\n\n\n在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将fork子进程，启动进程管理器，另外master进程将不会再返回，只有各worker进程会返回，也就是说fpm_run()之后的操作均是worker进程的。\n\n```c\nint fpm_run(int *max_requests)\n{\n    struct fpm_worker_pool_s *wp;\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        //调用fpm_children_make() fork子进程\n        is_parent = fpm_children_create_initial(wp);\n        \n        if (!is_parent) {\n            goto run_child;\n        }\n    }\n    //master进程将进入event循环，不再往下走\n    fpm_event_loop(0);\n\nrun_child: //只有worker进程会到这里\n\n    *max_requests = fpm_globals.max_requests;\n    return fpm_globals.listening_socket; //返回监听的套接字\n}\n```\n\n在fork后worker进程返回了监听的套接字继续main()后面的处理，而master将永远阻塞在fpm_event_loop().\n\n\n#### 2.2 worker-请求处理\nfpm_run()执行后将fork出worker进程，worker进程返回main()中继续向下执行，后面的流程就是worker进程不断accept请求，然后执行PHP脚本并返回。整体流程如下：\n- **等待请求**： worker进程阻塞在fcgi_accept_request()等待请求。\n- **解析请求**： fastcgi请求到达后被worker接收，然后开始接受并解析请求数据，直到request数据完全到达。\n- **请求初始化**：执行php_request_startup(), 此阶段会调用每个扩展的PHP_RINI_FUNCTION();\n- **编译、执行**：php_execute_script()完成PHP脚本的编译、执行。\n- **关闭请求**：请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。\n```c\nint main(int argc, char *argv[])\n{\n    ...\n    fcgi_fd = fpm_run(&max_requests);\n    parent = 0;\n\n    //初始化fastcgi请求\n    request = fpm_init_request(fcgi_fd);\n    \n    //worker进程将阻塞在这，等待请求\n    while (EXPECTED(fcgi_accept_request(request) >= 0)) {\n        SG(server_context) = (void *) request;\n        init_request_info();\n        \n        //请求开始\n        if (UNEXPECTED(php_request_startup() == FAILURE)) {\n            ...\n        }\n        ...\n\n        fpm_request_executing();\n        //编译、执行PHP脚本\n        php_execute_script(&file_handle);\n        ...\n        //请求结束\n        php_request_shutdown((void *) 0);\n        ...\n    }\n    ...\n    //worker进程退出\n    php_module_shutdown();\n    ...\n}\n```\nworker进程一次请求的处理被划分为5个阶段：\n\n- **FPM_REQUEST_ACCEPTING**: 等待请求阶段\n- **FPM_REQUEST_READING_HEADERS**: 读取fastcgi请求header阶段\n- **FPM_REQUEST_INFO**: 获取请求信息阶段，此阶段是将请求的method、query stirng、request uri等信息保存到各worker进程的fpm_scoreboard_proc_s结构中，此操作需要加锁，因为master进程也会操作此结构\n- **FPM_REQUEST_EXECUTING**: 执行请求阶段\n- **FPM_REQUEST_END**: 没有使用\n- **FPM_REQUEST_FINISHED**: 请求处理完成  \nworker处理到各个阶段时将会把当前阶段更新到==fpm_scoreboard_proc_s->request_stage==，master进程正是通过这个标识判断worker进程是否空闲的。\n\n#### 2.3 master-进程管理\n<u>master进程管理woker进程管理方式:</u>\n\n- **static**  \nworker进程数固定不变。在启动时master按照pm.max_children配置fork出相应数量的worker进程。\n- **dynamic**  \n动态进程管理。 \n    - 首先fpm启动时按照pm.start_servers初始化一定数量的worker（*默认情况为：pm.min_spare_servers + (max_spare_servers - min_spare_servers) / 2*）。\n    - 运行期间若master发现空闲的worker数低于pm.min_spare_servers(最小空闲数)配置数（请求较多，worker处理不过来）则会fork进程，但总worker数不能超过pm.max_children(最大进程数)；\n    - 若空闲worker数超过pm.max_spare_servers(最大空闲数)（空闲worker数过多），则kill掉一些wokrer，避免占用资源过多。\n```\npm.start_servers: 初始worker数\npm.min_spare_servers: 最小空闲worker数量\npm.max_spare_servers: 最大空闲worker数量\npm.max_children: 最大worker数\n```\n- **ondemand**  \n在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。\n```\npm.max_children: 最大worker数\npm.process_idle_timeout: 空闲超时时间\n```\n\n\n\nmaster整体的处理，其进程管理主要依赖注册的几个事件：\n\n```c\nvoid fpm_event_loop(int err)\n{\n    //创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]\n    //当sp[0]可读时将回调fpm_got_signal()\n    fpm_event_set(&signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &fpm_got_signal, NULL);\n    fpm_event_add(&signal_fd_event, 0);\n\n    //如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查\n    if (fpm_globals.heartbeat > 0) {\n        fpm_pctl_heartbeat(NULL, 0, NULL);\n    }\n    //定时触发进程管理\n    fpm_pctl_perform_idle_server_maintenance_heartbeat(NULL, 0, NULL);\n    \n    //进入事件循环，master进程将阻塞在此\n    while (1) {\n        ...\n        //等待IO事件\n        ret = module->wait(fpm_event_queue_fd, timeout);\n        ...\n        //检查定时器事件\n        ...\n    }\n}\n```\n##### 2.3.1. sp[1]管道可读事件：\n在fpm_init()阶段master曾创建了一个全双工的管道：`sp`，然后在这里创建了一个sp[0]可读的事件，当sp[0]可读时将交由fpm_got_signal()处理，向sp[1]写数据时sp[0]才会可读，那么什么时机会向sp[1]写数据呢？前面已经提到了：当master收到注册的那几种信号时会写入sp[1]端，这个时候将触发sp[0]可读事件。\n![master_event_1](https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec)\n信号用途：\n\n- SIGINT/SIGTERM/SIGQUIT:**退出fpm**，在master收到退出信号后将向所有的worker进程发送退出信号，然后master退出.\n- SIGUSR1:**重新加载日志文件**，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果fpm不重新加载将无法继续写入日志，这个时候就需要向master发送一个USR1的信号\n- SIGUSR2:**重启fpm**，首先master也是会向所有的worker进程发送退出信号，然后master会调用execvp()重新启动fpm，最后旧的master退出\n- SIGCHLD:这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用wait或者waitpid函数查询子进程退出状态后子进程才告终止，fpm中当worker进程因为异常原因(比如coredump了)退出而非master主动杀掉时master将受到此信号，这个时候父进程将调用waitpid()查下子进程的退出，然后检查下是不是需要重新fork新的worker\n\n##### 2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():\n这是进程管理实现的主要事件，master启动了一个定时器，每隔**1s**触发一次，主要用于dynamic、ondemand模式下的worker管理，master会定时检查各worker pool的worker进程数，通过此定时器实现worker数量的控制\n\n```\nstatic void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)\n{\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        struct fpm_child_s *last_idle_child = NULL; //空闲时间最久的worker\n        int idle = 0; //空闲worker数\n        int active = 0; //忙碌worker数\n        \n        for (child = wp->children; child; child = child->next) {\n            //根据worker进程的fpm_scoreboard_proc_s->request_stage判断\n            if (fpm_request_is_idle(child)) {\n                //找空闲时间最久的worker\n                ...\n                idle++;\n            }else{\n                active++;\n            }\n        }\n        ...\n        //ondemand模式\n        if (wp->config->pm == PM_STYLE_ONDEMAND) {\n            if (!last_idle_child) continue;\n\n            fpm_request_last_activity(last_idle_child, &last);\n            fpm_clock_get(&now);\n            if (last.tv_sec < now.tv_sec - wp->config->pm_process_idle_timeout) {\n                //如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker\n                last_idle_child->idle_kill = 1;\n                fpm_pctl_kill(last_idle_child->pid, FPM_PCTL_QUIT);\n            } \n            continue;\n        }\n        //dynamic\n        if (wp->config->pm != PM_STYLE_DYNAMIC) continue;\n        if (idle > wp->config->pm_max_spare_servers && last_idle_child) {\n            //空闲worker太多了，杀掉\n            last_idle_child->idle_kill = 1;\n            fpm_pctl_kill(last_idle_child->pid, FPM_PCTL_QUIT);\n            wp->idle_spawn_rate = 1;\n            continue;\n        }\n        if (idle < wp->config->pm_min_spare_servers) {\n            //空闲worker太少了，如果总worker数未达到max数则fork\n            ...\n        }\n    }\n}\n```\n##### 2.3.3 fpm_pctl_heartbeat():\n这个事件是用于限制worker处理单个请求最大耗时的，php-fpm.conf中有一个request_terminate_timeout的配置项，如果worker处理一个请求的总时长超过了这个值那么master将会向此worker进程发送kill -TERM信号杀掉worker进程，此配置单位为秒，默认值为0表示关闭此机制，另外fpm打印的slow log也是在这里完成的。\n```\nstatic void fpm_pctl_check_request_timeout(struct timeval *now)\n{   \n    struct fpm_worker_pool_s *wp;\n\n    for (wp = fpm_worker_all_pools; wp; wp = wp->next) {\n        int terminate_timeout = wp->config->request_terminate_timeout;\n        int slowlog_timeout = wp->config->request_slowlog_timeout;\n        struct fpm_child_s *child;\n\n        if (terminate_timeout || slowlog_timeout) { \n            for (child = wp->children; child; child = child->next) {\n                //检查当前当前worker处理的请求是否超时\n                fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);\n            }\n        }\n    }\n}\n```\n注：*ondemand模式下master监听的新请求到达的事件，因为ondemand模式下fpm启动时是不会预创建worker的，有请求时才会生成子进程，所以请求到达时需要通知master进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()。*\n\n\n\n\n---\n参考文档：  \n1、php内核剖析： http://www.php.cn/manual/view/32905.html  \n2、php7-integernal：https://github.com/pangudashu/php7-internal","slug":"PHP7内核-FPM","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabn1005z45g3dai026jk","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>FPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其<u>核心功能是进程管理</u>。<br>FastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。<u>注：FastCGI只是一种协议</u>。</p>\n<a id=\"more\"></a>\n\n<p>PHP处理Http请求过程：<code>PHP接收请求</code>、<code>解析协议</code>，<code>处理完成返回请求</code>。<br>在网络应用场景下，PHP实现了FastCGI协议，然后与web服务器配合实现了http的处理，web服务器处理http请求，然后将解析的结果通过FastCGI协议转发给处理程序，处理程序处理完成后将结果返回给web服务器，web服务器再返回给用户，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4\" alt=\"fastcgi\"></p>\n<p><u>PHP实现了FastCGI协议的解析，但未具体实现网络处理</u>，一般的处理模型：<code>多进程</code>，<code>多线程</code>。</p>\n<ul>\n<li><strong>多进程模型</strong>：主进程只负责管理子进程，而基本的网络事件由各个子进程处理，例如：nginx、fpm。</li>\n<li><strong>多线程模型</strong>：与多进程类似，只是它是线程粒度，这种模式通常由主线程监听、接收请求，然后交给子线程处理，例如：memcache。有的也用多进程的那种模式——主线程只负责管理子线程，各个子线程负责监听、接收、处理请求，例如：memcache使用udp协议的情况。</li>\n</ul>\n<p><em>进程拥有独立的地址空间及资源，而线程没有，线程之间共享进程的地址空间及资源，所以在资源管理上多进程模型比较简单，而多线程模型需考虑不同线程之间的资源冲突，及线程安全。</em></p>\n<h3 id=\"2-基本实现\"><a href=\"#2-基本实现\" class=\"headerlink\" title=\"2 基本实现\"></a>2 基本实现</h3><p>FPM是一个<code>多进程模型</code>，它由<code>一个master进程</code>和<code>多个worker进程</code>组成。master会创建一个socket，但不会接口处理进程，而是由fork出的worker进程处理接收请求和处理。</p>\n<ul>\n<li><strong>master进程</strong>：master进程的主要工作是管理worker进程，负责fork或kill掉worker进程。</li>\n<li><strong>worker进程</strong>：worker进程的主要工作是处理请求，其生命周期为：<code>accept请求-&gt;解析FastCGI-&gt;执行相应脚本-&gt;关闭请求-&gt;等待新的请求</code>。  </li>\n</ul>\n<p><em>注：Fpm为阻塞式模型，即一个进程只会同时链接一个请求。（目的是为了简化PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突）</em></p>\n<p><strong>FPM的实现概括</strong>：创建一个master进程，在master进程中创建并监听socket， 然后fork出多个子进程，这些子进程各自accept请求，有请求达到后开始读取请求数据，读取完成后开始处理然后返回。<u>（子进程启动后阻塞在accept上，直到有请求到达，且子进程同时只能响应一个请求。）</u></p>\n<p>FPM的master进程与worker进程之间不会直接进行通信，master通过<code>共享内存</code>获取worker进程的信息（worker当前状态、已处理请求数等），当master进程要kill一个worker进程则通过<code>发信号的方式</code>通知worker进程（<strong>master进程管理woker进程通过发信号的方式</strong>）。</p>\n<p><u>FPM可以监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程。</u><br><img src=\"https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd\" alt=\"worker_pool\"></p>\n<p>在<code>php-fpm.conf</code>（php-fpm.conf路径：<code>/etc/php/7.1/fpm/php-fpm.conf</code>）中通过[pool name]声明一个worker pool：<br>（php-fpm.conf文件中include了多个pool配置，相关配置在（<code>/etc/php/7.1/fpm/pool.d/*.conf</code>））</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[web1]</span><br><span class=\"line\">listen &#x3D; 127.0.0.1:9000</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">[web2]</span><br><span class=\"line\">listen &#x3D; 127.0.0.1:9001</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>启动fpm后查看进程：ps -aux|grep fpm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (&#x2F;usr&#x2F;local&#x2F;php7&#x2F;etc&#x2F;php-fpm.conf)</span><br><span class=\"line\">nobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class=\"line\">nobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class=\"line\">nobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br><span class=\"line\">nobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br></pre></td></tr></table></figure>\n\n<p><strong>具体实现</strong>：<br><code>worker pool</code>通过<code>fpm_worker_pool_s</code>这个结构表示，多个<code>worker pool</code>组成一个<strong>单链表</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">//指向下一个worker pool</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_config_s</span> *<span class=\"title\">config</span>;</span> <span class=\"comment\">//conf配置:pm、max_children、start_servers...</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listening_socket; <span class=\"comment\">//监听的套接字</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_child_s</span> *<span class=\"title\">children</span>;</span> <span class=\"comment\">// 当前pool的worker链表，每一个worker对应一个fpm_child_s结构</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> running_children; <span class=\"comment\">//当前pool的worker运行总数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idle_spawn_rate;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> warn_max_children;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_scoreboard_s</span> *<span class=\"title\">scoreboard</span>;</span> <span class=\"comment\">//记录worker的运行信息，比如空闲、忙碌worker数</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-FPM的初始化\"><a href=\"#2-1-FPM的初始化\" class=\"headerlink\" title=\"2.1 FPM的初始化\"></a>2.1 FPM的初始化</h4><p>Fpm在启动后首先会进行<code>SAPI的注册操作</code>，接着会进入PHP生命周期的<code>module startup</code>阶段，在这个阶段会调用各个扩展定义的MINT钩子函数，然后进行一系列的初始化操作，最后master，worker进程进入不同的处理环节。</p>\n<p><u>fpm的启动流程：</u></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sapi/fpm/fpm/fpm_main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//注册SAPI:将全局变量sapi_module设置为cgi_sapi_module</span></span><br><span class=\"line\">    sapi_startup(&amp;cgi_sapi_module);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//执行php_module_starup()</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cgi_sapi_module.startup(&amp;cgi_sapi_module) == FAILURE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FPM_EXIT_SOFTWARE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &gt; fpm_init(...))&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    fpm_is_running = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    fcgi_fd = fpm_run(&amp;max_requests);<span class=\"comment\">//后面都是worker进程的操作，master进程不会走到下面</span></span><br><span class=\"line\">    parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>fpm_init()</code>主要有以下几个关键操作：</p>\n<ul>\n<li><p>fpm_conf_init_main():  解析php-fpm.conf配置文件.<br>解析<code>php-fpm.conf</code>配置文件，分配worker pool内存结构并保存到全局变量中：fpm_worker_all_pools，各worker pool配置解析到<code>fpm_worker_pool_s-&gt;config</code>中，以下为config中的几个常用配置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_config_s</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *name; <span class=\"comment\">// pool名称，即配置：[pool name]</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *user; <span class=\"comment\">// Fpm的启动用户：配置：user</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *group; <span class=\"comment\">// 配置：group</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *listen_address; <span class=\"comment\">// 监听的地址，配置：listen</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm; <span class=\"comment\">// 进程模型：static、dynamic、ondemand</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_children; <span class=\"comment\">// 最大worker进程数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_start_servers; <span class=\"comment\">// 启动时初始化的worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_min_spare_servers; <span class=\"comment\">// 最小空闲worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_spare_servers; <span class=\"comment\">// 最大空闲worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_process_idle_timeout; <span class=\"comment\">// worker空闲时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_requests; <span class=\"comment\">// worker处理的最多请求数，超多这个值worker将被kill</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fpm_scoreboard_init_main():  分配用于记录worker进行运行信息的共享内存.<br>分配用于<code>记录worker进程运行信息的共享内存</code>。按照worker pool的最大worker进程数分配，每个worker pool分配一个<strong>fpm_scoreboard_s</strong>结构，pool下对应的每个worker进程分配一个<strong>fpm_scoreboard_proc_s</strong>结构，各结构的对应关系如下图。<br><img src=\"https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738\" alt=\"worker_pool_struct\"></p>\n</li>\n<li><p>fpm_signals_init_mian():  mataer进行创建管道及注册信号管理worker进程.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sp[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fpm_signals_init_main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建一个全双工管道，该管道不是用于master与worker进程通信的，只在master进程中使用。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &gt; socketpair(AF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>, sp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//注册信号处理handler</span></span><br><span class=\"line\">    act.sa_handler = sig_handler;</span><br><span class=\"line\">    sigfillset(&amp;act.sa_mask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &gt; sigaction(SIGTERM,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGINT,   &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGUSR1,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGUSR2,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGCHLD,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGQUIT,  &amp;act, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过**socketpair()**创建一个管道，此管道只在master进程中使用。另外设置master的信号处理handler，当master收到SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT这些信号时将调用sig_handler()处理：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sig_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> signo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> sig_chars[NSIG + <span class=\"number\">1</span>] = &#123;</span><br><span class=\"line\">        [SIGTERM] = <span class=\"string\">&#x27;T&#x27;</span>,</span><br><span class=\"line\">        [SIGINT]  = <span class=\"string\">&#x27;I&#x27;</span>,</span><br><span class=\"line\">        [SIGUSR1] = <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">        [SIGUSR2] = <span class=\"string\">&#x27;2&#x27;</span>,</span><br><span class=\"line\">        [SIGQUIT] = <span class=\"string\">&#x27;Q&#x27;</span>,</span><br><span class=\"line\">        [SIGCHLD] = <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    s = sig_chars[signo];</span><br><span class=\"line\">    <span class=\"comment\">//将信号通知写入管道sp[1]端</span></span><br><span class=\"line\">    write(sp[<span class=\"number\">1</span>], &amp;s, <span class=\"keyword\">sizeof</span>(s));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fpm_sockets_init_main():  创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。</p>\n</li>\n<li><p>fpm_event_init_main():  启动master的事件管理.<br>启动master的事件管理，fpm实现了一个事件管理器用于管理IO、定时事件，其中IO事件通过kqueue、epoll、poll、select等管理，定时事件就是定时器，一定时间后触发某个事件。</p>\n</li>\n</ul>\n<p>在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将fork子进程，启动进程管理器，另外master进程将不会再返回，只有各worker进程会返回，也就是说fpm_run()之后的操作均是worker进程的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fpm_run</span><span class=\"params\">(<span class=\"keyword\">int</span> *max_requests)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> *<span class=\"title\">wp</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (wp = fpm_worker_all_pools; wp; wp = wp-&gt;next) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用fpm_children_make() fork子进程</span></span><br><span class=\"line\">        is_parent = fpm_children_create_initial(wp);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!is_parent) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> run_child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//master进程将进入event循环，不再往下走</span></span><br><span class=\"line\">    fpm_event_loop(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">run_child: <span class=\"comment\">//只有worker进程会到这里</span></span><br><span class=\"line\"></span><br><span class=\"line\">    *max_requests = fpm_globals.max_requests;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fpm_globals.listening_socket; <span class=\"comment\">//返回监听的套接字</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在fork后worker进程返回了监听的套接字继续main()后面的处理，而master将永远阻塞在fpm_event_loop().</p>\n<h4 id=\"2-2-worker-请求处理\"><a href=\"#2-2-worker-请求处理\" class=\"headerlink\" title=\"2.2 worker-请求处理\"></a>2.2 worker-请求处理</h4><p>fpm_run()执行后将fork出worker进程，worker进程返回main()中继续向下执行，后面的流程就是worker进程不断accept请求，然后执行PHP脚本并返回。整体流程如下：</p>\n<ul>\n<li><p><strong>等待请求</strong>： worker进程阻塞在fcgi_accept_request()等待请求。</p>\n</li>\n<li><p><strong>解析请求</strong>： fastcgi请求到达后被worker接收，然后开始接受并解析请求数据，直到request数据完全到达。</p>\n</li>\n<li><p><strong>请求初始化</strong>：执行php_request_startup(), 此阶段会调用每个扩展的PHP_RINI_FUNCTION();</p>\n</li>\n<li><p><strong>编译、执行</strong>：php_execute_script()完成PHP脚本的编译、执行。</p>\n</li>\n<li><p><strong>关闭请求</strong>：请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    fcgi_fd = fpm_run(&amp;max_requests);</span><br><span class=\"line\">    parent = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化fastcgi请求</span></span><br><span class=\"line\">    request = fpm_init_request(fcgi_fd);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//worker进程将阻塞在这，等待请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (EXPECTED(fcgi_accept_request(request) &gt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        SG(server_context) = (<span class=\"keyword\">void</span> *) request;</span><br><span class=\"line\">        init_request_info();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//请求开始</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNEXPECTED(php_request_startup() == FAILURE)) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        fpm_request_executing();</span><br><span class=\"line\">        <span class=\"comment\">//编译、执行PHP脚本</span></span><br><span class=\"line\">        php_execute_script(&amp;file_handle);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//请求结束</span></span><br><span class=\"line\">        php_request_shutdown((<span class=\"keyword\">void</span> *) <span class=\"number\">0</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//worker进程退出</span></span><br><span class=\"line\">    php_module_shutdown();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>worker进程一次请求的处理被划分为5个阶段：</p>\n</li>\n<li><p><strong>FPM_REQUEST_ACCEPTING</strong>: 等待请求阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_READING_HEADERS</strong>: 读取fastcgi请求header阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_INFO</strong>: 获取请求信息阶段，此阶段是将请求的method、query stirng、request uri等信息保存到各worker进程的fpm_scoreboard_proc_s结构中，此操作需要加锁，因为master进程也会操作此结构</p>\n</li>\n<li><p><strong>FPM_REQUEST_EXECUTING</strong>: 执行请求阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_END</strong>: 没有使用</p>\n</li>\n<li><p><strong>FPM_REQUEST_FINISHED</strong>: 请求处理完成<br>worker处理到各个阶段时将会把当前阶段更新到==fpm_scoreboard_proc_s-&gt;request_stage==，master进程正是通过这个标识判断worker进程是否空闲的。</p>\n</li>\n</ul>\n<h4 id=\"2-3-master-进程管理\"><a href=\"#2-3-master-进程管理\" class=\"headerlink\" title=\"2.3 master-进程管理\"></a>2.3 master-进程管理</h4><p><u>master进程管理woker进程管理方式:</u></p>\n<ul>\n<li><strong>static</strong><br>worker进程数固定不变。在启动时master按照pm.max_children配置fork出相应数量的worker进程。</li>\n<li><strong>dynamic</strong><br>动态进程管理。 <ul>\n<li>首先fpm启动时按照pm.start_servers初始化一定数量的worker（<em>默认情况为：pm.min_spare_servers + (max_spare_servers - min_spare_servers) / 2</em>）。</li>\n<li>运行期间若master发现空闲的worker数低于pm.min_spare_servers(最小空闲数)配置数（请求较多，worker处理不过来）则会fork进程，但总worker数不能超过pm.max_children(最大进程数)；</li>\n<li>若空闲worker数超过pm.max_spare_servers(最大空闲数)（空闲worker数过多），则kill掉一些wokrer，避免占用资源过多。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.start_servers: 初始worker数</span><br><span class=\"line\">pm.min_spare_servers: 最小空闲worker数量</span><br><span class=\"line\">pm.max_spare_servers: 最大空闲worker数量</span><br><span class=\"line\">pm.max_children: 最大worker数</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>ondemand</strong><br>在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.max_children: 最大worker数</span><br><span class=\"line\">pm.process_idle_timeout: 空闲超时时间</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p>master整体的处理，其进程管理主要依赖注册的几个事件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fpm_event_loop</span><span class=\"params\">(<span class=\"keyword\">int</span> err)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]</span></span><br><span class=\"line\">    <span class=\"comment\">//当sp[0]可读时将回调fpm_got_signal()</span></span><br><span class=\"line\">    fpm_event_set(&amp;signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &amp;fpm_got_signal, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    fpm_event_add(&amp;signal_fd_event, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fpm_globals.heartbeat &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        fpm_pctl_heartbeat(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//定时触发进程管理</span></span><br><span class=\"line\">    fpm_pctl_perform_idle_server_maintenance_heartbeat(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//进入事件循环，master进程将阻塞在此</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//等待IO事件</span></span><br><span class=\"line\">        ret = <span class=\"keyword\">module</span>-&gt;wait(fpm_event_queue_fd, timeout);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//检查定时器事件</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-1-sp-1-管道可读事件：\"><a href=\"#2-3-1-sp-1-管道可读事件：\" class=\"headerlink\" title=\"2.3.1. sp[1]管道可读事件：\"></a>2.3.1. sp[1]管道可读事件：</h5><p>在fpm_init()阶段master曾创建了一个全双工的管道：<code>sp</code>，然后在这里创建了一个sp[0]可读的事件，当sp[0]可读时将交由fpm_got_signal()处理，向sp[1]写数据时sp[0]才会可读，那么什么时机会向sp[1]写数据呢？前面已经提到了：当master收到注册的那几种信号时会写入sp[1]端，这个时候将触发sp[0]可读事件。<br><img src=\"https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec\" alt=\"master_event_1\"><br>信号用途：</p>\n<ul>\n<li>SIGINT/SIGTERM/SIGQUIT:<strong>退出fpm</strong>，在master收到退出信号后将向所有的worker进程发送退出信号，然后master退出.</li>\n<li>SIGUSR1:<strong>重新加载日志文件</strong>，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果fpm不重新加载将无法继续写入日志，这个时候就需要向master发送一个USR1的信号</li>\n<li>SIGUSR2:<strong>重启fpm</strong>，首先master也是会向所有的worker进程发送退出信号，然后master会调用execvp()重新启动fpm，最后旧的master退出</li>\n<li>SIGCHLD:这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用wait或者waitpid函数查询子进程退出状态后子进程才告终止，fpm中当worker进程因为异常原因(比如coredump了)退出而非master主动杀掉时master将受到此信号，这个时候父进程将调用waitpid()查下子进程的退出，然后检查下是不是需要重新fork新的worker</li>\n</ul>\n<h5 id=\"2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat\"><a href=\"#2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat\" class=\"headerlink\" title=\"2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():\"></a>2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():</h5><p>这是进程管理实现的主要事件，master启动了一个定时器，每隔<strong>1s</strong>触发一次，主要用于dynamic、ondemand模式下的worker管理，master会定时检查各worker pool的worker进程数，通过此定时器实现worker数量的控制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class=\"line\">        struct fpm_child_s *last_idle_child &#x3D; NULL; &#x2F;&#x2F;空闲时间最久的worker</span><br><span class=\"line\">        int idle &#x3D; 0; &#x2F;&#x2F;空闲worker数</span><br><span class=\"line\">        int active &#x3D; 0; &#x2F;&#x2F;忙碌worker数</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;根据worker进程的fpm_scoreboard_proc_s-&gt;request_stage判断</span><br><span class=\"line\">            if (fpm_request_is_idle(child)) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;找空闲时间最久的worker</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                idle++;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                active++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#x2F;&#x2F;ondemand模式</span><br><span class=\"line\">        if (wp-&gt;config-&gt;pm &#x3D;&#x3D; PM_STYLE_ONDEMAND) &#123;</span><br><span class=\"line\">            if (!last_idle_child) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">            fpm_request_last_activity(last_idle_child, &amp;last);</span><br><span class=\"line\">            fpm_clock_get(&amp;now);</span><br><span class=\"line\">            if (last.tv_sec &lt; now.tv_sec - wp-&gt;config-&gt;pm_process_idle_timeout) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker</span><br><span class=\"line\">                last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class=\"line\">                fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;dynamic</span><br><span class=\"line\">        if (wp-&gt;config-&gt;pm !&#x3D; PM_STYLE_DYNAMIC) continue;</span><br><span class=\"line\">        if (idle &gt; wp-&gt;config-&gt;pm_max_spare_servers &amp;&amp; last_idle_child) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;空闲worker太多了，杀掉</span><br><span class=\"line\">            last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class=\"line\">            fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class=\"line\">            wp-&gt;idle_spawn_rate &#x3D; 1;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (idle &lt; wp-&gt;config-&gt;pm_min_spare_servers) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;空闲worker太少了，如果总worker数未达到max数则fork</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-3-fpm-pctl-heartbeat\"><a href=\"#2-3-3-fpm-pctl-heartbeat\" class=\"headerlink\" title=\"2.3.3 fpm_pctl_heartbeat():\"></a>2.3.3 fpm_pctl_heartbeat():</h5><p>这个事件是用于限制worker处理单个请求最大耗时的，php-fpm.conf中有一个request_terminate_timeout的配置项，如果worker处理一个请求的总时长超过了这个值那么master将会向此worker进程发送kill -TERM信号杀掉worker进程，此配置单位为秒，默认值为0表示关闭此机制，另外fpm打印的slow log也是在这里完成的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void fpm_pctl_check_request_timeout(struct timeval *now)</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    struct fpm_worker_pool_s *wp;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class=\"line\">        int terminate_timeout &#x3D; wp-&gt;config-&gt;request_terminate_timeout;</span><br><span class=\"line\">        int slowlog_timeout &#x3D; wp-&gt;config-&gt;request_slowlog_timeout;</span><br><span class=\"line\">        struct fpm_child_s *child;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (terminate_timeout || slowlog_timeout) &#123; </span><br><span class=\"line\">            for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;检查当前当前worker处理的请求是否超时</span><br><span class=\"line\">                fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：<em>ondemand模式下master监听的新请求到达的事件，因为ondemand模式下fpm启动时是不会预创建worker的，有请求时才会生成子进程，所以请求到达时需要通知master进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()。</em></p>\n<hr>\n<p>参考文档：<br>1、php内核剖析： <a href=\"http://www.php.cn/manual/view/32905.html\">http://www.php.cn/manual/view/32905.html</a><br>2、php7-integernal：<a href=\"https://github.com/pangudashu/php7-internal\">https://github.com/pangudashu/php7-internal</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>FPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其<u>核心功能是进程管理</u>。<br>FastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。<u>注：FastCGI只是一种协议</u>。</p>","more":"<p>PHP处理Http请求过程：<code>PHP接收请求</code>、<code>解析协议</code>，<code>处理完成返回请求</code>。<br>在网络应用场景下，PHP实现了FastCGI协议，然后与web服务器配合实现了http的处理，web服务器处理http请求，然后将解析的结果通过FastCGI协议转发给处理程序，处理程序处理完成后将结果返回给web服务器，web服务器再返回给用户，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4\" alt=\"fastcgi\"></p>\n<p><u>PHP实现了FastCGI协议的解析，但未具体实现网络处理</u>，一般的处理模型：<code>多进程</code>，<code>多线程</code>。</p>\n<ul>\n<li><strong>多进程模型</strong>：主进程只负责管理子进程，而基本的网络事件由各个子进程处理，例如：nginx、fpm。</li>\n<li><strong>多线程模型</strong>：与多进程类似，只是它是线程粒度，这种模式通常由主线程监听、接收请求，然后交给子线程处理，例如：memcache。有的也用多进程的那种模式——主线程只负责管理子线程，各个子线程负责监听、接收、处理请求，例如：memcache使用udp协议的情况。</li>\n</ul>\n<p><em>进程拥有独立的地址空间及资源，而线程没有，线程之间共享进程的地址空间及资源，所以在资源管理上多进程模型比较简单，而多线程模型需考虑不同线程之间的资源冲突，及线程安全。</em></p>\n<h3 id=\"2-基本实现\"><a href=\"#2-基本实现\" class=\"headerlink\" title=\"2 基本实现\"></a>2 基本实现</h3><p>FPM是一个<code>多进程模型</code>，它由<code>一个master进程</code>和<code>多个worker进程</code>组成。master会创建一个socket，但不会接口处理进程，而是由fork出的worker进程处理接收请求和处理。</p>\n<ul>\n<li><strong>master进程</strong>：master进程的主要工作是管理worker进程，负责fork或kill掉worker进程。</li>\n<li><strong>worker进程</strong>：worker进程的主要工作是处理请求，其生命周期为：<code>accept请求-&gt;解析FastCGI-&gt;执行相应脚本-&gt;关闭请求-&gt;等待新的请求</code>。  </li>\n</ul>\n<p><em>注：Fpm为阻塞式模型，即一个进程只会同时链接一个请求。（目的是为了简化PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突）</em></p>\n<p><strong>FPM的实现概括</strong>：创建一个master进程，在master进程中创建并监听socket， 然后fork出多个子进程，这些子进程各自accept请求，有请求达到后开始读取请求数据，读取完成后开始处理然后返回。<u>（子进程启动后阻塞在accept上，直到有请求到达，且子进程同时只能响应一个请求。）</u></p>\n<p>FPM的master进程与worker进程之间不会直接进行通信，master通过<code>共享内存</code>获取worker进程的信息（worker当前状态、已处理请求数等），当master进程要kill一个worker进程则通过<code>发信号的方式</code>通知worker进程（<strong>master进程管理woker进程通过发信号的方式</strong>）。</p>\n<p><u>FPM可以监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程。</u><br><img src=\"https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd\" alt=\"worker_pool\"></p>\n<p>在<code>php-fpm.conf</code>（php-fpm.conf路径：<code>/etc/php/7.1/fpm/php-fpm.conf</code>）中通过[pool name]声明一个worker pool：<br>（php-fpm.conf文件中include了多个pool配置，相关配置在（<code>/etc/php/7.1/fpm/pool.d/*.conf</code>））</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[web1]</span><br><span class=\"line\">listen &#x3D; 127.0.0.1:9000</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">[web2]</span><br><span class=\"line\">listen &#x3D; 127.0.0.1:9001</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>启动fpm后查看进程：ps -aux|grep fpm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (&#x2F;usr&#x2F;local&#x2F;php7&#x2F;etc&#x2F;php-fpm.conf)</span><br><span class=\"line\">nobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class=\"line\">nobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class=\"line\">nobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br><span class=\"line\">nobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br></pre></td></tr></table></figure>\n\n<p><strong>具体实现</strong>：<br><code>worker pool</code>通过<code>fpm_worker_pool_s</code>这个结构表示，多个<code>worker pool</code>组成一个<strong>单链表</strong>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">//指向下一个worker pool</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_config_s</span> *<span class=\"title\">config</span>;</span> <span class=\"comment\">//conf配置:pm、max_children、start_servers...</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listening_socket; <span class=\"comment\">//监听的套接字</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_child_s</span> *<span class=\"title\">children</span>;</span> <span class=\"comment\">// 当前pool的worker链表，每一个worker对应一个fpm_child_s结构</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> running_children; <span class=\"comment\">//当前pool的worker运行总数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idle_spawn_rate;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> warn_max_children;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_scoreboard_s</span> *<span class=\"title\">scoreboard</span>;</span> <span class=\"comment\">//记录worker的运行信息，比如空闲、忙碌worker数</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-FPM的初始化\"><a href=\"#2-1-FPM的初始化\" class=\"headerlink\" title=\"2.1 FPM的初始化\"></a>2.1 FPM的初始化</h4><p>Fpm在启动后首先会进行<code>SAPI的注册操作</code>，接着会进入PHP生命周期的<code>module startup</code>阶段，在这个阶段会调用各个扩展定义的MINT钩子函数，然后进行一系列的初始化操作，最后master，worker进程进入不同的处理环节。</p>\n<p><u>fpm的启动流程：</u></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sapi/fpm/fpm/fpm_main.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//注册SAPI:将全局变量sapi_module设置为cgi_sapi_module</span></span><br><span class=\"line\">    sapi_startup(&amp;cgi_sapi_module);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//执行php_module_starup()</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cgi_sapi_module.startup(&amp;cgi_sapi_module) == FAILURE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FPM_EXIT_SOFTWARE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &gt; fpm_init(...))&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    fpm_is_running = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    fcgi_fd = fpm_run(&amp;max_requests);<span class=\"comment\">//后面都是worker进程的操作，master进程不会走到下面</span></span><br><span class=\"line\">    parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>fpm_init()</code>主要有以下几个关键操作：</p>\n<ul>\n<li><p>fpm_conf_init_main():  解析php-fpm.conf配置文件.<br>解析<code>php-fpm.conf</code>配置文件，分配worker pool内存结构并保存到全局变量中：fpm_worker_all_pools，各worker pool配置解析到<code>fpm_worker_pool_s-&gt;config</code>中，以下为config中的几个常用配置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_config_s</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *name; <span class=\"comment\">// pool名称，即配置：[pool name]</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *user; <span class=\"comment\">// Fpm的启动用户：配置：user</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *group; <span class=\"comment\">// 配置：group</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *listen_address; <span class=\"comment\">// 监听的地址，配置：listen</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm; <span class=\"comment\">// 进程模型：static、dynamic、ondemand</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_children; <span class=\"comment\">// 最大worker进程数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_start_servers; <span class=\"comment\">// 启动时初始化的worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_min_spare_servers; <span class=\"comment\">// 最小空闲worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_spare_servers; <span class=\"comment\">// 最大空闲worker数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_process_idle_timeout; <span class=\"comment\">// worker空闲时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pm_max_requests; <span class=\"comment\">// worker处理的最多请求数，超多这个值worker将被kill</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fpm_scoreboard_init_main():  分配用于记录worker进行运行信息的共享内存.<br>分配用于<code>记录worker进程运行信息的共享内存</code>。按照worker pool的最大worker进程数分配，每个worker pool分配一个<strong>fpm_scoreboard_s</strong>结构，pool下对应的每个worker进程分配一个<strong>fpm_scoreboard_proc_s</strong>结构，各结构的对应关系如下图。<br><img src=\"https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738\" alt=\"worker_pool_struct\"></p>\n</li>\n<li><p>fpm_signals_init_mian():  mataer进行创建管道及注册信号管理worker进程.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sp[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fpm_signals_init_main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建一个全双工管道，该管道不是用于master与worker进程通信的，只在master进程中使用。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &gt; socketpair(AF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>, sp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//注册信号处理handler</span></span><br><span class=\"line\">    act.sa_handler = sig_handler;</span><br><span class=\"line\">    sigfillset(&amp;act.sa_mask);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &gt; sigaction(SIGTERM,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGINT,   &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGUSR1,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGUSR2,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGCHLD,  &amp;act, <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        <span class=\"number\">0</span> &gt; sigaction(SIGQUIT,  &amp;act, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过**socketpair()**创建一个管道，此管道只在master进程中使用。另外设置master的信号处理handler，当master收到SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT这些信号时将调用sig_handler()处理：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sig_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> signo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> sig_chars[NSIG + <span class=\"number\">1</span>] = &#123;</span><br><span class=\"line\">        [SIGTERM] = <span class=\"string\">&#x27;T&#x27;</span>,</span><br><span class=\"line\">        [SIGINT]  = <span class=\"string\">&#x27;I&#x27;</span>,</span><br><span class=\"line\">        [SIGUSR1] = <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">        [SIGUSR2] = <span class=\"string\">&#x27;2&#x27;</span>,</span><br><span class=\"line\">        [SIGQUIT] = <span class=\"string\">&#x27;Q&#x27;</span>,</span><br><span class=\"line\">        [SIGCHLD] = <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    s = sig_chars[signo];</span><br><span class=\"line\">    <span class=\"comment\">//将信号通知写入管道sp[1]端</span></span><br><span class=\"line\">    write(sp[<span class=\"number\">1</span>], &amp;s, <span class=\"keyword\">sizeof</span>(s));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fpm_sockets_init_main():  创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。</p>\n</li>\n<li><p>fpm_event_init_main():  启动master的事件管理.<br>启动master的事件管理，fpm实现了一个事件管理器用于管理IO、定时事件，其中IO事件通过kqueue、epoll、poll、select等管理，定时事件就是定时器，一定时间后触发某个事件。</p>\n</li>\n</ul>\n<p>在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将fork子进程，启动进程管理器，另外master进程将不会再返回，只有各worker进程会返回，也就是说fpm_run()之后的操作均是worker进程的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fpm_run</span><span class=\"params\">(<span class=\"keyword\">int</span> *max_requests)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fpm_worker_pool_s</span> *<span class=\"title\">wp</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (wp = fpm_worker_all_pools; wp; wp = wp-&gt;next) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用fpm_children_make() fork子进程</span></span><br><span class=\"line\">        is_parent = fpm_children_create_initial(wp);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!is_parent) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> run_child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//master进程将进入event循环，不再往下走</span></span><br><span class=\"line\">    fpm_event_loop(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">run_child: <span class=\"comment\">//只有worker进程会到这里</span></span><br><span class=\"line\"></span><br><span class=\"line\">    *max_requests = fpm_globals.max_requests;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fpm_globals.listening_socket; <span class=\"comment\">//返回监听的套接字</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在fork后worker进程返回了监听的套接字继续main()后面的处理，而master将永远阻塞在fpm_event_loop().</p>\n<h4 id=\"2-2-worker-请求处理\"><a href=\"#2-2-worker-请求处理\" class=\"headerlink\" title=\"2.2 worker-请求处理\"></a>2.2 worker-请求处理</h4><p>fpm_run()执行后将fork出worker进程，worker进程返回main()中继续向下执行，后面的流程就是worker进程不断accept请求，然后执行PHP脚本并返回。整体流程如下：</p>\n<ul>\n<li><p><strong>等待请求</strong>： worker进程阻塞在fcgi_accept_request()等待请求。</p>\n</li>\n<li><p><strong>解析请求</strong>： fastcgi请求到达后被worker接收，然后开始接受并解析请求数据，直到request数据完全到达。</p>\n</li>\n<li><p><strong>请求初始化</strong>：执行php_request_startup(), 此阶段会调用每个扩展的PHP_RINI_FUNCTION();</p>\n</li>\n<li><p><strong>编译、执行</strong>：php_execute_script()完成PHP脚本的编译、执行。</p>\n</li>\n<li><p><strong>关闭请求</strong>：请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    fcgi_fd = fpm_run(&amp;max_requests);</span><br><span class=\"line\">    parent = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化fastcgi请求</span></span><br><span class=\"line\">    request = fpm_init_request(fcgi_fd);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//worker进程将阻塞在这，等待请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (EXPECTED(fcgi_accept_request(request) &gt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        SG(server_context) = (<span class=\"keyword\">void</span> *) request;</span><br><span class=\"line\">        init_request_info();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//请求开始</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNEXPECTED(php_request_startup() == FAILURE)) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        fpm_request_executing();</span><br><span class=\"line\">        <span class=\"comment\">//编译、执行PHP脚本</span></span><br><span class=\"line\">        php_execute_script(&amp;file_handle);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//请求结束</span></span><br><span class=\"line\">        php_request_shutdown((<span class=\"keyword\">void</span> *) <span class=\"number\">0</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//worker进程退出</span></span><br><span class=\"line\">    php_module_shutdown();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>worker进程一次请求的处理被划分为5个阶段：</p>\n</li>\n<li><p><strong>FPM_REQUEST_ACCEPTING</strong>: 等待请求阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_READING_HEADERS</strong>: 读取fastcgi请求header阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_INFO</strong>: 获取请求信息阶段，此阶段是将请求的method、query stirng、request uri等信息保存到各worker进程的fpm_scoreboard_proc_s结构中，此操作需要加锁，因为master进程也会操作此结构</p>\n</li>\n<li><p><strong>FPM_REQUEST_EXECUTING</strong>: 执行请求阶段</p>\n</li>\n<li><p><strong>FPM_REQUEST_END</strong>: 没有使用</p>\n</li>\n<li><p><strong>FPM_REQUEST_FINISHED</strong>: 请求处理完成<br>worker处理到各个阶段时将会把当前阶段更新到==fpm_scoreboard_proc_s-&gt;request_stage==，master进程正是通过这个标识判断worker进程是否空闲的。</p>\n</li>\n</ul>\n<h4 id=\"2-3-master-进程管理\"><a href=\"#2-3-master-进程管理\" class=\"headerlink\" title=\"2.3 master-进程管理\"></a>2.3 master-进程管理</h4><p><u>master进程管理woker进程管理方式:</u></p>\n<ul>\n<li><strong>static</strong><br>worker进程数固定不变。在启动时master按照pm.max_children配置fork出相应数量的worker进程。</li>\n<li><strong>dynamic</strong><br>动态进程管理。 <ul>\n<li>首先fpm启动时按照pm.start_servers初始化一定数量的worker（<em>默认情况为：pm.min_spare_servers + (max_spare_servers - min_spare_servers) / 2</em>）。</li>\n<li>运行期间若master发现空闲的worker数低于pm.min_spare_servers(最小空闲数)配置数（请求较多，worker处理不过来）则会fork进程，但总worker数不能超过pm.max_children(最大进程数)；</li>\n<li>若空闲worker数超过pm.max_spare_servers(最大空闲数)（空闲worker数过多），则kill掉一些wokrer，避免占用资源过多。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.start_servers: 初始worker数</span><br><span class=\"line\">pm.min_spare_servers: 最小空闲worker数量</span><br><span class=\"line\">pm.max_spare_servers: 最大空闲worker数量</span><br><span class=\"line\">pm.max_children: 最大worker数</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>ondemand</strong><br>在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.max_children: 最大worker数</span><br><span class=\"line\">pm.process_idle_timeout: 空闲超时时间</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p>master整体的处理，其进程管理主要依赖注册的几个事件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fpm_event_loop</span><span class=\"params\">(<span class=\"keyword\">int</span> err)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]</span></span><br><span class=\"line\">    <span class=\"comment\">//当sp[0]可读时将回调fpm_got_signal()</span></span><br><span class=\"line\">    fpm_event_set(&amp;signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &amp;fpm_got_signal, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    fpm_event_add(&amp;signal_fd_event, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fpm_globals.heartbeat &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        fpm_pctl_heartbeat(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//定时触发进程管理</span></span><br><span class=\"line\">    fpm_pctl_perform_idle_server_maintenance_heartbeat(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//进入事件循环，master进程将阻塞在此</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//等待IO事件</span></span><br><span class=\"line\">        ret = <span class=\"keyword\">module</span>-&gt;wait(fpm_event_queue_fd, timeout);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">//检查定时器事件</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-1-sp-1-管道可读事件：\"><a href=\"#2-3-1-sp-1-管道可读事件：\" class=\"headerlink\" title=\"2.3.1. sp[1]管道可读事件：\"></a>2.3.1. sp[1]管道可读事件：</h5><p>在fpm_init()阶段master曾创建了一个全双工的管道：<code>sp</code>，然后在这里创建了一个sp[0]可读的事件，当sp[0]可读时将交由fpm_got_signal()处理，向sp[1]写数据时sp[0]才会可读，那么什么时机会向sp[1]写数据呢？前面已经提到了：当master收到注册的那几种信号时会写入sp[1]端，这个时候将触发sp[0]可读事件。<br><img src=\"https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec\" alt=\"master_event_1\"><br>信号用途：</p>\n<ul>\n<li>SIGINT/SIGTERM/SIGQUIT:<strong>退出fpm</strong>，在master收到退出信号后将向所有的worker进程发送退出信号，然后master退出.</li>\n<li>SIGUSR1:<strong>重新加载日志文件</strong>，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果fpm不重新加载将无法继续写入日志，这个时候就需要向master发送一个USR1的信号</li>\n<li>SIGUSR2:<strong>重启fpm</strong>，首先master也是会向所有的worker进程发送退出信号，然后master会调用execvp()重新启动fpm，最后旧的master退出</li>\n<li>SIGCHLD:这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用wait或者waitpid函数查询子进程退出状态后子进程才告终止，fpm中当worker进程因为异常原因(比如coredump了)退出而非master主动杀掉时master将受到此信号，这个时候父进程将调用waitpid()查下子进程的退出，然后检查下是不是需要重新fork新的worker</li>\n</ul>\n<h5 id=\"2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat\"><a href=\"#2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat\" class=\"headerlink\" title=\"2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():\"></a>2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():</h5><p>这是进程管理实现的主要事件，master启动了一个定时器，每隔<strong>1s</strong>触发一次，主要用于dynamic、ondemand模式下的worker管理，master会定时检查各worker pool的worker进程数，通过此定时器实现worker数量的控制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class=\"line\">        struct fpm_child_s *last_idle_child &#x3D; NULL; &#x2F;&#x2F;空闲时间最久的worker</span><br><span class=\"line\">        int idle &#x3D; 0; &#x2F;&#x2F;空闲worker数</span><br><span class=\"line\">        int active &#x3D; 0; &#x2F;&#x2F;忙碌worker数</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;根据worker进程的fpm_scoreboard_proc_s-&gt;request_stage判断</span><br><span class=\"line\">            if (fpm_request_is_idle(child)) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;找空闲时间最久的worker</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                idle++;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                active++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#x2F;&#x2F;ondemand模式</span><br><span class=\"line\">        if (wp-&gt;config-&gt;pm &#x3D;&#x3D; PM_STYLE_ONDEMAND) &#123;</span><br><span class=\"line\">            if (!last_idle_child) continue;</span><br><span class=\"line\"></span><br><span class=\"line\">            fpm_request_last_activity(last_idle_child, &amp;last);</span><br><span class=\"line\">            fpm_clock_get(&amp;now);</span><br><span class=\"line\">            if (last.tv_sec &lt; now.tv_sec - wp-&gt;config-&gt;pm_process_idle_timeout) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker</span><br><span class=\"line\">                last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class=\"line\">                fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;dynamic</span><br><span class=\"line\">        if (wp-&gt;config-&gt;pm !&#x3D; PM_STYLE_DYNAMIC) continue;</span><br><span class=\"line\">        if (idle &gt; wp-&gt;config-&gt;pm_max_spare_servers &amp;&amp; last_idle_child) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;空闲worker太多了，杀掉</span><br><span class=\"line\">            last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class=\"line\">            fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class=\"line\">            wp-&gt;idle_spawn_rate &#x3D; 1;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (idle &lt; wp-&gt;config-&gt;pm_min_spare_servers) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;空闲worker太少了，如果总worker数未达到max数则fork</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-3-fpm-pctl-heartbeat\"><a href=\"#2-3-3-fpm-pctl-heartbeat\" class=\"headerlink\" title=\"2.3.3 fpm_pctl_heartbeat():\"></a>2.3.3 fpm_pctl_heartbeat():</h5><p>这个事件是用于限制worker处理单个请求最大耗时的，php-fpm.conf中有一个request_terminate_timeout的配置项，如果worker处理一个请求的总时长超过了这个值那么master将会向此worker进程发送kill -TERM信号杀掉worker进程，此配置单位为秒，默认值为0表示关闭此机制，另外fpm打印的slow log也是在这里完成的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void fpm_pctl_check_request_timeout(struct timeval *now)</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    struct fpm_worker_pool_s *wp;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class=\"line\">        int terminate_timeout &#x3D; wp-&gt;config-&gt;request_terminate_timeout;</span><br><span class=\"line\">        int slowlog_timeout &#x3D; wp-&gt;config-&gt;request_slowlog_timeout;</span><br><span class=\"line\">        struct fpm_child_s *child;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (terminate_timeout || slowlog_timeout) &#123; </span><br><span class=\"line\">            for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F;检查当前当前worker处理的请求是否超时</span><br><span class=\"line\">                fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：<em>ondemand模式下master监听的新请求到达的事件，因为ondemand模式下fpm启动时是不会预创建worker的，有请求时才会生成子进程，所以请求到达时需要通知master进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()。</em></p>\n<hr>\n<p>参考文档：<br>1、php内核剖析： <a href=\"http://www.php.cn/manual/view/32905.html\">http://www.php.cn/manual/view/32905.html</a><br>2、php7-integernal：<a href=\"https://github.com/pangudashu/php7-internal\">https://github.com/pangudashu/php7-internal</a></p>"},{"title":"PHP7内核-内存管理-GC机制","date":"2020-08-25T03:20:09.000Z","_content":"\n##### 1 简介\n\nC/C++语言中，如果想在`堆`上分配变量，需要手动进行内存的分配与释放，变量的内存管理是见非常繁琐的事，稍有不慎就可能导致不可域值的错误。 PHP实现了自动GC机制，由语言自行管理。PHP中的变量是不需要手动释放的，内核帮我们实现了变量的内存管理，包括内存的分配与回收。\n\n<!--more-->\n\n**自动GC最简单的实现方式**：在函数中定义变量时分配一块内存，用于保存zval及对应的value结构，在函数返回时再将内存释放，若函数执行期间改变来凝固作为参数调用了其他函数或复制给了其他变量，则把变量复制一份，变量之间相互独立，不会出现冲突。\n（<u>问题：深拷贝可能造成内存浪费，比如定义一个变量赋值给另一个变量，后面是只读操作的情况</u>）\n\n\n\n**解决方式（PHP采用此种方式）:** `引用计数`+`写时复制`。\n\n- 当变量赋值、传递时多个变量公用一个value，引用计数用来记录value有多少个变量在使用；\n- 当变量的value发生改变时，进行深拷贝。\n\n注：long、double类型是使用的硬拷贝。\n\n\n\n##### 2 引用计数\n\n引用计数用来记录当前有多少`zval`指向同一个`zend_value`.\n引用计数：<u>指在value中增加一个字段refcount记录指向当前value的数量，变量复制、函数传参时并不直接硬拷贝一份value数据，而是将refcount++，变量销毁时将refcount--，等到refcount减为0时表示已经没有变量引用这个value，将它销毁即可。</u>\n\n**PHP7中将变量的引用计数保存在zend_value中**（与之前版本不同）\n\n之前变量中不同类型的结构体中都有一个相同的成员：gc，该结构用于保存引用计数的,其定义如下：\n\n```c\n// zend_type.h\ntypedef struct _zend_refcounted_h {\n    // 引用计数\n\tuint32_t         refcount;\t\t\t/* reference counter 32-bit */\n\tunion {\n\t\tstruct {\n\t\t\tZEND_ENDIAN_LOHI_3(\n\t\t\t    // 类型\n\t\t\t\tzend_uchar    type,\n\t\t\t\tzend_uchar    flags,    /* used for strings & objects */\n\t\t\t\t// 垃圾回收时用到\n\t\t\t\tuint16_t      gc_info)  /* keeps GC root number (or 0) and color */\n\t\t} v;\n\t\tuint32_t type_info;\n\t} u;\n} zend_refcounted_h;\n```\n\n例1：\n\n```php\n$a = \"time:\" . time();   //$a       ->  zend_string_1(refcount=1)\n$b = $a;                 //$a,$b    ->  zend_string_1(refcount=2)\n$c = $b;                 //$a,$b,$c ->  zend_string_1(refcount=3)\n\nunset($b);               //$b = IS_UNDEF  $a,$c ->  zend_string_1(refcount=2)\n```\n\n例2：\n\n```php\n$a = array();   // $a       -> zend_array(refcount=1)\n$b = $a;        // $a,$b    ->zend_array(refcount=2)\n$c = $b;        // $a,$b,$c -> zend_array(refcount=3)\nunset($b);      // $a,$c    -> zend_array(refcount=2)  $b = IS_UNDEF\n```\n\n\n\n**问: 是所有变量类型会用到引用计数吗?如果不是,那么那些情况不会用到呢?**\n\n不是, 其中不会用到引用计数的情况如下:\n\n- ①、没有具体value结构的类型是不会用到的，比如：整型、浮点型、布尔型、NULL，他们的值直接通过zval保存，赋值时采用<u>深拷贝</u>。\n- ②、interned string：内部字符串，在PHP中写的函数名、类名、变量名、静态字符串等都是这种类型，定义:$a = \"hi~\";后面的字符串内容是唯一不变的，这些字符串等同于C语言中定义在静态变量区的字符串：char *a = \"hi~\";，这些字符串的生命周期为request期间，request完成后会统一销毁释放，自然也就无需在运行期间通过引用计数管理内存。\n  （注：*内部字符串与普通字符串的类型都是IS_STRING，它们并不是通过type进行区分的，而是通过zend_refcount_h.u.v.flag区分，内部字符串的flag值将包含IS_STR_INTERNED*）\n- ③、immutable array：不可变数组，只有在用opcache的时候才会用到这种类型，不清楚具体实现，暂时忽略。\n\n除了以上几种情况, 其余类型将会用到引用计数。\n\n\n\n**问: PHP内核是怎样区分value是否支持引用计数的呢?**\n\n使用`zval.u1`中的类型掩码`type_flag`字段， 这个字段除了标识value是否支持引用计数外还有其它几个标识位，按位分割\n*注：type_flag与zval.value->gc.u.flag不是一个值。*\n\n支持引用计数的value类型是`zval.u1.type_flag & IS_TYPE_REFCOUNTED`。\n\n```c\n// IS_TYPE_REFCOUNTED = 4\n#define IS_TYPE_REFCOUNTED          (1<<2)\n```\n\n下列类型会使用引用计数机制：\n\n```\n|     type       | refcounted |\n+----------------+------------+\n|simple types    |            |\n|string          |      Y     |\n|interned string |            |\n|array           |      Y     |\n|immutable array |            |\n|object          |      Y     |\n|resource        |      Y     |\n|reference       |      Y     |\n```\n\n\n\n##### 3 写时复制\n\n写时复制机制，它只有在必要的时候（即发生写的时候）才会进行深拷贝，可以很好地提升效率。\n\n具体过程：<u>变量使用了引用计数，当出现其中一个变量修改value的情况，这个时候就需要对value进行分离，发生改变的变量恢复至一份数据出来进行修改，同时断开原来value的指向，指向新的value。</u>\n\n例1：\n\n```php\n$a = array(1,2);\n$b = &$a;\n$c = $a;\n\n//发生分离\n$b[] = 3;\n```\n\n![zval_sep](https://note.youdao.com/yws/api/personal/file/F0B25584D691443AB81AB2C8EA60C941?method=download&shareKey=98bf888bb661490664329007cb8b939c&ynotemdtimestamp=1598325595262)\n\n例2：\n\n```php\n$a = array(1,2);\n$b = &$a;\n$c = $a;\n\n//发生分离\n$c[] = 3;\n```\n\n![a、b、c发生写时复制的过程](https://note.youdao.com/yws/api/personal/file/4CDEAFB9332D4EEE9443D527A09934BF?method=download&shareKey=26b4c24edc932c27e427583bc422d2e3&ynotemdtimestamp=1598325595262)\n\n注：不是所有类型都可以copy的，比如<u>对象、资源就无法进行复制，也就是无法进行分离，如果多个变量指向同一个对象，当其中一个变量修改对象时，其修改将反映到所有变量上</u>。事实上**只有string、array两种支持value的分离**，与引用计数相同，也是通过`zval.u1.type_flag`标识value是否可复制的。\n\n```c\n// IS_TYPE_COPYABLE = 16\n#define IS_TYPE_COPYABLE         (1<<4)\n|     type       |  copyable  |\n+----------------+------------+\n|simple types    |            |\n|string          |      Y     |\n|interned string |            |\n|array           |      Y     |\n|immutable array |            |\n|object          |            |\n|resource        |            |\n|reference       |            |\n```\n\n\n\n##### 4 变量回收\n\nPHP变量回收方式：\n\n- 主动销毁：指的就是 unset。\n- 自动销毁：指PHP的自动管理机制（GC机制).\n  - 在return时减掉局部变量的refcount，即使没有显式的return，PHP也会自动给加上这个操作;\n  - 写时复制时也会断开原来value的指向，这时候也会检查断开后旧value的refcount。\n\n\n\n变量回收时机： zval断开value的指向时，若发现refcount=0则会直接释放value。其中发生断开的情况包括：\n\n- 修改变量：修改变量时会断开原有value的指向\n- 函数返回：函数返回时会释放所有的局部变量，也就是把所有局部变量的引用计数减1.\n\n\n\n##### 5 垃圾回收\n\nPHP用过引用计数实现了变量的自动GC机制，还是会有一种情况GC机制无法解决，从而导致变量无法回首导致内存始终得不到释放，造成内存泄露。\n\n造成内存泄漏的情况：<u>循环引用</u>\n\n**问: 什么是循环引用?**\n循环引用就是变量的内部成员引用了变量自身，比如数组中某个元素指向了数组，这样一来数组的引用计数中就有一个来自自身成员，当所有外部引用断开时，数组的refcount仍然大于0而得不到释放，但实际上这种变量不可能再被使用了。\n\n**垃圾收集器收集的时机**：<u>refcount减少时，即每次refcount减少都会试图收集</u>\n\n\n\n示例：\n\n```php\n$a = array(1);\n$a[] = &$a;\nunset($a);\n```\n\nunset($a)前，变量a的类型为引用，该引用的refcount=2，一个来自于$a,一个来自于$a[1];示意图如下： ![unset($a)前的引用关系](https://note.youdao.com/yws/api/personal/file/8C22AE1A04B249948E9ADECA4F6D9865?method=download&shareKey=90e64014943ead9d4294b592037d0484&ynotemdtimestamp=1598325595262)\n\nunset($a)后，减少了一次该引用的refcount，此时已经没有任何外部引用了，但是数组中仍然有一个元素指向该引用，如下图所示： ![unset($a)后的引用关系](https://note.youdao.com/yws/api/personal/file/74E94E6D9F384C0A9E9F44FF5F086CC9?method=download&shareKey=1ef849b379e45a8729679844f572119d&ynotemdtimestamp=1598325595262)\n\n这种因为循环引用而导致无法释放的变量称之为垃圾，PHP引入了另一种机制来对这些垃圾进行回收，即**垃圾回收器**。\n\n- 若一个变量value的refcount减少到0，那么此vlaue可以被释放掉，不属于垃圾。\n- 若一个变量value的refcount减少之后大于0，那么此vlaue还不能被释放，此value<u>可能</u>成为一个垃圾。\n\n\n\n垃圾回收器会将可能成为垃圾的value收集起来，等到达一定数量后开始启动垃圾鉴定程序，将真正的垃圾释放掉。\n\n**当前垃圾只会出现在array、object两种类型中**\n\n- array：数组中的某个成员指向了数组\n- object：对象的成员属性引用对象本身\n\n\n\n**问：垃圾回收器怎样判断当前类型是否可回收？** \n\n垃圾回收器不是通过变量类型进行判断的，而是通过`zval.u1.type_flag`标识进行判断，只有包含`IS_TYPE_COLLECTABLE`标识的变量类型才会被收集。\n\n```c\n// IS_TYPE_COLLECTABLE = 8\n# define IS_TYPE_COLLECTABLE  (1<<3)\n```\n\n###### 5.1 回收算法\n\n垃圾回收器把收集到的可能垃圾保存到一个buffer缓冲区中，当到达一定数量后就会启动垃圾鉴定、回收程序。\n回收算法的原理：<u>既然垃圾是由于成员引用自身导致的，那么就对value的所有成员减一遍引用计数，如果发现value本身refcount变为了0，则表明引用全部来自自身成员。</u>\n\n###### 5.2 具体实现\n\n垃圾回收器主要通过`zend_gc_globals`这个这结构对垃圾进行管理，收集到的可能成为垃圾的vlaue就保存在这个结构的buf中，即`垃圾缓冲区`。\n\n```c\n// zend_gc.h\ntypedef struct _zend_gc_globals {\n    // 是否启用gc（php.ini中zend.enable_gc设置是否开启，默认是开启的）\n\tzend_bool         gc_enabled;\n\t// 是否在垃圾检查过程中\n\tzend_bool         gc_active;\n\t// 缓存区是否已满\n\tzend_bool         gc_full;\n    // 启动时分配的用于保存可能垃圾的缓存区(初始化时，一次性分配了10001个gc_root_buffer,其中第一个被保留)\n\tgc_root_buffer   *buf;\t\t\t\t/* preallocated arrays of buffers   */\n\t// 指向buf中最新加入的一个可能垃圾（root是一个双向链表的头部）\n\tgc_root_buffer    roots;\t\t\t/* list of possible roots of cycles */\n\t// 指向bug中没有使用的buffer（用于管理buf中开始加入后面又删除的结点，是一个单链表）\n\tgc_root_buffer   *unused;\t\t\t/* list of unused buffers           */\n\t// 指向buf中第一个没有使用的buffer\n\tgc_root_buffer   *first_unused;\t\t/* pointer to first unused buffer   */\n\t// 指向buf尾部\n\tgc_root_buffer   *last_unused;\t\t/* pointer to last unused buffer    */\n    // 待释放的垃圾\n\tgc_root_buffer    to_free;\t\t\t/* list to free                     */\n\tgc_root_buffer   *next_to_free;\n    // 统计gc运行次数\n\tuint32_t gc_runs;\n\t// 统计已回收的垃圾数\n\tuint32_t collected;\n\n#if GC_BENCH\n\tuint32_t root_buf_length;\n\tuint32_t root_buf_peak;\n\tuint32_t zval_possible_root;\n\tuint32_t zval_buffered;\n\tuint32_t zval_remove_from_buffer;\n\tuint32_t zval_marked_grey;\n#endif\n\n\tgc_additional_buffer *additional_buffer;\n\n} zend_gc_globals;\n```\n\n- buf用于保存收集到的value，他是一个数组，在垃圾回收器初始化时一次性分配了10001个gc_root_buffer，其中第一个buffer被保留，插入vlaue时直接取出可用结点即可。\n- roots指向buf中最新加入的一个结点，root是一个双向链表的头部，之所以是一个双向链表，是因为bug数组中保存的只是有可能成为垃圾的vlaue吗，其中有些value在加入之后又被删除了，这样bug数组中就会出现一些空隙。\n- first_unused一开始指向bug的第一个位置，有些元素插入roots时如果first_unused还没有到达buf尾部，则返回first_unused给最新的元素，然后执行first_unused++,直到last_unused.\n\n下图为已经加入了2个gc的结构： ![buf缓冲区的可用节点](https://note.youdao.com/yws/api/personal/file/0A2236A0CF6442A0BB985383709DB5B7?method=download&shareKey=6656570e92c3731c6f1ce8572522a2d0&ynotemdtimestamp=1598325595262)\n\n- unused成员，他的含义与first_unused类似，用来管理buf中开始加入后面又删除的结点，是一个单链表结构。也就是说first_unused是一直往后偏移的，直到buf的结尾，buf中间由于value删除而重新空闲的结点则由unused串起来。下次有新的value插入roots时优先使用unused的这些节点，其次才是first_unused的结点。\n\n下图为移除了buf[1]的结构： ![buf[1]移除缓存去后的可用结点](https://note.youdao.com/yws/api/personal/file/B788660EE8EE43DDB952F0DC408264B7?method=download&shareKey=3896ffff3a8a0ab653a5c4fd197426da&ynotemdtimestamp=1598325595262)\n\n- 第一步，初始化 gc_init()初始化垃圾回收器：分配buf数组内存、设置first_unused/unused等\n\n```c\nZEND_API void gc_init(void)\n{\n\tif (GC_G(buf) == NULL && GC_G(gc_enabled)) {\n\t    // 分配buf缓冲区内存，大小为GC_ROOT_BUFFER_MAX_ENTERIES(10001),其中第1个保留不被使用。\n\t\tGC_G(buf) = (gc_root_buffer*) malloc(sizeof(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);\n\t\tGC_G(last_unused) = &GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];\n\t\t// 进行GC_G的初始化，其中：GC_G(first_unused) = GC_G(buf) + 1;从第二个开始，保留第一个。\n\t\tgc_reset();\n\t}\n}\n```\n\n- 第二步，垃圾回收，在Zend执行过程中如果销毁一个变量就会判断是否需要加入垃圾收集器。销毁一个zval会调用i_zval_ptr_dtor()进行处理。\n\n```c\n// file:zend_variables.h\nstatic zend_always_inline void i_zval_ptr_dtor(zval *zval_ptr ZEND_FILE_LINE_DC)\n{\n    // 不使用引用计数的类型不需要进行回收（整型、浮点型、布尔型，null）\n\tif (Z_REFCOUNTED_P(zval_ptr)) {\n\t    // refcount减一\n\t\tif (!Z_DELREF_P(zval_ptr)) {\n\t\t    // refcount减一后变为0，不是垃圾，正常回收\n\t\t\t_zval_dtor_func_for_ptr(Z_COUNTED_P(zval_ptr) ZEND_FILE_LINE_RELAY_CC);\n\t\t} else {\n\t\t    // refcount减一后仍然大于0，表示该变量可能是一个垃圾，被垃圾回收器回收。\n\t\t\tGC_ZVAL_CHECK_POSSIBLE_ROOT(zval_ptr);\n\t\t}\n\t}\n}\n// file:zend_gc.h\n#define GC_ZVAL_CHECK_POSSIBLE_ROOT(z) \\\n\tgc_check_possible_root((z))\n\nstatic zend_always_inline void gc_check_possible_root(zval *z)\n{\n\tZVAL_DEREF(z);\n\t// 判断是否是可收集（检查变量类型掩码zval.u1.type_flag是否包含IS_TYPE_COLLECTABLE,即数组、对象）以及是否已经收集过了（通过zend_refcount_h.v.u.gc_info来判断，第一次收集后会把这个值设置为GC_PURPLE来避免重复收集）\n\tif (Z_COLLECTABLE_P(z) && UNEXPECTED(!Z_GC_INFO_P(z))) {\n\t\tgc_possible_root(Z_COUNTED_P(z));\n\t}\n}\n```\n\n收集时首先会从buf中选择一个空闲节点，然后将vlaue的gc保存到这个结点中，若没有空闲节点则表明回收器已经满了，这个时候就会触发垃圾鉴定、回收程序。\n\n```c\n// file:zend_gc.c\nZEND_API void ZEND_FASTCALL gc_possible_root(zend_refcounted *ref)\n{\n\tgc_root_buffer *newRoot;\n\n\tif (UNEXPECTED(CG(unclean_shutdown)) || UNEXPECTED(GC_G(gc_active))) {\n\t\treturn;\n\t}\n\n\tZEND_ASSERT(GC_TYPE(ref) == IS_ARRAY || GC_TYPE(ref) == IS_OBJECT);\n\t// 插入的结点必须是GC_BLACK,防止重复插入\n\tZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(ref) == GC_BLACK));\n\tZEND_ASSERT(!GC_ADDRESS(GC_INFO(ref)));\n\n\tGC_BENCH_INC(zval_possible_root);\n\n    // 首先看一下unused中又没有可用的。\n\tnewRoot = GC_G(unused);\n\tif (newRoot) {\n\t    // 有的话先用unused的，然后将GC_G(unused)指向单链表的下一个\n\t\tGC_G(unused) = newRoot->prev;\n\t} else if (GC_G(first_unused) != GC_G(last_unused)) {\n\t    // unused没有可用的，且bug中还有可用\n\t\tnewRoot = GC_G(first_unused);\n\t\tGC_G(first_unused)++;\n\t} else {\n\t    // buf缓存区已满，这时需要启动垃圾鉴定、回收程序。\n\t\t...\n\t}\n    // 将插入的red标位紫色，防止重复插入\n\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);\n\t// 将该节点在buf中的位置保存到gc_info中，目的在于当后续value的refcount变为了0，需要将其从buf中删除时可以知道该value保存在那个gc_root_buffer中，如果没有这个信息，在删除vlaue时无法获取gc_root_buffer的位置。\n\tGC_INFO(ref) = (newRoot - GC_G(buf)) | GC_PURPLE;\n\tnewRoot->ref = ref;\n    // 插入roots链表头部\n\tnewRoot->next = GC_G(roots).next;\n\tnewRoot->prev = &GC_G(roots);\n\tGC_G(roots).next->prev = newRoot;\n\tGC_G(roots).next = newRoot;\n\n\tGC_BENCH_INC(zval_buffered);\n\tGC_BENCH_INC(root_buf_length);\n\tGC_BENCH_PEAK(root_buf_peak, root_buf_length);\n}\n```\n\n- 第三步，删除 删除的操作通过GC_REMOVE_FROM_BUFFER()完成。\n\n```c\n// file:zend_gc.h\n#define GC_REMOVE_FROM_BUFFER(p) do { \\\n\t\tzend_refcounted *_p = (zend_refcounted*)(p); \\\n\t\tif (GC_ADDRESS(GC_INFO(_p))) { \\\n\t\t\tgc_remove_from_buffer(_p); \\\n\t\t} \\\n\t} while (0)\n\t\n#define GC_ADDRESS(v) \\\n\t((v) & ~GC_COLOR)\n```\n\n删除时，先根据gc_info取到gc_root_buffer，然后再从buf中移除，删除后再把空的gc_root_buffer插入到unused单链表尾部。\n\n```c\n// file:zend_gc.c\nZEND_API void ZEND_FASTCALL gc_remove_from_buffer(zend_refcounted *ref)\n{\n\tgc_root_buffer *root;\n\n\tZEND_ASSERT(GC_ADDRESS(GC_INFO(ref)));\n\n\tGC_BENCH_INC(zval_remove_from_buffer);\n\n\tif (EXPECTED(GC_ADDRESS(GC_INFO(ref)) < GC_ROOT_BUFFER_MAX_ENTRIES)) {\n\t\troot = GC_G(buf) + GC_ADDRESS(GC_INFO(ref));\n\t\tgc_remove_from_roots(root);\n\t} else {\n\t\troot = gc_find_additional_buffer(ref);\n\t\tgc_remove_from_additional_roots(root);\n\t}\n\tif (GC_REF_GET_COLOR(ref) != GC_BLACK) {\n\t\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);\n\t}\n\tGC_INFO(ref) = 0;\n\n\t/* updete next root that is going to be freed */\n\tif (GC_G(next_to_free) == root) {\n\t\tGC_G(next_to_free) = root->next;\n\t}\n}\n```\n\n当buf缓存区满了执行垃圾回收的过程如下：\n\n```c\nZEND_API int zend_gc_collect_cycles(void)\n{\n\t    ...\n\t    // (1)遍历roots链表，对当前结点vlaue的所有成员（如数组元素、成员变量）进行深度优先遍历，把成员refcount减1.\n\t\tgc_mark_roots();\n\t\tGC_TRACE(\"Scanning roots\");\n\t\t// (2)再次遍历roots链表，检查各结点当前refcount是否为0，是的话标为white，表示是垃圾，不是的话需要还原（1），吧refcount再加回去\n\t\tgc_scan_roots();\n\n#if ZEND_GC_DEBUG\n\t\torig_gc_full = GC_G(gc_full);\n\t\tGC_G(gc_full) = 0;\n#endif\n\n\t\tGC_TRACE(\"Collecting roots\");\n\t\tadditional_buffer_snapshot = GC_G(additional_buffer);\n\t\t// 将roots链表中的非白色结点删除，之后roots链表中全部是真正的垃圾，将垃圾链表转到to_free等待释放\n\t  \n\t  ...\n\t  \n\t\t\n\t\t// 释放垃圾\n\t\tcurrent = to_free.next;\n\t\twhile (current != &to_free) {\n\t\t\tnext = current->next;\n\t\t\tp = current->ref;\n\t\t\tif (EXPECTED(current >= GC_G(buf) && current < GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) {\n\t\t\t\tcurrent->prev = GC_G(unused);\n\t\t\t\tGC_G(unused) = current;\n\t\t\t}\n\t\t\tefree(p);\n\t\t\tcurrent = next;\n\t\t}\n\n\t...\n}\n```","source":"_posts/PHP7内核-内存管理-GC机制.md","raw":"---\ntitle: PHP7内核-内存管理-GC机制\ndate: 2020-08-25 11:20:09\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n##### 1 简介\n\nC/C++语言中，如果想在`堆`上分配变量，需要手动进行内存的分配与释放，变量的内存管理是见非常繁琐的事，稍有不慎就可能导致不可域值的错误。 PHP实现了自动GC机制，由语言自行管理。PHP中的变量是不需要手动释放的，内核帮我们实现了变量的内存管理，包括内存的分配与回收。\n\n<!--more-->\n\n**自动GC最简单的实现方式**：在函数中定义变量时分配一块内存，用于保存zval及对应的value结构，在函数返回时再将内存释放，若函数执行期间改变来凝固作为参数调用了其他函数或复制给了其他变量，则把变量复制一份，变量之间相互独立，不会出现冲突。\n（<u>问题：深拷贝可能造成内存浪费，比如定义一个变量赋值给另一个变量，后面是只读操作的情况</u>）\n\n\n\n**解决方式（PHP采用此种方式）:** `引用计数`+`写时复制`。\n\n- 当变量赋值、传递时多个变量公用一个value，引用计数用来记录value有多少个变量在使用；\n- 当变量的value发生改变时，进行深拷贝。\n\n注：long、double类型是使用的硬拷贝。\n\n\n\n##### 2 引用计数\n\n引用计数用来记录当前有多少`zval`指向同一个`zend_value`.\n引用计数：<u>指在value中增加一个字段refcount记录指向当前value的数量，变量复制、函数传参时并不直接硬拷贝一份value数据，而是将refcount++，变量销毁时将refcount--，等到refcount减为0时表示已经没有变量引用这个value，将它销毁即可。</u>\n\n**PHP7中将变量的引用计数保存在zend_value中**（与之前版本不同）\n\n之前变量中不同类型的结构体中都有一个相同的成员：gc，该结构用于保存引用计数的,其定义如下：\n\n```c\n// zend_type.h\ntypedef struct _zend_refcounted_h {\n    // 引用计数\n\tuint32_t         refcount;\t\t\t/* reference counter 32-bit */\n\tunion {\n\t\tstruct {\n\t\t\tZEND_ENDIAN_LOHI_3(\n\t\t\t    // 类型\n\t\t\t\tzend_uchar    type,\n\t\t\t\tzend_uchar    flags,    /* used for strings & objects */\n\t\t\t\t// 垃圾回收时用到\n\t\t\t\tuint16_t      gc_info)  /* keeps GC root number (or 0) and color */\n\t\t} v;\n\t\tuint32_t type_info;\n\t} u;\n} zend_refcounted_h;\n```\n\n例1：\n\n```php\n$a = \"time:\" . time();   //$a       ->  zend_string_1(refcount=1)\n$b = $a;                 //$a,$b    ->  zend_string_1(refcount=2)\n$c = $b;                 //$a,$b,$c ->  zend_string_1(refcount=3)\n\nunset($b);               //$b = IS_UNDEF  $a,$c ->  zend_string_1(refcount=2)\n```\n\n例2：\n\n```php\n$a = array();   // $a       -> zend_array(refcount=1)\n$b = $a;        // $a,$b    ->zend_array(refcount=2)\n$c = $b;        // $a,$b,$c -> zend_array(refcount=3)\nunset($b);      // $a,$c    -> zend_array(refcount=2)  $b = IS_UNDEF\n```\n\n\n\n**问: 是所有变量类型会用到引用计数吗?如果不是,那么那些情况不会用到呢?**\n\n不是, 其中不会用到引用计数的情况如下:\n\n- ①、没有具体value结构的类型是不会用到的，比如：整型、浮点型、布尔型、NULL，他们的值直接通过zval保存，赋值时采用<u>深拷贝</u>。\n- ②、interned string：内部字符串，在PHP中写的函数名、类名、变量名、静态字符串等都是这种类型，定义:$a = \"hi~\";后面的字符串内容是唯一不变的，这些字符串等同于C语言中定义在静态变量区的字符串：char *a = \"hi~\";，这些字符串的生命周期为request期间，request完成后会统一销毁释放，自然也就无需在运行期间通过引用计数管理内存。\n  （注：*内部字符串与普通字符串的类型都是IS_STRING，它们并不是通过type进行区分的，而是通过zend_refcount_h.u.v.flag区分，内部字符串的flag值将包含IS_STR_INTERNED*）\n- ③、immutable array：不可变数组，只有在用opcache的时候才会用到这种类型，不清楚具体实现，暂时忽略。\n\n除了以上几种情况, 其余类型将会用到引用计数。\n\n\n\n**问: PHP内核是怎样区分value是否支持引用计数的呢?**\n\n使用`zval.u1`中的类型掩码`type_flag`字段， 这个字段除了标识value是否支持引用计数外还有其它几个标识位，按位分割\n*注：type_flag与zval.value->gc.u.flag不是一个值。*\n\n支持引用计数的value类型是`zval.u1.type_flag & IS_TYPE_REFCOUNTED`。\n\n```c\n// IS_TYPE_REFCOUNTED = 4\n#define IS_TYPE_REFCOUNTED          (1<<2)\n```\n\n下列类型会使用引用计数机制：\n\n```\n|     type       | refcounted |\n+----------------+------------+\n|simple types    |            |\n|string          |      Y     |\n|interned string |            |\n|array           |      Y     |\n|immutable array |            |\n|object          |      Y     |\n|resource        |      Y     |\n|reference       |      Y     |\n```\n\n\n\n##### 3 写时复制\n\n写时复制机制，它只有在必要的时候（即发生写的时候）才会进行深拷贝，可以很好地提升效率。\n\n具体过程：<u>变量使用了引用计数，当出现其中一个变量修改value的情况，这个时候就需要对value进行分离，发生改变的变量恢复至一份数据出来进行修改，同时断开原来value的指向，指向新的value。</u>\n\n例1：\n\n```php\n$a = array(1,2);\n$b = &$a;\n$c = $a;\n\n//发生分离\n$b[] = 3;\n```\n\n![zval_sep](https://note.youdao.com/yws/api/personal/file/F0B25584D691443AB81AB2C8EA60C941?method=download&shareKey=98bf888bb661490664329007cb8b939c&ynotemdtimestamp=1598325595262)\n\n例2：\n\n```php\n$a = array(1,2);\n$b = &$a;\n$c = $a;\n\n//发生分离\n$c[] = 3;\n```\n\n![a、b、c发生写时复制的过程](https://note.youdao.com/yws/api/personal/file/4CDEAFB9332D4EEE9443D527A09934BF?method=download&shareKey=26b4c24edc932c27e427583bc422d2e3&ynotemdtimestamp=1598325595262)\n\n注：不是所有类型都可以copy的，比如<u>对象、资源就无法进行复制，也就是无法进行分离，如果多个变量指向同一个对象，当其中一个变量修改对象时，其修改将反映到所有变量上</u>。事实上**只有string、array两种支持value的分离**，与引用计数相同，也是通过`zval.u1.type_flag`标识value是否可复制的。\n\n```c\n// IS_TYPE_COPYABLE = 16\n#define IS_TYPE_COPYABLE         (1<<4)\n|     type       |  copyable  |\n+----------------+------------+\n|simple types    |            |\n|string          |      Y     |\n|interned string |            |\n|array           |      Y     |\n|immutable array |            |\n|object          |            |\n|resource        |            |\n|reference       |            |\n```\n\n\n\n##### 4 变量回收\n\nPHP变量回收方式：\n\n- 主动销毁：指的就是 unset。\n- 自动销毁：指PHP的自动管理机制（GC机制).\n  - 在return时减掉局部变量的refcount，即使没有显式的return，PHP也会自动给加上这个操作;\n  - 写时复制时也会断开原来value的指向，这时候也会检查断开后旧value的refcount。\n\n\n\n变量回收时机： zval断开value的指向时，若发现refcount=0则会直接释放value。其中发生断开的情况包括：\n\n- 修改变量：修改变量时会断开原有value的指向\n- 函数返回：函数返回时会释放所有的局部变量，也就是把所有局部变量的引用计数减1.\n\n\n\n##### 5 垃圾回收\n\nPHP用过引用计数实现了变量的自动GC机制，还是会有一种情况GC机制无法解决，从而导致变量无法回首导致内存始终得不到释放，造成内存泄露。\n\n造成内存泄漏的情况：<u>循环引用</u>\n\n**问: 什么是循环引用?**\n循环引用就是变量的内部成员引用了变量自身，比如数组中某个元素指向了数组，这样一来数组的引用计数中就有一个来自自身成员，当所有外部引用断开时，数组的refcount仍然大于0而得不到释放，但实际上这种变量不可能再被使用了。\n\n**垃圾收集器收集的时机**：<u>refcount减少时，即每次refcount减少都会试图收集</u>\n\n\n\n示例：\n\n```php\n$a = array(1);\n$a[] = &$a;\nunset($a);\n```\n\nunset($a)前，变量a的类型为引用，该引用的refcount=2，一个来自于$a,一个来自于$a[1];示意图如下： ![unset($a)前的引用关系](https://note.youdao.com/yws/api/personal/file/8C22AE1A04B249948E9ADECA4F6D9865?method=download&shareKey=90e64014943ead9d4294b592037d0484&ynotemdtimestamp=1598325595262)\n\nunset($a)后，减少了一次该引用的refcount，此时已经没有任何外部引用了，但是数组中仍然有一个元素指向该引用，如下图所示： ![unset($a)后的引用关系](https://note.youdao.com/yws/api/personal/file/74E94E6D9F384C0A9E9F44FF5F086CC9?method=download&shareKey=1ef849b379e45a8729679844f572119d&ynotemdtimestamp=1598325595262)\n\n这种因为循环引用而导致无法释放的变量称之为垃圾，PHP引入了另一种机制来对这些垃圾进行回收，即**垃圾回收器**。\n\n- 若一个变量value的refcount减少到0，那么此vlaue可以被释放掉，不属于垃圾。\n- 若一个变量value的refcount减少之后大于0，那么此vlaue还不能被释放，此value<u>可能</u>成为一个垃圾。\n\n\n\n垃圾回收器会将可能成为垃圾的value收集起来，等到达一定数量后开始启动垃圾鉴定程序，将真正的垃圾释放掉。\n\n**当前垃圾只会出现在array、object两种类型中**\n\n- array：数组中的某个成员指向了数组\n- object：对象的成员属性引用对象本身\n\n\n\n**问：垃圾回收器怎样判断当前类型是否可回收？** \n\n垃圾回收器不是通过变量类型进行判断的，而是通过`zval.u1.type_flag`标识进行判断，只有包含`IS_TYPE_COLLECTABLE`标识的变量类型才会被收集。\n\n```c\n// IS_TYPE_COLLECTABLE = 8\n# define IS_TYPE_COLLECTABLE  (1<<3)\n```\n\n###### 5.1 回收算法\n\n垃圾回收器把收集到的可能垃圾保存到一个buffer缓冲区中，当到达一定数量后就会启动垃圾鉴定、回收程序。\n回收算法的原理：<u>既然垃圾是由于成员引用自身导致的，那么就对value的所有成员减一遍引用计数，如果发现value本身refcount变为了0，则表明引用全部来自自身成员。</u>\n\n###### 5.2 具体实现\n\n垃圾回收器主要通过`zend_gc_globals`这个这结构对垃圾进行管理，收集到的可能成为垃圾的vlaue就保存在这个结构的buf中，即`垃圾缓冲区`。\n\n```c\n// zend_gc.h\ntypedef struct _zend_gc_globals {\n    // 是否启用gc（php.ini中zend.enable_gc设置是否开启，默认是开启的）\n\tzend_bool         gc_enabled;\n\t// 是否在垃圾检查过程中\n\tzend_bool         gc_active;\n\t// 缓存区是否已满\n\tzend_bool         gc_full;\n    // 启动时分配的用于保存可能垃圾的缓存区(初始化时，一次性分配了10001个gc_root_buffer,其中第一个被保留)\n\tgc_root_buffer   *buf;\t\t\t\t/* preallocated arrays of buffers   */\n\t// 指向buf中最新加入的一个可能垃圾（root是一个双向链表的头部）\n\tgc_root_buffer    roots;\t\t\t/* list of possible roots of cycles */\n\t// 指向bug中没有使用的buffer（用于管理buf中开始加入后面又删除的结点，是一个单链表）\n\tgc_root_buffer   *unused;\t\t\t/* list of unused buffers           */\n\t// 指向buf中第一个没有使用的buffer\n\tgc_root_buffer   *first_unused;\t\t/* pointer to first unused buffer   */\n\t// 指向buf尾部\n\tgc_root_buffer   *last_unused;\t\t/* pointer to last unused buffer    */\n    // 待释放的垃圾\n\tgc_root_buffer    to_free;\t\t\t/* list to free                     */\n\tgc_root_buffer   *next_to_free;\n    // 统计gc运行次数\n\tuint32_t gc_runs;\n\t// 统计已回收的垃圾数\n\tuint32_t collected;\n\n#if GC_BENCH\n\tuint32_t root_buf_length;\n\tuint32_t root_buf_peak;\n\tuint32_t zval_possible_root;\n\tuint32_t zval_buffered;\n\tuint32_t zval_remove_from_buffer;\n\tuint32_t zval_marked_grey;\n#endif\n\n\tgc_additional_buffer *additional_buffer;\n\n} zend_gc_globals;\n```\n\n- buf用于保存收集到的value，他是一个数组，在垃圾回收器初始化时一次性分配了10001个gc_root_buffer，其中第一个buffer被保留，插入vlaue时直接取出可用结点即可。\n- roots指向buf中最新加入的一个结点，root是一个双向链表的头部，之所以是一个双向链表，是因为bug数组中保存的只是有可能成为垃圾的vlaue吗，其中有些value在加入之后又被删除了，这样bug数组中就会出现一些空隙。\n- first_unused一开始指向bug的第一个位置，有些元素插入roots时如果first_unused还没有到达buf尾部，则返回first_unused给最新的元素，然后执行first_unused++,直到last_unused.\n\n下图为已经加入了2个gc的结构： ![buf缓冲区的可用节点](https://note.youdao.com/yws/api/personal/file/0A2236A0CF6442A0BB985383709DB5B7?method=download&shareKey=6656570e92c3731c6f1ce8572522a2d0&ynotemdtimestamp=1598325595262)\n\n- unused成员，他的含义与first_unused类似，用来管理buf中开始加入后面又删除的结点，是一个单链表结构。也就是说first_unused是一直往后偏移的，直到buf的结尾，buf中间由于value删除而重新空闲的结点则由unused串起来。下次有新的value插入roots时优先使用unused的这些节点，其次才是first_unused的结点。\n\n下图为移除了buf[1]的结构： ![buf[1]移除缓存去后的可用结点](https://note.youdao.com/yws/api/personal/file/B788660EE8EE43DDB952F0DC408264B7?method=download&shareKey=3896ffff3a8a0ab653a5c4fd197426da&ynotemdtimestamp=1598325595262)\n\n- 第一步，初始化 gc_init()初始化垃圾回收器：分配buf数组内存、设置first_unused/unused等\n\n```c\nZEND_API void gc_init(void)\n{\n\tif (GC_G(buf) == NULL && GC_G(gc_enabled)) {\n\t    // 分配buf缓冲区内存，大小为GC_ROOT_BUFFER_MAX_ENTERIES(10001),其中第1个保留不被使用。\n\t\tGC_G(buf) = (gc_root_buffer*) malloc(sizeof(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);\n\t\tGC_G(last_unused) = &GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];\n\t\t// 进行GC_G的初始化，其中：GC_G(first_unused) = GC_G(buf) + 1;从第二个开始，保留第一个。\n\t\tgc_reset();\n\t}\n}\n```\n\n- 第二步，垃圾回收，在Zend执行过程中如果销毁一个变量就会判断是否需要加入垃圾收集器。销毁一个zval会调用i_zval_ptr_dtor()进行处理。\n\n```c\n// file:zend_variables.h\nstatic zend_always_inline void i_zval_ptr_dtor(zval *zval_ptr ZEND_FILE_LINE_DC)\n{\n    // 不使用引用计数的类型不需要进行回收（整型、浮点型、布尔型，null）\n\tif (Z_REFCOUNTED_P(zval_ptr)) {\n\t    // refcount减一\n\t\tif (!Z_DELREF_P(zval_ptr)) {\n\t\t    // refcount减一后变为0，不是垃圾，正常回收\n\t\t\t_zval_dtor_func_for_ptr(Z_COUNTED_P(zval_ptr) ZEND_FILE_LINE_RELAY_CC);\n\t\t} else {\n\t\t    // refcount减一后仍然大于0，表示该变量可能是一个垃圾，被垃圾回收器回收。\n\t\t\tGC_ZVAL_CHECK_POSSIBLE_ROOT(zval_ptr);\n\t\t}\n\t}\n}\n// file:zend_gc.h\n#define GC_ZVAL_CHECK_POSSIBLE_ROOT(z) \\\n\tgc_check_possible_root((z))\n\nstatic zend_always_inline void gc_check_possible_root(zval *z)\n{\n\tZVAL_DEREF(z);\n\t// 判断是否是可收集（检查变量类型掩码zval.u1.type_flag是否包含IS_TYPE_COLLECTABLE,即数组、对象）以及是否已经收集过了（通过zend_refcount_h.v.u.gc_info来判断，第一次收集后会把这个值设置为GC_PURPLE来避免重复收集）\n\tif (Z_COLLECTABLE_P(z) && UNEXPECTED(!Z_GC_INFO_P(z))) {\n\t\tgc_possible_root(Z_COUNTED_P(z));\n\t}\n}\n```\n\n收集时首先会从buf中选择一个空闲节点，然后将vlaue的gc保存到这个结点中，若没有空闲节点则表明回收器已经满了，这个时候就会触发垃圾鉴定、回收程序。\n\n```c\n// file:zend_gc.c\nZEND_API void ZEND_FASTCALL gc_possible_root(zend_refcounted *ref)\n{\n\tgc_root_buffer *newRoot;\n\n\tif (UNEXPECTED(CG(unclean_shutdown)) || UNEXPECTED(GC_G(gc_active))) {\n\t\treturn;\n\t}\n\n\tZEND_ASSERT(GC_TYPE(ref) == IS_ARRAY || GC_TYPE(ref) == IS_OBJECT);\n\t// 插入的结点必须是GC_BLACK,防止重复插入\n\tZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(ref) == GC_BLACK));\n\tZEND_ASSERT(!GC_ADDRESS(GC_INFO(ref)));\n\n\tGC_BENCH_INC(zval_possible_root);\n\n    // 首先看一下unused中又没有可用的。\n\tnewRoot = GC_G(unused);\n\tif (newRoot) {\n\t    // 有的话先用unused的，然后将GC_G(unused)指向单链表的下一个\n\t\tGC_G(unused) = newRoot->prev;\n\t} else if (GC_G(first_unused) != GC_G(last_unused)) {\n\t    // unused没有可用的，且bug中还有可用\n\t\tnewRoot = GC_G(first_unused);\n\t\tGC_G(first_unused)++;\n\t} else {\n\t    // buf缓存区已满，这时需要启动垃圾鉴定、回收程序。\n\t\t...\n\t}\n    // 将插入的red标位紫色，防止重复插入\n\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);\n\t// 将该节点在buf中的位置保存到gc_info中，目的在于当后续value的refcount变为了0，需要将其从buf中删除时可以知道该value保存在那个gc_root_buffer中，如果没有这个信息，在删除vlaue时无法获取gc_root_buffer的位置。\n\tGC_INFO(ref) = (newRoot - GC_G(buf)) | GC_PURPLE;\n\tnewRoot->ref = ref;\n    // 插入roots链表头部\n\tnewRoot->next = GC_G(roots).next;\n\tnewRoot->prev = &GC_G(roots);\n\tGC_G(roots).next->prev = newRoot;\n\tGC_G(roots).next = newRoot;\n\n\tGC_BENCH_INC(zval_buffered);\n\tGC_BENCH_INC(root_buf_length);\n\tGC_BENCH_PEAK(root_buf_peak, root_buf_length);\n}\n```\n\n- 第三步，删除 删除的操作通过GC_REMOVE_FROM_BUFFER()完成。\n\n```c\n// file:zend_gc.h\n#define GC_REMOVE_FROM_BUFFER(p) do { \\\n\t\tzend_refcounted *_p = (zend_refcounted*)(p); \\\n\t\tif (GC_ADDRESS(GC_INFO(_p))) { \\\n\t\t\tgc_remove_from_buffer(_p); \\\n\t\t} \\\n\t} while (0)\n\t\n#define GC_ADDRESS(v) \\\n\t((v) & ~GC_COLOR)\n```\n\n删除时，先根据gc_info取到gc_root_buffer，然后再从buf中移除，删除后再把空的gc_root_buffer插入到unused单链表尾部。\n\n```c\n// file:zend_gc.c\nZEND_API void ZEND_FASTCALL gc_remove_from_buffer(zend_refcounted *ref)\n{\n\tgc_root_buffer *root;\n\n\tZEND_ASSERT(GC_ADDRESS(GC_INFO(ref)));\n\n\tGC_BENCH_INC(zval_remove_from_buffer);\n\n\tif (EXPECTED(GC_ADDRESS(GC_INFO(ref)) < GC_ROOT_BUFFER_MAX_ENTRIES)) {\n\t\troot = GC_G(buf) + GC_ADDRESS(GC_INFO(ref));\n\t\tgc_remove_from_roots(root);\n\t} else {\n\t\troot = gc_find_additional_buffer(ref);\n\t\tgc_remove_from_additional_roots(root);\n\t}\n\tif (GC_REF_GET_COLOR(ref) != GC_BLACK) {\n\t\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);\n\t}\n\tGC_INFO(ref) = 0;\n\n\t/* updete next root that is going to be freed */\n\tif (GC_G(next_to_free) == root) {\n\t\tGC_G(next_to_free) = root->next;\n\t}\n}\n```\n\n当buf缓存区满了执行垃圾回收的过程如下：\n\n```c\nZEND_API int zend_gc_collect_cycles(void)\n{\n\t    ...\n\t    // (1)遍历roots链表，对当前结点vlaue的所有成员（如数组元素、成员变量）进行深度优先遍历，把成员refcount减1.\n\t\tgc_mark_roots();\n\t\tGC_TRACE(\"Scanning roots\");\n\t\t// (2)再次遍历roots链表，检查各结点当前refcount是否为0，是的话标为white，表示是垃圾，不是的话需要还原（1），吧refcount再加回去\n\t\tgc_scan_roots();\n\n#if ZEND_GC_DEBUG\n\t\torig_gc_full = GC_G(gc_full);\n\t\tGC_G(gc_full) = 0;\n#endif\n\n\t\tGC_TRACE(\"Collecting roots\");\n\t\tadditional_buffer_snapshot = GC_G(additional_buffer);\n\t\t// 将roots链表中的非白色结点删除，之后roots链表中全部是真正的垃圾，将垃圾链表转到to_free等待释放\n\t  \n\t  ...\n\t  \n\t\t\n\t\t// 释放垃圾\n\t\tcurrent = to_free.next;\n\t\twhile (current != &to_free) {\n\t\t\tnext = current->next;\n\t\t\tp = current->ref;\n\t\t\tif (EXPECTED(current >= GC_G(buf) && current < GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) {\n\t\t\t\tcurrent->prev = GC_G(unused);\n\t\t\t\tGC_G(unused) = current;\n\t\t\t}\n\t\t\tefree(p);\n\t\t\tcurrent = next;\n\t\t}\n\n\t...\n}\n```","slug":"PHP7内核-内存管理-GC机制","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabn3006345g34nhy5upt","content":"<h5 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h5><p>C/C++语言中，如果想在<code>堆</code>上分配变量，需要手动进行内存的分配与释放，变量的内存管理是见非常繁琐的事，稍有不慎就可能导致不可域值的错误。 PHP实现了自动GC机制，由语言自行管理。PHP中的变量是不需要手动释放的，内核帮我们实现了变量的内存管理，包括内存的分配与回收。</p>\n<a id=\"more\"></a>\n\n<p><strong>自动GC最简单的实现方式</strong>：在函数中定义变量时分配一块内存，用于保存zval及对应的value结构，在函数返回时再将内存释放，若函数执行期间改变来凝固作为参数调用了其他函数或复制给了其他变量，则把变量复制一份，变量之间相互独立，不会出现冲突。<br>（<u>问题：深拷贝可能造成内存浪费，比如定义一个变量赋值给另一个变量，后面是只读操作的情况</u>）</p>\n<p><strong>解决方式（PHP采用此种方式）:</strong> <code>引用计数</code>+<code>写时复制</code>。</p>\n<ul>\n<li>当变量赋值、传递时多个变量公用一个value，引用计数用来记录value有多少个变量在使用；</li>\n<li>当变量的value发生改变时，进行深拷贝。</li>\n</ul>\n<p>注：long、double类型是使用的硬拷贝。</p>\n<h5 id=\"2-引用计数\"><a href=\"#2-引用计数\" class=\"headerlink\" title=\"2 引用计数\"></a>2 引用计数</h5><p>引用计数用来记录当前有多少<code>zval</code>指向同一个<code>zend_value</code>.<br>引用计数：<u>指在value中增加一个字段refcount记录指向当前value的数量，变量复制、函数传参时并不直接硬拷贝一份value数据，而是将refcount++，变量销毁时将refcount–，等到refcount减为0时表示已经没有变量引用这个value，将它销毁即可。</u></p>\n<p><strong>PHP7中将变量的引用计数保存在zend_value中</strong>（与之前版本不同）</p>\n<p>之前变量中不同类型的结构体中都有一个相同的成员：gc，该结构用于保存引用计数的,其定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_type.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_refcounted_h</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span>         refcount;\t\t\t<span class=\"comment\">/* reference counter 32-bit */</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\tZEND_ENDIAN_LOHI_3(</span><br><span class=\"line\">\t\t\t    <span class=\"comment\">// 类型</span></span><br><span class=\"line\">\t\t\t\tzend_uchar    type,</span><br><span class=\"line\">\t\t\t\tzend_uchar    flags,    <span class=\"comment\">/* used for strings &amp; objects */</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 垃圾回收时用到</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">uint16_t</span>      gc_info)  <span class=\"comment\">/* keeps GC root number (or 0) and color */</span></span><br><span class=\"line\">\t\t&#125; v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> type_info;</span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">&#125; zend_refcounted_h;</span><br></pre></td></tr></table></figure>\n\n<p>例1：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"string\">&quot;time:&quot;</span> . time();   <span class=\"comment\">//$a       -&gt;  zend_string_1(refcount=1)</span></span><br><span class=\"line\">$b = $a;                 <span class=\"comment\">//$a,$b    -&gt;  zend_string_1(refcount=2)</span></span><br><span class=\"line\">$c = $b;                 <span class=\"comment\">//$a,$b,$c -&gt;  zend_string_1(refcount=3)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unset</span>($b);               <span class=\"comment\">//$b = IS_UNDEF  $a,$c -&gt;  zend_string_1(refcount=2)</span></span><br></pre></td></tr></table></figure>\n\n<p>例2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>();   <span class=\"comment\">// $a       -&gt; zend_array(refcount=1)</span></span><br><span class=\"line\">$b = $a;        <span class=\"comment\">// $a,$b    -&gt;zend_array(refcount=2)</span></span><br><span class=\"line\">$c = $b;        <span class=\"comment\">// $a,$b,$c -&gt; zend_array(refcount=3)</span></span><br><span class=\"line\"><span class=\"keyword\">unset</span>($b);      <span class=\"comment\">// $a,$c    -&gt; zend_array(refcount=2)  $b = IS_UNDEF</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>问: 是所有变量类型会用到引用计数吗?如果不是,那么那些情况不会用到呢?</strong></p>\n<p>不是, 其中不会用到引用计数的情况如下:</p>\n<ul>\n<li>①、没有具体value结构的类型是不会用到的，比如：整型、浮点型、布尔型、NULL，他们的值直接通过zval保存，赋值时采用<u>深拷贝</u>。</li>\n<li>②、interned string：内部字符串，在PHP中写的函数名、类名、变量名、静态字符串等都是这种类型，定义:$a = “hi<del>“;后面的字符串内容是唯一不变的，这些字符串等同于C语言中定义在静态变量区的字符串：char *a = “hi</del>“;，这些字符串的生命周期为request期间，request完成后会统一销毁释放，自然也就无需在运行期间通过引用计数管理内存。<br>（注：<em>内部字符串与普通字符串的类型都是IS_STRING，它们并不是通过type进行区分的，而是通过zend_refcount_h.u.v.flag区分，内部字符串的flag值将包含IS_STR_INTERNED</em>）</li>\n<li>③、immutable array：不可变数组，只有在用opcache的时候才会用到这种类型，不清楚具体实现，暂时忽略。</li>\n</ul>\n<p>除了以上几种情况, 其余类型将会用到引用计数。</p>\n<p><strong>问: PHP内核是怎样区分value是否支持引用计数的呢?</strong></p>\n<p>使用<code>zval.u1</code>中的类型掩码<code>type_flag</code>字段， 这个字段除了标识value是否支持引用计数外还有其它几个标识位，按位分割<br><em>注：type_flag与zval.value-&gt;gc.u.flag不是一个值。</em></p>\n<p>支持引用计数的value类型是<code>zval.u1.type_flag &amp; IS_TYPE_REFCOUNTED</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_REFCOUNTED = 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TYPE_REFCOUNTED          (1&lt;&lt;2)</span></span><br></pre></td></tr></table></figure>\n\n<p>下列类型会使用引用计数机制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|     type       | refcounted |</span><br><span class=\"line\">+----------------+------------+</span><br><span class=\"line\">|simple types    |            |</span><br><span class=\"line\">|string          |      Y     |</span><br><span class=\"line\">|interned string |            |</span><br><span class=\"line\">|array           |      Y     |</span><br><span class=\"line\">|immutable array |            |</span><br><span class=\"line\">|object          |      Y     |</span><br><span class=\"line\">|resource        |      Y     |</span><br><span class=\"line\">|reference       |      Y     |</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3-写时复制\"><a href=\"#3-写时复制\" class=\"headerlink\" title=\"3 写时复制\"></a>3 写时复制</h5><p>写时复制机制，它只有在必要的时候（即发生写的时候）才会进行深拷贝，可以很好地提升效率。</p>\n<p>具体过程：<u>变量使用了引用计数，当出现其中一个变量修改value的情况，这个时候就需要对value进行分离，发生改变的变量恢复至一份数据出来进行修改，同时断开原来value的指向，指向新的value。</u></p>\n<p>例1：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发生分离</span></span><br><span class=\"line\">$b[] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/F0B25584D691443AB81AB2C8EA60C941?method=download&shareKey=98bf888bb661490664329007cb8b939c&ynotemdtimestamp=1598325595262\" alt=\"zval_sep\"></p>\n<p>例2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发生分离</span></span><br><span class=\"line\">$c[] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/4CDEAFB9332D4EEE9443D527A09934BF?method=download&shareKey=26b4c24edc932c27e427583bc422d2e3&ynotemdtimestamp=1598325595262\" alt=\"a、b、c发生写时复制的过程\"></p>\n<p>注：不是所有类型都可以copy的，比如<u>对象、资源就无法进行复制，也就是无法进行分离，如果多个变量指向同一个对象，当其中一个变量修改对象时，其修改将反映到所有变量上</u>。事实上<strong>只有string、array两种支持value的分离</strong>，与引用计数相同，也是通过<code>zval.u1.type_flag</code>标识value是否可复制的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_COPYABLE = 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TYPE_COPYABLE         (1&lt;&lt;4)</span></span><br><span class=\"line\">|     type       |  copyable  |</span><br><span class=\"line\">+----------------+------------+</span><br><span class=\"line\">|simple types    |            |</span><br><span class=\"line\">|<span class=\"built_in\">string</span>          |      Y     |</span><br><span class=\"line\">|interned <span class=\"built_in\">string</span> |            |</span><br><span class=\"line\">|<span class=\"built_in\">array</span>           |      Y     |</span><br><span class=\"line\">|immutable <span class=\"built_in\">array</span> |            |</span><br><span class=\"line\">|object          |            |</span><br><span class=\"line\">|resource        |            |</span><br><span class=\"line\">|reference       |            |</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"4-变量回收\"><a href=\"#4-变量回收\" class=\"headerlink\" title=\"4 变量回收\"></a>4 变量回收</h5><p>PHP变量回收方式：</p>\n<ul>\n<li>主动销毁：指的就是 unset。</li>\n<li>自动销毁：指PHP的自动管理机制（GC机制).<ul>\n<li>在return时减掉局部变量的refcount，即使没有显式的return，PHP也会自动给加上这个操作;</li>\n<li>写时复制时也会断开原来value的指向，这时候也会检查断开后旧value的refcount。</li>\n</ul>\n</li>\n</ul>\n<p>变量回收时机： zval断开value的指向时，若发现refcount=0则会直接释放value。其中发生断开的情况包括：</p>\n<ul>\n<li>修改变量：修改变量时会断开原有value的指向</li>\n<li>函数返回：函数返回时会释放所有的局部变量，也就是把所有局部变量的引用计数减1.</li>\n</ul>\n<h5 id=\"5-垃圾回收\"><a href=\"#5-垃圾回收\" class=\"headerlink\" title=\"5 垃圾回收\"></a>5 垃圾回收</h5><p>PHP用过引用计数实现了变量的自动GC机制，还是会有一种情况GC机制无法解决，从而导致变量无法回首导致内存始终得不到释放，造成内存泄露。</p>\n<p>造成内存泄漏的情况：<u>循环引用</u></p>\n<p><strong>问: 什么是循环引用?</strong><br>循环引用就是变量的内部成员引用了变量自身，比如数组中某个元素指向了数组，这样一来数组的引用计数中就有一个来自自身成员，当所有外部引用断开时，数组的refcount仍然大于0而得不到释放，但实际上这种变量不可能再被使用了。</p>\n<p><strong>垃圾收集器收集的时机</strong>：<u>refcount减少时，即每次refcount减少都会试图收集</u></p>\n<p>示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">$a[] = &amp;$a;</span><br><span class=\"line\"><span class=\"keyword\">unset</span>($a);</span><br></pre></td></tr></table></figure>\n\n<p>unset($a)前，变量a的类型为引用，该引用的refcount=2，一个来自于$a,一个来自于$a[1];示意图如下： <img src=\"https://note.youdao.com/yws/api/personal/file/8C22AE1A04B249948E9ADECA4F6D9865?method=download&shareKey=90e64014943ead9d4294b592037d0484&ynotemdtimestamp=1598325595262\" alt=\"unset($a)前的引用关系\"></p>\n<p>unset($a)后，减少了一次该引用的refcount，此时已经没有任何外部引用了，但是数组中仍然有一个元素指向该引用，如下图所示： <img src=\"https://note.youdao.com/yws/api/personal/file/74E94E6D9F384C0A9E9F44FF5F086CC9?method=download&shareKey=1ef849b379e45a8729679844f572119d&ynotemdtimestamp=1598325595262\" alt=\"unset($a)后的引用关系\"></p>\n<p>这种因为循环引用而导致无法释放的变量称之为垃圾，PHP引入了另一种机制来对这些垃圾进行回收，即<strong>垃圾回收器</strong>。</p>\n<ul>\n<li>若一个变量value的refcount减少到0，那么此vlaue可以被释放掉，不属于垃圾。</li>\n<li>若一个变量value的refcount减少之后大于0，那么此vlaue还不能被释放，此value<u>可能</u>成为一个垃圾。</li>\n</ul>\n<p>垃圾回收器会将可能成为垃圾的value收集起来，等到达一定数量后开始启动垃圾鉴定程序，将真正的垃圾释放掉。</p>\n<p><strong>当前垃圾只会出现在array、object两种类型中</strong></p>\n<ul>\n<li>array：数组中的某个成员指向了数组</li>\n<li>object：对象的成员属性引用对象本身</li>\n</ul>\n<p><strong>问：垃圾回收器怎样判断当前类型是否可回收？</strong> </p>\n<p>垃圾回收器不是通过变量类型进行判断的，而是通过<code>zval.u1.type_flag</code>标识进行判断，只有包含<code>IS_TYPE_COLLECTABLE</code>标识的变量类型才会被收集。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_COLLECTABLE = 8</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> IS_TYPE_COLLECTABLE  (1&lt;&lt;3)</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"5-1-回收算法\"><a href=\"#5-1-回收算法\" class=\"headerlink\" title=\"5.1 回收算法\"></a>5.1 回收算法</h6><p>垃圾回收器把收集到的可能垃圾保存到一个buffer缓冲区中，当到达一定数量后就会启动垃圾鉴定、回收程序。<br>回收算法的原理：<u>既然垃圾是由于成员引用自身导致的，那么就对value的所有成员减一遍引用计数，如果发现value本身refcount变为了0，则表明引用全部来自自身成员。</u></p>\n<h6 id=\"5-2-具体实现\"><a href=\"#5-2-具体实现\" class=\"headerlink\" title=\"5.2 具体实现\"></a>5.2 具体实现</h6><p>垃圾回收器主要通过<code>zend_gc_globals</code>这个这结构对垃圾进行管理，收集到的可能成为垃圾的vlaue就保存在这个结构的buf中，即<code>垃圾缓冲区</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_gc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_gc_globals</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 是否启用gc（php.ini中zend.enable_gc设置是否开启，默认是开启的）</span></span><br><span class=\"line\">\tzend_bool         gc_enabled;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否在垃圾检查过程中</span></span><br><span class=\"line\">\tzend_bool         gc_active;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存区是否已满</span></span><br><span class=\"line\">\tzend_bool         gc_full;</span><br><span class=\"line\">    <span class=\"comment\">// 启动时分配的用于保存可能垃圾的缓存区(初始化时，一次性分配了10001个gc_root_buffer,其中第一个被保留)</span></span><br><span class=\"line\">\tgc_root_buffer   *buf;\t\t\t\t<span class=\"comment\">/* preallocated arrays of buffers   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf中最新加入的一个可能垃圾（root是一个双向链表的头部）</span></span><br><span class=\"line\">\tgc_root_buffer    roots;\t\t\t<span class=\"comment\">/* list of possible roots of cycles */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向bug中没有使用的buffer（用于管理buf中开始加入后面又删除的结点，是一个单链表）</span></span><br><span class=\"line\">\tgc_root_buffer   *unused;\t\t\t<span class=\"comment\">/* list of unused buffers           */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf中第一个没有使用的buffer</span></span><br><span class=\"line\">\tgc_root_buffer   *first_unused;\t\t<span class=\"comment\">/* pointer to first unused buffer   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf尾部</span></span><br><span class=\"line\">\tgc_root_buffer   *last_unused;\t\t<span class=\"comment\">/* pointer to last unused buffer    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 待释放的垃圾</span></span><br><span class=\"line\">\tgc_root_buffer    to_free;\t\t\t<span class=\"comment\">/* list to free                     */</span></span><br><span class=\"line\">\tgc_root_buffer   *next_to_free;</span><br><span class=\"line\">    <span class=\"comment\">// 统计gc运行次数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> gc_runs;</span><br><span class=\"line\">\t<span class=\"comment\">// 统计已回收的垃圾数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> collected;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> GC_BENCH</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> root_buf_length;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> root_buf_peak;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_possible_root;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_buffered;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_remove_from_buffer;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_marked_grey;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tgc_additional_buffer *additional_buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; zend_gc_globals;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>buf用于保存收集到的value，他是一个数组，在垃圾回收器初始化时一次性分配了10001个gc_root_buffer，其中第一个buffer被保留，插入vlaue时直接取出可用结点即可。</li>\n<li>roots指向buf中最新加入的一个结点，root是一个双向链表的头部，之所以是一个双向链表，是因为bug数组中保存的只是有可能成为垃圾的vlaue吗，其中有些value在加入之后又被删除了，这样bug数组中就会出现一些空隙。</li>\n<li>first_unused一开始指向bug的第一个位置，有些元素插入roots时如果first_unused还没有到达buf尾部，则返回first_unused给最新的元素，然后执行first_unused++,直到last_unused.</li>\n</ul>\n<p>下图为已经加入了2个gc的结构： <img src=\"https://note.youdao.com/yws/api/personal/file/0A2236A0CF6442A0BB985383709DB5B7?method=download&shareKey=6656570e92c3731c6f1ce8572522a2d0&ynotemdtimestamp=1598325595262\" alt=\"buf缓冲区的可用节点\"></p>\n<ul>\n<li>unused成员，他的含义与first_unused类似，用来管理buf中开始加入后面又删除的结点，是一个单链表结构。也就是说first_unused是一直往后偏移的，直到buf的结尾，buf中间由于value删除而重新空闲的结点则由unused串起来。下次有新的value插入roots时优先使用unused的这些节点，其次才是first_unused的结点。</li>\n</ul>\n<p>下图为移除了buf[1]的结构： <img src=\"https://note.youdao.com/yws/api/personal/file/B788660EE8EE43DDB952F0DC408264B7?method=download&shareKey=3896ffff3a8a0ab653a5c4fd197426da&ynotemdtimestamp=1598325595262\" alt=\"buf[1]移除缓存去后的可用结点\"></p>\n<ul>\n<li>第一步，初始化 gc_init()初始化垃圾回收器：分配buf数组内存、设置first_unused/unused等</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">gc_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_G(buf) == <span class=\"literal\">NULL</span> &amp;&amp; GC_G(gc_enabled)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 分配buf缓冲区内存，大小为GC_ROOT_BUFFER_MAX_ENTERIES(10001),其中第1个保留不被使用。</span></span><br><span class=\"line\">\t\tGC_G(buf) = (gc_root_buffer*) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);</span><br><span class=\"line\">\t\tGC_G(last_unused) = &amp;GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];</span><br><span class=\"line\">\t\t<span class=\"comment\">// 进行GC_G的初始化，其中：GC_G(first_unused) = GC_G(buf) + 1;从第二个开始，保留第一个。</span></span><br><span class=\"line\">\t\tgc_reset();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二步，垃圾回收，在Zend执行过程中如果销毁一个变量就会判断是否需要加入垃圾收集器。销毁一个zval会调用i_zval_ptr_dtor()进行处理。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_variables.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> <span class=\"title\">i_zval_ptr_dtor</span><span class=\"params\">(zval *zval_ptr ZEND_FILE_LINE_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不使用引用计数的类型不需要进行回收（整型、浮点型、布尔型，null）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Z_REFCOUNTED_P(zval_ptr)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// refcount减一</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!Z_DELREF_P(zval_ptr)) &#123;</span><br><span class=\"line\">\t\t    <span class=\"comment\">// refcount减一后变为0，不是垃圾，正常回收</span></span><br><span class=\"line\">\t\t\t_zval_dtor_func_for_ptr(Z_COUNTED_P(zval_ptr) ZEND_FILE_LINE_RELAY_CC);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t    <span class=\"comment\">// refcount减一后仍然大于0，表示该变量可能是一个垃圾，被垃圾回收器回收。</span></span><br><span class=\"line\">\t\t\tGC_ZVAL_CHECK_POSSIBLE_ROOT(zval_ptr);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// file:zend_gc.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_ZVAL_CHECK_POSSIBLE_ROOT(z) \\</span></span><br><span class=\"line\">\tgc_check_possible_root((z))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> <span class=\"title\">gc_check_possible_root</span><span class=\"params\">(zval *z)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tZVAL_DEREF(z);</span><br><span class=\"line\">\t<span class=\"comment\">// 判断是否是可收集（检查变量类型掩码zval.u1.type_flag是否包含IS_TYPE_COLLECTABLE,即数组、对象）以及是否已经收集过了（通过zend_refcount_h.v.u.gc_info来判断，第一次收集后会把这个值设置为GC_PURPLE来避免重复收集）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Z_COLLECTABLE_P(z) &amp;&amp; UNEXPECTED(!Z_GC_INFO_P(z))) &#123;</span><br><span class=\"line\">\t\tgc_possible_root(Z_COUNTED_P(z));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>收集时首先会从buf中选择一个空闲节点，然后将vlaue的gc保存到这个结点中，若没有空闲节点则表明回收器已经满了，这个时候就会触发垃圾鉴定、回收程序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.c</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">gc_possible_root</span><span class=\"params\">(zend_refcounted *ref)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgc_root_buffer *newRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(CG(unclean_shutdown)) || UNEXPECTED(GC_G(gc_active))) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tZEND_ASSERT(GC_TYPE(ref) == IS_ARRAY || GC_TYPE(ref) == IS_OBJECT);</span><br><span class=\"line\">\t<span class=\"comment\">// 插入的结点必须是GC_BLACK,防止重复插入</span></span><br><span class=\"line\">\tZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(ref) == GC_BLACK));</span><br><span class=\"line\">\tZEND_ASSERT(!GC_ADDRESS(GC_INFO(ref)));</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_possible_root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 首先看一下unused中又没有可用的。</span></span><br><span class=\"line\">\tnewRoot = GC_G(unused);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newRoot) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 有的话先用unused的，然后将GC_G(unused)指向单链表的下一个</span></span><br><span class=\"line\">\t\tGC_G(unused) = newRoot-&gt;prev;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (GC_G(first_unused) != GC_G(last_unused)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// unused没有可用的，且bug中还有可用</span></span><br><span class=\"line\">\t\tnewRoot = GC_G(first_unused);</span><br><span class=\"line\">\t\tGC_G(first_unused)++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// buf缓存区已满，这时需要启动垃圾鉴定、回收程序。</span></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将插入的red标位紫色，防止重复插入</span></span><br><span class=\"line\">\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);</span><br><span class=\"line\">\t<span class=\"comment\">// 将该节点在buf中的位置保存到gc_info中，目的在于当后续value的refcount变为了0，需要将其从buf中删除时可以知道该value保存在那个gc_root_buffer中，如果没有这个信息，在删除vlaue时无法获取gc_root_buffer的位置。</span></span><br><span class=\"line\">\tGC_INFO(ref) = (newRoot - GC_G(buf)) | GC_PURPLE;</span><br><span class=\"line\">\tnewRoot-&gt;ref = ref;</span><br><span class=\"line\">    <span class=\"comment\">// 插入roots链表头部</span></span><br><span class=\"line\">\tnewRoot-&gt;next = GC_G(roots).next;</span><br><span class=\"line\">\tnewRoot-&gt;prev = &amp;GC_G(roots);</span><br><span class=\"line\">\tGC_G(roots).next-&gt;prev = newRoot;</span><br><span class=\"line\">\tGC_G(roots).next = newRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_buffered);</span><br><span class=\"line\">\tGC_BENCH_INC(root_buf_length);</span><br><span class=\"line\">\tGC_BENCH_PEAK(root_buf_peak, root_buf_length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第三步，删除 删除的操作通过GC_REMOVE_FROM_BUFFER()完成。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_REMOVE_FROM_BUFFER(p) do &#123; \\</span></span><br><span class=\"line\">\t\tzend_refcounted *_p = (zend_refcounted*)(p); \\</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (GC_ADDRESS(GC_INFO(_p))) &#123; \\</span><br><span class=\"line\">\t\t\tgc_remove_from_buffer(_p); \\</span><br><span class=\"line\">\t\t&#125; \\</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_ADDRESS(v) \\</span></span><br><span class=\"line\">\t((v) &amp; ~GC_COLOR)</span><br></pre></td></tr></table></figure>\n\n<p>删除时，先根据gc_info取到gc_root_buffer，然后再从buf中移除，删除后再把空的gc_root_buffer插入到unused单链表尾部。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.c</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">gc_remove_from_buffer</span><span class=\"params\">(zend_refcounted *ref)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgc_root_buffer *root;</span><br><span class=\"line\"></span><br><span class=\"line\">\tZEND_ASSERT(GC_ADDRESS(GC_INFO(ref)));</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_remove_from_buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (EXPECTED(GC_ADDRESS(GC_INFO(ref)) &lt; GC_ROOT_BUFFER_MAX_ENTRIES)) &#123;</span><br><span class=\"line\">\t\troot = GC_G(buf) + GC_ADDRESS(GC_INFO(ref));</span><br><span class=\"line\">\t\tgc_remove_from_roots(root);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\troot = gc_find_additional_buffer(ref);</span><br><span class=\"line\">\t\tgc_remove_from_additional_roots(root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_REF_GET_COLOR(ref) != GC_BLACK) &#123;</span><br><span class=\"line\">\t\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tGC_INFO(ref) = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* updete next root that is going to be freed */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_G(next_to_free) == root) &#123;</span><br><span class=\"line\">\t\tGC_G(next_to_free) = root-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当buf缓存区满了执行垃圾回收的过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">int</span> <span class=\"title\">zend_gc_collect_cycles</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t    ...</span><br><span class=\"line\">\t    <span class=\"comment\">// (1)遍历roots链表，对当前结点vlaue的所有成员（如数组元素、成员变量）进行深度优先遍历，把成员refcount减1.</span></span><br><span class=\"line\">\t\tgc_mark_roots();</span><br><span class=\"line\">\t\tGC_TRACE(<span class=\"string\">&quot;Scanning roots&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// (2)再次遍历roots链表，检查各结点当前refcount是否为0，是的话标为white，表示是垃圾，不是的话需要还原（1），吧refcount再加回去</span></span><br><span class=\"line\">\t\tgc_scan_roots();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_GC_DEBUG</span></span><br><span class=\"line\">\t\torig_gc_full = GC_G(gc_full);</span><br><span class=\"line\">\t\tGC_G(gc_full) = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tGC_TRACE(<span class=\"string\">&quot;Collecting roots&quot;</span>);</span><br><span class=\"line\">\t\tadditional_buffer_snapshot = GC_G(additional_buffer);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将roots链表中的非白色结点删除，之后roots链表中全部是真正的垃圾，将垃圾链表转到to_free等待释放</span></span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t  ...</span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 释放垃圾</span></span><br><span class=\"line\">\t\tcurrent = to_free.next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (current != &amp;to_free) &#123;</span><br><span class=\"line\">\t\t\tnext = current-&gt;next;</span><br><span class=\"line\">\t\t\tp = current-&gt;ref;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (EXPECTED(current &gt;= GC_G(buf) &amp;&amp; current &lt; GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) &#123;</span><br><span class=\"line\">\t\t\t\tcurrent-&gt;prev = GC_G(unused);</span><br><span class=\"line\">\t\t\t\tGC_G(unused) = current;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tefree(p);</span><br><span class=\"line\">\t\t\tcurrent = next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h5 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h5><p>C/C++语言中，如果想在<code>堆</code>上分配变量，需要手动进行内存的分配与释放，变量的内存管理是见非常繁琐的事，稍有不慎就可能导致不可域值的错误。 PHP实现了自动GC机制，由语言自行管理。PHP中的变量是不需要手动释放的，内核帮我们实现了变量的内存管理，包括内存的分配与回收。</p>","more":"<p><strong>自动GC最简单的实现方式</strong>：在函数中定义变量时分配一块内存，用于保存zval及对应的value结构，在函数返回时再将内存释放，若函数执行期间改变来凝固作为参数调用了其他函数或复制给了其他变量，则把变量复制一份，变量之间相互独立，不会出现冲突。<br>（<u>问题：深拷贝可能造成内存浪费，比如定义一个变量赋值给另一个变量，后面是只读操作的情况</u>）</p>\n<p><strong>解决方式（PHP采用此种方式）:</strong> <code>引用计数</code>+<code>写时复制</code>。</p>\n<ul>\n<li>当变量赋值、传递时多个变量公用一个value，引用计数用来记录value有多少个变量在使用；</li>\n<li>当变量的value发生改变时，进行深拷贝。</li>\n</ul>\n<p>注：long、double类型是使用的硬拷贝。</p>\n<h5 id=\"2-引用计数\"><a href=\"#2-引用计数\" class=\"headerlink\" title=\"2 引用计数\"></a>2 引用计数</h5><p>引用计数用来记录当前有多少<code>zval</code>指向同一个<code>zend_value</code>.<br>引用计数：<u>指在value中增加一个字段refcount记录指向当前value的数量，变量复制、函数传参时并不直接硬拷贝一份value数据，而是将refcount++，变量销毁时将refcount–，等到refcount减为0时表示已经没有变量引用这个value，将它销毁即可。</u></p>\n<p><strong>PHP7中将变量的引用计数保存在zend_value中</strong>（与之前版本不同）</p>\n<p>之前变量中不同类型的结构体中都有一个相同的成员：gc，该结构用于保存引用计数的,其定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_type.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_refcounted_h</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span>         refcount;\t\t\t<span class=\"comment\">/* reference counter 32-bit */</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\tZEND_ENDIAN_LOHI_3(</span><br><span class=\"line\">\t\t\t    <span class=\"comment\">// 类型</span></span><br><span class=\"line\">\t\t\t\tzend_uchar    type,</span><br><span class=\"line\">\t\t\t\tzend_uchar    flags,    <span class=\"comment\">/* used for strings &amp; objects */</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 垃圾回收时用到</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">uint16_t</span>      gc_info)  <span class=\"comment\">/* keeps GC root number (or 0) and color */</span></span><br><span class=\"line\">\t\t&#125; v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> type_info;</span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">&#125; zend_refcounted_h;</span><br></pre></td></tr></table></figure>\n\n<p>例1：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"string\">&quot;time:&quot;</span> . time();   <span class=\"comment\">//$a       -&gt;  zend_string_1(refcount=1)</span></span><br><span class=\"line\">$b = $a;                 <span class=\"comment\">//$a,$b    -&gt;  zend_string_1(refcount=2)</span></span><br><span class=\"line\">$c = $b;                 <span class=\"comment\">//$a,$b,$c -&gt;  zend_string_1(refcount=3)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unset</span>($b);               <span class=\"comment\">//$b = IS_UNDEF  $a,$c -&gt;  zend_string_1(refcount=2)</span></span><br></pre></td></tr></table></figure>\n\n<p>例2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>();   <span class=\"comment\">// $a       -&gt; zend_array(refcount=1)</span></span><br><span class=\"line\">$b = $a;        <span class=\"comment\">// $a,$b    -&gt;zend_array(refcount=2)</span></span><br><span class=\"line\">$c = $b;        <span class=\"comment\">// $a,$b,$c -&gt; zend_array(refcount=3)</span></span><br><span class=\"line\"><span class=\"keyword\">unset</span>($b);      <span class=\"comment\">// $a,$c    -&gt; zend_array(refcount=2)  $b = IS_UNDEF</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>问: 是所有变量类型会用到引用计数吗?如果不是,那么那些情况不会用到呢?</strong></p>\n<p>不是, 其中不会用到引用计数的情况如下:</p>\n<ul>\n<li>①、没有具体value结构的类型是不会用到的，比如：整型、浮点型、布尔型、NULL，他们的值直接通过zval保存，赋值时采用<u>深拷贝</u>。</li>\n<li>②、interned string：内部字符串，在PHP中写的函数名、类名、变量名、静态字符串等都是这种类型，定义:$a = “hi<del>“;后面的字符串内容是唯一不变的，这些字符串等同于C语言中定义在静态变量区的字符串：char *a = “hi</del>“;，这些字符串的生命周期为request期间，request完成后会统一销毁释放，自然也就无需在运行期间通过引用计数管理内存。<br>（注：<em>内部字符串与普通字符串的类型都是IS_STRING，它们并不是通过type进行区分的，而是通过zend_refcount_h.u.v.flag区分，内部字符串的flag值将包含IS_STR_INTERNED</em>）</li>\n<li>③、immutable array：不可变数组，只有在用opcache的时候才会用到这种类型，不清楚具体实现，暂时忽略。</li>\n</ul>\n<p>除了以上几种情况, 其余类型将会用到引用计数。</p>\n<p><strong>问: PHP内核是怎样区分value是否支持引用计数的呢?</strong></p>\n<p>使用<code>zval.u1</code>中的类型掩码<code>type_flag</code>字段， 这个字段除了标识value是否支持引用计数外还有其它几个标识位，按位分割<br><em>注：type_flag与zval.value-&gt;gc.u.flag不是一个值。</em></p>\n<p>支持引用计数的value类型是<code>zval.u1.type_flag &amp; IS_TYPE_REFCOUNTED</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_REFCOUNTED = 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TYPE_REFCOUNTED          (1&lt;&lt;2)</span></span><br></pre></td></tr></table></figure>\n\n<p>下列类型会使用引用计数机制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|     type       | refcounted |</span><br><span class=\"line\">+----------------+------------+</span><br><span class=\"line\">|simple types    |            |</span><br><span class=\"line\">|string          |      Y     |</span><br><span class=\"line\">|interned string |            |</span><br><span class=\"line\">|array           |      Y     |</span><br><span class=\"line\">|immutable array |            |</span><br><span class=\"line\">|object          |      Y     |</span><br><span class=\"line\">|resource        |      Y     |</span><br><span class=\"line\">|reference       |      Y     |</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"3-写时复制\"><a href=\"#3-写时复制\" class=\"headerlink\" title=\"3 写时复制\"></a>3 写时复制</h5><p>写时复制机制，它只有在必要的时候（即发生写的时候）才会进行深拷贝，可以很好地提升效率。</p>\n<p>具体过程：<u>变量使用了引用计数，当出现其中一个变量修改value的情况，这个时候就需要对value进行分离，发生改变的变量恢复至一份数据出来进行修改，同时断开原来value的指向，指向新的value。</u></p>\n<p>例1：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发生分离</span></span><br><span class=\"line\">$b[] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/F0B25584D691443AB81AB2C8EA60C941?method=download&shareKey=98bf888bb661490664329007cb8b939c&ynotemdtimestamp=1598325595262\" alt=\"zval_sep\"></p>\n<p>例2：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发生分离</span></span><br><span class=\"line\">$c[] = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/4CDEAFB9332D4EEE9443D527A09934BF?method=download&shareKey=26b4c24edc932c27e427583bc422d2e3&ynotemdtimestamp=1598325595262\" alt=\"a、b、c发生写时复制的过程\"></p>\n<p>注：不是所有类型都可以copy的，比如<u>对象、资源就无法进行复制，也就是无法进行分离，如果多个变量指向同一个对象，当其中一个变量修改对象时，其修改将反映到所有变量上</u>。事实上<strong>只有string、array两种支持value的分离</strong>，与引用计数相同，也是通过<code>zval.u1.type_flag</code>标识value是否可复制的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_COPYABLE = 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TYPE_COPYABLE         (1&lt;&lt;4)</span></span><br><span class=\"line\">|     type       |  copyable  |</span><br><span class=\"line\">+----------------+------------+</span><br><span class=\"line\">|simple types    |            |</span><br><span class=\"line\">|<span class=\"built_in\">string</span>          |      Y     |</span><br><span class=\"line\">|interned <span class=\"built_in\">string</span> |            |</span><br><span class=\"line\">|<span class=\"built_in\">array</span>           |      Y     |</span><br><span class=\"line\">|immutable <span class=\"built_in\">array</span> |            |</span><br><span class=\"line\">|object          |            |</span><br><span class=\"line\">|resource        |            |</span><br><span class=\"line\">|reference       |            |</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"4-变量回收\"><a href=\"#4-变量回收\" class=\"headerlink\" title=\"4 变量回收\"></a>4 变量回收</h5><p>PHP变量回收方式：</p>\n<ul>\n<li>主动销毁：指的就是 unset。</li>\n<li>自动销毁：指PHP的自动管理机制（GC机制).<ul>\n<li>在return时减掉局部变量的refcount，即使没有显式的return，PHP也会自动给加上这个操作;</li>\n<li>写时复制时也会断开原来value的指向，这时候也会检查断开后旧value的refcount。</li>\n</ul>\n</li>\n</ul>\n<p>变量回收时机： zval断开value的指向时，若发现refcount=0则会直接释放value。其中发生断开的情况包括：</p>\n<ul>\n<li>修改变量：修改变量时会断开原有value的指向</li>\n<li>函数返回：函数返回时会释放所有的局部变量，也就是把所有局部变量的引用计数减1.</li>\n</ul>\n<h5 id=\"5-垃圾回收\"><a href=\"#5-垃圾回收\" class=\"headerlink\" title=\"5 垃圾回收\"></a>5 垃圾回收</h5><p>PHP用过引用计数实现了变量的自动GC机制，还是会有一种情况GC机制无法解决，从而导致变量无法回首导致内存始终得不到释放，造成内存泄露。</p>\n<p>造成内存泄漏的情况：<u>循环引用</u></p>\n<p><strong>问: 什么是循环引用?</strong><br>循环引用就是变量的内部成员引用了变量自身，比如数组中某个元素指向了数组，这样一来数组的引用计数中就有一个来自自身成员，当所有外部引用断开时，数组的refcount仍然大于0而得不到释放，但实际上这种变量不可能再被使用了。</p>\n<p><strong>垃圾收集器收集的时机</strong>：<u>refcount减少时，即每次refcount减少都会试图收集</u></p>\n<p>示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">$a[] = &amp;$a;</span><br><span class=\"line\"><span class=\"keyword\">unset</span>($a);</span><br></pre></td></tr></table></figure>\n\n<p>unset($a)前，变量a的类型为引用，该引用的refcount=2，一个来自于$a,一个来自于$a[1];示意图如下： <img src=\"https://note.youdao.com/yws/api/personal/file/8C22AE1A04B249948E9ADECA4F6D9865?method=download&shareKey=90e64014943ead9d4294b592037d0484&ynotemdtimestamp=1598325595262\" alt=\"unset($a)前的引用关系\"></p>\n<p>unset($a)后，减少了一次该引用的refcount，此时已经没有任何外部引用了，但是数组中仍然有一个元素指向该引用，如下图所示： <img src=\"https://note.youdao.com/yws/api/personal/file/74E94E6D9F384C0A9E9F44FF5F086CC9?method=download&shareKey=1ef849b379e45a8729679844f572119d&ynotemdtimestamp=1598325595262\" alt=\"unset($a)后的引用关系\"></p>\n<p>这种因为循环引用而导致无法释放的变量称之为垃圾，PHP引入了另一种机制来对这些垃圾进行回收，即<strong>垃圾回收器</strong>。</p>\n<ul>\n<li>若一个变量value的refcount减少到0，那么此vlaue可以被释放掉，不属于垃圾。</li>\n<li>若一个变量value的refcount减少之后大于0，那么此vlaue还不能被释放，此value<u>可能</u>成为一个垃圾。</li>\n</ul>\n<p>垃圾回收器会将可能成为垃圾的value收集起来，等到达一定数量后开始启动垃圾鉴定程序，将真正的垃圾释放掉。</p>\n<p><strong>当前垃圾只会出现在array、object两种类型中</strong></p>\n<ul>\n<li>array：数组中的某个成员指向了数组</li>\n<li>object：对象的成员属性引用对象本身</li>\n</ul>\n<p><strong>问：垃圾回收器怎样判断当前类型是否可回收？</strong> </p>\n<p>垃圾回收器不是通过变量类型进行判断的，而是通过<code>zval.u1.type_flag</code>标识进行判断，只有包含<code>IS_TYPE_COLLECTABLE</code>标识的变量类型才会被收集。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IS_TYPE_COLLECTABLE = 8</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> IS_TYPE_COLLECTABLE  (1&lt;&lt;3)</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"5-1-回收算法\"><a href=\"#5-1-回收算法\" class=\"headerlink\" title=\"5.1 回收算法\"></a>5.1 回收算法</h6><p>垃圾回收器把收集到的可能垃圾保存到一个buffer缓冲区中，当到达一定数量后就会启动垃圾鉴定、回收程序。<br>回收算法的原理：<u>既然垃圾是由于成员引用自身导致的，那么就对value的所有成员减一遍引用计数，如果发现value本身refcount变为了0，则表明引用全部来自自身成员。</u></p>\n<h6 id=\"5-2-具体实现\"><a href=\"#5-2-具体实现\" class=\"headerlink\" title=\"5.2 具体实现\"></a>5.2 具体实现</h6><p>垃圾回收器主要通过<code>zend_gc_globals</code>这个这结构对垃圾进行管理，收集到的可能成为垃圾的vlaue就保存在这个结构的buf中，即<code>垃圾缓冲区</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_gc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_gc_globals</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 是否启用gc（php.ini中zend.enable_gc设置是否开启，默认是开启的）</span></span><br><span class=\"line\">\tzend_bool         gc_enabled;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否在垃圾检查过程中</span></span><br><span class=\"line\">\tzend_bool         gc_active;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存区是否已满</span></span><br><span class=\"line\">\tzend_bool         gc_full;</span><br><span class=\"line\">    <span class=\"comment\">// 启动时分配的用于保存可能垃圾的缓存区(初始化时，一次性分配了10001个gc_root_buffer,其中第一个被保留)</span></span><br><span class=\"line\">\tgc_root_buffer   *buf;\t\t\t\t<span class=\"comment\">/* preallocated arrays of buffers   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf中最新加入的一个可能垃圾（root是一个双向链表的头部）</span></span><br><span class=\"line\">\tgc_root_buffer    roots;\t\t\t<span class=\"comment\">/* list of possible roots of cycles */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向bug中没有使用的buffer（用于管理buf中开始加入后面又删除的结点，是一个单链表）</span></span><br><span class=\"line\">\tgc_root_buffer   *unused;\t\t\t<span class=\"comment\">/* list of unused buffers           */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf中第一个没有使用的buffer</span></span><br><span class=\"line\">\tgc_root_buffer   *first_unused;\t\t<span class=\"comment\">/* pointer to first unused buffer   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向buf尾部</span></span><br><span class=\"line\">\tgc_root_buffer   *last_unused;\t\t<span class=\"comment\">/* pointer to last unused buffer    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 待释放的垃圾</span></span><br><span class=\"line\">\tgc_root_buffer    to_free;\t\t\t<span class=\"comment\">/* list to free                     */</span></span><br><span class=\"line\">\tgc_root_buffer   *next_to_free;</span><br><span class=\"line\">    <span class=\"comment\">// 统计gc运行次数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> gc_runs;</span><br><span class=\"line\">\t<span class=\"comment\">// 统计已回收的垃圾数</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> collected;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> GC_BENCH</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> root_buf_length;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> root_buf_peak;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_possible_root;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_buffered;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_remove_from_buffer;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> zval_marked_grey;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tgc_additional_buffer *additional_buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; zend_gc_globals;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>buf用于保存收集到的value，他是一个数组，在垃圾回收器初始化时一次性分配了10001个gc_root_buffer，其中第一个buffer被保留，插入vlaue时直接取出可用结点即可。</li>\n<li>roots指向buf中最新加入的一个结点，root是一个双向链表的头部，之所以是一个双向链表，是因为bug数组中保存的只是有可能成为垃圾的vlaue吗，其中有些value在加入之后又被删除了，这样bug数组中就会出现一些空隙。</li>\n<li>first_unused一开始指向bug的第一个位置，有些元素插入roots时如果first_unused还没有到达buf尾部，则返回first_unused给最新的元素，然后执行first_unused++,直到last_unused.</li>\n</ul>\n<p>下图为已经加入了2个gc的结构： <img src=\"https://note.youdao.com/yws/api/personal/file/0A2236A0CF6442A0BB985383709DB5B7?method=download&shareKey=6656570e92c3731c6f1ce8572522a2d0&ynotemdtimestamp=1598325595262\" alt=\"buf缓冲区的可用节点\"></p>\n<ul>\n<li>unused成员，他的含义与first_unused类似，用来管理buf中开始加入后面又删除的结点，是一个单链表结构。也就是说first_unused是一直往后偏移的，直到buf的结尾，buf中间由于value删除而重新空闲的结点则由unused串起来。下次有新的value插入roots时优先使用unused的这些节点，其次才是first_unused的结点。</li>\n</ul>\n<p>下图为移除了buf[1]的结构： <img src=\"https://note.youdao.com/yws/api/personal/file/B788660EE8EE43DDB952F0DC408264B7?method=download&shareKey=3896ffff3a8a0ab653a5c4fd197426da&ynotemdtimestamp=1598325595262\" alt=\"buf[1]移除缓存去后的可用结点\"></p>\n<ul>\n<li>第一步，初始化 gc_init()初始化垃圾回收器：分配buf数组内存、设置first_unused/unused等</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">gc_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_G(buf) == <span class=\"literal\">NULL</span> &amp;&amp; GC_G(gc_enabled)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 分配buf缓冲区内存，大小为GC_ROOT_BUFFER_MAX_ENTERIES(10001),其中第1个保留不被使用。</span></span><br><span class=\"line\">\t\tGC_G(buf) = (gc_root_buffer*) <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);</span><br><span class=\"line\">\t\tGC_G(last_unused) = &amp;GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];</span><br><span class=\"line\">\t\t<span class=\"comment\">// 进行GC_G的初始化，其中：GC_G(first_unused) = GC_G(buf) + 1;从第二个开始，保留第一个。</span></span><br><span class=\"line\">\t\tgc_reset();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二步，垃圾回收，在Zend执行过程中如果销毁一个变量就会判断是否需要加入垃圾收集器。销毁一个zval会调用i_zval_ptr_dtor()进行处理。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_variables.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> <span class=\"title\">i_zval_ptr_dtor</span><span class=\"params\">(zval *zval_ptr ZEND_FILE_LINE_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不使用引用计数的类型不需要进行回收（整型、浮点型、布尔型，null）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Z_REFCOUNTED_P(zval_ptr)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// refcount减一</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!Z_DELREF_P(zval_ptr)) &#123;</span><br><span class=\"line\">\t\t    <span class=\"comment\">// refcount减一后变为0，不是垃圾，正常回收</span></span><br><span class=\"line\">\t\t\t_zval_dtor_func_for_ptr(Z_COUNTED_P(zval_ptr) ZEND_FILE_LINE_RELAY_CC);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t    <span class=\"comment\">// refcount减一后仍然大于0，表示该变量可能是一个垃圾，被垃圾回收器回收。</span></span><br><span class=\"line\">\t\t\tGC_ZVAL_CHECK_POSSIBLE_ROOT(zval_ptr);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// file:zend_gc.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_ZVAL_CHECK_POSSIBLE_ROOT(z) \\</span></span><br><span class=\"line\">\tgc_check_possible_root((z))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> <span class=\"title\">gc_check_possible_root</span><span class=\"params\">(zval *z)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tZVAL_DEREF(z);</span><br><span class=\"line\">\t<span class=\"comment\">// 判断是否是可收集（检查变量类型掩码zval.u1.type_flag是否包含IS_TYPE_COLLECTABLE,即数组、对象）以及是否已经收集过了（通过zend_refcount_h.v.u.gc_info来判断，第一次收集后会把这个值设置为GC_PURPLE来避免重复收集）</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Z_COLLECTABLE_P(z) &amp;&amp; UNEXPECTED(!Z_GC_INFO_P(z))) &#123;</span><br><span class=\"line\">\t\tgc_possible_root(Z_COUNTED_P(z));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>收集时首先会从buf中选择一个空闲节点，然后将vlaue的gc保存到这个结点中，若没有空闲节点则表明回收器已经满了，这个时候就会触发垃圾鉴定、回收程序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.c</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">gc_possible_root</span><span class=\"params\">(zend_refcounted *ref)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgc_root_buffer *newRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(CG(unclean_shutdown)) || UNEXPECTED(GC_G(gc_active))) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tZEND_ASSERT(GC_TYPE(ref) == IS_ARRAY || GC_TYPE(ref) == IS_OBJECT);</span><br><span class=\"line\">\t<span class=\"comment\">// 插入的结点必须是GC_BLACK,防止重复插入</span></span><br><span class=\"line\">\tZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(ref) == GC_BLACK));</span><br><span class=\"line\">\tZEND_ASSERT(!GC_ADDRESS(GC_INFO(ref)));</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_possible_root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 首先看一下unused中又没有可用的。</span></span><br><span class=\"line\">\tnewRoot = GC_G(unused);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newRoot) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 有的话先用unused的，然后将GC_G(unused)指向单链表的下一个</span></span><br><span class=\"line\">\t\tGC_G(unused) = newRoot-&gt;prev;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (GC_G(first_unused) != GC_G(last_unused)) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// unused没有可用的，且bug中还有可用</span></span><br><span class=\"line\">\t\tnewRoot = GC_G(first_unused);</span><br><span class=\"line\">\t\tGC_G(first_unused)++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// buf缓存区已满，这时需要启动垃圾鉴定、回收程序。</span></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将插入的red标位紫色，防止重复插入</span></span><br><span class=\"line\">\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);</span><br><span class=\"line\">\t<span class=\"comment\">// 将该节点在buf中的位置保存到gc_info中，目的在于当后续value的refcount变为了0，需要将其从buf中删除时可以知道该value保存在那个gc_root_buffer中，如果没有这个信息，在删除vlaue时无法获取gc_root_buffer的位置。</span></span><br><span class=\"line\">\tGC_INFO(ref) = (newRoot - GC_G(buf)) | GC_PURPLE;</span><br><span class=\"line\">\tnewRoot-&gt;ref = ref;</span><br><span class=\"line\">    <span class=\"comment\">// 插入roots链表头部</span></span><br><span class=\"line\">\tnewRoot-&gt;next = GC_G(roots).next;</span><br><span class=\"line\">\tnewRoot-&gt;prev = &amp;GC_G(roots);</span><br><span class=\"line\">\tGC_G(roots).next-&gt;prev = newRoot;</span><br><span class=\"line\">\tGC_G(roots).next = newRoot;</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_buffered);</span><br><span class=\"line\">\tGC_BENCH_INC(root_buf_length);</span><br><span class=\"line\">\tGC_BENCH_PEAK(root_buf_peak, root_buf_length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第三步，删除 删除的操作通过GC_REMOVE_FROM_BUFFER()完成。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_REMOVE_FROM_BUFFER(p) do &#123; \\</span></span><br><span class=\"line\">\t\tzend_refcounted *_p = (zend_refcounted*)(p); \\</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (GC_ADDRESS(GC_INFO(_p))) &#123; \\</span><br><span class=\"line\">\t\t\tgc_remove_from_buffer(_p); \\</span><br><span class=\"line\">\t\t&#125; \\</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GC_ADDRESS(v) \\</span></span><br><span class=\"line\">\t((v) &amp; ~GC_COLOR)</span><br></pre></td></tr></table></figure>\n\n<p>删除时，先根据gc_info取到gc_root_buffer，然后再从buf中移除，删除后再把空的gc_root_buffer插入到unused单链表尾部。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_gc.c</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">gc_remove_from_buffer</span><span class=\"params\">(zend_refcounted *ref)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgc_root_buffer *root;</span><br><span class=\"line\"></span><br><span class=\"line\">\tZEND_ASSERT(GC_ADDRESS(GC_INFO(ref)));</span><br><span class=\"line\"></span><br><span class=\"line\">\tGC_BENCH_INC(zval_remove_from_buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (EXPECTED(GC_ADDRESS(GC_INFO(ref)) &lt; GC_ROOT_BUFFER_MAX_ENTRIES)) &#123;</span><br><span class=\"line\">\t\troot = GC_G(buf) + GC_ADDRESS(GC_INFO(ref));</span><br><span class=\"line\">\t\tgc_remove_from_roots(root);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\troot = gc_find_additional_buffer(ref);</span><br><span class=\"line\">\t\tgc_remove_from_additional_roots(root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_REF_GET_COLOR(ref) != GC_BLACK) &#123;</span><br><span class=\"line\">\t\tGC_TRACE_SET_COLOR(ref, GC_PURPLE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tGC_INFO(ref) = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* updete next root that is going to be freed */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (GC_G(next_to_free) == root) &#123;</span><br><span class=\"line\">\t\tGC_G(next_to_free) = root-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当buf缓存区满了执行垃圾回收的过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">int</span> <span class=\"title\">zend_gc_collect_cycles</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t    ...</span><br><span class=\"line\">\t    <span class=\"comment\">// (1)遍历roots链表，对当前结点vlaue的所有成员（如数组元素、成员变量）进行深度优先遍历，把成员refcount减1.</span></span><br><span class=\"line\">\t\tgc_mark_roots();</span><br><span class=\"line\">\t\tGC_TRACE(<span class=\"string\">&quot;Scanning roots&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// (2)再次遍历roots链表，检查各结点当前refcount是否为0，是的话标为white，表示是垃圾，不是的话需要还原（1），吧refcount再加回去</span></span><br><span class=\"line\">\t\tgc_scan_roots();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_GC_DEBUG</span></span><br><span class=\"line\">\t\torig_gc_full = GC_G(gc_full);</span><br><span class=\"line\">\t\tGC_G(gc_full) = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tGC_TRACE(<span class=\"string\">&quot;Collecting roots&quot;</span>);</span><br><span class=\"line\">\t\tadditional_buffer_snapshot = GC_G(additional_buffer);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将roots链表中的非白色结点删除，之后roots链表中全部是真正的垃圾，将垃圾链表转到to_free等待释放</span></span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t  ...</span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 释放垃圾</span></span><br><span class=\"line\">\t\tcurrent = to_free.next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (current != &amp;to_free) &#123;</span><br><span class=\"line\">\t\t\tnext = current-&gt;next;</span><br><span class=\"line\">\t\t\tp = current-&gt;ref;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (EXPECTED(current &gt;= GC_G(buf) &amp;&amp; current &lt; GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) &#123;</span><br><span class=\"line\">\t\t\t\tcurrent-&gt;prev = GC_G(unused);</span><br><span class=\"line\">\t\t\t\tGC_G(unused) = current;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tefree(p);</span><br><span class=\"line\">\t\t\tcurrent = next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"PHP7内核-内存管理-内存池","date":"2020-08-25T06:29:45.000Z","_content":"\n#### 1 简介\n在C语言中，通常直接使用malloc进行内存的分配，而频繁的分配、释放内存无疑会产生内存碎片，降低系统性能。PHP自己实现了一套内存池（`ZendMM`：`Zend Memery Manager`）用于替换`glibc`的`malloc`、`free`，以解决内存频繁分配、释放的问题。\n\n<!--more-->\n\n内存池技术主要作用：\n- ①、减少内存分配及释放的次数\n- ②、有效控制内存碎片的产生\n\nPHP的内存池的实现参考了`tcmalloc`的设计，`tcmalloc`是`Google`开源的一个非常优秀的内存分配器。\n\n内存池是PHP内核中最底层的内存操作，他是非常独立的一个模块，可以移植到其他C语言应用中去。  \n\n\n\n**内存池定义了三种粒度的内存块**：\n\n- **chunk**：每个chunk的大小为2M\n- **page**：page的大小为4KB，每个chunk被切割为512个page（2048/4）\n- **slot**：一个或若干个page被切割为多个slot\n\n\n\n申请内存时按照不同的申请大小决定具体的分配策略：\n\n- **Huge(chunk)**:申请内存大于2MB，<u>直接调用系统分配</u>，分配若干个chunk.(>2MB)\n- **Large(page)**：申请内~~存大于3092B~~（即page大小的3/4, 4 * 1024 * 3/4 = 3072B）,小于2044KB（即511个page的大小），分配若干个page。(3072B~2044KB)\n- **Small(slot)**:申请内存小于等于3092B(即page大小的3/4)，<u>内存池提前定义好了30种同等大小的内存（8、16、24、32...3072）,它们分配在不同的page上（不同大小的内存可能会分配在多个连续的page），申请内存时直接在对应的page上查找可用的slot</u>。(<3092B)\n\n内存池通过**zend_mm_heap**结构存储内存池的主要信息，比如`大内存链表`、`chunk链表`、`slot各大小内存链表`等。\n```C\n// file:zend_alloc.c\n# define AG(v) (alloc_globals.v)\nstatic zend_alloc_globals alloc_globals;\n\n// file:zend_alloc.h\ntypedef struct _zend_mm_heap zend_mm_heap;\nstruct _zend_mm_heap {\n#if ZEND_MM_CUSTOM\n\tint                use_custom_heap;\n#endif\n#if ZEND_MM_STORAGE\n\tzend_mm_storage   *storage;\n#endif\n#if ZEND_MM_STAT\n    // 当前已使用的内存数\n\tsize_t             size;                    /* current memory usage */\n\t// 内存单次申请的峰值\n\tsize_t             peak;                    /* peak memory usage */\n#endif\n    // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部\n\tzend_mm_free_slot *free_slot[ZEND_MM_BINS]; /* free lists for small sizes */\n\n    ...\n\n    // 大内存链表\n\tzend_mm_huge_list *huge_list;               /* list of huge allocated blocks */\n    // 指向chunk链表头部\n\tzend_mm_chunk     *main_chunk;\n\t// 缓存的chunk链表\n\tzend_mm_chunk     *cached_chunks;\t\t\t/* list of unused chunks */\n\t// 已分配的chunk数\n\tint                chunks_count;\t\t\t/* number of alocated chunks */\n\t// 当前request使用chunk峰值\n\tint                peak_chunks_count;\t\t/* peak number of allocated chunks for current request */\n\t// 缓存的chunk数\n\tint                cached_chunks_count;\t\t/* number of cached chunks */\n\t// chunk使用均值，每次请求结束后会根据peak_chunk_count重新计算：(avg_chunks_count + peak_chunks_count)/2.0\n\tdouble             avg_chunks_count;\t\t/* average number of chunks allocated per request */\n\tint                last_chunks_delete_boundary; /* numer of chunks after last deletion */\n\tint                last_chunks_delete_count;    /* number of deletion over the last boundary */\n    ...\n};\n```\n大内存分配的是若干个chunk，然后通过一个`zend_mm_huge_list结构`进行管理，**大内存之间构成一个单向链表**。\n```c\n// file:zend_alloc.h\ntypedef struct  _zend_mm_huge_list zend_mm_huge_list;\n\nstruct _zend_mm_huge_list {\n\tvoid              *ptr;\n\tsize_t             size;\n\tzend_mm_huge_list *next;\n#if ZEND_DEBUG\n\tzend_mm_debug_info dbg;\n#endif\n};\n```\n![huge_list链表](https://note.youdao.com/yws/api/personal/file/48872B5FBB994E018B73A4AF38B466CE?method=download&shareKey=b96499c0e19a3b8b9803bcfe2f50d9eb)\n\n<u>chunk是内存池向系统申请、释放内存的最小粒度。</u>`chunk`之间构成双向链表，第一个chunk的地址保存于`zend_mm_heap->main_chunk`。\n\n每个chunk的大小为2MB，被切割为512个page，所以每个page的大小为4KB，其中第一个page的内存用于chunk自己的结构体成员，主要记录chunk的一些信息，比如前后chunk的指针，当前chunk上各个page的使用情况等。\n\nchunk的定义结构如下：\n```c\n// file:zend_alloc.c\nstruct _zend_mm_chunk {\n\tzend_mm_heap      *heap;\n\t// 指向下一个chunk\n\tzend_mm_chunk     *next;\n\t// 指向上一个chunk\n\tzend_mm_chunk     *prev;\n\t// 当前chunk的剩余可用page数\n\tint                free_pages;\t\t\t\t/* number of free pages */\n\tint                free_tail;               /* number of free pages at the end of chunk */\n\tint                num;\n\tchar               reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)];\n\t// heap结构，只有主chunk会用到（即第一个chunk）\n\tzend_mm_heap       heap_slot;               /* used only in main chunk */\n\t// 标识各page是否已使用的bitmap，总大小为512bit，对应page总数，每个page占一个bit位。\n\tzend_mm_page_map   free_map;                /* 512 bits or 64 bytes */\n\t// 各page的信息：当前page使用类型（用于large分配还是small）、占用的page数等\n\tzend_mm_page_info  map[ZEND_MM_PAGES];      /* 2 KB = 512 * 4 */\n};\n```\n\n\n\nslot内存是把若干个page按照固定大小分割好的内存块。\n\n**内存池定义了30中大小的slot内存**：8、16、24、32...1792、2048、3072.这些slot的大小是有规律的。\n- ①、最小的slot大小为8byte\n- ②、前8个slot一次递增8byte（0~7递增 8byte）\n- ③、后面每隔4个递增值乘以2（8~11递增16byte、12~15递增32byte、16~19递增64byte、20~23递增128byte、24~27递增256byte、28~30递增512byte）\n\n\n\n每种大小的slot占用的page数不相同的：\n- ①、slot0~15各占1个page\n\n- ②、slot16~29分别占5、3、1、1、5、3、2、2、5、3、7、4、5、3个page；  \n    注：这个值实际也是有规律可循的，其算法为，目的是为了减少内存的碎片。\n    ```\n    page的个数 = 最小公倍数(slot对应的内存大小, page的大小即4096) / 4096\n    ```\n\n    \n    分配各个规格的slot时会按照各这个配置申请对应的数量的page，然后进行分割组成链表。<u>相同大小的slot之间构成单链表</u>。\n```\nstruct _zend_mm_free_slot {\n\tzend_mm_free_slot *next_free_slot;\n};\n```\n\nheap、huge、chunk、page、slot之间的关系如下图所示：\n![heap、huge、chunk、page、slot结构关系](https://note.youdao.com/yws/api/personal/file/A8793900579C4D84A8CCE6E131F70B04?method=download&shareKey=7c1b42213c6357aae7855f4bcc43c78c)\n\n#### 2 内存池的初始化\n初始化过程主要是`分配heap结构`，<u>如果是多线程环境，则会为每一个线程分配一个内存池，线程之间互不影响</u>。\n\n注：<u>`zend_mm_heap`这个结构不是单独分配的，它嵌在`chunk`结构体中（即`heap_slot`成员）</u>。也就是说内存池初始化时是分配了一个chunk结构，`zend_mm_chunk->heap_slot`作为内存池的heap结构，这个chunk也是第一个chunk，即main_chunk,如下图所示：\n![zend_mm_heap结构的分配](https://note.youdao.com/yws/api/personal/file/1598F914D6D043A2928403E3B65280FE?method=download&shareKey=fa722c4892712fb681baea9ac6c93cf8)\n\n**问题：为什么内存时的heap结构要嵌在chunk中而不是单独分配呢？** \n因为每个chunk的第一个page始终是给chunk结构体自己使用的，剩下的511个page才会做内存分配，但是chunk结构体并不需要一个page那么大的内存。也就是说被占用的page会有剩余的空间，因此，为了尽可能利用空间，就将heap结构嵌在了chunk中。\n\n具体的分配过成在zend_mm_init()中实现：\n```c\n// file:zend_alloc.c\nstatic zend_mm_heap *zend_mm_init(void)\n{\n    // 向系统申请2MB大小的chunk\n\tzend_mm_chunk *chunk = (zend_mm_chunk*)zend_mm_chunk_alloc_int(ZEND_MM_CHUNK_SIZE, ZEND_MM_CHUNK_SIZE);\n\tzend_mm_heap *heap;\n\n\tif (UNEXPECTED(chunk == NULL)) {\n#if ZEND_MM_ERROR\n#ifdef _WIN32\n\t\tstderr_last_error(\"Can't initialize heap\");\n#else\n\t\tfprintf(stderr, \"\\nCan't initialize heap: [%d] %s\\n\", errno, strerror(errno));\n#endif\n#endif\n\t\treturn NULL;\n\t}\n\t// heap结构实际数主chunk嵌入的一个结构，后面再分配的chunk的heap_slot不再使用\n\theap = &chunk->heap_slot;\n\tchunk->heap = heap;\n\tchunk->next = chunk;\n\tchunk->prev = chunk;\n\t// 剩余可用page数\n\tchunk->free_pages = ZEND_MM_PAGES - ZEND_MM_FIRST_PAGE;\n\tchunk->free_tail = ZEND_MM_FIRST_PAGE;\n\tchunk->num = 0\n\t// 将第一个page的bit分配标识位设置为1，表示已经被分配、占用\n\tchunk->free_map[0] = (Z_L(1) << ZEND_MM_FIRST_PAGE) - 1;\n\t// 第一个page的类型为ZEND_MM_IS_LRUN,即large内存\n\tchunk->map[0] = ZEND_MM_LRUN(ZEND_MM_FIRST_PAGE);\n\t// 指向主chunk\n\theap->main_chunk = chunk;\n\t// 初始化剩下的一些成员\n\t...\n\t// huge内存链表\n\theap->huge_list = NULL;\n\treturn heap;\n}\n\n```\n\n#### 3 内存的分配\nHuge大内存的分配过程比较简单、而Large与Small内存分配涉及到page的查找操作，过程稍显复杂。\n\n使用`emalloc`申请时，内存池会按照申请内存的大小自动选择那种格内存进行分配，如下图所示：\n![内存的分配流程](https://note.youdao.com/yws/api/personal/file/1C273A1B04A44C379427B94CBE2A42FB?method=download&shareKey=d5059f5c0dafd673a661edf8efe31120)\n\n##### 3.1 Huge分配\nHuge是指超多2MB大小内存的分配，<u>实际分配时将对齐到n个chunk</u>，分配完还会分配一个zend_mm_huge_list结构，用于管理所有的Huge内存。\n```c\nstatic void *zend_mm_alloc_huge(zend_mm_heap *heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n#ifdef ZEND_WIN32\n\t/* On Windows we don't have ability to extend huge blocks in-place.\n\t * We allocate them with 2MB size granularity, to avoid many\n\t * reallocations when they are extended by small pieces\n\t */\n\t // 按页大小重置实际要分配的内存\n\tsize_t new_size = ZEND_MM_ALIGNED_SIZE_EX(size, MAX(REAL_PAGE_SIZE, ZEND_MM_CHUNK_SIZE));\n#else\n\tsize_t new_size = ZEND_MM_ALIGNED_SIZE_EX(size, REAL_PAGE_SIZE);\n#endif\n\tvoid *ptr;\n\n#if ZEND_MM_LIMIT\n    // 如果有内存使用限制，则检查是否已达上限，达到的话进行zend_mm_gc清理后再检查\n\tif (UNEXPECTED(heap->real_size + new_size > heap->limit)) {\n\t\tif (zend_mm_gc(heap) && heap->real_size + new_size <= heap->limit) {\n\t\t\t/* pass */\n\t\t} else if (heap->overflow == 0) {\n#if ZEND_DEBUG\n\t\t\tzend_mm_safe_error(heap, \"Allowed memory size of %zu bytes exhausted at %s:%d (tried to allocate %zu bytes)\", heap->limit, __zend_filename, __zend_lineno, size);\n#else\n\t\t\tzend_mm_safe_error(heap, \"Allowed memory size of %zu bytes exhausted (tried to allocate %zu bytes)\", heap->limit, size);\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n    // 分配chunk()，系统返回的地址是随机的，并不一定是ZEND_MM_CHUNK_ZIZE的整数倍，内存池需要自己移动到对齐的位置，比如：返回地址ptr是2000，而最近的一个对齐地址是2048，内存池会把ptr移动到2048，从这个位置使用。\n\tptr = zend_mm_chunk_alloc(heap, new_size, ZEND_MM_CHUNK_SIZE);\n   \n    ... \n    \n#if ZEND_DEBUG\n    // 将申请的内存通过zend_mm_huge_list插入到链表中\n\tzend_mm_add_huge_block(heap, ptr, new_size, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#else\n\tzend_mm_add_huge_block(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#endif\n    ...\n\treturn ptr;\n}\n```\n除了Huge分配以外，分配chunk内存也是Large、Small内存分配的基础，<u>它是ZendMM向系统申请内存的唯一粒度</u>。\n\n注：*分配chunk时，会将内存地址对齐到chunk的大小2MB（`ZEND_MM_THUNK_SIZE`）。也就是说，分配的chunk地址都是`ZEND_MM_THUNK_SIZE`的整数倍。（**实际上这个对齐并不是由系统简单的完成，而是需要内存池在申请内存后自己进行调整！**）*\n\n\n\n`ZendMM`具体处理对齐的方法是：\n\n- ①、按实际要申请的内存大小申请一次\n    - 若系统分配的地址恰好是ZEND_MM_CHUNK_SIZE的整数倍，则不需要调整，直接返回。\n    - 若系统分配的地址不是ZEND_MM_CHUNK_SIZE的整数倍，则需要使用第②步进行调整。\n- ②、调整方式：\n    - 首先ZendMM会将这块内存释放掉；\n    - 按照“`实际要申请的内存大小 + ZEND_MM_CHUNK_SIZE`”的大小重新申请一块内存，多申请的ZEND_MM_CHUNK大小的内存是用来调整的`，ZendMM`会从系统分配的地址向后偏移到最近一个`ZEND_MM_CHUNK_SIZE的整数倍`位置，调整完之后再把剩余的内存释放掉。\n\n```c\nstatic void *zend_mm_chunk_alloc_int(size_t size, size_t alignment)\n{\n    // 向系统申请size大小的内存\n\tvoid *ptr = zend_mm_mmap(size);\n\n\tif (ptr == NULL) {\n\t\treturn NULL;\n\t} else if (ZEND_MM_ALIGNED_OFFSET(ptr, alignment) == 0) { // 判断申请的内存是都为alignment的整数倍，是的话直接返回\n#ifdef MADV_HUGEPAGE\n\t    madvise(ptr, size, MADV_HUGEPAGE);\n#endif\n\t\treturn ptr;\n\t} else {\n\t    // 申请的内存不是按照alignment对齐的\n\t\tsize_t offset;\n\n\t\t// 将申请的内存释放掉重新申请\n\t\tzend_mm_munmap(ptr, size);\n\t\t// 重新申请一块内存，这里会多申请一块内存，用于截取到alignment的整数倍，可以忽略REAL_PAGE_SIZE\n\t\tptr = zend_mm_mmap(size + alignment - REAL_PAGE_SIZE);\n#ifdef _WIN32\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tzend_mm_munmap(ptr, size + alignment - REAL_PAGE_SIZE);\n\t\tptr = zend_mm_mmap_fixed((void*)((char*)ptr + (alignment - offset)), size);\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tif (offset != 0) {\n\t\t\tzend_mm_munmap(ptr, size);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ptr;\n#else\n        // offset为ptr距离上一个alignment对齐内存位置的大小，注意不能往前移，因为前面的内存都是分配了的。\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tif (offset != 0) {\n\t\t\toffset = alignment - offset;\n\t\t\tzend_mm_munmap(ptr, offset);\n\t\t\t// 偏移ptr，对齐到alignment\n\t\t\tptr = (char*)ptr + offset;\n\t\t\talignment -= offset;\n\t\t}\n\t\tif (alignment > REAL_PAGE_SIZE) {\n\t\t\tzend_mm_munmap((char*)ptr + size, alignment - REAL_PAGE_SIZE);\n\t\t}\n# ifdef MADV_HUGEPAGE\n\t    madvise(ptr, size, MADV_HUGEPAGE);\n# endif\n#endif\n\t\treturn ptr;\n\t}\n}\n```\n\n其中用到了`ZEND_MM_ALIGNED_OFFSET宏`，这个宏的作用是计算按alignment对齐的内存地址距离上一个alignment整数倍内存地址的大小，也就是offset偏移量。\n\n**alignment必须是2的n次方**，比如一段`n*alignment`大小的内存，ptr为其中一个位置，那么就可以通过位运算计算得到ptr在所属alignment内存块中的offset，如下图所示：\n\n```\n#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\\n\t(((size_t)(size)) & ((alignment) - 1))\n```\n![相对对齐值的内存offset](https://note.youdao.com/yws/api/personal/file/9940B8821F1E4B19B2783B68381DFD5C?method=download&shareKey=8e13fe6980c3aa04d6cf3c97f1522b9d)\n\n这个位运算是因为`alignment`为`2^n`（用二进制表示即为第n个位上为1，其余位为0，当alignment-1相当于将除了第n位为0，其余低位全部为1），所以通过alignment取到最低的位置，也就是相对上一个整数倍的alignment的offset，非位运算算式如下，但效率没有位运算高。\n```\noffset = ptr - (ptr/alignment取整 * alignment)\n```\n\n##### 3.2 Large分配\n当申请的内存大于3072B、小于2044KB时，内存池会选择在chunk上查找对应数量的page返回。<u>Large内存申请的粒度是page，也就是分配n页连续的page</u>，所以Large分配的过程就转化为在chunk上查找n页连续可用的page的过程。\n\n```c\nstatic zend_always_inline void *zend_mm_alloc_large(zend_mm_heap *heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n    // 根据size大小计算需要分配多少个page\n\tint pages_count = (int)ZEND_MM_SIZE_TO_NUM(size, ZEND_MM_PAGE_SIZE);\n#if ZEND_DEBUG\n    // 分配page_count个page\n\tvoid *ptr = zend_mm_alloc_pages(heap, pages_count, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#else\n\tvoid *ptr = zend_mm_alloc_pages(heap, pages_count ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#endif\n#if ZEND_MM_STAT\n\tdo {\n\t\tsize_t size = heap->size + pages_count * ZEND_MM_PAGE_SIZE;\n\t\tsize_t peak = MAX(heap->peak, size);\n\t\theap->size = size;\n\t\theap->peak = peak;\n\t} while (0);\n#endif\n\treturn ptr;\n}\n```\n\nchunk结构中有两个成员用于记录page分配信息：\n- **free_map**：类型为`zend_mm_page_map`，实际就是`zend_ulong_free_map[16/8]`，这是一个bitmap，总大小为64byte，也就是512bit，用于记录用当前chunk上512个page是否分配，512个page对应512bit，1表示已分配，0表示未分配。\n![free_map](https://note.youdao.com/yws/api/personal/file/C879457EC2154FAEA678D562C217773B?method=download&shareKey=29d90ba60d479fdeccd33ac88325813a)\n- **map**：这个是一个可容纳512个类型为uint32_t元素的数组，<u>该数组用于记录各page的分配类型及分配的page页数</u>，每个page对应一个数组成员。Large内存、Small内存都会占用page，正是通过这个数组标识改page属于哪个类型（最高两位用于标识page的分配类型）：\n    \n    - Large：01（0x40000000）\n    \n- Small：10（0x80000000）\n    \n      \n    \n      示例：申请12KB的内存，即3个page，内存池分配了page1，2，3，则map[1] = 0x400000000|3,如下图所示：\n      ![page的分配类型及页数](https://note.youdao.com/yws/api/personal/file/474A05B6CB2D401785FA0FAB75FB3E97?method=download&shareKey=a1ce9cdd22022755fffe79243bd1db0e)\n\npage分配时从第一个chunk开始遍历，依次查找各chunk是否有满足要求的page，如果当前chunk没有合适的，则进入下一chunk，如果直到最后都没有找到，则新分配一个chunk。\n<u>分配准则为：申请的page页数要尽可能地填满chunk的空隙</u>，也就是说尽可能的与分配了的page连在一起，避免中间出现page空隙。减少后续分配时的茶之后按次数，提高内存利用率。\n\n最优page的检索过程如下：\n- step1：  \n  首先从第一个page分组（page0~63）开始检查，如果当前分组无空闲page（即free_map[x]=-1）则进入下一分组，知道当前分组有空闲page，然后进入step2.\n- step2：  \n  当前分组有可用page，首先检查当前page分组的bit位，找到第一个空闲page的位置，记做page_num，接着继续向下查找空闲page，知道遇到第一个已经分配的page位置，将最后一个空闲page位置记做`end_page_num`。（*注：查找end_page_num时并不局限在当前page分组内，会向下查找，直到最后一页。其查找做成主要依据free_map*），page_num至end_page_num为找到的可用page，接着判断找到的page页数是否够用：\n  \n    - 不够的情况：将page_num至end_page_num这些page的bit位标为1，也就是已分配，然后回到step1继续检索其他page分组。\n    - 刚好是要申请的页数：直接使用，中断检索。\n    - page页数比申请的页数大，则表示可用，但不一定是最优的，将page_num暂存起来，接着回到step1继续向后找别的空闲page，最后比较选择best_len最小的，即能够最大程度填满page间隔\n\t  ```c\n\t\t\t\t/* find first 0 bit */\n\t\t\t\t // tmp为当前page分组的bit位，i为当前分组第1个page的页码。\n\t\t\t\tpage_num = i + zend_mm_bitset_nts(tmp);\n\t\t\t\t/* reset bits from 0 to \"bit\" */\n\t\t\t\ttmp &= tmp + 1;\n\t\t\t\t/* skip free blocks */\n\t\t\t\t// 快速跳过剩余page全部可用的分组\n\t\t\t\twhile (tmp == 0) {\n\t\t\t\t\ti += ZEND_MM_BITSET_LEN;\n\t\t\t\t\tif (i >= free_tail || i == ZEND_MM_PAGES) {\n\t\t\t\t\t\tlen = ZEND_MM_PAGES - page_num;\n\t\t\t\t\t\tif (len >= pages_count && len < best_len) {\n\t\t\t\t\t\t\tchunk->free_tail = page_num + pages_count;\n\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* set accurate value */\n\t\t\t\t\t\t\tchunk->free_tail = page_num;\n\t\t\t\t\t\t\tif (best > 0) {\n\t\t\t\t\t\t\t\tpage_num = best;\n\t\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto not_found;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 当前分组剩下的page都是可用的，直接跳到下一分组\n\t\t\t\t\ttmp = *(bitset++);\n\t\t\t\t}\n\t\t\t\t/* find first 1 bit */\n\t\t\t\t// 找到第一个已分配page\n\t\t\t\tlen = i + zend_mm_bitset_ntz(tmp) - page_num;\n\t\t\t\tif (len >= pages_count) {\n\t\t\t\t\tif (len == pages_count) {\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t} else if (len < best_len) {\n\t\t\t\t\t\tbest_len = len;\n\t\t\t\t\t\tbest = page_num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* set bits from 0 to \"bit\" */\n\t\t\t\t// 把找到的这些page标为已分配，注：此时tmp已经经过tmp &= tmp + 1处理\n  \t\t\ttmp |= tmp - 1;\n  ```\n示例：当前某个chunk的page分配情况如下图中的A所示，page：0，1，2，6，9，10已经分配占用，接下来要申请2页的page。\n  ![page的查找过程](https://note.youdao.com/yws/api/personal/file/335A8945237E483EAD280F5A26DED219?method=download&shareKey=29b8b43bfeb58653a22ace5a4562f538)\n- step3：\n   最后没找到合适的page页后设置对应page的分配信息，即free_map、map,然后返回找到第一页page的地址\n    ```c\n    found:\n\tif (steps > 2 && pages_count < 8) {\n\t\t/* move chunk into the head of the linked-list */\n\t\tchunk->prev->next = chunk->next;\n\t\tchunk->next->prev = chunk->prev;\n\t\tchunk->next = heap->main_chunk->next;\n\t\tchunk->prev = heap->main_chunk;\n\t\tchunk->prev->next = chunk;\n\t\tchunk->next->prev = chunk;\n\t}\n\t/* mark run as allocated */\n\tchunk->free_pages -= pages_count;\n\tzend_mm_bitset_set_range(chunk->free_map, page_num, pages_count);\n\tchunk->map[page_num] = ZEND_MM_LRUN(pages_count);\n\tif (page_num == chunk->free_tail) {\n\t\tchunk->free_tail = page_num + pages_count;\n\t}\n\treturn ZEND_MM_PAGE_ADDR(chunk, page_num);\n    ```\n   \n##### 3.3 Small分配\nSmall内存在分配时，首先检查申请规格的内存是否已经分配，如果没有分配或者分配的已经用完了，则申请相应页数的page，page的分配过成与Larg分配完全一致，申请到page以后按固定大小将page切割为slot，slot之间构成单链表，链表头部保存至`AG(mm_heap)->free_slot`；如果对应的slot已经分配，则直接返回`AG(mm_heap)->free_slot`。  \n\n示例：16byte、3072byte大小的slot，将分别申请1个、3个page、然后切割为256个16byte的slot，以及4个3072byte的slot，如下图所示：\n![slot[1]与slot[29]链表](https://note.youdao.com/yws/api/personal/file/4345829756E149EEAB1C4DE3928C76AC?method=download&shareKey=c358be1e7b73c1ff04ccac1eb772c992)\n\n#### 4 系统内存分配\n<u>内存池向系统申请内存的最小粒度是chunk</u>，通过mmap()来申请。\n\n#### 5 内存释放\n内存释放主要通过`efree()`来完成，内存池会根据释放的内存地址自动判断属于哪种粒度的内存，从而执行不同的释放逻辑。\n\n\n\n**问：内存池是如何只根据一个地址就判断出改地址属于哪种内存类型的呢？**  \n因为chunk分配时是按照ZEND_MM_CHUNK_SIZE（即2MB）对齐的，也就是chunk的起始内存地址一定是ZEND_MM_CHUNK_SIZE的整数倍，所以可以根据chunk上的任意位置知道chunk的起始位置与所在page。\n\n##### 5.1 Huge内存的释放\n首先，根据释放地址ptr计算该机制相对chunk起始位置的内存偏移量，这个值通过宏ZEND_MM_ALIGNED_OFFSET()的到，通过位运算计算的到。  \n\n示例：ptr = 0x7ffff7c01000，计算的到offset = 4096\n\n```\noffet = ptr & (alignment - 1) = 0x7ffff7c01000 & 0x1fffff = 0x1000 = 4096\n```\n\n<u>Huge内存能够完全使用chunk，也就是Huge内存地址相对chunk的offset一定等于0，而Large、Small内存因为chunk的第1个page被占用了，所以这两种内存的offset不可能为0.</u>\n\n内存池根据offset值判断出释放的内存是否为`Huge类型`，如果是则将占用的chunk释放，同时从AG(mm_heap)->huge_list链表中删除。\n\n##### 5.2 Large内存的释放\n若计算得到的offset不等于0，则表示该地址是Large内存或者Small内存，然后根据offset值进一步计算出属于第几个page   \n<u>计算方法：根据offset除page的大小取整，的到`page_num`，的到`page`页码后就可以从`chunk->map`中获取该`page`的分配类型，知道是何种粒度的内存了。</u>\n\nLarge内存，<u>并不会直接释放物理内存</u>，只是将对应的page的分配信息重新设置为未分配。若释放page后，<u>当前chunk下所有的page都是未分配的，则会释放chunk</u>，释放时优先选择把chunk移到`AG(mm_heap)->cached_chunks`缓存队列中，缓存数达到一定值后就不在继续缓存新加入的chunk，将内存归还系统，便面占用过多的资源。\n（分配chunk时，如果发现cached_chunks中有缓存的chunk,就直接取出使用，不再向系统申请。）\n\n##### 5.3 Small内存的释放\n若待释放的地址为Small内存，则会将释放的slot插入到该规格slot可用链表的头部，如下图所示：\n![释放slot](https://note.youdao.com/yws/api/personal/file/9141601D64BF4D76AF0A211F55A479A2?method=download&shareKey=7df69cd6f617df511be8d5f87c7a58f4)","source":"_posts/PHP7内核-内存管理-内存池.md","raw":"---\ntitle: PHP7内核-内存管理-内存池\ndate: 2020-08-25 14:29:45\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n#### 1 简介\n在C语言中，通常直接使用malloc进行内存的分配，而频繁的分配、释放内存无疑会产生内存碎片，降低系统性能。PHP自己实现了一套内存池（`ZendMM`：`Zend Memery Manager`）用于替换`glibc`的`malloc`、`free`，以解决内存频繁分配、释放的问题。\n\n<!--more-->\n\n内存池技术主要作用：\n- ①、减少内存分配及释放的次数\n- ②、有效控制内存碎片的产生\n\nPHP的内存池的实现参考了`tcmalloc`的设计，`tcmalloc`是`Google`开源的一个非常优秀的内存分配器。\n\n内存池是PHP内核中最底层的内存操作，他是非常独立的一个模块，可以移植到其他C语言应用中去。  \n\n\n\n**内存池定义了三种粒度的内存块**：\n\n- **chunk**：每个chunk的大小为2M\n- **page**：page的大小为4KB，每个chunk被切割为512个page（2048/4）\n- **slot**：一个或若干个page被切割为多个slot\n\n\n\n申请内存时按照不同的申请大小决定具体的分配策略：\n\n- **Huge(chunk)**:申请内存大于2MB，<u>直接调用系统分配</u>，分配若干个chunk.(>2MB)\n- **Large(page)**：申请内~~存大于3092B~~（即page大小的3/4, 4 * 1024 * 3/4 = 3072B）,小于2044KB（即511个page的大小），分配若干个page。(3072B~2044KB)\n- **Small(slot)**:申请内存小于等于3092B(即page大小的3/4)，<u>内存池提前定义好了30种同等大小的内存（8、16、24、32...3072）,它们分配在不同的page上（不同大小的内存可能会分配在多个连续的page），申请内存时直接在对应的page上查找可用的slot</u>。(<3092B)\n\n内存池通过**zend_mm_heap**结构存储内存池的主要信息，比如`大内存链表`、`chunk链表`、`slot各大小内存链表`等。\n```C\n// file:zend_alloc.c\n# define AG(v) (alloc_globals.v)\nstatic zend_alloc_globals alloc_globals;\n\n// file:zend_alloc.h\ntypedef struct _zend_mm_heap zend_mm_heap;\nstruct _zend_mm_heap {\n#if ZEND_MM_CUSTOM\n\tint                use_custom_heap;\n#endif\n#if ZEND_MM_STORAGE\n\tzend_mm_storage   *storage;\n#endif\n#if ZEND_MM_STAT\n    // 当前已使用的内存数\n\tsize_t             size;                    /* current memory usage */\n\t// 内存单次申请的峰值\n\tsize_t             peak;                    /* peak memory usage */\n#endif\n    // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部\n\tzend_mm_free_slot *free_slot[ZEND_MM_BINS]; /* free lists for small sizes */\n\n    ...\n\n    // 大内存链表\n\tzend_mm_huge_list *huge_list;               /* list of huge allocated blocks */\n    // 指向chunk链表头部\n\tzend_mm_chunk     *main_chunk;\n\t// 缓存的chunk链表\n\tzend_mm_chunk     *cached_chunks;\t\t\t/* list of unused chunks */\n\t// 已分配的chunk数\n\tint                chunks_count;\t\t\t/* number of alocated chunks */\n\t// 当前request使用chunk峰值\n\tint                peak_chunks_count;\t\t/* peak number of allocated chunks for current request */\n\t// 缓存的chunk数\n\tint                cached_chunks_count;\t\t/* number of cached chunks */\n\t// chunk使用均值，每次请求结束后会根据peak_chunk_count重新计算：(avg_chunks_count + peak_chunks_count)/2.0\n\tdouble             avg_chunks_count;\t\t/* average number of chunks allocated per request */\n\tint                last_chunks_delete_boundary; /* numer of chunks after last deletion */\n\tint                last_chunks_delete_count;    /* number of deletion over the last boundary */\n    ...\n};\n```\n大内存分配的是若干个chunk，然后通过一个`zend_mm_huge_list结构`进行管理，**大内存之间构成一个单向链表**。\n```c\n// file:zend_alloc.h\ntypedef struct  _zend_mm_huge_list zend_mm_huge_list;\n\nstruct _zend_mm_huge_list {\n\tvoid              *ptr;\n\tsize_t             size;\n\tzend_mm_huge_list *next;\n#if ZEND_DEBUG\n\tzend_mm_debug_info dbg;\n#endif\n};\n```\n![huge_list链表](https://note.youdao.com/yws/api/personal/file/48872B5FBB994E018B73A4AF38B466CE?method=download&shareKey=b96499c0e19a3b8b9803bcfe2f50d9eb)\n\n<u>chunk是内存池向系统申请、释放内存的最小粒度。</u>`chunk`之间构成双向链表，第一个chunk的地址保存于`zend_mm_heap->main_chunk`。\n\n每个chunk的大小为2MB，被切割为512个page，所以每个page的大小为4KB，其中第一个page的内存用于chunk自己的结构体成员，主要记录chunk的一些信息，比如前后chunk的指针，当前chunk上各个page的使用情况等。\n\nchunk的定义结构如下：\n```c\n// file:zend_alloc.c\nstruct _zend_mm_chunk {\n\tzend_mm_heap      *heap;\n\t// 指向下一个chunk\n\tzend_mm_chunk     *next;\n\t// 指向上一个chunk\n\tzend_mm_chunk     *prev;\n\t// 当前chunk的剩余可用page数\n\tint                free_pages;\t\t\t\t/* number of free pages */\n\tint                free_tail;               /* number of free pages at the end of chunk */\n\tint                num;\n\tchar               reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)];\n\t// heap结构，只有主chunk会用到（即第一个chunk）\n\tzend_mm_heap       heap_slot;               /* used only in main chunk */\n\t// 标识各page是否已使用的bitmap，总大小为512bit，对应page总数，每个page占一个bit位。\n\tzend_mm_page_map   free_map;                /* 512 bits or 64 bytes */\n\t// 各page的信息：当前page使用类型（用于large分配还是small）、占用的page数等\n\tzend_mm_page_info  map[ZEND_MM_PAGES];      /* 2 KB = 512 * 4 */\n};\n```\n\n\n\nslot内存是把若干个page按照固定大小分割好的内存块。\n\n**内存池定义了30中大小的slot内存**：8、16、24、32...1792、2048、3072.这些slot的大小是有规律的。\n- ①、最小的slot大小为8byte\n- ②、前8个slot一次递增8byte（0~7递增 8byte）\n- ③、后面每隔4个递增值乘以2（8~11递增16byte、12~15递增32byte、16~19递增64byte、20~23递增128byte、24~27递增256byte、28~30递增512byte）\n\n\n\n每种大小的slot占用的page数不相同的：\n- ①、slot0~15各占1个page\n\n- ②、slot16~29分别占5、3、1、1、5、3、2、2、5、3、7、4、5、3个page；  \n    注：这个值实际也是有规律可循的，其算法为，目的是为了减少内存的碎片。\n    ```\n    page的个数 = 最小公倍数(slot对应的内存大小, page的大小即4096) / 4096\n    ```\n\n    \n    分配各个规格的slot时会按照各这个配置申请对应的数量的page，然后进行分割组成链表。<u>相同大小的slot之间构成单链表</u>。\n```\nstruct _zend_mm_free_slot {\n\tzend_mm_free_slot *next_free_slot;\n};\n```\n\nheap、huge、chunk、page、slot之间的关系如下图所示：\n![heap、huge、chunk、page、slot结构关系](https://note.youdao.com/yws/api/personal/file/A8793900579C4D84A8CCE6E131F70B04?method=download&shareKey=7c1b42213c6357aae7855f4bcc43c78c)\n\n#### 2 内存池的初始化\n初始化过程主要是`分配heap结构`，<u>如果是多线程环境，则会为每一个线程分配一个内存池，线程之间互不影响</u>。\n\n注：<u>`zend_mm_heap`这个结构不是单独分配的，它嵌在`chunk`结构体中（即`heap_slot`成员）</u>。也就是说内存池初始化时是分配了一个chunk结构，`zend_mm_chunk->heap_slot`作为内存池的heap结构，这个chunk也是第一个chunk，即main_chunk,如下图所示：\n![zend_mm_heap结构的分配](https://note.youdao.com/yws/api/personal/file/1598F914D6D043A2928403E3B65280FE?method=download&shareKey=fa722c4892712fb681baea9ac6c93cf8)\n\n**问题：为什么内存时的heap结构要嵌在chunk中而不是单独分配呢？** \n因为每个chunk的第一个page始终是给chunk结构体自己使用的，剩下的511个page才会做内存分配，但是chunk结构体并不需要一个page那么大的内存。也就是说被占用的page会有剩余的空间，因此，为了尽可能利用空间，就将heap结构嵌在了chunk中。\n\n具体的分配过成在zend_mm_init()中实现：\n```c\n// file:zend_alloc.c\nstatic zend_mm_heap *zend_mm_init(void)\n{\n    // 向系统申请2MB大小的chunk\n\tzend_mm_chunk *chunk = (zend_mm_chunk*)zend_mm_chunk_alloc_int(ZEND_MM_CHUNK_SIZE, ZEND_MM_CHUNK_SIZE);\n\tzend_mm_heap *heap;\n\n\tif (UNEXPECTED(chunk == NULL)) {\n#if ZEND_MM_ERROR\n#ifdef _WIN32\n\t\tstderr_last_error(\"Can't initialize heap\");\n#else\n\t\tfprintf(stderr, \"\\nCan't initialize heap: [%d] %s\\n\", errno, strerror(errno));\n#endif\n#endif\n\t\treturn NULL;\n\t}\n\t// heap结构实际数主chunk嵌入的一个结构，后面再分配的chunk的heap_slot不再使用\n\theap = &chunk->heap_slot;\n\tchunk->heap = heap;\n\tchunk->next = chunk;\n\tchunk->prev = chunk;\n\t// 剩余可用page数\n\tchunk->free_pages = ZEND_MM_PAGES - ZEND_MM_FIRST_PAGE;\n\tchunk->free_tail = ZEND_MM_FIRST_PAGE;\n\tchunk->num = 0\n\t// 将第一个page的bit分配标识位设置为1，表示已经被分配、占用\n\tchunk->free_map[0] = (Z_L(1) << ZEND_MM_FIRST_PAGE) - 1;\n\t// 第一个page的类型为ZEND_MM_IS_LRUN,即large内存\n\tchunk->map[0] = ZEND_MM_LRUN(ZEND_MM_FIRST_PAGE);\n\t// 指向主chunk\n\theap->main_chunk = chunk;\n\t// 初始化剩下的一些成员\n\t...\n\t// huge内存链表\n\theap->huge_list = NULL;\n\treturn heap;\n}\n\n```\n\n#### 3 内存的分配\nHuge大内存的分配过程比较简单、而Large与Small内存分配涉及到page的查找操作，过程稍显复杂。\n\n使用`emalloc`申请时，内存池会按照申请内存的大小自动选择那种格内存进行分配，如下图所示：\n![内存的分配流程](https://note.youdao.com/yws/api/personal/file/1C273A1B04A44C379427B94CBE2A42FB?method=download&shareKey=d5059f5c0dafd673a661edf8efe31120)\n\n##### 3.1 Huge分配\nHuge是指超多2MB大小内存的分配，<u>实际分配时将对齐到n个chunk</u>，分配完还会分配一个zend_mm_huge_list结构，用于管理所有的Huge内存。\n```c\nstatic void *zend_mm_alloc_huge(zend_mm_heap *heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n#ifdef ZEND_WIN32\n\t/* On Windows we don't have ability to extend huge blocks in-place.\n\t * We allocate them with 2MB size granularity, to avoid many\n\t * reallocations when they are extended by small pieces\n\t */\n\t // 按页大小重置实际要分配的内存\n\tsize_t new_size = ZEND_MM_ALIGNED_SIZE_EX(size, MAX(REAL_PAGE_SIZE, ZEND_MM_CHUNK_SIZE));\n#else\n\tsize_t new_size = ZEND_MM_ALIGNED_SIZE_EX(size, REAL_PAGE_SIZE);\n#endif\n\tvoid *ptr;\n\n#if ZEND_MM_LIMIT\n    // 如果有内存使用限制，则检查是否已达上限，达到的话进行zend_mm_gc清理后再检查\n\tif (UNEXPECTED(heap->real_size + new_size > heap->limit)) {\n\t\tif (zend_mm_gc(heap) && heap->real_size + new_size <= heap->limit) {\n\t\t\t/* pass */\n\t\t} else if (heap->overflow == 0) {\n#if ZEND_DEBUG\n\t\t\tzend_mm_safe_error(heap, \"Allowed memory size of %zu bytes exhausted at %s:%d (tried to allocate %zu bytes)\", heap->limit, __zend_filename, __zend_lineno, size);\n#else\n\t\t\tzend_mm_safe_error(heap, \"Allowed memory size of %zu bytes exhausted (tried to allocate %zu bytes)\", heap->limit, size);\n#endif\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n    // 分配chunk()，系统返回的地址是随机的，并不一定是ZEND_MM_CHUNK_ZIZE的整数倍，内存池需要自己移动到对齐的位置，比如：返回地址ptr是2000，而最近的一个对齐地址是2048，内存池会把ptr移动到2048，从这个位置使用。\n\tptr = zend_mm_chunk_alloc(heap, new_size, ZEND_MM_CHUNK_SIZE);\n   \n    ... \n    \n#if ZEND_DEBUG\n    // 将申请的内存通过zend_mm_huge_list插入到链表中\n\tzend_mm_add_huge_block(heap, ptr, new_size, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#else\n\tzend_mm_add_huge_block(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#endif\n    ...\n\treturn ptr;\n}\n```\n除了Huge分配以外，分配chunk内存也是Large、Small内存分配的基础，<u>它是ZendMM向系统申请内存的唯一粒度</u>。\n\n注：*分配chunk时，会将内存地址对齐到chunk的大小2MB（`ZEND_MM_THUNK_SIZE`）。也就是说，分配的chunk地址都是`ZEND_MM_THUNK_SIZE`的整数倍。（**实际上这个对齐并不是由系统简单的完成，而是需要内存池在申请内存后自己进行调整！**）*\n\n\n\n`ZendMM`具体处理对齐的方法是：\n\n- ①、按实际要申请的内存大小申请一次\n    - 若系统分配的地址恰好是ZEND_MM_CHUNK_SIZE的整数倍，则不需要调整，直接返回。\n    - 若系统分配的地址不是ZEND_MM_CHUNK_SIZE的整数倍，则需要使用第②步进行调整。\n- ②、调整方式：\n    - 首先ZendMM会将这块内存释放掉；\n    - 按照“`实际要申请的内存大小 + ZEND_MM_CHUNK_SIZE`”的大小重新申请一块内存，多申请的ZEND_MM_CHUNK大小的内存是用来调整的`，ZendMM`会从系统分配的地址向后偏移到最近一个`ZEND_MM_CHUNK_SIZE的整数倍`位置，调整完之后再把剩余的内存释放掉。\n\n```c\nstatic void *zend_mm_chunk_alloc_int(size_t size, size_t alignment)\n{\n    // 向系统申请size大小的内存\n\tvoid *ptr = zend_mm_mmap(size);\n\n\tif (ptr == NULL) {\n\t\treturn NULL;\n\t} else if (ZEND_MM_ALIGNED_OFFSET(ptr, alignment) == 0) { // 判断申请的内存是都为alignment的整数倍，是的话直接返回\n#ifdef MADV_HUGEPAGE\n\t    madvise(ptr, size, MADV_HUGEPAGE);\n#endif\n\t\treturn ptr;\n\t} else {\n\t    // 申请的内存不是按照alignment对齐的\n\t\tsize_t offset;\n\n\t\t// 将申请的内存释放掉重新申请\n\t\tzend_mm_munmap(ptr, size);\n\t\t// 重新申请一块内存，这里会多申请一块内存，用于截取到alignment的整数倍，可以忽略REAL_PAGE_SIZE\n\t\tptr = zend_mm_mmap(size + alignment - REAL_PAGE_SIZE);\n#ifdef _WIN32\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tzend_mm_munmap(ptr, size + alignment - REAL_PAGE_SIZE);\n\t\tptr = zend_mm_mmap_fixed((void*)((char*)ptr + (alignment - offset)), size);\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tif (offset != 0) {\n\t\t\tzend_mm_munmap(ptr, size);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ptr;\n#else\n        // offset为ptr距离上一个alignment对齐内存位置的大小，注意不能往前移，因为前面的内存都是分配了的。\n\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);\n\t\tif (offset != 0) {\n\t\t\toffset = alignment - offset;\n\t\t\tzend_mm_munmap(ptr, offset);\n\t\t\t// 偏移ptr，对齐到alignment\n\t\t\tptr = (char*)ptr + offset;\n\t\t\talignment -= offset;\n\t\t}\n\t\tif (alignment > REAL_PAGE_SIZE) {\n\t\t\tzend_mm_munmap((char*)ptr + size, alignment - REAL_PAGE_SIZE);\n\t\t}\n# ifdef MADV_HUGEPAGE\n\t    madvise(ptr, size, MADV_HUGEPAGE);\n# endif\n#endif\n\t\treturn ptr;\n\t}\n}\n```\n\n其中用到了`ZEND_MM_ALIGNED_OFFSET宏`，这个宏的作用是计算按alignment对齐的内存地址距离上一个alignment整数倍内存地址的大小，也就是offset偏移量。\n\n**alignment必须是2的n次方**，比如一段`n*alignment`大小的内存，ptr为其中一个位置，那么就可以通过位运算计算得到ptr在所属alignment内存块中的offset，如下图所示：\n\n```\n#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\\n\t(((size_t)(size)) & ((alignment) - 1))\n```\n![相对对齐值的内存offset](https://note.youdao.com/yws/api/personal/file/9940B8821F1E4B19B2783B68381DFD5C?method=download&shareKey=8e13fe6980c3aa04d6cf3c97f1522b9d)\n\n这个位运算是因为`alignment`为`2^n`（用二进制表示即为第n个位上为1，其余位为0，当alignment-1相当于将除了第n位为0，其余低位全部为1），所以通过alignment取到最低的位置，也就是相对上一个整数倍的alignment的offset，非位运算算式如下，但效率没有位运算高。\n```\noffset = ptr - (ptr/alignment取整 * alignment)\n```\n\n##### 3.2 Large分配\n当申请的内存大于3072B、小于2044KB时，内存池会选择在chunk上查找对应数量的page返回。<u>Large内存申请的粒度是page，也就是分配n页连续的page</u>，所以Large分配的过程就转化为在chunk上查找n页连续可用的page的过程。\n\n```c\nstatic zend_always_inline void *zend_mm_alloc_large(zend_mm_heap *heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n    // 根据size大小计算需要分配多少个page\n\tint pages_count = (int)ZEND_MM_SIZE_TO_NUM(size, ZEND_MM_PAGE_SIZE);\n#if ZEND_DEBUG\n    // 分配page_count个page\n\tvoid *ptr = zend_mm_alloc_pages(heap, pages_count, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#else\n\tvoid *ptr = zend_mm_alloc_pages(heap, pages_count ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n#endif\n#if ZEND_MM_STAT\n\tdo {\n\t\tsize_t size = heap->size + pages_count * ZEND_MM_PAGE_SIZE;\n\t\tsize_t peak = MAX(heap->peak, size);\n\t\theap->size = size;\n\t\theap->peak = peak;\n\t} while (0);\n#endif\n\treturn ptr;\n}\n```\n\nchunk结构中有两个成员用于记录page分配信息：\n- **free_map**：类型为`zend_mm_page_map`，实际就是`zend_ulong_free_map[16/8]`，这是一个bitmap，总大小为64byte，也就是512bit，用于记录用当前chunk上512个page是否分配，512个page对应512bit，1表示已分配，0表示未分配。\n![free_map](https://note.youdao.com/yws/api/personal/file/C879457EC2154FAEA678D562C217773B?method=download&shareKey=29d90ba60d479fdeccd33ac88325813a)\n- **map**：这个是一个可容纳512个类型为uint32_t元素的数组，<u>该数组用于记录各page的分配类型及分配的page页数</u>，每个page对应一个数组成员。Large内存、Small内存都会占用page，正是通过这个数组标识改page属于哪个类型（最高两位用于标识page的分配类型）：\n    \n    - Large：01（0x40000000）\n    \n- Small：10（0x80000000）\n    \n      \n    \n      示例：申请12KB的内存，即3个page，内存池分配了page1，2，3，则map[1] = 0x400000000|3,如下图所示：\n      ![page的分配类型及页数](https://note.youdao.com/yws/api/personal/file/474A05B6CB2D401785FA0FAB75FB3E97?method=download&shareKey=a1ce9cdd22022755fffe79243bd1db0e)\n\npage分配时从第一个chunk开始遍历，依次查找各chunk是否有满足要求的page，如果当前chunk没有合适的，则进入下一chunk，如果直到最后都没有找到，则新分配一个chunk。\n<u>分配准则为：申请的page页数要尽可能地填满chunk的空隙</u>，也就是说尽可能的与分配了的page连在一起，避免中间出现page空隙。减少后续分配时的茶之后按次数，提高内存利用率。\n\n最优page的检索过程如下：\n- step1：  \n  首先从第一个page分组（page0~63）开始检查，如果当前分组无空闲page（即free_map[x]=-1）则进入下一分组，知道当前分组有空闲page，然后进入step2.\n- step2：  \n  当前分组有可用page，首先检查当前page分组的bit位，找到第一个空闲page的位置，记做page_num，接着继续向下查找空闲page，知道遇到第一个已经分配的page位置，将最后一个空闲page位置记做`end_page_num`。（*注：查找end_page_num时并不局限在当前page分组内，会向下查找，直到最后一页。其查找做成主要依据free_map*），page_num至end_page_num为找到的可用page，接着判断找到的page页数是否够用：\n  \n    - 不够的情况：将page_num至end_page_num这些page的bit位标为1，也就是已分配，然后回到step1继续检索其他page分组。\n    - 刚好是要申请的页数：直接使用，中断检索。\n    - page页数比申请的页数大，则表示可用，但不一定是最优的，将page_num暂存起来，接着回到step1继续向后找别的空闲page，最后比较选择best_len最小的，即能够最大程度填满page间隔\n\t  ```c\n\t\t\t\t/* find first 0 bit */\n\t\t\t\t // tmp为当前page分组的bit位，i为当前分组第1个page的页码。\n\t\t\t\tpage_num = i + zend_mm_bitset_nts(tmp);\n\t\t\t\t/* reset bits from 0 to \"bit\" */\n\t\t\t\ttmp &= tmp + 1;\n\t\t\t\t/* skip free blocks */\n\t\t\t\t// 快速跳过剩余page全部可用的分组\n\t\t\t\twhile (tmp == 0) {\n\t\t\t\t\ti += ZEND_MM_BITSET_LEN;\n\t\t\t\t\tif (i >= free_tail || i == ZEND_MM_PAGES) {\n\t\t\t\t\t\tlen = ZEND_MM_PAGES - page_num;\n\t\t\t\t\t\tif (len >= pages_count && len < best_len) {\n\t\t\t\t\t\t\tchunk->free_tail = page_num + pages_count;\n\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* set accurate value */\n\t\t\t\t\t\t\tchunk->free_tail = page_num;\n\t\t\t\t\t\t\tif (best > 0) {\n\t\t\t\t\t\t\t\tpage_num = best;\n\t\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto not_found;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 当前分组剩下的page都是可用的，直接跳到下一分组\n\t\t\t\t\ttmp = *(bitset++);\n\t\t\t\t}\n\t\t\t\t/* find first 1 bit */\n\t\t\t\t// 找到第一个已分配page\n\t\t\t\tlen = i + zend_mm_bitset_ntz(tmp) - page_num;\n\t\t\t\tif (len >= pages_count) {\n\t\t\t\t\tif (len == pages_count) {\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t} else if (len < best_len) {\n\t\t\t\t\t\tbest_len = len;\n\t\t\t\t\t\tbest = page_num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* set bits from 0 to \"bit\" */\n\t\t\t\t// 把找到的这些page标为已分配，注：此时tmp已经经过tmp &= tmp + 1处理\n  \t\t\ttmp |= tmp - 1;\n  ```\n示例：当前某个chunk的page分配情况如下图中的A所示，page：0，1，2，6，9，10已经分配占用，接下来要申请2页的page。\n  ![page的查找过程](https://note.youdao.com/yws/api/personal/file/335A8945237E483EAD280F5A26DED219?method=download&shareKey=29b8b43bfeb58653a22ace5a4562f538)\n- step3：\n   最后没找到合适的page页后设置对应page的分配信息，即free_map、map,然后返回找到第一页page的地址\n    ```c\n    found:\n\tif (steps > 2 && pages_count < 8) {\n\t\t/* move chunk into the head of the linked-list */\n\t\tchunk->prev->next = chunk->next;\n\t\tchunk->next->prev = chunk->prev;\n\t\tchunk->next = heap->main_chunk->next;\n\t\tchunk->prev = heap->main_chunk;\n\t\tchunk->prev->next = chunk;\n\t\tchunk->next->prev = chunk;\n\t}\n\t/* mark run as allocated */\n\tchunk->free_pages -= pages_count;\n\tzend_mm_bitset_set_range(chunk->free_map, page_num, pages_count);\n\tchunk->map[page_num] = ZEND_MM_LRUN(pages_count);\n\tif (page_num == chunk->free_tail) {\n\t\tchunk->free_tail = page_num + pages_count;\n\t}\n\treturn ZEND_MM_PAGE_ADDR(chunk, page_num);\n    ```\n   \n##### 3.3 Small分配\nSmall内存在分配时，首先检查申请规格的内存是否已经分配，如果没有分配或者分配的已经用完了，则申请相应页数的page，page的分配过成与Larg分配完全一致，申请到page以后按固定大小将page切割为slot，slot之间构成单链表，链表头部保存至`AG(mm_heap)->free_slot`；如果对应的slot已经分配，则直接返回`AG(mm_heap)->free_slot`。  \n\n示例：16byte、3072byte大小的slot，将分别申请1个、3个page、然后切割为256个16byte的slot，以及4个3072byte的slot，如下图所示：\n![slot[1]与slot[29]链表](https://note.youdao.com/yws/api/personal/file/4345829756E149EEAB1C4DE3928C76AC?method=download&shareKey=c358be1e7b73c1ff04ccac1eb772c992)\n\n#### 4 系统内存分配\n<u>内存池向系统申请内存的最小粒度是chunk</u>，通过mmap()来申请。\n\n#### 5 内存释放\n内存释放主要通过`efree()`来完成，内存池会根据释放的内存地址自动判断属于哪种粒度的内存，从而执行不同的释放逻辑。\n\n\n\n**问：内存池是如何只根据一个地址就判断出改地址属于哪种内存类型的呢？**  \n因为chunk分配时是按照ZEND_MM_CHUNK_SIZE（即2MB）对齐的，也就是chunk的起始内存地址一定是ZEND_MM_CHUNK_SIZE的整数倍，所以可以根据chunk上的任意位置知道chunk的起始位置与所在page。\n\n##### 5.1 Huge内存的释放\n首先，根据释放地址ptr计算该机制相对chunk起始位置的内存偏移量，这个值通过宏ZEND_MM_ALIGNED_OFFSET()的到，通过位运算计算的到。  \n\n示例：ptr = 0x7ffff7c01000，计算的到offset = 4096\n\n```\noffet = ptr & (alignment - 1) = 0x7ffff7c01000 & 0x1fffff = 0x1000 = 4096\n```\n\n<u>Huge内存能够完全使用chunk，也就是Huge内存地址相对chunk的offset一定等于0，而Large、Small内存因为chunk的第1个page被占用了，所以这两种内存的offset不可能为0.</u>\n\n内存池根据offset值判断出释放的内存是否为`Huge类型`，如果是则将占用的chunk释放，同时从AG(mm_heap)->huge_list链表中删除。\n\n##### 5.2 Large内存的释放\n若计算得到的offset不等于0，则表示该地址是Large内存或者Small内存，然后根据offset值进一步计算出属于第几个page   \n<u>计算方法：根据offset除page的大小取整，的到`page_num`，的到`page`页码后就可以从`chunk->map`中获取该`page`的分配类型，知道是何种粒度的内存了。</u>\n\nLarge内存，<u>并不会直接释放物理内存</u>，只是将对应的page的分配信息重新设置为未分配。若释放page后，<u>当前chunk下所有的page都是未分配的，则会释放chunk</u>，释放时优先选择把chunk移到`AG(mm_heap)->cached_chunks`缓存队列中，缓存数达到一定值后就不在继续缓存新加入的chunk，将内存归还系统，便面占用过多的资源。\n（分配chunk时，如果发现cached_chunks中有缓存的chunk,就直接取出使用，不再向系统申请。）\n\n##### 5.3 Small内存的释放\n若待释放的地址为Small内存，则会将释放的slot插入到该规格slot可用链表的头部，如下图所示：\n![释放slot](https://note.youdao.com/yws/api/personal/file/9141601D64BF4D76AF0A211F55A479A2?method=download&shareKey=7df69cd6f617df511be8d5f87c7a58f4)","slug":"PHP7内核-内存管理-内存池","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabn5006645g3he0hb4zo","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>在C语言中，通常直接使用malloc进行内存的分配，而频繁的分配、释放内存无疑会产生内存碎片，降低系统性能。PHP自己实现了一套内存池（<code>ZendMM</code>：<code>Zend Memery Manager</code>）用于替换<code>glibc</code>的<code>malloc</code>、<code>free</code>，以解决内存频繁分配、释放的问题。</p>\n<a id=\"more\"></a>\n\n<p>内存池技术主要作用：</p>\n<ul>\n<li>①、减少内存分配及释放的次数</li>\n<li>②、有效控制内存碎片的产生</li>\n</ul>\n<p>PHP的内存池的实现参考了<code>tcmalloc</code>的设计，<code>tcmalloc</code>是<code>Google</code>开源的一个非常优秀的内存分配器。</p>\n<p>内存池是PHP内核中最底层的内存操作，他是非常独立的一个模块，可以移植到其他C语言应用中去。  </p>\n<p><strong>内存池定义了三种粒度的内存块</strong>：</p>\n<ul>\n<li><strong>chunk</strong>：每个chunk的大小为2M</li>\n<li><strong>page</strong>：page的大小为4KB，每个chunk被切割为512个page（2048/4）</li>\n<li><strong>slot</strong>：一个或若干个page被切割为多个slot</li>\n</ul>\n<p>申请内存时按照不同的申请大小决定具体的分配策略：</p>\n<ul>\n<li><strong>Huge(chunk)</strong>:申请内存大于2MB，<u>直接调用系统分配</u>，分配若干个chunk.(&gt;2MB)</li>\n<li>**Large(page)**：申请内<del>存大于3092B</del>（即page大小的3/4, 4 * 1024 * 3/4 = 3072B）,小于2044KB（即511个page的大小），分配若干个page。(3072B~2044KB)</li>\n<li><strong>Small(slot)</strong>:申请内存小于等于3092B(即page大小的3/4)，<u>内存池提前定义好了30种同等大小的内存（8、16、24、32…3072）,它们分配在不同的page上（不同大小的内存可能会分配在多个连续的page），申请内存时直接在对应的page上查找可用的slot</u>。(&lt;3092B)</li>\n</ul>\n<p>内存池通过<strong>zend_mm_heap</strong>结构存储内存池的主要信息，比如<code>大内存链表</code>、<code>chunk链表</code>、<code>slot各大小内存链表</code>等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> AG(v) (alloc_globals.v)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> zend_alloc_globals alloc_globals;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// file:zend_alloc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_heap</span> <span class=\"title\">zend_mm_heap</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_heap</span> &#123;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_CUSTOM</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                use_custom_heap;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STORAGE</span></span><br><span class=\"line\">\tzend_mm_storage   *storage;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STAT</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前已使用的内存数</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             size;                    <span class=\"comment\">/* current memory usage */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 内存单次申请的峰值</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             peak;                    <span class=\"comment\">/* peak memory usage */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部</span></span><br><span class=\"line\">\tzend_mm_free_slot *free_slot[ZEND_MM_BINS]; <span class=\"comment\">/* free lists for small sizes */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 大内存链表</span></span><br><span class=\"line\">\tzend_mm_huge_list *huge_list;               <span class=\"comment\">/* list of huge allocated blocks */</span></span><br><span class=\"line\">    <span class=\"comment\">// 指向chunk链表头部</span></span><br><span class=\"line\">\tzend_mm_chunk     *main_chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存的chunk链表</span></span><br><span class=\"line\">\tzend_mm_chunk     *cached_chunks;\t\t\t<span class=\"comment\">/* list of unused chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 已分配的chunk数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                chunks_count;\t\t\t<span class=\"comment\">/* number of alocated chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当前request使用chunk峰值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                peak_chunks_count;\t\t<span class=\"comment\">/* peak number of allocated chunks for current request */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 缓存的chunk数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                cached_chunks_count;\t\t<span class=\"comment\">/* number of cached chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// chunk使用均值，每次请求结束后会根据peak_chunk_count重新计算：(avg_chunks_count + peak_chunks_count)/2.0</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span>             avg_chunks_count;\t\t<span class=\"comment\">/* average number of chunks allocated per request */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                last_chunks_delete_boundary; <span class=\"comment\">/* numer of chunks after last deletion */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                last_chunks_delete_count;    <span class=\"comment\">/* number of deletion over the last boundary */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>大内存分配的是若干个chunk，然后通过一个<code>zend_mm_huge_list结构</code>进行管理，<strong>大内存之间构成一个单向链表</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>  _<span class=\"title\">zend_mm_huge_list</span> <span class=\"title\">zend_mm_huge_list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_huge_list</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>              *ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             size;</span><br><span class=\"line\">\tzend_mm_huge_list *next;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">\tzend_mm_debug_info dbg;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/48872B5FBB994E018B73A4AF38B466CE?method=download&shareKey=b96499c0e19a3b8b9803bcfe2f50d9eb\" alt=\"huge_list链表\"></p>\n<p><u>chunk是内存池向系统申请、释放内存的最小粒度。</u><code>chunk</code>之间构成双向链表，第一个chunk的地址保存于<code>zend_mm_heap-&gt;main_chunk</code>。</p>\n<p>每个chunk的大小为2MB，被切割为512个page，所以每个page的大小为4KB，其中第一个page的内存用于chunk自己的结构体成员，主要记录chunk的一些信息，比如前后chunk的指针，当前chunk上各个page的使用情况等。</p>\n<p>chunk的定义结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_chunk</span> &#123;</span></span><br><span class=\"line\">\tzend_mm_heap      *heap;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向下一个chunk</span></span><br><span class=\"line\">\tzend_mm_chunk     *next;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向上一个chunk</span></span><br><span class=\"line\">\tzend_mm_chunk     *prev;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前chunk的剩余可用page数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                free_pages;\t\t\t\t<span class=\"comment\">/* number of free pages */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                free_tail;               <span class=\"comment\">/* number of free pages at the end of chunk */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                num;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>               reserve[<span class=\"number\">64</span> - (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*) * <span class=\"number\">3</span> + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">3</span>)];</span><br><span class=\"line\">\t<span class=\"comment\">// heap结构，只有主chunk会用到（即第一个chunk）</span></span><br><span class=\"line\">\tzend_mm_heap       heap_slot;               <span class=\"comment\">/* used only in main chunk */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 标识各page是否已使用的bitmap，总大小为512bit，对应page总数，每个page占一个bit位。</span></span><br><span class=\"line\">\tzend_mm_page_map   free_map;                <span class=\"comment\">/* 512 bits or 64 bytes */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 各page的信息：当前page使用类型（用于large分配还是small）、占用的page数等</span></span><br><span class=\"line\">\tzend_mm_page_info  <span class=\"built_in\">map</span>[ZEND_MM_PAGES];      <span class=\"comment\">/* 2 KB = 512 * 4 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>slot内存是把若干个page按照固定大小分割好的内存块。</p>\n<p><strong>内存池定义了30中大小的slot内存</strong>：8、16、24、32…1792、2048、3072.这些slot的大小是有规律的。</p>\n<ul>\n<li>①、最小的slot大小为8byte</li>\n<li>②、前8个slot一次递增8byte（0~7递增 8byte）</li>\n<li>③、后面每隔4个递增值乘以2（8<del>11递增16byte、12</del>15递增32byte、16<del>19递增64byte、20</del>23递增128byte、24<del>27递增256byte、28</del>30递增512byte）</li>\n</ul>\n<p>每种大小的slot占用的page数不相同的：</p>\n<ul>\n<li><p>①、slot0~15各占1个page</p>\n</li>\n<li><p>②、slot16~29分别占5、3、1、1、5、3、2、2、5、3、7、4、5、3个page；<br>  注：这个值实际也是有规律可循的，其算法为，目的是为了减少内存的碎片。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page的个数 &#x3D; 最小公倍数(slot对应的内存大小, page的大小即4096) &#x2F; 4096</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<pre><code>分配各个规格的slot时会按照各这个配置申请对应的数量的page，然后进行分割组成链表。&lt;u&gt;相同大小的slot之间构成单链表&lt;/u&gt;。</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_mm_free_slot &#123;</span><br><span class=\"line\">\tzend_mm_free_slot *next_free_slot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>heap、huge、chunk、page、slot之间的关系如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/A8793900579C4D84A8CCE6E131F70B04?method=download&shareKey=7c1b42213c6357aae7855f4bcc43c78c\" alt=\"heap、huge、chunk、page、slot结构关系\"></p>\n<h4 id=\"2-内存池的初始化\"><a href=\"#2-内存池的初始化\" class=\"headerlink\" title=\"2 内存池的初始化\"></a>2 内存池的初始化</h4><p>初始化过程主要是<code>分配heap结构</code>，<u>如果是多线程环境，则会为每一个线程分配一个内存池，线程之间互不影响</u>。</p>\n<p>注：<u><code>zend_mm_heap</code>这个结构不是单独分配的，它嵌在<code>chunk</code>结构体中（即<code>heap_slot</code>成员）</u>。也就是说内存池初始化时是分配了一个chunk结构，<code>zend_mm_chunk-&gt;heap_slot</code>作为内存池的heap结构，这个chunk也是第一个chunk，即main_chunk,如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/1598F914D6D043A2928403E3B65280FE?method=download&shareKey=fa722c4892712fb681baea9ac6c93cf8\" alt=\"zend_mm_heap结构的分配\"></p>\n<p><strong>问题：为什么内存时的heap结构要嵌在chunk中而不是单独分配呢？</strong><br>因为每个chunk的第一个page始终是给chunk结构体自己使用的，剩下的511个page才会做内存分配，但是chunk结构体并不需要一个page那么大的内存。也就是说被占用的page会有剩余的空间，因此，为了尽可能利用空间，就将heap结构嵌在了chunk中。</p>\n<p>具体的分配过成在zend_mm_init()中实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_mm_heap *<span class=\"title\">zend_mm_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 向系统申请2MB大小的chunk</span></span><br><span class=\"line\">\tzend_mm_chunk *chunk = (zend_mm_chunk*)zend_mm_chunk_alloc_int(ZEND_MM_CHUNK_SIZE, ZEND_MM_CHUNK_SIZE);</span><br><span class=\"line\">\tzend_mm_heap *heap;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(chunk == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_ERROR</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _WIN32</span></span><br><span class=\"line\">\t\tstderr_last_error(<span class=\"string\">&quot;Can&#x27;t initialize heap&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;\\nCan&#x27;t initialize heap: [%d] %s\\n&quot;</span>, errno, strerror(errno));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// heap结构实际数主chunk嵌入的一个结构，后面再分配的chunk的heap_slot不再使用</span></span><br><span class=\"line\">\theap = &amp;chunk-&gt;heap_slot;</span><br><span class=\"line\">\tchunk-&gt;heap = heap;</span><br><span class=\"line\">\tchunk-&gt;next = chunk;</span><br><span class=\"line\">\tchunk-&gt;prev = chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 剩余可用page数</span></span><br><span class=\"line\">\tchunk-&gt;free_pages = ZEND_MM_PAGES - ZEND_MM_FIRST_PAGE;</span><br><span class=\"line\">\tchunk-&gt;free_tail = ZEND_MM_FIRST_PAGE;</span><br><span class=\"line\">\tchunk-&gt;num = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"comment\">// 将第一个page的bit分配标识位设置为1，表示已经被分配、占用</span></span><br><span class=\"line\">\tchunk-&gt;free_map[<span class=\"number\">0</span>] = (Z_L(<span class=\"number\">1</span>) &lt;&lt; ZEND_MM_FIRST_PAGE) - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一个page的类型为ZEND_MM_IS_LRUN,即large内存</span></span><br><span class=\"line\">\tchunk-&gt;<span class=\"built_in\">map</span>[<span class=\"number\">0</span>] = ZEND_MM_LRUN(ZEND_MM_FIRST_PAGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 指向主chunk</span></span><br><span class=\"line\">\theap-&gt;main_chunk = chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化剩下的一些成员</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// huge内存链表</span></span><br><span class=\"line\">\theap-&gt;huge_list = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-内存的分配\"><a href=\"#3-内存的分配\" class=\"headerlink\" title=\"3 内存的分配\"></a>3 内存的分配</h4><p>Huge大内存的分配过程比较简单、而Large与Small内存分配涉及到page的查找操作，过程稍显复杂。</p>\n<p>使用<code>emalloc</code>申请时，内存池会按照申请内存的大小自动选择那种格内存进行分配，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/1C273A1B04A44C379427B94CBE2A42FB?method=download&shareKey=d5059f5c0dafd673a661edf8efe31120\" alt=\"内存的分配流程\"></p>\n<h5 id=\"3-1-Huge分配\"><a href=\"#3-1-Huge分配\" class=\"headerlink\" title=\"3.1 Huge分配\"></a>3.1 Huge分配</h5><p>Huge是指超多2MB大小内存的分配，<u>实际分配时将对齐到n个chunk</u>，分配完还会分配一个zend_mm_huge_list结构，用于管理所有的Huge内存。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_alloc_huge</span><span class=\"params\">(zend_mm_heap *heap, <span class=\"keyword\">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ZEND_WIN32</span></span><br><span class=\"line\">\t<span class=\"comment\">/* On Windows we don&#x27;t have ability to extend huge blocks in-place.</span></span><br><span class=\"line\"><span class=\"comment\">\t * We allocate them with 2MB size granularity, to avoid many</span></span><br><span class=\"line\"><span class=\"comment\">\t * reallocations when they are extended by small pieces</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t <span class=\"comment\">// 按页大小重置实际要分配的内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> new_size = ZEND_MM_ALIGNED_SIZE_EX(size, MAX(REAL_PAGE_SIZE, ZEND_MM_CHUNK_SIZE));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> new_size = ZEND_MM_ALIGNED_SIZE_EX(size, REAL_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_LIMIT</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果有内存使用限制，则检查是否已达上限，达到的话进行zend_mm_gc清理后再检查</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(heap-&gt;real_size + new_size &gt; heap-&gt;limit)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (zend_mm_gc(heap) &amp;&amp; heap-&gt;real_size + new_size &lt;= heap-&gt;limit) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* pass */</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (heap-&gt;overflow == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">#<span class=\"keyword\">if</span> ZEND_DEBUG</span><br><span class=\"line\">\t\t\tzend_mm_safe_error(heap, <span class=\"string\">&quot;Allowed memory size of %zu bytes exhausted at %s:%d (tried to allocate %zu bytes)&quot;</span>, heap-&gt;limit, __zend_filename, __zend_lineno, size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\tzend_mm_safe_error(heap, <span class=\"string\">&quot;Allowed memory size of %zu bytes exhausted (tried to allocate %zu bytes)&quot;</span>, heap-&gt;limit, size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 分配chunk()，系统返回的地址是随机的，并不一定是ZEND_MM_CHUNK_ZIZE的整数倍，内存池需要自己移动到对齐的位置，比如：返回地址ptr是2000，而最近的一个对齐地址是2048，内存池会把ptr移动到2048，从这个位置使用。</span></span><br><span class=\"line\">\tptr = zend_mm_chunk_alloc(heap, new_size, ZEND_MM_CHUNK_SIZE);</span><br><span class=\"line\">   </span><br><span class=\"line\">    ... </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">    <span class=\"comment\">// 将申请的内存通过zend_mm_huge_list插入到链表中</span></span><br><span class=\"line\">\tzend_mm_add_huge_block(heap, ptr, new_size, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\tzend_mm_add_huge_block(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了Huge分配以外，分配chunk内存也是Large、Small内存分配的基础，<u>它是ZendMM向系统申请内存的唯一粒度</u>。</p>\n<p>注：<em>分配chunk时，会将内存地址对齐到chunk的大小2MB（<code>ZEND_MM_THUNK_SIZE</code>）。也就是说，分配的chunk地址都是<code>ZEND_MM_THUNK_SIZE</code>的整数倍。（<strong>实际上这个对齐并不是由系统简单的完成，而是需要内存池在申请内存后自己进行调整！</strong>）</em></p>\n<p><code>ZendMM</code>具体处理对齐的方法是：</p>\n<ul>\n<li>①、按实际要申请的内存大小申请一次<ul>\n<li>若系统分配的地址恰好是ZEND_MM_CHUNK_SIZE的整数倍，则不需要调整，直接返回。</li>\n<li>若系统分配的地址不是ZEND_MM_CHUNK_SIZE的整数倍，则需要使用第②步进行调整。</li>\n</ul>\n</li>\n<li>②、调整方式：<ul>\n<li>首先ZendMM会将这块内存释放掉；</li>\n<li>按照“<code>实际要申请的内存大小 + ZEND_MM_CHUNK_SIZE</code>”的大小重新申请一块内存，多申请的ZEND_MM_CHUNK大小的内存是用来调整的<code>，ZendMM</code>会从系统分配的地址向后偏移到最近一个<code>ZEND_MM_CHUNK_SIZE的整数倍</code>位置，调整完之后再把剩余的内存释放掉。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_chunk_alloc_int</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> alignment)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 向系统申请size大小的内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_mmap(size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ptr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ZEND_MM_ALIGNED_OFFSET(ptr, alignment) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 判断申请的内存是都为alignment的整数倍，是的话直接返回</span></span><br><span class=\"line\">#ifdef MADV_HUGEPAGE</span><br><span class=\"line\">\t    madvise(ptr, size, MADV_HUGEPAGE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 申请的内存不是按照alignment对齐的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> offset;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将申请的内存释放掉重新申请</span></span><br><span class=\"line\">\t\tzend_mm_munmap(ptr, size);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 重新申请一块内存，这里会多申请一块内存，用于截取到alignment的整数倍，可以忽略REAL_PAGE_SIZE</span></span><br><span class=\"line\">\t\tptr = zend_mm_mmap(size + alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _WIN32</span></span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\tzend_mm_munmap(ptr, size + alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\">\t\tptr = zend_mm_mmap_fixed((<span class=\"keyword\">void</span>*)((<span class=\"keyword\">char</span>*)ptr + (alignment - offset)), size);</span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (offset != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tzend_mm_munmap(ptr, size);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        <span class=\"comment\">// offset为ptr距离上一个alignment对齐内存位置的大小，注意不能往前移，因为前面的内存都是分配了的。</span></span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (offset != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\toffset = alignment - offset;</span><br><span class=\"line\">\t\t\tzend_mm_munmap(ptr, offset);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 偏移ptr，对齐到alignment</span></span><br><span class=\"line\">\t\t\tptr = (<span class=\"keyword\">char</span>*)ptr + offset;</span><br><span class=\"line\">\t\t\talignment -= offset;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (alignment &gt; REAL_PAGE_SIZE) &#123;</span><br><span class=\"line\">\t\t\tzend_mm_munmap((<span class=\"keyword\">char</span>*)ptr + size, alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">ifdef</span> MADV_HUGEPAGE</span></span><br><span class=\"line\">\t    madvise(ptr, size, MADV_HUGEPAGE);</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中用到了<code>ZEND_MM_ALIGNED_OFFSET宏</code>，这个宏的作用是计算按alignment对齐的内存地址距离上一个alignment整数倍内存地址的大小，也就是offset偏移量。</p>\n<p><strong>alignment必须是2的n次方</strong>，比如一段<code>n*alignment</code>大小的内存，ptr为其中一个位置，那么就可以通过位运算计算得到ptr在所属alignment内存块中的offset，如下图所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\</span><br><span class=\"line\">\t(((size_t)(size)) &amp; ((alignment) - 1))</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/9940B8821F1E4B19B2783B68381DFD5C?method=download&shareKey=8e13fe6980c3aa04d6cf3c97f1522b9d\" alt=\"相对对齐值的内存offset\"></p>\n<p>这个位运算是因为<code>alignment</code>为<code>2^n</code>（用二进制表示即为第n个位上为1，其余位为0，当alignment-1相当于将除了第n位为0，其余低位全部为1），所以通过alignment取到最低的位置，也就是相对上一个整数倍的alignment的offset，非位运算算式如下，但效率没有位运算高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offset &#x3D; ptr - (ptr&#x2F;alignment取整 * alignment)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-Large分配\"><a href=\"#3-2-Large分配\" class=\"headerlink\" title=\"3.2 Large分配\"></a>3.2 Large分配</h5><p>当申请的内存大于3072B、小于2044KB时，内存池会选择在chunk上查找对应数量的page返回。<u>Large内存申请的粒度是page，也就是分配n页连续的page</u>，所以Large分配的过程就转化为在chunk上查找n页连续可用的page的过程。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_alloc_large</span><span class=\"params\">(zend_mm_heap *heap, <span class=\"keyword\">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据size大小计算需要分配多少个page</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pages_count = (<span class=\"keyword\">int</span>)ZEND_MM_SIZE_TO_NUM(size, ZEND_MM_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">    <span class=\"comment\">// 分配page_count个page</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_alloc_pages(heap, pages_count, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_alloc_pages(heap, pages_count ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STAT</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> size = heap-&gt;size + pages_count * ZEND_MM_PAGE_SIZE;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> peak = MAX(heap-&gt;peak, size);</span><br><span class=\"line\">\t\theap-&gt;size = size;</span><br><span class=\"line\">\t\theap-&gt;peak = peak;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>chunk结构中有两个成员用于记录page分配信息：</p>\n<ul>\n<li><p><strong>free_map</strong>：类型为<code>zend_mm_page_map</code>，实际就是<code>zend_ulong_free_map[16/8]</code>，这是一个bitmap，总大小为64byte，也就是512bit，用于记录用当前chunk上512个page是否分配，512个page对应512bit，1表示已分配，0表示未分配。<br><img src=\"https://note.youdao.com/yws/api/personal/file/C879457EC2154FAEA678D562C217773B?method=download&shareKey=29d90ba60d479fdeccd33ac88325813a\" alt=\"free_map\"></p>\n</li>\n<li><p><strong>map</strong>：这个是一个可容纳512个类型为uint32_t元素的数组，<u>该数组用于记录各page的分配类型及分配的page页数</u>，每个page对应一个数组成员。Large内存、Small内存都会占用page，正是通过这个数组标识改page属于哪个类型（最高两位用于标识page的分配类型）：</p>\n<ul>\n<li>Large：01（0x40000000）</li>\n</ul>\n</li>\n<li><p>Small：10（0x80000000）</p>\n</li>\n</ul>\n<pre><code>  示例：申请12KB的内存，即3个page，内存池分配了page1，2，3，则map[1] = 0x400000000|3,如下图所示：\n  ![page的分配类型及页数](https://note.youdao.com/yws/api/personal/file/474A05B6CB2D401785FA0FAB75FB3E97?method=download&amp;shareKey=a1ce9cdd22022755fffe79243bd1db0e)</code></pre>\n<p>page分配时从第一个chunk开始遍历，依次查找各chunk是否有满足要求的page，如果当前chunk没有合适的，则进入下一chunk，如果直到最后都没有找到，则新分配一个chunk。<br><u>分配准则为：申请的page页数要尽可能地填满chunk的空隙</u>，也就是说尽可能的与分配了的page连在一起，避免中间出现page空隙。减少后续分配时的茶之后按次数，提高内存利用率。</p>\n<p>最优page的检索过程如下：</p>\n<ul>\n<li><p>step1：<br>首先从第一个page分组（page0~63）开始检查，如果当前分组无空闲page（即free_map[x]=-1）则进入下一分组，知道当前分组有空闲page，然后进入step2.</p>\n</li>\n<li><p>step2：<br>当前分组有可用page，首先检查当前page分组的bit位，找到第一个空闲page的位置，记做page_num，接着继续向下查找空闲page，知道遇到第一个已经分配的page位置，将最后一个空闲page位置记做<code>end_page_num</code>。（<em>注：查找end_page_num时并不局限在当前page分组内，会向下查找，直到最后一页。其查找做成主要依据free_map</em>），page_num至end_page_num为找到的可用page，接着判断找到的page页数是否够用：</p>\n<ul>\n<li>不够的情况：将page_num至end_page_num这些page的bit位标为1，也就是已分配，然后回到step1继续检索其他page分组。</li>\n<li>刚好是要申请的页数：直接使用，中断检索。</li>\n<li>page页数比申请的页数大，则表示可用，但不一定是最优的，将page_num暂存起来，接着回到step1继续向后找别的空闲page，最后比较选择best_len最小的，即能够最大程度填满page间隔<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* find first 0 bit */</span></span><br><span class=\"line\"> <span class=\"comment\">// tmp为当前page分组的bit位，i为当前分组第1个page的页码。</span></span><br><span class=\"line\">page_num = i + zend_mm_bitset_nts(tmp);</span><br><span class=\"line\"><span class=\"comment\">/* reset bits from 0 to &quot;bit&quot; */</span></span><br><span class=\"line\">tmp &amp;= tmp + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">/* skip free blocks */</span></span><br><span class=\"line\"><span class=\"comment\">// 快速跳过剩余page全部可用的分组</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (tmp == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\ti += ZEND_MM_BITSET_LEN;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i &gt;= free_tail || i == ZEND_MM_PAGES) &#123;</span><br><span class=\"line\">\t\tlen = ZEND_MM_PAGES - page_num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (len &gt;= pages_count &amp;&amp; len &lt; best_len) &#123;</span><br><span class=\"line\">\t\t\tchunk-&gt;free_tail = page_num + pages_count;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* set accurate value */</span></span><br><span class=\"line\">\t\t\tchunk-&gt;free_tail = page_num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (best &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tpage_num = best;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> not_found;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前分组剩下的page都是可用的，直接跳到下一分组</span></span><br><span class=\"line\">\ttmp = *(<span class=\"built_in\">bitset</span>++);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* find first 1 bit */</span></span><br><span class=\"line\"><span class=\"comment\">// 找到第一个已分配page</span></span><br><span class=\"line\">len = i + zend_mm_bitset_ntz(tmp) - page_num;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (len &gt;= pages_count) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (len == pages_count) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &lt; best_len) &#123;</span><br><span class=\"line\">\t\tbest_len = len;</span><br><span class=\"line\">\t\tbest = page_num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* set bits from 0 to &quot;bit&quot; */</span></span><br><span class=\"line\"><span class=\"comment\">// 把找到的这些page标为已分配，注：此时tmp已经经过tmp &amp;= tmp + 1处理</span></span><br><span class=\"line\">\ttmp |= tmp - <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n示例：当前某个chunk的page分配情况如下图中的A所示，page：0，1，2，6，9，10已经分配占用，接下来要申请2页的page。<br><img src=\"https://note.youdao.com/yws/api/personal/file/335A8945237E483EAD280F5A26DED219?method=download&shareKey=29b8b43bfeb58653a22ace5a4562f538\" alt=\"page的查找过程\"></li>\n</ul>\n</li>\n<li><p>step3：<br> 最后没找到合适的page页后设置对应page的分配信息，即free_map、map,然后返回找到第一页page的地址</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   found:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (steps &gt; <span class=\"number\">2</span> &amp;&amp; pages_count &lt; <span class=\"number\">8</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* move chunk into the head of the linked-list */</span></span><br><span class=\"line\">\tchunk-&gt;prev-&gt;next = chunk-&gt;next;</span><br><span class=\"line\">\tchunk-&gt;next-&gt;prev = chunk-&gt;prev;</span><br><span class=\"line\">\tchunk-&gt;next = heap-&gt;main_chunk-&gt;next;</span><br><span class=\"line\">\tchunk-&gt;prev = heap-&gt;main_chunk;</span><br><span class=\"line\">\tchunk-&gt;prev-&gt;next = chunk;</span><br><span class=\"line\">\tchunk-&gt;next-&gt;prev = chunk;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* mark run as allocated */</span></span><br><span class=\"line\">chunk-&gt;free_pages -= pages_count;</span><br><span class=\"line\">zend_mm_bitset_set_range(chunk-&gt;free_map, page_num, pages_count);</span><br><span class=\"line\">chunk-&gt;<span class=\"built_in\">map</span>[page_num] = ZEND_MM_LRUN(pages_count);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (page_num == chunk-&gt;free_tail) &#123;</span><br><span class=\"line\">\tchunk-&gt;free_tail = page_num + pages_count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ZEND_MM_PAGE_ADDR(chunk, page_num);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h5 id=\"3-3-Small分配\"><a href=\"#3-3-Small分配\" class=\"headerlink\" title=\"3.3 Small分配\"></a>3.3 Small分配</h5><p>Small内存在分配时，首先检查申请规格的内存是否已经分配，如果没有分配或者分配的已经用完了，则申请相应页数的page，page的分配过成与Larg分配完全一致，申请到page以后按固定大小将page切割为slot，slot之间构成单链表，链表头部保存至<code>AG(mm_heap)-&gt;free_slot</code>；如果对应的slot已经分配，则直接返回<code>AG(mm_heap)-&gt;free_slot</code>。  </p>\n<p>示例：16byte、3072byte大小的slot，将分别申请1个、3个page、然后切割为256个16byte的slot，以及4个3072byte的slot，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/4345829756E149EEAB1C4DE3928C76AC?method=download&shareKey=c358be1e7b73c1ff04ccac1eb772c992\" alt=\"slot[1]与slot[29]链表\"></p>\n<h4 id=\"4-系统内存分配\"><a href=\"#4-系统内存分配\" class=\"headerlink\" title=\"4 系统内存分配\"></a>4 系统内存分配</h4><p><u>内存池向系统申请内存的最小粒度是chunk</u>，通过mmap()来申请。</p>\n<h4 id=\"5-内存释放\"><a href=\"#5-内存释放\" class=\"headerlink\" title=\"5 内存释放\"></a>5 内存释放</h4><p>内存释放主要通过<code>efree()</code>来完成，内存池会根据释放的内存地址自动判断属于哪种粒度的内存，从而执行不同的释放逻辑。</p>\n<p><strong>问：内存池是如何只根据一个地址就判断出改地址属于哪种内存类型的呢？</strong><br>因为chunk分配时是按照ZEND_MM_CHUNK_SIZE（即2MB）对齐的，也就是chunk的起始内存地址一定是ZEND_MM_CHUNK_SIZE的整数倍，所以可以根据chunk上的任意位置知道chunk的起始位置与所在page。</p>\n<h5 id=\"5-1-Huge内存的释放\"><a href=\"#5-1-Huge内存的释放\" class=\"headerlink\" title=\"5.1 Huge内存的释放\"></a>5.1 Huge内存的释放</h5><p>首先，根据释放地址ptr计算该机制相对chunk起始位置的内存偏移量，这个值通过宏ZEND_MM_ALIGNED_OFFSET()的到，通过位运算计算的到。  </p>\n<p>示例：ptr = 0x7ffff7c01000，计算的到offset = 4096</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offet &#x3D; ptr &amp; (alignment - 1) &#x3D; 0x7ffff7c01000 &amp; 0x1fffff &#x3D; 0x1000 &#x3D; 4096</span><br></pre></td></tr></table></figure>\n\n<p><u>Huge内存能够完全使用chunk，也就是Huge内存地址相对chunk的offset一定等于0，而Large、Small内存因为chunk的第1个page被占用了，所以这两种内存的offset不可能为0.</u></p>\n<p>内存池根据offset值判断出释放的内存是否为<code>Huge类型</code>，如果是则将占用的chunk释放，同时从AG(mm_heap)-&gt;huge_list链表中删除。</p>\n<h5 id=\"5-2-Large内存的释放\"><a href=\"#5-2-Large内存的释放\" class=\"headerlink\" title=\"5.2 Large内存的释放\"></a>5.2 Large内存的释放</h5><p>若计算得到的offset不等于0，则表示该地址是Large内存或者Small内存，然后根据offset值进一步计算出属于第几个page<br><u>计算方法：根据offset除page的大小取整，的到<code>page_num</code>，的到<code>page</code>页码后就可以从<code>chunk-&gt;map</code>中获取该<code>page</code>的分配类型，知道是何种粒度的内存了。</u></p>\n<p>Large内存，<u>并不会直接释放物理内存</u>，只是将对应的page的分配信息重新设置为未分配。若释放page后，<u>当前chunk下所有的page都是未分配的，则会释放chunk</u>，释放时优先选择把chunk移到<code>AG(mm_heap)-&gt;cached_chunks</code>缓存队列中，缓存数达到一定值后就不在继续缓存新加入的chunk，将内存归还系统，便面占用过多的资源。<br>（分配chunk时，如果发现cached_chunks中有缓存的chunk,就直接取出使用，不再向系统申请。）</p>\n<h5 id=\"5-3-Small内存的释放\"><a href=\"#5-3-Small内存的释放\" class=\"headerlink\" title=\"5.3 Small内存的释放\"></a>5.3 Small内存的释放</h5><p>若待释放的地址为Small内存，则会将释放的slot插入到该规格slot可用链表的头部，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/9141601D64BF4D76AF0A211F55A479A2?method=download&shareKey=7df69cd6f617df511be8d5f87c7a58f4\" alt=\"释放slot\"></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>在C语言中，通常直接使用malloc进行内存的分配，而频繁的分配、释放内存无疑会产生内存碎片，降低系统性能。PHP自己实现了一套内存池（<code>ZendMM</code>：<code>Zend Memery Manager</code>）用于替换<code>glibc</code>的<code>malloc</code>、<code>free</code>，以解决内存频繁分配、释放的问题。</p>","more":"<p>内存池技术主要作用：</p>\n<ul>\n<li>①、减少内存分配及释放的次数</li>\n<li>②、有效控制内存碎片的产生</li>\n</ul>\n<p>PHP的内存池的实现参考了<code>tcmalloc</code>的设计，<code>tcmalloc</code>是<code>Google</code>开源的一个非常优秀的内存分配器。</p>\n<p>内存池是PHP内核中最底层的内存操作，他是非常独立的一个模块，可以移植到其他C语言应用中去。  </p>\n<p><strong>内存池定义了三种粒度的内存块</strong>：</p>\n<ul>\n<li><strong>chunk</strong>：每个chunk的大小为2M</li>\n<li><strong>page</strong>：page的大小为4KB，每个chunk被切割为512个page（2048/4）</li>\n<li><strong>slot</strong>：一个或若干个page被切割为多个slot</li>\n</ul>\n<p>申请内存时按照不同的申请大小决定具体的分配策略：</p>\n<ul>\n<li><strong>Huge(chunk)</strong>:申请内存大于2MB，<u>直接调用系统分配</u>，分配若干个chunk.(&gt;2MB)</li>\n<li>**Large(page)**：申请内<del>存大于3092B</del>（即page大小的3/4, 4 * 1024 * 3/4 = 3072B）,小于2044KB（即511个page的大小），分配若干个page。(3072B~2044KB)</li>\n<li><strong>Small(slot)</strong>:申请内存小于等于3092B(即page大小的3/4)，<u>内存池提前定义好了30种同等大小的内存（8、16、24、32…3072）,它们分配在不同的page上（不同大小的内存可能会分配在多个连续的page），申请内存时直接在对应的page上查找可用的slot</u>。(&lt;3092B)</li>\n</ul>\n<p>内存池通过<strong>zend_mm_heap</strong>结构存储内存池的主要信息，比如<code>大内存链表</code>、<code>chunk链表</code>、<code>slot各大小内存链表</code>等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> AG(v) (alloc_globals.v)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> zend_alloc_globals alloc_globals;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// file:zend_alloc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_heap</span> <span class=\"title\">zend_mm_heap</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_heap</span> &#123;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_CUSTOM</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                use_custom_heap;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STORAGE</span></span><br><span class=\"line\">\tzend_mm_storage   *storage;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STAT</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前已使用的内存数</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             size;                    <span class=\"comment\">/* current memory usage */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 内存单次申请的峰值</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             peak;                    <span class=\"comment\">/* peak memory usage */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部</span></span><br><span class=\"line\">\tzend_mm_free_slot *free_slot[ZEND_MM_BINS]; <span class=\"comment\">/* free lists for small sizes */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 大内存链表</span></span><br><span class=\"line\">\tzend_mm_huge_list *huge_list;               <span class=\"comment\">/* list of huge allocated blocks */</span></span><br><span class=\"line\">    <span class=\"comment\">// 指向chunk链表头部</span></span><br><span class=\"line\">\tzend_mm_chunk     *main_chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 缓存的chunk链表</span></span><br><span class=\"line\">\tzend_mm_chunk     *cached_chunks;\t\t\t<span class=\"comment\">/* list of unused chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 已分配的chunk数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                chunks_count;\t\t\t<span class=\"comment\">/* number of alocated chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当前request使用chunk峰值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                peak_chunks_count;\t\t<span class=\"comment\">/* peak number of allocated chunks for current request */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 缓存的chunk数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                cached_chunks_count;\t\t<span class=\"comment\">/* number of cached chunks */</span></span><br><span class=\"line\">\t<span class=\"comment\">// chunk使用均值，每次请求结束后会根据peak_chunk_count重新计算：(avg_chunks_count + peak_chunks_count)/2.0</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span>             avg_chunks_count;\t\t<span class=\"comment\">/* average number of chunks allocated per request */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                last_chunks_delete_boundary; <span class=\"comment\">/* numer of chunks after last deletion */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                last_chunks_delete_count;    <span class=\"comment\">/* number of deletion over the last boundary */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>大内存分配的是若干个chunk，然后通过一个<code>zend_mm_huge_list结构</code>进行管理，<strong>大内存之间构成一个单向链表</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>  _<span class=\"title\">zend_mm_huge_list</span> <span class=\"title\">zend_mm_huge_list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_huge_list</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>              *ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span>             size;</span><br><span class=\"line\">\tzend_mm_huge_list *next;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">\tzend_mm_debug_info dbg;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/48872B5FBB994E018B73A4AF38B466CE?method=download&shareKey=b96499c0e19a3b8b9803bcfe2f50d9eb\" alt=\"huge_list链表\"></p>\n<p><u>chunk是内存池向系统申请、释放内存的最小粒度。</u><code>chunk</code>之间构成双向链表，第一个chunk的地址保存于<code>zend_mm_heap-&gt;main_chunk</code>。</p>\n<p>每个chunk的大小为2MB，被切割为512个page，所以每个page的大小为4KB，其中第一个page的内存用于chunk自己的结构体成员，主要记录chunk的一些信息，比如前后chunk的指针，当前chunk上各个page的使用情况等。</p>\n<p>chunk的定义结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_mm_chunk</span> &#123;</span></span><br><span class=\"line\">\tzend_mm_heap      *heap;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向下一个chunk</span></span><br><span class=\"line\">\tzend_mm_chunk     *next;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向上一个chunk</span></span><br><span class=\"line\">\tzend_mm_chunk     *prev;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前chunk的剩余可用page数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                free_pages;\t\t\t\t<span class=\"comment\">/* number of free pages */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                free_tail;               <span class=\"comment\">/* number of free pages at the end of chunk */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>                num;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>               reserve[<span class=\"number\">64</span> - (<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*) * <span class=\"number\">3</span> + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * <span class=\"number\">3</span>)];</span><br><span class=\"line\">\t<span class=\"comment\">// heap结构，只有主chunk会用到（即第一个chunk）</span></span><br><span class=\"line\">\tzend_mm_heap       heap_slot;               <span class=\"comment\">/* used only in main chunk */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 标识各page是否已使用的bitmap，总大小为512bit，对应page总数，每个page占一个bit位。</span></span><br><span class=\"line\">\tzend_mm_page_map   free_map;                <span class=\"comment\">/* 512 bits or 64 bytes */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 各page的信息：当前page使用类型（用于large分配还是small）、占用的page数等</span></span><br><span class=\"line\">\tzend_mm_page_info  <span class=\"built_in\">map</span>[ZEND_MM_PAGES];      <span class=\"comment\">/* 2 KB = 512 * 4 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>slot内存是把若干个page按照固定大小分割好的内存块。</p>\n<p><strong>内存池定义了30中大小的slot内存</strong>：8、16、24、32…1792、2048、3072.这些slot的大小是有规律的。</p>\n<ul>\n<li>①、最小的slot大小为8byte</li>\n<li>②、前8个slot一次递增8byte（0~7递增 8byte）</li>\n<li>③、后面每隔4个递增值乘以2（8<del>11递增16byte、12</del>15递增32byte、16<del>19递增64byte、20</del>23递增128byte、24<del>27递增256byte、28</del>30递增512byte）</li>\n</ul>\n<p>每种大小的slot占用的page数不相同的：</p>\n<ul>\n<li><p>①、slot0~15各占1个page</p>\n</li>\n<li><p>②、slot16~29分别占5、3、1、1、5、3、2、2、5、3、7、4、5、3个page；<br>  注：这个值实际也是有规律可循的，其算法为，目的是为了减少内存的碎片。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page的个数 &#x3D; 最小公倍数(slot对应的内存大小, page的大小即4096) &#x2F; 4096</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<pre><code>分配各个规格的slot时会按照各这个配置申请对应的数量的page，然后进行分割组成链表。&lt;u&gt;相同大小的slot之间构成单链表&lt;/u&gt;。</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_mm_free_slot &#123;</span><br><span class=\"line\">\tzend_mm_free_slot *next_free_slot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>heap、huge、chunk、page、slot之间的关系如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/A8793900579C4D84A8CCE6E131F70B04?method=download&shareKey=7c1b42213c6357aae7855f4bcc43c78c\" alt=\"heap、huge、chunk、page、slot结构关系\"></p>\n<h4 id=\"2-内存池的初始化\"><a href=\"#2-内存池的初始化\" class=\"headerlink\" title=\"2 内存池的初始化\"></a>2 内存池的初始化</h4><p>初始化过程主要是<code>分配heap结构</code>，<u>如果是多线程环境，则会为每一个线程分配一个内存池，线程之间互不影响</u>。</p>\n<p>注：<u><code>zend_mm_heap</code>这个结构不是单独分配的，它嵌在<code>chunk</code>结构体中（即<code>heap_slot</code>成员）</u>。也就是说内存池初始化时是分配了一个chunk结构，<code>zend_mm_chunk-&gt;heap_slot</code>作为内存池的heap结构，这个chunk也是第一个chunk，即main_chunk,如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/1598F914D6D043A2928403E3B65280FE?method=download&shareKey=fa722c4892712fb681baea9ac6c93cf8\" alt=\"zend_mm_heap结构的分配\"></p>\n<p><strong>问题：为什么内存时的heap结构要嵌在chunk中而不是单独分配呢？</strong><br>因为每个chunk的第一个page始终是给chunk结构体自己使用的，剩下的511个page才会做内存分配，但是chunk结构体并不需要一个page那么大的内存。也就是说被占用的page会有剩余的空间，因此，为了尽可能利用空间，就将heap结构嵌在了chunk中。</p>\n<p>具体的分配过成在zend_mm_init()中实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file:zend_alloc.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_mm_heap *<span class=\"title\">zend_mm_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 向系统申请2MB大小的chunk</span></span><br><span class=\"line\">\tzend_mm_chunk *chunk = (zend_mm_chunk*)zend_mm_chunk_alloc_int(ZEND_MM_CHUNK_SIZE, ZEND_MM_CHUNK_SIZE);</span><br><span class=\"line\">\tzend_mm_heap *heap;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(chunk == <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_ERROR</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _WIN32</span></span><br><span class=\"line\">\t\tstderr_last_error(<span class=\"string\">&quot;Can&#x27;t initialize heap&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;\\nCan&#x27;t initialize heap: [%d] %s\\n&quot;</span>, errno, strerror(errno));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// heap结构实际数主chunk嵌入的一个结构，后面再分配的chunk的heap_slot不再使用</span></span><br><span class=\"line\">\theap = &amp;chunk-&gt;heap_slot;</span><br><span class=\"line\">\tchunk-&gt;heap = heap;</span><br><span class=\"line\">\tchunk-&gt;next = chunk;</span><br><span class=\"line\">\tchunk-&gt;prev = chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 剩余可用page数</span></span><br><span class=\"line\">\tchunk-&gt;free_pages = ZEND_MM_PAGES - ZEND_MM_FIRST_PAGE;</span><br><span class=\"line\">\tchunk-&gt;free_tail = ZEND_MM_FIRST_PAGE;</span><br><span class=\"line\">\tchunk-&gt;num = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"comment\">// 将第一个page的bit分配标识位设置为1，表示已经被分配、占用</span></span><br><span class=\"line\">\tchunk-&gt;free_map[<span class=\"number\">0</span>] = (Z_L(<span class=\"number\">1</span>) &lt;&lt; ZEND_MM_FIRST_PAGE) - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一个page的类型为ZEND_MM_IS_LRUN,即large内存</span></span><br><span class=\"line\">\tchunk-&gt;<span class=\"built_in\">map</span>[<span class=\"number\">0</span>] = ZEND_MM_LRUN(ZEND_MM_FIRST_PAGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 指向主chunk</span></span><br><span class=\"line\">\theap-&gt;main_chunk = chunk;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化剩下的一些成员</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// huge内存链表</span></span><br><span class=\"line\">\theap-&gt;huge_list = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-内存的分配\"><a href=\"#3-内存的分配\" class=\"headerlink\" title=\"3 内存的分配\"></a>3 内存的分配</h4><p>Huge大内存的分配过程比较简单、而Large与Small内存分配涉及到page的查找操作，过程稍显复杂。</p>\n<p>使用<code>emalloc</code>申请时，内存池会按照申请内存的大小自动选择那种格内存进行分配，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/1C273A1B04A44C379427B94CBE2A42FB?method=download&shareKey=d5059f5c0dafd673a661edf8efe31120\" alt=\"内存的分配流程\"></p>\n<h5 id=\"3-1-Huge分配\"><a href=\"#3-1-Huge分配\" class=\"headerlink\" title=\"3.1 Huge分配\"></a>3.1 Huge分配</h5><p>Huge是指超多2MB大小内存的分配，<u>实际分配时将对齐到n个chunk</u>，分配完还会分配一个zend_mm_huge_list结构，用于管理所有的Huge内存。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_alloc_huge</span><span class=\"params\">(zend_mm_heap *heap, <span class=\"keyword\">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ZEND_WIN32</span></span><br><span class=\"line\">\t<span class=\"comment\">/* On Windows we don&#x27;t have ability to extend huge blocks in-place.</span></span><br><span class=\"line\"><span class=\"comment\">\t * We allocate them with 2MB size granularity, to avoid many</span></span><br><span class=\"line\"><span class=\"comment\">\t * reallocations when they are extended by small pieces</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t <span class=\"comment\">// 按页大小重置实际要分配的内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> new_size = ZEND_MM_ALIGNED_SIZE_EX(size, MAX(REAL_PAGE_SIZE, ZEND_MM_CHUNK_SIZE));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> new_size = ZEND_MM_ALIGNED_SIZE_EX(size, REAL_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_LIMIT</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果有内存使用限制，则检查是否已达上限，达到的话进行zend_mm_gc清理后再检查</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (UNEXPECTED(heap-&gt;real_size + new_size &gt; heap-&gt;limit)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (zend_mm_gc(heap) &amp;&amp; heap-&gt;real_size + new_size &lt;= heap-&gt;limit) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* pass */</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (heap-&gt;overflow == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">#<span class=\"keyword\">if</span> ZEND_DEBUG</span><br><span class=\"line\">\t\t\tzend_mm_safe_error(heap, <span class=\"string\">&quot;Allowed memory size of %zu bytes exhausted at %s:%d (tried to allocate %zu bytes)&quot;</span>, heap-&gt;limit, __zend_filename, __zend_lineno, size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\tzend_mm_safe_error(heap, <span class=\"string\">&quot;Allowed memory size of %zu bytes exhausted (tried to allocate %zu bytes)&quot;</span>, heap-&gt;limit, size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 分配chunk()，系统返回的地址是随机的，并不一定是ZEND_MM_CHUNK_ZIZE的整数倍，内存池需要自己移动到对齐的位置，比如：返回地址ptr是2000，而最近的一个对齐地址是2048，内存池会把ptr移动到2048，从这个位置使用。</span></span><br><span class=\"line\">\tptr = zend_mm_chunk_alloc(heap, new_size, ZEND_MM_CHUNK_SIZE);</span><br><span class=\"line\">   </span><br><span class=\"line\">    ... </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">    <span class=\"comment\">// 将申请的内存通过zend_mm_huge_list插入到链表中</span></span><br><span class=\"line\">\tzend_mm_add_huge_block(heap, ptr, new_size, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\tzend_mm_add_huge_block(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了Huge分配以外，分配chunk内存也是Large、Small内存分配的基础，<u>它是ZendMM向系统申请内存的唯一粒度</u>。</p>\n<p>注：<em>分配chunk时，会将内存地址对齐到chunk的大小2MB（<code>ZEND_MM_THUNK_SIZE</code>）。也就是说，分配的chunk地址都是<code>ZEND_MM_THUNK_SIZE</code>的整数倍。（<strong>实际上这个对齐并不是由系统简单的完成，而是需要内存池在申请内存后自己进行调整！</strong>）</em></p>\n<p><code>ZendMM</code>具体处理对齐的方法是：</p>\n<ul>\n<li>①、按实际要申请的内存大小申请一次<ul>\n<li>若系统分配的地址恰好是ZEND_MM_CHUNK_SIZE的整数倍，则不需要调整，直接返回。</li>\n<li>若系统分配的地址不是ZEND_MM_CHUNK_SIZE的整数倍，则需要使用第②步进行调整。</li>\n</ul>\n</li>\n<li>②、调整方式：<ul>\n<li>首先ZendMM会将这块内存释放掉；</li>\n<li>按照“<code>实际要申请的内存大小 + ZEND_MM_CHUNK_SIZE</code>”的大小重新申请一块内存，多申请的ZEND_MM_CHUNK大小的内存是用来调整的<code>，ZendMM</code>会从系统分配的地址向后偏移到最近一个<code>ZEND_MM_CHUNK_SIZE的整数倍</code>位置，调整完之后再把剩余的内存释放掉。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_chunk_alloc_int</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> alignment)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 向系统申请size大小的内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_mmap(size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ptr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ZEND_MM_ALIGNED_OFFSET(ptr, alignment) == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 判断申请的内存是都为alignment的整数倍，是的话直接返回</span></span><br><span class=\"line\">#ifdef MADV_HUGEPAGE</span><br><span class=\"line\">\t    madvise(ptr, size, MADV_HUGEPAGE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 申请的内存不是按照alignment对齐的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> offset;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将申请的内存释放掉重新申请</span></span><br><span class=\"line\">\t\tzend_mm_munmap(ptr, size);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 重新申请一块内存，这里会多申请一块内存，用于截取到alignment的整数倍，可以忽略REAL_PAGE_SIZE</span></span><br><span class=\"line\">\t\tptr = zend_mm_mmap(size + alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _WIN32</span></span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\tzend_mm_munmap(ptr, size + alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\">\t\tptr = zend_mm_mmap_fixed((<span class=\"keyword\">void</span>*)((<span class=\"keyword\">char</span>*)ptr + (alignment - offset)), size);</span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (offset != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tzend_mm_munmap(ptr, size);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        <span class=\"comment\">// offset为ptr距离上一个alignment对齐内存位置的大小，注意不能往前移，因为前面的内存都是分配了的。</span></span><br><span class=\"line\">\t\toffset = ZEND_MM_ALIGNED_OFFSET(ptr, alignment);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (offset != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\toffset = alignment - offset;</span><br><span class=\"line\">\t\t\tzend_mm_munmap(ptr, offset);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 偏移ptr，对齐到alignment</span></span><br><span class=\"line\">\t\t\tptr = (<span class=\"keyword\">char</span>*)ptr + offset;</span><br><span class=\"line\">\t\t\talignment -= offset;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (alignment &gt; REAL_PAGE_SIZE) &#123;</span><br><span class=\"line\">\t\t\tzend_mm_munmap((<span class=\"keyword\">char</span>*)ptr + size, alignment - REAL_PAGE_SIZE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">ifdef</span> MADV_HUGEPAGE</span></span><br><span class=\"line\">\t    madvise(ptr, size, MADV_HUGEPAGE);</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中用到了<code>ZEND_MM_ALIGNED_OFFSET宏</code>，这个宏的作用是计算按alignment对齐的内存地址距离上一个alignment整数倍内存地址的大小，也就是offset偏移量。</p>\n<p><strong>alignment必须是2的n次方</strong>，比如一段<code>n*alignment</code>大小的内存，ptr为其中一个位置，那么就可以通过位运算计算得到ptr在所属alignment内存块中的offset，如下图所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define ZEND_MM_ALIGNED_OFFSET(size, alignment) \\</span><br><span class=\"line\">\t(((size_t)(size)) &amp; ((alignment) - 1))</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/9940B8821F1E4B19B2783B68381DFD5C?method=download&shareKey=8e13fe6980c3aa04d6cf3c97f1522b9d\" alt=\"相对对齐值的内存offset\"></p>\n<p>这个位运算是因为<code>alignment</code>为<code>2^n</code>（用二进制表示即为第n个位上为1，其余位为0，当alignment-1相当于将除了第n位为0，其余低位全部为1），所以通过alignment取到最低的位置，也就是相对上一个整数倍的alignment的offset，非位运算算式如下，但效率没有位运算高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offset &#x3D; ptr - (ptr&#x2F;alignment取整 * alignment)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-Large分配\"><a href=\"#3-2-Large分配\" class=\"headerlink\" title=\"3.2 Large分配\"></a>3.2 Large分配</h5><p>当申请的内存大于3072B、小于2044KB时，内存池会选择在chunk上查找对应数量的page返回。<u>Large内存申请的粒度是page，也就是分配n页连续的page</u>，所以Large分配的过程就转化为在chunk上查找n页连续可用的page的过程。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline <span class=\"keyword\">void</span> *<span class=\"title\">zend_mm_alloc_large</span><span class=\"params\">(zend_mm_heap *heap, <span class=\"keyword\">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据size大小计算需要分配多少个page</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> pages_count = (<span class=\"keyword\">int</span>)ZEND_MM_SIZE_TO_NUM(size, ZEND_MM_PAGE_SIZE);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_DEBUG</span></span><br><span class=\"line\">    <span class=\"comment\">// 分配page_count个page</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_alloc_pages(heap, pages_count, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr = zend_mm_alloc_pages(heap, pages_count ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> ZEND_MM_STAT</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> size = heap-&gt;size + pages_count * ZEND_MM_PAGE_SIZE;</span><br><span class=\"line\">\t\t<span class=\"keyword\">size_t</span> peak = MAX(heap-&gt;peak, size);</span><br><span class=\"line\">\t\theap-&gt;size = size;</span><br><span class=\"line\">\t\theap-&gt;peak = peak;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>chunk结构中有两个成员用于记录page分配信息：</p>\n<ul>\n<li><p><strong>free_map</strong>：类型为<code>zend_mm_page_map</code>，实际就是<code>zend_ulong_free_map[16/8]</code>，这是一个bitmap，总大小为64byte，也就是512bit，用于记录用当前chunk上512个page是否分配，512个page对应512bit，1表示已分配，0表示未分配。<br><img src=\"https://note.youdao.com/yws/api/personal/file/C879457EC2154FAEA678D562C217773B?method=download&shareKey=29d90ba60d479fdeccd33ac88325813a\" alt=\"free_map\"></p>\n</li>\n<li><p><strong>map</strong>：这个是一个可容纳512个类型为uint32_t元素的数组，<u>该数组用于记录各page的分配类型及分配的page页数</u>，每个page对应一个数组成员。Large内存、Small内存都会占用page，正是通过这个数组标识改page属于哪个类型（最高两位用于标识page的分配类型）：</p>\n<ul>\n<li>Large：01（0x40000000）</li>\n</ul>\n</li>\n<li><p>Small：10（0x80000000）</p>\n</li>\n</ul>\n<pre><code>  示例：申请12KB的内存，即3个page，内存池分配了page1，2，3，则map[1] = 0x400000000|3,如下图所示：\n  ![page的分配类型及页数](https://note.youdao.com/yws/api/personal/file/474A05B6CB2D401785FA0FAB75FB3E97?method=download&amp;shareKey=a1ce9cdd22022755fffe79243bd1db0e)</code></pre>\n<p>page分配时从第一个chunk开始遍历，依次查找各chunk是否有满足要求的page，如果当前chunk没有合适的，则进入下一chunk，如果直到最后都没有找到，则新分配一个chunk。<br><u>分配准则为：申请的page页数要尽可能地填满chunk的空隙</u>，也就是说尽可能的与分配了的page连在一起，避免中间出现page空隙。减少后续分配时的茶之后按次数，提高内存利用率。</p>\n<p>最优page的检索过程如下：</p>\n<ul>\n<li><p>step1：<br>首先从第一个page分组（page0~63）开始检查，如果当前分组无空闲page（即free_map[x]=-1）则进入下一分组，知道当前分组有空闲page，然后进入step2.</p>\n</li>\n<li><p>step2：<br>当前分组有可用page，首先检查当前page分组的bit位，找到第一个空闲page的位置，记做page_num，接着继续向下查找空闲page，知道遇到第一个已经分配的page位置，将最后一个空闲page位置记做<code>end_page_num</code>。（<em>注：查找end_page_num时并不局限在当前page分组内，会向下查找，直到最后一页。其查找做成主要依据free_map</em>），page_num至end_page_num为找到的可用page，接着判断找到的page页数是否够用：</p>\n<ul>\n<li>不够的情况：将page_num至end_page_num这些page的bit位标为1，也就是已分配，然后回到step1继续检索其他page分组。</li>\n<li>刚好是要申请的页数：直接使用，中断检索。</li>\n<li>page页数比申请的页数大，则表示可用，但不一定是最优的，将page_num暂存起来，接着回到step1继续向后找别的空闲page，最后比较选择best_len最小的，即能够最大程度填满page间隔<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* find first 0 bit */</span></span><br><span class=\"line\"> <span class=\"comment\">// tmp为当前page分组的bit位，i为当前分组第1个page的页码。</span></span><br><span class=\"line\">page_num = i + zend_mm_bitset_nts(tmp);</span><br><span class=\"line\"><span class=\"comment\">/* reset bits from 0 to &quot;bit&quot; */</span></span><br><span class=\"line\">tmp &amp;= tmp + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">/* skip free blocks */</span></span><br><span class=\"line\"><span class=\"comment\">// 快速跳过剩余page全部可用的分组</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (tmp == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\ti += ZEND_MM_BITSET_LEN;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i &gt;= free_tail || i == ZEND_MM_PAGES) &#123;</span><br><span class=\"line\">\t\tlen = ZEND_MM_PAGES - page_num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (len &gt;= pages_count &amp;&amp; len &lt; best_len) &#123;</span><br><span class=\"line\">\t\t\tchunk-&gt;free_tail = page_num + pages_count;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* set accurate value */</span></span><br><span class=\"line\">\t\t\tchunk-&gt;free_tail = page_num;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (best &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tpage_num = best;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> not_found;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前分组剩下的page都是可用的，直接跳到下一分组</span></span><br><span class=\"line\">\ttmp = *(<span class=\"built_in\">bitset</span>++);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* find first 1 bit */</span></span><br><span class=\"line\"><span class=\"comment\">// 找到第一个已分配page</span></span><br><span class=\"line\">len = i + zend_mm_bitset_ntz(tmp) - page_num;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (len &gt;= pages_count) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (len == pages_count) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> found;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &lt; best_len) &#123;</span><br><span class=\"line\">\t\tbest_len = len;</span><br><span class=\"line\">\t\tbest = page_num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* set bits from 0 to &quot;bit&quot; */</span></span><br><span class=\"line\"><span class=\"comment\">// 把找到的这些page标为已分配，注：此时tmp已经经过tmp &amp;= tmp + 1处理</span></span><br><span class=\"line\">\ttmp |= tmp - <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n示例：当前某个chunk的page分配情况如下图中的A所示，page：0，1，2，6，9，10已经分配占用，接下来要申请2页的page。<br><img src=\"https://note.youdao.com/yws/api/personal/file/335A8945237E483EAD280F5A26DED219?method=download&shareKey=29b8b43bfeb58653a22ace5a4562f538\" alt=\"page的查找过程\"></li>\n</ul>\n</li>\n<li><p>step3：<br> 最后没找到合适的page页后设置对应page的分配信息，即free_map、map,然后返回找到第一页page的地址</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   found:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (steps &gt; <span class=\"number\">2</span> &amp;&amp; pages_count &lt; <span class=\"number\">8</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* move chunk into the head of the linked-list */</span></span><br><span class=\"line\">\tchunk-&gt;prev-&gt;next = chunk-&gt;next;</span><br><span class=\"line\">\tchunk-&gt;next-&gt;prev = chunk-&gt;prev;</span><br><span class=\"line\">\tchunk-&gt;next = heap-&gt;main_chunk-&gt;next;</span><br><span class=\"line\">\tchunk-&gt;prev = heap-&gt;main_chunk;</span><br><span class=\"line\">\tchunk-&gt;prev-&gt;next = chunk;</span><br><span class=\"line\">\tchunk-&gt;next-&gt;prev = chunk;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* mark run as allocated */</span></span><br><span class=\"line\">chunk-&gt;free_pages -= pages_count;</span><br><span class=\"line\">zend_mm_bitset_set_range(chunk-&gt;free_map, page_num, pages_count);</span><br><span class=\"line\">chunk-&gt;<span class=\"built_in\">map</span>[page_num] = ZEND_MM_LRUN(pages_count);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (page_num == chunk-&gt;free_tail) &#123;</span><br><span class=\"line\">\tchunk-&gt;free_tail = page_num + pages_count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> ZEND_MM_PAGE_ADDR(chunk, page_num);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h5 id=\"3-3-Small分配\"><a href=\"#3-3-Small分配\" class=\"headerlink\" title=\"3.3 Small分配\"></a>3.3 Small分配</h5><p>Small内存在分配时，首先检查申请规格的内存是否已经分配，如果没有分配或者分配的已经用完了，则申请相应页数的page，page的分配过成与Larg分配完全一致，申请到page以后按固定大小将page切割为slot，slot之间构成单链表，链表头部保存至<code>AG(mm_heap)-&gt;free_slot</code>；如果对应的slot已经分配，则直接返回<code>AG(mm_heap)-&gt;free_slot</code>。  </p>\n<p>示例：16byte、3072byte大小的slot，将分别申请1个、3个page、然后切割为256个16byte的slot，以及4个3072byte的slot，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/4345829756E149EEAB1C4DE3928C76AC?method=download&shareKey=c358be1e7b73c1ff04ccac1eb772c992\" alt=\"slot[1]与slot[29]链表\"></p>\n<h4 id=\"4-系统内存分配\"><a href=\"#4-系统内存分配\" class=\"headerlink\" title=\"4 系统内存分配\"></a>4 系统内存分配</h4><p><u>内存池向系统申请内存的最小粒度是chunk</u>，通过mmap()来申请。</p>\n<h4 id=\"5-内存释放\"><a href=\"#5-内存释放\" class=\"headerlink\" title=\"5 内存释放\"></a>5 内存释放</h4><p>内存释放主要通过<code>efree()</code>来完成，内存池会根据释放的内存地址自动判断属于哪种粒度的内存，从而执行不同的释放逻辑。</p>\n<p><strong>问：内存池是如何只根据一个地址就判断出改地址属于哪种内存类型的呢？</strong><br>因为chunk分配时是按照ZEND_MM_CHUNK_SIZE（即2MB）对齐的，也就是chunk的起始内存地址一定是ZEND_MM_CHUNK_SIZE的整数倍，所以可以根据chunk上的任意位置知道chunk的起始位置与所在page。</p>\n<h5 id=\"5-1-Huge内存的释放\"><a href=\"#5-1-Huge内存的释放\" class=\"headerlink\" title=\"5.1 Huge内存的释放\"></a>5.1 Huge内存的释放</h5><p>首先，根据释放地址ptr计算该机制相对chunk起始位置的内存偏移量，这个值通过宏ZEND_MM_ALIGNED_OFFSET()的到，通过位运算计算的到。  </p>\n<p>示例：ptr = 0x7ffff7c01000，计算的到offset = 4096</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offet &#x3D; ptr &amp; (alignment - 1) &#x3D; 0x7ffff7c01000 &amp; 0x1fffff &#x3D; 0x1000 &#x3D; 4096</span><br></pre></td></tr></table></figure>\n\n<p><u>Huge内存能够完全使用chunk，也就是Huge内存地址相对chunk的offset一定等于0，而Large、Small内存因为chunk的第1个page被占用了，所以这两种内存的offset不可能为0.</u></p>\n<p>内存池根据offset值判断出释放的内存是否为<code>Huge类型</code>，如果是则将占用的chunk释放，同时从AG(mm_heap)-&gt;huge_list链表中删除。</p>\n<h5 id=\"5-2-Large内存的释放\"><a href=\"#5-2-Large内存的释放\" class=\"headerlink\" title=\"5.2 Large内存的释放\"></a>5.2 Large内存的释放</h5><p>若计算得到的offset不等于0，则表示该地址是Large内存或者Small内存，然后根据offset值进一步计算出属于第几个page<br><u>计算方法：根据offset除page的大小取整，的到<code>page_num</code>，的到<code>page</code>页码后就可以从<code>chunk-&gt;map</code>中获取该<code>page</code>的分配类型，知道是何种粒度的内存了。</u></p>\n<p>Large内存，<u>并不会直接释放物理内存</u>，只是将对应的page的分配信息重新设置为未分配。若释放page后，<u>当前chunk下所有的page都是未分配的，则会释放chunk</u>，释放时优先选择把chunk移到<code>AG(mm_heap)-&gt;cached_chunks</code>缓存队列中，缓存数达到一定值后就不在继续缓存新加入的chunk，将内存归还系统，便面占用过多的资源。<br>（分配chunk时，如果发现cached_chunks中有缓存的chunk,就直接取出使用，不再向系统申请。）</p>\n<h5 id=\"5-3-Small内存的释放\"><a href=\"#5-3-Small内存的释放\" class=\"headerlink\" title=\"5.3 Small内存的释放\"></a>5.3 Small内存的释放</h5><p>若待释放的地址为Small内存，则会将释放的slot插入到该规格slot可用链表的头部，如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/9141601D64BF4D76AF0A211F55A479A2?method=download&shareKey=7df69cd6f617df511be8d5f87c7a58f4\" alt=\"释放slot\"></p>"},{"title":"PHP7内核-变量","date":"2020-08-21T08:28:40.000Z","_content":"\n\n\n#### 变量的内部实现\n​\t\t变量是一个语言实现的基础，变量有两个组成部分：变量名、变量值，PHP中可以将其对应为：`zval`、`zend_value`，这两个概念一定要区分开，PHP中变量的内存是通过`引用计数`进行管理的，而且**PHP7中引用计数是在`zend_value`而不是zval上，变量之间的传递、赋值通常也是针对zend_value**。\n\n<!--more-->\n\nPHP中可以通过`$关键词`定义一个变量：`$a;`，在定义的同时可以进行初始化：`$a = \"hi~\";`<u>注意这实际是两步：定义、初始化</u>，只定义一个变量也是可以的，可以不给它赋值，比如：\n\n```php\n$a;\n$b = 1;\n```\n这段代码在执行时会分配两个zval。\n\n#### 变量的基础结构\n```c\n//zend_types.h\ntypedef struct _zval_struct     zval;\nstruct _zval_struct {\n    zend_value        value; //变量实际的value\n    union {\n        struct {\n            ZEND_ENDIAN_LOHI_4(  //这个是为了兼容大小字节序，小字节序就是下面的顺序，大字节序则下面4个顺序翻转\n                zend_uchar    type,         //变量类型\n                zend_uchar    type_flags,  //类型掩码，不同的类型会有不同的几种属性，内存管理会用到\n                zend_uchar    const_flags,\n                zend_uchar    reserved)     //call info，zend执行流程会用到\n        } v;\n        uint32_t type_info; //上面4个值的组合值，可以直接根据type_info取到4个对应位置的值\n    } u1;\n    union {\n        uint32_t     var_flags;\n        uint32_t     next;                 //哈希表中解决哈希冲突时用到\n        uint32_t     cache_slot;           /* literal cache slot 运行时缓存会用到*/ \n        uint32_t     lineno;               /* line number (for ast nodes) */\n        uint32_t     num_args;             /* arguments number for EX(This) */\n        uint32_t     fe_pos;               /* foreach position foreach遍历时会用到*/\n        uint32_t     fe_iter_idx;          /* foreach iterator index */\n    } u2; //一些辅助值\n};\n```\n`\t\tzval`结构比较简单，内嵌一个union类型的`zend_value`保存具体变量类型的值或指针，zval中还有两个union：`u1`、`u2`:\n\n- **u1**: 它是联合了一个结构体`v`和一个32位无符号整型`type_info`；ZEND_ENDIAN_LOHI_4是一个宏，用于解决字节序问题的，他会根据系统字节序决定struct v中4个成员的顺序。v定义了4个成员变量，**变量的类型就通过u1.v.type区分**；另外一个值`type_flags`为类型掩码，在变量的内存管理、gc机制中会用到；至于后面两个const_flags、reserved暂且不管。\n- **u2**: 这个值纯粹是个辅助值，zval结构中value、u1分别占了8byte、4byte，一共12byte，假如zval只有:value、u1两个值，整个zval的大小也会对齐到16byte，既然不管有没有u2大小都是16byte，把多余的4byte拿出来用于一些特殊用途还是很划算的，比如next在哈希表解决哈希冲突时会用到，还有fe_pos在foreach会用到......  \n\n```c\ntypedef union _zend_value {\n    zend_long         lval;    //int整形\n    double            dval;    //浮点型\n    zend_refcounted  *counted;\n    zend_string      *str;     //string字符串\n    zend_array       *arr;     //array数组\n    zend_object      *obj;     //object对象\n    zend_resource    *res;     //resource资源类型\n    zend_reference   *ref;     //引用类型，通过&$var_name定义的\n    zend_ast_ref     *ast;     //下面几个都是内核使用的value\n    zval             *zv;\n    void             *ptr;\n    zend_class_entry *ce;\n    zend_function    *func;\n    struct {\n        uint32_t w1;\n        uint32_t w2;\n    } ww;\n} zend_value;\n\n```\n​\t\t`zend_value`是一个联合体，各个类型根据自己的类型选择使用不同的成员，**从zend_value可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构**。zend_value中没有布尔型，这是因为PHP7中将布尔型具体拆分为了true、false两种类型，通过zval.u1.v.type进行区分（注：老版本中，布尔型是通过整型进行区分的）\n\n#### 类型\n`zval.u1.type`类型：\n\n```c\n/* regular data types */\n#define IS_UNDEF                    0\n#define IS_NULL                     1\n#define IS_FALSE                    2\n#define IS_TRUE                     3\n#define IS_LONG                     4\n#define IS_DOUBLE                   5\n#define IS_STRING                   6\n#define IS_ARRAY                    7\n#define IS_OBJECT                   8\n#define IS_RESOURCE                 9\n#define IS_REFERENCE                10\n\n/* constant expressions */\n#define IS_CONSTANT                 11\n#define IS_CONSTANT_AST             12\n\n/* fake types */\n#define _IS_BOOL                    13\n#define IS_CALLABLE                 14\n\n/* internal types */\n#define IS_INDIRECT                 15\n#define IS_PTR                      17\n```\n\n##### 标量类型\n- 没有value，直接根据type区分的类型：`true`、`false`、`null`\n- 值存于value中，无需额外的value指针：`zend_long`、 `double`\n\n##### 字符串（zend_string）\n​\t\tPHP中没有使用`char`来表示字符串，而是为字符串单独定义了一个结构`zend_string`，其中除了存储字符串内容，还存储了其他信息。\n```c\nstruct _zend_string {\n    zend_refcounted_h gc; // 变量引用计数信息，用于内存管理。比如当前value的引用数，所有用到引用计数的变量类型都会有这个结构\n    zend_ulong        h;  /* hash value 哈希值，数组中计算索引时会用到*/\n    size_t            len; // 字符串长度，通过这个值保证二进制安全\n    char              val[1]; // 字符串内容，变长struct，分配时按len长度申请内存\n};\n```\n​\t\t字符串内容`val`是一个可变数组，在字符串分配时的操作为`malloc(sizeof(zend_string) + 字符串长度)`。\n*注：val中多出一个字节（val[1]而不是val[0]）用于存储字符串的最后一个字符\"\\0\".*\n\n例如：$a=\"abc\"，对应zend_string内存结构如下：\n![zend_string内存结构](https://note.youdao.com/yws/api/personal/file/39A4055CBC584591A643CF8855653427?method=download&shareKey=100018cf52486ade9a25e3f4d8227678)\n\n\n字符串具体分类：\n- `IS_STR_PERSISTENT`: 通过malloc分配。\n- `IS_STR_INTERNED`: php代码中写的一些字面量，如函数名、变量名。\n- `IS_STR_PERMERNENT`:永久值，生命周期大于request。\n- `IS_STR_CONSTANT`:常量。\n- `IS_STR_CONSTANT_UNQUALIFIED`:这个信息通过flag保存：zval.value->gc.u.flags\n\n##### 数组（array）\n​\t\t`Array`是PHP中非常强大的一个数据结构，它的**底层实现为散列表（HashTable 哈希表）**。\n​\t\t散列表是根据`key`直接进行访问的数据结构，它的`key-value`之间有一个映射函数，可以根据key通过映射函数直接索引到对应的value值，直接根据`“内存起始地址+偏移值”`进行寻址，加快查找速度。理想情况下，查找的期望时间复杂度为O(1).\n\n\n\nHashTable的数据结构如下:\n\n```c\ntypedef struct _zend_array HashTable;\n\nstruct _zend_array {\n    zend_refcounted_h gc; //引用计数信息，与字符串相同\n    // 提供一些辅助的功能，比如，flag用来设置散列表的一些属性，是否持久化、是否已经初始化。\n    union {\n        struct {\n            ZEND_ENDIAN_LOHI_4(\n                zend_uchar    flags,\n                zend_uchar    nApplyCount,\n                zend_uchar    nIteratorsCount,\n                zend_uchar    reserve)\n        } v;\n        uint32_t flags;\n    } u;\n    // 用于散列函数映射存储元素在arData数组中的下标。其值实际是nTableSize的负数，即nTableMask=-nTableSize（nTableMask=~nTableSize+1）\n    uint32_t          nTableMask; //计算bucket索引时的掩码\n    // 存储元素数组，每个元素的结构统一为Bucket，其内存是连续的，arData指向第一个Bucket（即指向数组的起始位置）\n    Bucket           *arData; //bucket数组\n    // 当前已使用的Bucket数，但这些Bucket并不都是有效的，因此再删除一个数组元素时，并不会马上将其从数组中移除，而是将这个元素的类型表位IS_UNDEF，只有在数组容量超过限制，需要扩容时才会删除。\n    uint32_t          nNumUsed; \n    // 数组实际存储的元素数（有效元素数）。\n    uint32_t          nNumOfElements; //已有元素数，nNumOfElements <= nNumUsed，因为删除的并不是直接从arData中移除\n    // 数组的总容量，其大小为2的幂次方，最小为8（即2^3）。\n    uint32_t          nTableSize; //数组的大小，为2^n\n    uint32_t          nInternalPointer; //数值索引\n    // 下一个可用的数值索引，如arr[]=1;arr['a']=2;arr[]=3;则nNextFreeElement=2；该成员是给自动确定数值索引使用的。\n    zend_long         nNextFreeElement;\n    // 当删除或覆盖数组中的某个元素时，若提供了这个函数句柄，则会回调此函数。\n    dtor_func_t       pDestructor;\n};\n```\n\n\nBucket的结构如下,主要用来保存元素的key及value。\n\n```c\ntypedef struct _Bucket {\n    // 存储的具体的value，这里嵌入了一个zval而不是一个指针。\n\tzval              val;\n\t// hash code，用来映射元素的存储位置。若元素是数值索引，那么他的值就是数值索引的值；若是字符串，那么这个只就是根据字符串key通过Time33算法计算得到的散列值。\n\tzend_ulong        h;                /* hash value (or numeric index)   */\n\t// 存储元素的key。\n\tzend_string      *key;              /* string key or NULL for numerics */\n} Bucket;\n```\n###### 基本实现\n散列表主要由两部分组成：\n- 存储元素数组\n- 散列函数\n一个简单的散列函数可以采用取模的方式，比如散列表的大小为8，那么在散列表初始化数组时就会分配8个元素大小的空间，根据key的hash code与8取模的到的值作为该元素在数组中的下标。其示意图如下：\n\n![散列表的基本实现](https://note.youdao.com/yws/api/personal/file/F2CB6F384907410BB02F7F7411F4E341?method=download&shareKey=fc47b2317eb268543f1440ed7296beb0)\n\n**以散列函数的输出值作为该元素在存储元素数组中的下标的方式有一个问题: **元素在数组中的位置是随机的，它是无序的。\n\n\n\n- **问：那么PHP是如何保证元素的顺序与其插入顺序一致？** \n  \t\t为了实现散列表的有序性，PHP在散列函数与元素数组之间加了一层映射表，该映射表也是一个数组，大小与存储元素的数组相同，它存储的元素类型为整型，用于保存实际存储的有序数组中的下标：**元素按照先后顺序依次插入实际存储的数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中**，如下图所示。\n\n![散列表映射关系](https://note.youdao.com/yws/api/personal/file/A8DBDBE3688A48739E06BF38ACDA300F?method=download&shareKey=6e4969019969485debc917c11a87da4d)\n\n原理如上，但实际上PHP是将这个映射表与arData放在一起，在数组初始化时会分配存储Bucket的内存，同时还会分配相同数量的uint32_t大小的空间，将arData偏移到存储元素数组的位置，这个中间映射表可以通过arData向前访问到。如下图所示：\n![HashTable中间映射表](https://note.youdao.com/yws/api/personal/file/358B60D6F6AA407E9B034BACE5E8ACB6?method=download&shareKey=e515e9d30e617ea6c6fa8b9475a9efeb)\n\n###### 散列函数\n​\t\t通常散列会数会以取模的方式给出，比如：`key->h%nTableSize`.但是PHP采用了另一种方式，因为散列表的大小为2的幂次方，所以通过**或运算**可以得到`[-1,nTableMask]`之间的散列值。\n```\nnIndex = h | ht->nTableMask\n```\n\n\neg：\n\n```\nh=18003212\nnTableSize=8\n\nnTableMask=-8\nnIndex=-4\n```\n\n\n\n###### 数组的初始化\n\n​\t\t数组初始化的过程主要是对`HashTable`中的成员进行设置，初始化时并不会立即分配`arData`的内存，`arData`的内存在**插入第一个元素时才会分配**。\n```c\nZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n    // 初始化gc信息\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\t// 设置flags\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\t// nTableMask的值是临时的\n\tht->nTableMask = HT_MIN_MASK;\n\t// 临时设置ht->arData\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n\t// 把数组的大小重置为2的幂次方\n\tht->nTableSize = zend_hash_check_size(nSize);\n}\n```\n###### 插入\n​\t\t插入时，会检查数组是否已经分配存储空间。PHP会在第一次插入时根据`nTableSize`的大小分配，分配完成后把`HashTable->u.flags`打上`HASH_FLAG_INITIALIZAED`掩码。\n\n- 分配内存  \n分配的内存包括映射表及元素数组：\n```\nnTableSize * (sizeof(Bucket) + sizeof(uint32_t))\n```\n分配完成后，将`HashTable->arData`指向第一个`Bucket`的位置。\n\n- 插入数据  \n将元素按照顺序插入`arData`，然后将其在`arData`数组中的位置存储到根据`key`的`hash code`（即`key->h`）与`nTableMask`计算得到的中间映射表中的对应位置。\n```c\nzend_hash.c\n// _zend_hash_add_or_update_i:\nadd_to_hash:\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\t// idx为Bucket在arData中存储位置\n\tidx = ht->nNumUsed++;\n\tht->nNumOfElements++;\n\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\tht->nInternalPointer = idx;\n\t}\n\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);\n\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t}\n\t// 找到存储Bucket，设置key、value\n\tp = ht->arData + idx;\n\tp->h = h;\n\tp->key = NULL;\n\t// 计算中间映射表的散列值，idx将保存在映射数组的nIndex位置\n\tnIndex = h | ht->nTableMask;\n\t// 将映射表中原来的值保存到新Bucket中，哈希冲突时会用到\n\tZVAL_COPY_VALUE(&p->val, pData);\n\t// 先把旧的值保存到新插入的元素中\n\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t// 再把新元素数组存储位置更新到映射表中\n\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn &p->val;\n```\n###### 哈希冲突\n​\t\t散列表中不同元素的`key`可能计算得到相同的哈希值，这些具有相同哈希值的元素在插入散列表时就会发生冲突，因为映射表只能存储一个元素。  \n**常见的解决方式（PHP采用这种方式）：将冲突的Bucket串成链表，查找时需要遍历这个链表，逐个比较`key`，从而找到目标元素。**\n\n- 具体操作：\n  \t\t`HashTable`中的`Bucket`会记录与它冲突的元素在`arData`数组中的存储位置。在设置映射值时，如果发现映射表中要设置的位置已经被之前插入的元素占用了（值不等于初始化的-1），那么会把已经存在的值保存到新插入的`Bucket`中，然后将映射表中的值更新为新`Bucket`的存储位置（即每次都会把冲突的元素插到开头）。  \n  **冲突元素的保存位置为：**`Bucket.val.u2.next`\n\n\n\n**示例**：一个数组有三个元素，按照a、b、c的顺序插入，加入a、c两个key冲突了，则HashTable的结构如下：\n$arr = [];\n$arr['a'] = 11;\n$arr['b'] = 22;\n$arr['c'] = 33;\n![哈希冲突链表](https://note.youdao.com/yws/api/personal/file/C469391F27FF454698CCD908B98FB2B2?method=download&shareKey=9501d4a7b3029c279f3d545c7f9c18e2)\n\n###### 查找\n查找过程如下：\n- ①、根据`key`计算出`hash code`（即`zend_string->h`）与`nTableMask`计算得到散列值`nIndex`。\n- ②、根据散列值从中间映射表中得到存储元素在有序存储数组中的位置`idx`。\n- ③、根据`idx`从有序存储数组（`HashTable->arData`）中取出`Bucket`\n- ④、从取出的`Bucket`进行遍历，判断Bucket的key是否是要查找的key，若是则停止遍历，否则继续根据`zval.u2.next`遍历比较。\n\n```c\n// zend_hash_find_bucket:\n// 根据zend_string *key进行查找\nstatic zend_always_inline Bucket *zend_hash_find_bucket(const HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\th = zend_string_hash_val(key);\n\tarData = ht->arData;\n\t// 计算散列值\n\tnIndex = h | ht->nTableMask;\n\t// 获取Bucket存储位置\n\tidx = HT_HASH_EX(arData, nIndex);\n    // 遍历\n\twhile (EXPECTED(idx != HT_INVALID_IDX)) {\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif (EXPECTED(p->key == key)) { /* check for the same interned string */\n\t\t\treturn p;\n\t\t} else if (EXPECTED(p->h == h) && // 先比较hash code\n\t\t     EXPECTED(p->key) && \n\t\t     // 在比较key长度，最后按字符比较是否相同\n\t\t     EXPECTED(ZSTR_LEN(p->key) == ZSTR_LEN(key)) &&\n\t\t     EXPECTED(memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {// 比较查找的key与Bucket的key是否匹配\n\t\t\treturn p;\n\t\t}\n\t\t// 不匹配则继续遍历\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n```\n\n\n###### 扩容\n\n​\t\t数组的容量是有限的，最多可以存储`nTableSize`个元素，那么当数组空间已满还要继续插入时如何处理？  \n\n\n\n**问: PHP是怎样实现的自动扩容？**\n\n​\t\t**扩容的过程为**：检查数组中已经删除的元素所占的比例（已经删除但未从存储数组中移除的元素）.若比例达到域值，则触发**重建索引**的操作，这个过程会把删除的Bucket移除，然后把后面的Bucket往前移补上空缺的Bucket；若还没有达到域值，则分配一个原数组大小2倍的新数组，然后把原数组的元素复制到新数组上，重建索引。 \n\n\n<u>域值判断公式</u>如下，即域值为`nNumOfElement + (nNumElement / 32)`\n\n```\nht->nNumUsed > ht->nNumOfElement + (ht->nNumOfElement >> 5)\n```\n\n具体的处理过程：\n```c\nstatic void ZEND_FASTCALL zend_hash_do_resize(HashTable *ht)\n{\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed > ht->nNumOfElements + (ht->nNumOfElements >> 5)) { // 无序扩容，将删除的Bucket移除，然后把后面的bucket往前补上空缺\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t// 只有到达一定域值才进行rehash操作\n\t\tzend_hash_rehash(ht); // 重建索引数组\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else if (ht->nTableSize < HT_MAX_SIZE) { // 扩容，分配原数组大小2倍的新数组。\n\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\t// 扩大为2倍，加法比乘法快\n\t\tuint32_t nSize = ht->nTableSize + ht->nTableSize;\n\t\tBucket *old_buckets = ht->arData;\n\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t// 新分配arData空间，大小为(sizeof(Bucket) + sizeof(uint32_t)) * nSize;\n\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\tht->nTableSize = nSize;\n\t\tht->nTableMask = -ht->nTableSize;\n\t    // 将arData指针偏移到Bucket数组起始位置\n\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\t// 将旧的Bucket数组复制到新空间（此步只复制存储的元素，即HashTable->arData，不会复制中间映射表，因为扩容后旧的映射表已无法使用，key-value的映射关系需要重新计算，即重建索引）\n\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\t// 释放旧空间\n\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\t// 重建索引数组：映射表\n\t\tzend_hash_rehash(ht);\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", ht->nTableSize * 2, sizeof(Bucket) + sizeof(uint32_t), sizeof(Bucket));\n\t}\n}\n```\n重建索引的过程实际上就是将所有元素重新插入一遍，其处理过程如下：\n```\n// 遍历数组，重新设置中间映射表（索引表）\n    do {\n\t\t\tnIndex = p->h | ht->nTableMask;\n\t\t\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);\n\t\t\tp++;\n\t\t} while (++i < ht->nNumUsed);\n```\n重建索引会将已删除的bucket移除，移除后会把这个Bucket之后的元素全部向前移动一个位置，所以**重建索引后存储数组中元素全部紧密排列在一起**。\n\n\n\n##### 引用\n\n​\t\t引用类型是PHP中比较特殊的一种类型，它实际是指向另外一个PHP变量（*在PHP中通过`&操作符`产生一个引用变量*），对它的修改会直接改动实际指向的zval，<u>可以简单的理解为C中的指针</u>。  \n\n操作步骤：\n\n- 首先为`&`操作的变量分配一个`zend_reference结构`，其内嵌一个`zval`，这个`zval`的`value`指向原来`zval`的`value`(**注: 如果是布尔、整形、浮点则直接复制原来的值**)。\n- 然后将原`zval`的类型修改为`IS_REFERENCE`，原`zval`的`value`指向新创建的`zend_reference`结构。\n```\nstruct _zend_reference {\n    zend_refcounted_h gc;\n    zval              val; // 指向原来的value\n};\n```\n示例1：\n```\n$a = date('Y-m-d');\n$b = &$a;\n```\n![a与b内存引用关系](https://note.youdao.com/yws/api/personal/file/A5F4C7219117457A88A7D7CC3AFB53A9?method=download&shareKey=3d6950341fd9f21fea74f78f022500fd)\n\n**注：若此时将`$b`复制给其他变量，那么传递给新变量的value将实时及引用的值，而不是引用本身**。PHP中的引用只有一级，不会出现一个引用指向另外一个引用的情况，即没有C语言中多级指针的概念。\n\n```\n$a = date('Y-m-d');\n$b = &$a;\n$c = $b; // 若想让$c也指向$a/$b引用的值，则：$c = &$b或$c = &$a;\n```\n![a,b与c内存引用关系](https://note.youdao.com/yws/api/personal/file/1E8C8DDDE51D479296CA8F63EA5353B7?method=download&shareKey=43183c8018d3140f9b924508528c2af2)\n\n\n示例2：\n```\n$a = \"time:\" . time();      //$a    -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n```\n![zend_ref](https://note.youdao.com/yws/api/personal/file/697F728B851442D4AF142554DDF78333?method=download&shareKey=59d725805b5b7c8bc59c391e87607101)\n\n注意：**引用只能通过`&`产生，无法通过赋值传递**  \n\n例：\n\n```\nerror:\n$a = \"time:\" . time();      //$a    -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n$c = $b;                    //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=2)\n                            //$c    -> \nright:\n$a = \"time:\" . time();      //$a       -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b    -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n$c = &$b;/*或$c = &$a*/     //$a,$b,$c -> zend_reference_1(refcount=3) -> zend_string_1(refcount=1)                             \n```\n这个也表示PHP中的 **引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况** ，也就是没有C语言中指针的指针的概念。\n\n\n\n##### 对象/资源\n对象比较常见，资源指的是tcp连接、文件句柄等等类型。\n```\nstruct _zend_object {\n    zend_refcounted_h gc;\n    uint32_t          handle;\n    zend_class_entry *ce; //对象对应的class类\n    const zend_object_handlers *handlers;\n    HashTable        *properties; //对象属性哈希表\n    zval              properties_table[1];\n};\n\nstruct _zend_resource {\n    zend_refcounted_h gc;\n    int               handle;\n    int               type;\n    void             *ptr;\n};\n```\n\n##### 类型转换\n​\t\tPHP是弱类型语言，使用时不需要明确定义变量的类型，Zend虚拟机在执行PHP代码时，会根据具体的应用场景进行转换，也就是变量会按照类型转换规则将不合格变量转换给合格的变量，然后进行操作。\n\n例:\n```\n$a = \"100\" + 200\n```\n执行时Zend发现相加的一个值为字符串，就会试图将`字符串100`转为数值类型（整型或浮点型），然后与200相加。  \n**注：转换的时候并不会改变原来的值，而是会生成一个新的变量进行处理。**\n\n\n\n###### 强制转换\n\nPHP提供了一种强制转换方式：\n- (int)/(integer): 转换为整型integer\n- (bool)/(boolean):转换为布尔类型boolean\n- (flaot)/(double)/(real):转换为浮点型flaot\n- (string):转换为字符串string\n- (array):转换为数组array\n- (object):转换为对象object\n- (unset):转换为null\n\n*注：有些类型之间是无法转换的，如：资源类型，无法将任何类型转换为资源类型。*\n\n###### 转换为null\n​\t\t任意类型都可以转为null，转换时直接将新的`zval类型`设置为`IS_NULL`。\n\n\n\n###### 转换为布尔型\n\n​\t\t当转换为布尔型时，根据原值的`true`、`false`决定转换后的结果，一些值被认为是`false`，除此之外的其他值通常被认为是`true`。\n\n被认为是false的值:\n\n- 布尔值false本身\n- 整型0\n- 浮点型值0.0\n- ==空字符串（‘’），以及字符串‘0’==\n- 空数组\n- null\n\n\n\n###### 转换为整型\n\n从`其他值`转换为`整型`的规则如下：\n- null：转换为0\n- 布尔型：false转为0，true转为1\n- 浮点型：向下取整，比如，(int)2.8 = 2\n- 字符串：与C语言strtoll()的规则一致\n    - 字符串以合法数值(包含正负数)开始，就使用该数值\n    - **否则，其值为0**\n- 数组：很多操作不支持将一个数组自动转为整型处理，比如array()+2将报error错误，但可以强制把数组转为整型：\n    - 非空数组：1\n    - 空数组：0\n```php\nphp > $a = array()+2;\nPHP Fatal error:  Unsupported operand types in php shell code on line 1\nPHP Stack trace:\nPHP   1. {main}() php shell code:0\nPHP   2. {main}() php shell code:0\nphp > \nphp > $a = array();\nphp > $b = (int)$a;\nphp > echo $b;\n0\n```\n- 对象：与数组类似，很多操作也不支持将兑现个自动转为整型，但有些操作只会抛一个warning警告，还是会把对象转换为1.\n- 资源：转为分配给这个资源的唯一编号\n\n\n\n###### 转为浮点型\n\n​\t\t除了字符串类型外，其他类型转换规则与整型基本一致，只是在整型转换结果上加了小数位，字符串转为浮点数有`zend_strtod`完成。\n\n\n\n###### 转换为字符串\n\n- 强制转换：\n    - (string)\n    - strval()函数\n- 自动转换：\n    - 需要字符串的表达式中，比如：函数echo或print时\n    - 非string类型变量与一个string变量进行比较时\n        - null/fasle:转为空字符串\n        - true：转为“1”\n        - 整型：原样转为字符串，**转换时将各位一次除10取余**\n        - 浮点型：原样转为字符串\n        - 资源：转为“Resource id#xxx”\n        - 数组：转为“Array”，同时报Notice\n        - 对象：不能转换，将报错,如下：\n        ```php\n        php > class A \n        php > {public $b;}\n        php > \n        php > $a = new A();\n        php > \n        php > echo 'a= ' . $a;\n        PHP Catchable fatal error:  Object of class A could not be converted to string in php shell code on line 1\n        PHP Stack trace:\n        PHP   1. {main}() php shell code:0\n        ```\n###### 转换为数组\n- 若变量类型为`null`、`integer`、`float`、`string`、`boolean`和`resource`中的一个：将得到一个仅有一个元素的数组，其`下标为0`，即(array)$scalarValue与`array($scalarValue)`完全一样。\n- 若变量类型为object：其结果为一个数组，数组的元素为该对象的全部属性（包含public、private、protected），但他们也是有区别的，如下：\n    - public的属性：key\n    - private的属性：key加类型作为前缀\n    - protected的属性：'*'加key作为前缀\n    ```\n    class test\n    {\n        public $a = 123;\n        private $b = 'bbb';\n        protected $c = 'ccc';\n    }\n\n    $test = new test();\n    print_r((array)$test);\n    ```\n    以上例子将输出：\n    ```\n    $php stat.php \n    Array\n    (\n        [a] => 123\n        [testb] => bbb\n        [*c] => ccc\n    )\n    ```\n\n###### 转换为对象\n其他任何类型的值被转换为对象，将会创建一个内置类stdClass的实例：\n- 若该值为null：新的实例为空\n- array：转换成的object将以键名成为属性名，并具有相对应的值\n    - 数值索引的元素也将转为属性，但无法通过“->”访问，只能遍历获取\n    - 非数值索引：会以‘scalar’作为属性名","source":"_posts/PHP7内核-变量.md","raw":"---\ntitle: PHP7内核-变量\ndate: 2020-08-21 16:28:40\ntags: [\"PHP\"]\ncategories: [\"PHP\"]\n---\n\n\n\n#### 变量的内部实现\n​\t\t变量是一个语言实现的基础，变量有两个组成部分：变量名、变量值，PHP中可以将其对应为：`zval`、`zend_value`，这两个概念一定要区分开，PHP中变量的内存是通过`引用计数`进行管理的，而且**PHP7中引用计数是在`zend_value`而不是zval上，变量之间的传递、赋值通常也是针对zend_value**。\n\n<!--more-->\n\nPHP中可以通过`$关键词`定义一个变量：`$a;`，在定义的同时可以进行初始化：`$a = \"hi~\";`<u>注意这实际是两步：定义、初始化</u>，只定义一个变量也是可以的，可以不给它赋值，比如：\n\n```php\n$a;\n$b = 1;\n```\n这段代码在执行时会分配两个zval。\n\n#### 变量的基础结构\n```c\n//zend_types.h\ntypedef struct _zval_struct     zval;\nstruct _zval_struct {\n    zend_value        value; //变量实际的value\n    union {\n        struct {\n            ZEND_ENDIAN_LOHI_4(  //这个是为了兼容大小字节序，小字节序就是下面的顺序，大字节序则下面4个顺序翻转\n                zend_uchar    type,         //变量类型\n                zend_uchar    type_flags,  //类型掩码，不同的类型会有不同的几种属性，内存管理会用到\n                zend_uchar    const_flags,\n                zend_uchar    reserved)     //call info，zend执行流程会用到\n        } v;\n        uint32_t type_info; //上面4个值的组合值，可以直接根据type_info取到4个对应位置的值\n    } u1;\n    union {\n        uint32_t     var_flags;\n        uint32_t     next;                 //哈希表中解决哈希冲突时用到\n        uint32_t     cache_slot;           /* literal cache slot 运行时缓存会用到*/ \n        uint32_t     lineno;               /* line number (for ast nodes) */\n        uint32_t     num_args;             /* arguments number for EX(This) */\n        uint32_t     fe_pos;               /* foreach position foreach遍历时会用到*/\n        uint32_t     fe_iter_idx;          /* foreach iterator index */\n    } u2; //一些辅助值\n};\n```\n`\t\tzval`结构比较简单，内嵌一个union类型的`zend_value`保存具体变量类型的值或指针，zval中还有两个union：`u1`、`u2`:\n\n- **u1**: 它是联合了一个结构体`v`和一个32位无符号整型`type_info`；ZEND_ENDIAN_LOHI_4是一个宏，用于解决字节序问题的，他会根据系统字节序决定struct v中4个成员的顺序。v定义了4个成员变量，**变量的类型就通过u1.v.type区分**；另外一个值`type_flags`为类型掩码，在变量的内存管理、gc机制中会用到；至于后面两个const_flags、reserved暂且不管。\n- **u2**: 这个值纯粹是个辅助值，zval结构中value、u1分别占了8byte、4byte，一共12byte，假如zval只有:value、u1两个值，整个zval的大小也会对齐到16byte，既然不管有没有u2大小都是16byte，把多余的4byte拿出来用于一些特殊用途还是很划算的，比如next在哈希表解决哈希冲突时会用到，还有fe_pos在foreach会用到......  \n\n```c\ntypedef union _zend_value {\n    zend_long         lval;    //int整形\n    double            dval;    //浮点型\n    zend_refcounted  *counted;\n    zend_string      *str;     //string字符串\n    zend_array       *arr;     //array数组\n    zend_object      *obj;     //object对象\n    zend_resource    *res;     //resource资源类型\n    zend_reference   *ref;     //引用类型，通过&$var_name定义的\n    zend_ast_ref     *ast;     //下面几个都是内核使用的value\n    zval             *zv;\n    void             *ptr;\n    zend_class_entry *ce;\n    zend_function    *func;\n    struct {\n        uint32_t w1;\n        uint32_t w2;\n    } ww;\n} zend_value;\n\n```\n​\t\t`zend_value`是一个联合体，各个类型根据自己的类型选择使用不同的成员，**从zend_value可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构**。zend_value中没有布尔型，这是因为PHP7中将布尔型具体拆分为了true、false两种类型，通过zval.u1.v.type进行区分（注：老版本中，布尔型是通过整型进行区分的）\n\n#### 类型\n`zval.u1.type`类型：\n\n```c\n/* regular data types */\n#define IS_UNDEF                    0\n#define IS_NULL                     1\n#define IS_FALSE                    2\n#define IS_TRUE                     3\n#define IS_LONG                     4\n#define IS_DOUBLE                   5\n#define IS_STRING                   6\n#define IS_ARRAY                    7\n#define IS_OBJECT                   8\n#define IS_RESOURCE                 9\n#define IS_REFERENCE                10\n\n/* constant expressions */\n#define IS_CONSTANT                 11\n#define IS_CONSTANT_AST             12\n\n/* fake types */\n#define _IS_BOOL                    13\n#define IS_CALLABLE                 14\n\n/* internal types */\n#define IS_INDIRECT                 15\n#define IS_PTR                      17\n```\n\n##### 标量类型\n- 没有value，直接根据type区分的类型：`true`、`false`、`null`\n- 值存于value中，无需额外的value指针：`zend_long`、 `double`\n\n##### 字符串（zend_string）\n​\t\tPHP中没有使用`char`来表示字符串，而是为字符串单独定义了一个结构`zend_string`，其中除了存储字符串内容，还存储了其他信息。\n```c\nstruct _zend_string {\n    zend_refcounted_h gc; // 变量引用计数信息，用于内存管理。比如当前value的引用数，所有用到引用计数的变量类型都会有这个结构\n    zend_ulong        h;  /* hash value 哈希值，数组中计算索引时会用到*/\n    size_t            len; // 字符串长度，通过这个值保证二进制安全\n    char              val[1]; // 字符串内容，变长struct，分配时按len长度申请内存\n};\n```\n​\t\t字符串内容`val`是一个可变数组，在字符串分配时的操作为`malloc(sizeof(zend_string) + 字符串长度)`。\n*注：val中多出一个字节（val[1]而不是val[0]）用于存储字符串的最后一个字符\"\\0\".*\n\n例如：$a=\"abc\"，对应zend_string内存结构如下：\n![zend_string内存结构](https://note.youdao.com/yws/api/personal/file/39A4055CBC584591A643CF8855653427?method=download&shareKey=100018cf52486ade9a25e3f4d8227678)\n\n\n字符串具体分类：\n- `IS_STR_PERSISTENT`: 通过malloc分配。\n- `IS_STR_INTERNED`: php代码中写的一些字面量，如函数名、变量名。\n- `IS_STR_PERMERNENT`:永久值，生命周期大于request。\n- `IS_STR_CONSTANT`:常量。\n- `IS_STR_CONSTANT_UNQUALIFIED`:这个信息通过flag保存：zval.value->gc.u.flags\n\n##### 数组（array）\n​\t\t`Array`是PHP中非常强大的一个数据结构，它的**底层实现为散列表（HashTable 哈希表）**。\n​\t\t散列表是根据`key`直接进行访问的数据结构，它的`key-value`之间有一个映射函数，可以根据key通过映射函数直接索引到对应的value值，直接根据`“内存起始地址+偏移值”`进行寻址，加快查找速度。理想情况下，查找的期望时间复杂度为O(1).\n\n\n\nHashTable的数据结构如下:\n\n```c\ntypedef struct _zend_array HashTable;\n\nstruct _zend_array {\n    zend_refcounted_h gc; //引用计数信息，与字符串相同\n    // 提供一些辅助的功能，比如，flag用来设置散列表的一些属性，是否持久化、是否已经初始化。\n    union {\n        struct {\n            ZEND_ENDIAN_LOHI_4(\n                zend_uchar    flags,\n                zend_uchar    nApplyCount,\n                zend_uchar    nIteratorsCount,\n                zend_uchar    reserve)\n        } v;\n        uint32_t flags;\n    } u;\n    // 用于散列函数映射存储元素在arData数组中的下标。其值实际是nTableSize的负数，即nTableMask=-nTableSize（nTableMask=~nTableSize+1）\n    uint32_t          nTableMask; //计算bucket索引时的掩码\n    // 存储元素数组，每个元素的结构统一为Bucket，其内存是连续的，arData指向第一个Bucket（即指向数组的起始位置）\n    Bucket           *arData; //bucket数组\n    // 当前已使用的Bucket数，但这些Bucket并不都是有效的，因此再删除一个数组元素时，并不会马上将其从数组中移除，而是将这个元素的类型表位IS_UNDEF，只有在数组容量超过限制，需要扩容时才会删除。\n    uint32_t          nNumUsed; \n    // 数组实际存储的元素数（有效元素数）。\n    uint32_t          nNumOfElements; //已有元素数，nNumOfElements <= nNumUsed，因为删除的并不是直接从arData中移除\n    // 数组的总容量，其大小为2的幂次方，最小为8（即2^3）。\n    uint32_t          nTableSize; //数组的大小，为2^n\n    uint32_t          nInternalPointer; //数值索引\n    // 下一个可用的数值索引，如arr[]=1;arr['a']=2;arr[]=3;则nNextFreeElement=2；该成员是给自动确定数值索引使用的。\n    zend_long         nNextFreeElement;\n    // 当删除或覆盖数组中的某个元素时，若提供了这个函数句柄，则会回调此函数。\n    dtor_func_t       pDestructor;\n};\n```\n\n\nBucket的结构如下,主要用来保存元素的key及value。\n\n```c\ntypedef struct _Bucket {\n    // 存储的具体的value，这里嵌入了一个zval而不是一个指针。\n\tzval              val;\n\t// hash code，用来映射元素的存储位置。若元素是数值索引，那么他的值就是数值索引的值；若是字符串，那么这个只就是根据字符串key通过Time33算法计算得到的散列值。\n\tzend_ulong        h;                /* hash value (or numeric index)   */\n\t// 存储元素的key。\n\tzend_string      *key;              /* string key or NULL for numerics */\n} Bucket;\n```\n###### 基本实现\n散列表主要由两部分组成：\n- 存储元素数组\n- 散列函数\n一个简单的散列函数可以采用取模的方式，比如散列表的大小为8，那么在散列表初始化数组时就会分配8个元素大小的空间，根据key的hash code与8取模的到的值作为该元素在数组中的下标。其示意图如下：\n\n![散列表的基本实现](https://note.youdao.com/yws/api/personal/file/F2CB6F384907410BB02F7F7411F4E341?method=download&shareKey=fc47b2317eb268543f1440ed7296beb0)\n\n**以散列函数的输出值作为该元素在存储元素数组中的下标的方式有一个问题: **元素在数组中的位置是随机的，它是无序的。\n\n\n\n- **问：那么PHP是如何保证元素的顺序与其插入顺序一致？** \n  \t\t为了实现散列表的有序性，PHP在散列函数与元素数组之间加了一层映射表，该映射表也是一个数组，大小与存储元素的数组相同，它存储的元素类型为整型，用于保存实际存储的有序数组中的下标：**元素按照先后顺序依次插入实际存储的数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中**，如下图所示。\n\n![散列表映射关系](https://note.youdao.com/yws/api/personal/file/A8DBDBE3688A48739E06BF38ACDA300F?method=download&shareKey=6e4969019969485debc917c11a87da4d)\n\n原理如上，但实际上PHP是将这个映射表与arData放在一起，在数组初始化时会分配存储Bucket的内存，同时还会分配相同数量的uint32_t大小的空间，将arData偏移到存储元素数组的位置，这个中间映射表可以通过arData向前访问到。如下图所示：\n![HashTable中间映射表](https://note.youdao.com/yws/api/personal/file/358B60D6F6AA407E9B034BACE5E8ACB6?method=download&shareKey=e515e9d30e617ea6c6fa8b9475a9efeb)\n\n###### 散列函数\n​\t\t通常散列会数会以取模的方式给出，比如：`key->h%nTableSize`.但是PHP采用了另一种方式，因为散列表的大小为2的幂次方，所以通过**或运算**可以得到`[-1,nTableMask]`之间的散列值。\n```\nnIndex = h | ht->nTableMask\n```\n\n\neg：\n\n```\nh=18003212\nnTableSize=8\n\nnTableMask=-8\nnIndex=-4\n```\n\n\n\n###### 数组的初始化\n\n​\t\t数组初始化的过程主要是对`HashTable`中的成员进行设置，初始化时并不会立即分配`arData`的内存，`arData`的内存在**插入第一个元素时才会分配**。\n```c\nZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n    // 初始化gc信息\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\t// 设置flags\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\t// nTableMask的值是临时的\n\tht->nTableMask = HT_MIN_MASK;\n\t// 临时设置ht->arData\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n\t// 把数组的大小重置为2的幂次方\n\tht->nTableSize = zend_hash_check_size(nSize);\n}\n```\n###### 插入\n​\t\t插入时，会检查数组是否已经分配存储空间。PHP会在第一次插入时根据`nTableSize`的大小分配，分配完成后把`HashTable->u.flags`打上`HASH_FLAG_INITIALIZAED`掩码。\n\n- 分配内存  \n分配的内存包括映射表及元素数组：\n```\nnTableSize * (sizeof(Bucket) + sizeof(uint32_t))\n```\n分配完成后，将`HashTable->arData`指向第一个`Bucket`的位置。\n\n- 插入数据  \n将元素按照顺序插入`arData`，然后将其在`arData`数组中的位置存储到根据`key`的`hash code`（即`key->h`）与`nTableMask`计算得到的中间映射表中的对应位置。\n```c\nzend_hash.c\n// _zend_hash_add_or_update_i:\nadd_to_hash:\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\t// idx为Bucket在arData中存储位置\n\tidx = ht->nNumUsed++;\n\tht->nNumOfElements++;\n\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\tht->nInternalPointer = idx;\n\t}\n\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);\n\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t}\n\t// 找到存储Bucket，设置key、value\n\tp = ht->arData + idx;\n\tp->h = h;\n\tp->key = NULL;\n\t// 计算中间映射表的散列值，idx将保存在映射数组的nIndex位置\n\tnIndex = h | ht->nTableMask;\n\t// 将映射表中原来的值保存到新Bucket中，哈希冲突时会用到\n\tZVAL_COPY_VALUE(&p->val, pData);\n\t// 先把旧的值保存到新插入的元素中\n\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t// 再把新元素数组存储位置更新到映射表中\n\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn &p->val;\n```\n###### 哈希冲突\n​\t\t散列表中不同元素的`key`可能计算得到相同的哈希值，这些具有相同哈希值的元素在插入散列表时就会发生冲突，因为映射表只能存储一个元素。  \n**常见的解决方式（PHP采用这种方式）：将冲突的Bucket串成链表，查找时需要遍历这个链表，逐个比较`key`，从而找到目标元素。**\n\n- 具体操作：\n  \t\t`HashTable`中的`Bucket`会记录与它冲突的元素在`arData`数组中的存储位置。在设置映射值时，如果发现映射表中要设置的位置已经被之前插入的元素占用了（值不等于初始化的-1），那么会把已经存在的值保存到新插入的`Bucket`中，然后将映射表中的值更新为新`Bucket`的存储位置（即每次都会把冲突的元素插到开头）。  \n  **冲突元素的保存位置为：**`Bucket.val.u2.next`\n\n\n\n**示例**：一个数组有三个元素，按照a、b、c的顺序插入，加入a、c两个key冲突了，则HashTable的结构如下：\n$arr = [];\n$arr['a'] = 11;\n$arr['b'] = 22;\n$arr['c'] = 33;\n![哈希冲突链表](https://note.youdao.com/yws/api/personal/file/C469391F27FF454698CCD908B98FB2B2?method=download&shareKey=9501d4a7b3029c279f3d545c7f9c18e2)\n\n###### 查找\n查找过程如下：\n- ①、根据`key`计算出`hash code`（即`zend_string->h`）与`nTableMask`计算得到散列值`nIndex`。\n- ②、根据散列值从中间映射表中得到存储元素在有序存储数组中的位置`idx`。\n- ③、根据`idx`从有序存储数组（`HashTable->arData`）中取出`Bucket`\n- ④、从取出的`Bucket`进行遍历，判断Bucket的key是否是要查找的key，若是则停止遍历，否则继续根据`zval.u2.next`遍历比较。\n\n```c\n// zend_hash_find_bucket:\n// 根据zend_string *key进行查找\nstatic zend_always_inline Bucket *zend_hash_find_bucket(const HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\th = zend_string_hash_val(key);\n\tarData = ht->arData;\n\t// 计算散列值\n\tnIndex = h | ht->nTableMask;\n\t// 获取Bucket存储位置\n\tidx = HT_HASH_EX(arData, nIndex);\n    // 遍历\n\twhile (EXPECTED(idx != HT_INVALID_IDX)) {\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif (EXPECTED(p->key == key)) { /* check for the same interned string */\n\t\t\treturn p;\n\t\t} else if (EXPECTED(p->h == h) && // 先比较hash code\n\t\t     EXPECTED(p->key) && \n\t\t     // 在比较key长度，最后按字符比较是否相同\n\t\t     EXPECTED(ZSTR_LEN(p->key) == ZSTR_LEN(key)) &&\n\t\t     EXPECTED(memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {// 比较查找的key与Bucket的key是否匹配\n\t\t\treturn p;\n\t\t}\n\t\t// 不匹配则继续遍历\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n```\n\n\n###### 扩容\n\n​\t\t数组的容量是有限的，最多可以存储`nTableSize`个元素，那么当数组空间已满还要继续插入时如何处理？  \n\n\n\n**问: PHP是怎样实现的自动扩容？**\n\n​\t\t**扩容的过程为**：检查数组中已经删除的元素所占的比例（已经删除但未从存储数组中移除的元素）.若比例达到域值，则触发**重建索引**的操作，这个过程会把删除的Bucket移除，然后把后面的Bucket往前移补上空缺的Bucket；若还没有达到域值，则分配一个原数组大小2倍的新数组，然后把原数组的元素复制到新数组上，重建索引。 \n\n\n<u>域值判断公式</u>如下，即域值为`nNumOfElement + (nNumElement / 32)`\n\n```\nht->nNumUsed > ht->nNumOfElement + (ht->nNumOfElement >> 5)\n```\n\n具体的处理过程：\n```c\nstatic void ZEND_FASTCALL zend_hash_do_resize(HashTable *ht)\n{\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed > ht->nNumOfElements + (ht->nNumOfElements >> 5)) { // 无序扩容，将删除的Bucket移除，然后把后面的bucket往前补上空缺\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t// 只有到达一定域值才进行rehash操作\n\t\tzend_hash_rehash(ht); // 重建索引数组\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else if (ht->nTableSize < HT_MAX_SIZE) { // 扩容，分配原数组大小2倍的新数组。\n\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\t// 扩大为2倍，加法比乘法快\n\t\tuint32_t nSize = ht->nTableSize + ht->nTableSize;\n\t\tBucket *old_buckets = ht->arData;\n\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t// 新分配arData空间，大小为(sizeof(Bucket) + sizeof(uint32_t)) * nSize;\n\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\tht->nTableSize = nSize;\n\t\tht->nTableMask = -ht->nTableSize;\n\t    // 将arData指针偏移到Bucket数组起始位置\n\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\t// 将旧的Bucket数组复制到新空间（此步只复制存储的元素，即HashTable->arData，不会复制中间映射表，因为扩容后旧的映射表已无法使用，key-value的映射关系需要重新计算，即重建索引）\n\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\t// 释放旧空间\n\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\t// 重建索引数组：映射表\n\t\tzend_hash_rehash(ht);\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", ht->nTableSize * 2, sizeof(Bucket) + sizeof(uint32_t), sizeof(Bucket));\n\t}\n}\n```\n重建索引的过程实际上就是将所有元素重新插入一遍，其处理过程如下：\n```\n// 遍历数组，重新设置中间映射表（索引表）\n    do {\n\t\t\tnIndex = p->h | ht->nTableMask;\n\t\t\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);\n\t\t\tp++;\n\t\t} while (++i < ht->nNumUsed);\n```\n重建索引会将已删除的bucket移除，移除后会把这个Bucket之后的元素全部向前移动一个位置，所以**重建索引后存储数组中元素全部紧密排列在一起**。\n\n\n\n##### 引用\n\n​\t\t引用类型是PHP中比较特殊的一种类型，它实际是指向另外一个PHP变量（*在PHP中通过`&操作符`产生一个引用变量*），对它的修改会直接改动实际指向的zval，<u>可以简单的理解为C中的指针</u>。  \n\n操作步骤：\n\n- 首先为`&`操作的变量分配一个`zend_reference结构`，其内嵌一个`zval`，这个`zval`的`value`指向原来`zval`的`value`(**注: 如果是布尔、整形、浮点则直接复制原来的值**)。\n- 然后将原`zval`的类型修改为`IS_REFERENCE`，原`zval`的`value`指向新创建的`zend_reference`结构。\n```\nstruct _zend_reference {\n    zend_refcounted_h gc;\n    zval              val; // 指向原来的value\n};\n```\n示例1：\n```\n$a = date('Y-m-d');\n$b = &$a;\n```\n![a与b内存引用关系](https://note.youdao.com/yws/api/personal/file/A5F4C7219117457A88A7D7CC3AFB53A9?method=download&shareKey=3d6950341fd9f21fea74f78f022500fd)\n\n**注：若此时将`$b`复制给其他变量，那么传递给新变量的value将实时及引用的值，而不是引用本身**。PHP中的引用只有一级，不会出现一个引用指向另外一个引用的情况，即没有C语言中多级指针的概念。\n\n```\n$a = date('Y-m-d');\n$b = &$a;\n$c = $b; // 若想让$c也指向$a/$b引用的值，则：$c = &$b或$c = &$a;\n```\n![a,b与c内存引用关系](https://note.youdao.com/yws/api/personal/file/1E8C8DDDE51D479296CA8F63EA5353B7?method=download&shareKey=43183c8018d3140f9b924508528c2af2)\n\n\n示例2：\n```\n$a = \"time:\" . time();      //$a    -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n```\n![zend_ref](https://note.youdao.com/yws/api/personal/file/697F728B851442D4AF142554DDF78333?method=download&shareKey=59d725805b5b7c8bc59c391e87607101)\n\n注意：**引用只能通过`&`产生，无法通过赋值传递**  \n\n例：\n\n```\nerror:\n$a = \"time:\" . time();      //$a    -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n$c = $b;                    //$a,$b -> zend_reference_1(refcount=2) -> zend_string_1(refcount=2)\n                            //$c    -> \nright:\n$a = \"time:\" . time();      //$a       -> zend_string_1(refcount=1)\n$b = &$a;                   //$a,$b    -> zend_reference_1(refcount=2) -> zend_string_1(refcount=1)\n$c = &$b;/*或$c = &$a*/     //$a,$b,$c -> zend_reference_1(refcount=3) -> zend_string_1(refcount=1)                             \n```\n这个也表示PHP中的 **引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况** ，也就是没有C语言中指针的指针的概念。\n\n\n\n##### 对象/资源\n对象比较常见，资源指的是tcp连接、文件句柄等等类型。\n```\nstruct _zend_object {\n    zend_refcounted_h gc;\n    uint32_t          handle;\n    zend_class_entry *ce; //对象对应的class类\n    const zend_object_handlers *handlers;\n    HashTable        *properties; //对象属性哈希表\n    zval              properties_table[1];\n};\n\nstruct _zend_resource {\n    zend_refcounted_h gc;\n    int               handle;\n    int               type;\n    void             *ptr;\n};\n```\n\n##### 类型转换\n​\t\tPHP是弱类型语言，使用时不需要明确定义变量的类型，Zend虚拟机在执行PHP代码时，会根据具体的应用场景进行转换，也就是变量会按照类型转换规则将不合格变量转换给合格的变量，然后进行操作。\n\n例:\n```\n$a = \"100\" + 200\n```\n执行时Zend发现相加的一个值为字符串，就会试图将`字符串100`转为数值类型（整型或浮点型），然后与200相加。  \n**注：转换的时候并不会改变原来的值，而是会生成一个新的变量进行处理。**\n\n\n\n###### 强制转换\n\nPHP提供了一种强制转换方式：\n- (int)/(integer): 转换为整型integer\n- (bool)/(boolean):转换为布尔类型boolean\n- (flaot)/(double)/(real):转换为浮点型flaot\n- (string):转换为字符串string\n- (array):转换为数组array\n- (object):转换为对象object\n- (unset):转换为null\n\n*注：有些类型之间是无法转换的，如：资源类型，无法将任何类型转换为资源类型。*\n\n###### 转换为null\n​\t\t任意类型都可以转为null，转换时直接将新的`zval类型`设置为`IS_NULL`。\n\n\n\n###### 转换为布尔型\n\n​\t\t当转换为布尔型时，根据原值的`true`、`false`决定转换后的结果，一些值被认为是`false`，除此之外的其他值通常被认为是`true`。\n\n被认为是false的值:\n\n- 布尔值false本身\n- 整型0\n- 浮点型值0.0\n- ==空字符串（‘’），以及字符串‘0’==\n- 空数组\n- null\n\n\n\n###### 转换为整型\n\n从`其他值`转换为`整型`的规则如下：\n- null：转换为0\n- 布尔型：false转为0，true转为1\n- 浮点型：向下取整，比如，(int)2.8 = 2\n- 字符串：与C语言strtoll()的规则一致\n    - 字符串以合法数值(包含正负数)开始，就使用该数值\n    - **否则，其值为0**\n- 数组：很多操作不支持将一个数组自动转为整型处理，比如array()+2将报error错误，但可以强制把数组转为整型：\n    - 非空数组：1\n    - 空数组：0\n```php\nphp > $a = array()+2;\nPHP Fatal error:  Unsupported operand types in php shell code on line 1\nPHP Stack trace:\nPHP   1. {main}() php shell code:0\nPHP   2. {main}() php shell code:0\nphp > \nphp > $a = array();\nphp > $b = (int)$a;\nphp > echo $b;\n0\n```\n- 对象：与数组类似，很多操作也不支持将兑现个自动转为整型，但有些操作只会抛一个warning警告，还是会把对象转换为1.\n- 资源：转为分配给这个资源的唯一编号\n\n\n\n###### 转为浮点型\n\n​\t\t除了字符串类型外，其他类型转换规则与整型基本一致，只是在整型转换结果上加了小数位，字符串转为浮点数有`zend_strtod`完成。\n\n\n\n###### 转换为字符串\n\n- 强制转换：\n    - (string)\n    - strval()函数\n- 自动转换：\n    - 需要字符串的表达式中，比如：函数echo或print时\n    - 非string类型变量与一个string变量进行比较时\n        - null/fasle:转为空字符串\n        - true：转为“1”\n        - 整型：原样转为字符串，**转换时将各位一次除10取余**\n        - 浮点型：原样转为字符串\n        - 资源：转为“Resource id#xxx”\n        - 数组：转为“Array”，同时报Notice\n        - 对象：不能转换，将报错,如下：\n        ```php\n        php > class A \n        php > {public $b;}\n        php > \n        php > $a = new A();\n        php > \n        php > echo 'a= ' . $a;\n        PHP Catchable fatal error:  Object of class A could not be converted to string in php shell code on line 1\n        PHP Stack trace:\n        PHP   1. {main}() php shell code:0\n        ```\n###### 转换为数组\n- 若变量类型为`null`、`integer`、`float`、`string`、`boolean`和`resource`中的一个：将得到一个仅有一个元素的数组，其`下标为0`，即(array)$scalarValue与`array($scalarValue)`完全一样。\n- 若变量类型为object：其结果为一个数组，数组的元素为该对象的全部属性（包含public、private、protected），但他们也是有区别的，如下：\n    - public的属性：key\n    - private的属性：key加类型作为前缀\n    - protected的属性：'*'加key作为前缀\n    ```\n    class test\n    {\n        public $a = 123;\n        private $b = 'bbb';\n        protected $c = 'ccc';\n    }\n\n    $test = new test();\n    print_r((array)$test);\n    ```\n    以上例子将输出：\n    ```\n    $php stat.php \n    Array\n    (\n        [a] => 123\n        [testb] => bbb\n        [*c] => ccc\n    )\n    ```\n\n###### 转换为对象\n其他任何类型的值被转换为对象，将会创建一个内置类stdClass的实例：\n- 若该值为null：新的实例为空\n- array：转换成的object将以键名成为属性名，并具有相对应的值\n    - 数值索引的元素也将转为属性，但无法通过“->”访问，只能遍历获取\n    - 非数值索引：会以‘scalar’作为属性名","slug":"PHP7内核-变量","published":1,"updated":"2020-08-30T12:42:36.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabn7006945g3eoff7nnz","content":"<h4 id=\"变量的内部实现\"><a href=\"#变量的内部实现\" class=\"headerlink\" title=\"变量的内部实现\"></a>变量的内部实现</h4><p>​        变量是一个语言实现的基础，变量有两个组成部分：变量名、变量值，PHP中可以将其对应为：<code>zval</code>、<code>zend_value</code>，这两个概念一定要区分开，PHP中变量的内存是通过<code>引用计数</code>进行管理的，而且<strong>PHP7中引用计数是在<code>zend_value</code>而不是zval上，变量之间的传递、赋值通常也是针对zend_value</strong>。</p>\n<a id=\"more\"></a>\n\n<p>PHP中可以通过<code>$关键词</code>定义一个变量：<code>$a;</code>，在定义的同时可以进行初始化：<code>$a = &quot;hi~&quot;;</code><u>注意这实际是两步：定义、初始化</u>，只定义一个变量也是可以的，可以不给它赋值，比如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a;</span><br><span class=\"line\">$b = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>这段代码在执行时会分配两个zval。</p>\n<h4 id=\"变量的基础结构\"><a href=\"#变量的基础结构\" class=\"headerlink\" title=\"变量的基础结构\"></a>变量的基础结构</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//zend_types.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span>     <span class=\"title\">zval</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span> &#123;</span></span><br><span class=\"line\">    zend_value        value; <span class=\"comment\">//变量实际的value</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_4(  <span class=\"comment\">//这个是为了兼容大小字节序，小字节序就是下面的顺序，大字节序则下面4个顺序翻转</span></span><br><span class=\"line\">                zend_uchar    type,         <span class=\"comment\">//变量类型</span></span><br><span class=\"line\">                zend_uchar    type_flags,  <span class=\"comment\">//类型掩码，不同的类型会有不同的几种属性，内存管理会用到</span></span><br><span class=\"line\">                zend_uchar    const_flags,</span><br><span class=\"line\">                zend_uchar    reserved)     <span class=\"comment\">//call info，zend执行流程会用到</span></span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> type_info; <span class=\"comment\">//上面4个值的组合值，可以直接根据type_info取到4个对应位置的值</span></span><br><span class=\"line\">    &#125; u1;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     var_flags;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     next;                 <span class=\"comment\">//哈希表中解决哈希冲突时用到</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     cache_slot;           <span class=\"comment\">/* literal cache slot 运行时缓存会用到*/</span> </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     lineno;               <span class=\"comment\">/* line number (for ast nodes) */</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     num_args;             <span class=\"comment\">/* arguments number for EX(This) */</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     fe_pos;               <span class=\"comment\">/* foreach position foreach遍历时会用到*/</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     fe_iter_idx;          <span class=\"comment\">/* foreach iterator index */</span></span><br><span class=\"line\">    &#125; u2; <span class=\"comment\">//一些辅助值</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>        zval</code>结构比较简单，内嵌一个union类型的<code>zend_value</code>保存具体变量类型的值或指针，zval中还有两个union：<code>u1</code>、<code>u2</code>:</p>\n<ul>\n<li><strong>u1</strong>: 它是联合了一个结构体<code>v</code>和一个32位无符号整型<code>type_info</code>；ZEND_ENDIAN_LOHI_4是一个宏，用于解决字节序问题的，他会根据系统字节序决定struct v中4个成员的顺序。v定义了4个成员变量，<strong>变量的类型就通过u1.v.type区分</strong>；另外一个值<code>type_flags</code>为类型掩码，在变量的内存管理、gc机制中会用到；至于后面两个const_flags、reserved暂且不管。</li>\n<li><strong>u2</strong>: 这个值纯粹是个辅助值，zval结构中value、u1分别占了8byte、4byte，一共12byte，假如zval只有:value、u1两个值，整个zval的大小也会对齐到16byte，既然不管有没有u2大小都是16byte，把多余的4byte拿出来用于一些特殊用途还是很划算的，比如next在哈希表解决哈希冲突时会用到，还有fe_pos在foreach会用到……  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> _zend_value &#123;</span><br><span class=\"line\">    zend_long         lval;    <span class=\"comment\">//int整形</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span>            dval;    <span class=\"comment\">//浮点型</span></span><br><span class=\"line\">    zend_refcounted  *counted;</span><br><span class=\"line\">    zend_string      *str;     <span class=\"comment\">//string字符串</span></span><br><span class=\"line\">    zend_array       *arr;     <span class=\"comment\">//array数组</span></span><br><span class=\"line\">    zend_object      *obj;     <span class=\"comment\">//object对象</span></span><br><span class=\"line\">    zend_resource    *res;     <span class=\"comment\">//resource资源类型</span></span><br><span class=\"line\">    zend_reference   *ref;     <span class=\"comment\">//引用类型，通过&amp;$var_name定义的</span></span><br><span class=\"line\">    zend_ast_ref     *ast;     <span class=\"comment\">//下面几个都是内核使用的value</span></span><br><span class=\"line\">    zval             *zv;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>             *ptr;</span><br><span class=\"line\">    zend_class_entry *ce;</span><br><span class=\"line\">    zend_function    *func;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> w1;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> w2;</span><br><span class=\"line\">    &#125; ww;</span><br><span class=\"line\">&#125; zend_value;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>​        <code>zend_value</code>是一个联合体，各个类型根据自己的类型选择使用不同的成员，<strong>从zend_value可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构</strong>。zend_value中没有布尔型，这是因为PHP7中将布尔型具体拆分为了true、false两种类型，通过zval.u1.v.type进行区分（注：老版本中，布尔型是通过整型进行区分的）</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><code>zval.u1.type</code>类型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* regular data types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_UNDEF                    0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_NULL                     1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_FALSE                    2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TRUE                     3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_LONG                     4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_DOUBLE                   5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_STRING                   6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_ARRAY                    7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_OBJECT                   8</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_RESOURCE                 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_REFERENCE                10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* constant expressions */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CONSTANT                 11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CONSTANT_AST             12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* fake types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _IS_BOOL                    13</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CALLABLE                 14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* internal types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_INDIRECT                 15</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_PTR                      17</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"标量类型\"><a href=\"#标量类型\" class=\"headerlink\" title=\"标量类型\"></a>标量类型</h5><ul>\n<li>没有value，直接根据type区分的类型：<code>true</code>、<code>false</code>、<code>null</code></li>\n<li>值存于value中，无需额外的value指针：<code>zend_long</code>、 <code>double</code></li>\n</ul>\n<h5 id=\"字符串（zend-string）\"><a href=\"#字符串（zend-string）\" class=\"headerlink\" title=\"字符串（zend_string）\"></a>字符串（zend_string）</h5><p>​        PHP中没有使用<code>char</code>来表示字符串，而是为字符串单独定义了一个结构<code>zend_string</code>，其中除了存储字符串内容，还存储了其他信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_string</span> &#123;</span></span><br><span class=\"line\">    zend_refcounted_h gc; <span class=\"comment\">// 变量引用计数信息，用于内存管理。比如当前value的引用数，所有用到引用计数的变量类型都会有这个结构</span></span><br><span class=\"line\">    zend_ulong        h;  <span class=\"comment\">/* hash value 哈希值，数组中计算索引时会用到*/</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span>            len; <span class=\"comment\">// 字符串长度，通过这个值保证二进制安全</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>              val[<span class=\"number\">1</span>]; <span class=\"comment\">// 字符串内容，变长struct，分配时按len长度申请内存</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>​        字符串内容<code>val</code>是一个可变数组，在字符串分配时的操作为<code>malloc(sizeof(zend_string) + 字符串长度)</code>。<br><em>注：val中多出一个字节（val[1]而不是val[0]）用于存储字符串的最后一个字符”\\0”.</em></p>\n<p>例如：$a=”abc”，对应zend_string内存结构如下：<br><img src=\"https://note.youdao.com/yws/api/personal/file/39A4055CBC584591A643CF8855653427?method=download&shareKey=100018cf52486ade9a25e3f4d8227678\" alt=\"zend_string内存结构\"></p>\n<p>字符串具体分类：</p>\n<ul>\n<li><code>IS_STR_PERSISTENT</code>: 通过malloc分配。</li>\n<li><code>IS_STR_INTERNED</code>: php代码中写的一些字面量，如函数名、变量名。</li>\n<li><code>IS_STR_PERMERNENT</code>:永久值，生命周期大于request。</li>\n<li><code>IS_STR_CONSTANT</code>:常量。</li>\n<li><code>IS_STR_CONSTANT_UNQUALIFIED</code>:这个信息通过flag保存：zval.value-&gt;gc.u.flags</li>\n</ul>\n<h5 id=\"数组（array）\"><a href=\"#数组（array）\" class=\"headerlink\" title=\"数组（array）\"></a>数组（array）</h5><p>​        <code>Array</code>是PHP中非常强大的一个数据结构，它的<strong>底层实现为散列表（HashTable 哈希表）</strong>。<br>​        散列表是根据<code>key</code>直接进行访问的数据结构，它的<code>key-value</code>之间有一个映射函数，可以根据key通过映射函数直接索引到对应的value值，直接根据<code>“内存起始地址+偏移值”</code>进行寻址，加快查找速度。理想情况下，查找的期望时间复杂度为O(1).</p>\n<p>HashTable的数据结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_array</span> <span class=\"title\">HashTable</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_array</span> &#123;</span></span><br><span class=\"line\">    zend_refcounted_h gc; <span class=\"comment\">//引用计数信息，与字符串相同</span></span><br><span class=\"line\">    <span class=\"comment\">// 提供一些辅助的功能，比如，flag用来设置散列表的一些属性，是否持久化、是否已经初始化。</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_4(</span><br><span class=\"line\">                zend_uchar    flags,</span><br><span class=\"line\">                zend_uchar    nApplyCount,</span><br><span class=\"line\">                zend_uchar    nIteratorsCount,</span><br><span class=\"line\">                zend_uchar    reserve)</span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    &#125; u;</span><br><span class=\"line\">    <span class=\"comment\">// 用于散列函数映射存储元素在arData数组中的下标。其值实际是nTableSize的负数，即nTableMask=-nTableSize（nTableMask=~nTableSize+1）</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nTableMask; <span class=\"comment\">//计算bucket索引时的掩码</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储元素数组，每个元素的结构统一为Bucket，其内存是连续的，arData指向第一个Bucket（即指向数组的起始位置）</span></span><br><span class=\"line\">    Bucket           *arData; <span class=\"comment\">//bucket数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前已使用的Bucket数，但这些Bucket并不都是有效的，因此再删除一个数组元素时，并不会马上将其从数组中移除，而是将这个元素的类型表位IS_UNDEF，只有在数组容量超过限制，需要扩容时才会删除。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nNumUsed; </span><br><span class=\"line\">    <span class=\"comment\">// 数组实际存储的元素数（有效元素数）。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nNumOfElements; <span class=\"comment\">//已有元素数，nNumOfElements &lt;= nNumUsed，因为删除的并不是直接从arData中移除</span></span><br><span class=\"line\">    <span class=\"comment\">// 数组的总容量，其大小为2的幂次方，最小为8（即2^3）。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nTableSize; <span class=\"comment\">//数组的大小，为2^n</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nInternalPointer; <span class=\"comment\">//数值索引</span></span><br><span class=\"line\">    <span class=\"comment\">// 下一个可用的数值索引，如arr[]=1;arr[&#x27;a&#x27;]=2;arr[]=3;则nNextFreeElement=2；该成员是给自动确定数值索引使用的。</span></span><br><span class=\"line\">    zend_long         nNextFreeElement;</span><br><span class=\"line\">    <span class=\"comment\">// 当删除或覆盖数组中的某个元素时，若提供了这个函数句柄，则会回调此函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">dtor_func_t</span>       pDestructor;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>Bucket的结构如下,主要用来保存元素的key及value。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Bucket</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储的具体的value，这里嵌入了一个zval而不是一个指针。</span></span><br><span class=\"line\">\tzval              val;</span><br><span class=\"line\">\t<span class=\"comment\">// hash code，用来映射元素的存储位置。若元素是数值索引，那么他的值就是数值索引的值；若是字符串，那么这个只就是根据字符串key通过Time33算法计算得到的散列值。</span></span><br><span class=\"line\">\tzend_ulong        h;                <span class=\"comment\">/* hash value (or numeric index)   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 存储元素的key。</span></span><br><span class=\"line\">\tzend_string      *key;              <span class=\"comment\">/* string key or NULL for numerics */</span></span><br><span class=\"line\">&#125; Bucket;</span><br></pre></td></tr></table></figure>\n<h6 id=\"基本实现\"><a href=\"#基本实现\" class=\"headerlink\" title=\"基本实现\"></a>基本实现</h6><p>散列表主要由两部分组成：</p>\n<ul>\n<li>存储元素数组</li>\n<li>散列函数<br>一个简单的散列函数可以采用取模的方式，比如散列表的大小为8，那么在散列表初始化数组时就会分配8个元素大小的空间，根据key的hash code与8取模的到的值作为该元素在数组中的下标。其示意图如下：</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/F2CB6F384907410BB02F7F7411F4E341?method=download&shareKey=fc47b2317eb268543f1440ed7296beb0\" alt=\"散列表的基本实现\"></p>\n<p>**以散列函数的输出值作为该元素在存储元素数组中的下标的方式有一个问题: **元素在数组中的位置是随机的，它是无序的。</p>\n<ul>\n<li><strong>问：那么PHP是如何保证元素的顺序与其插入顺序一致？</strong> <pre><code>    为了实现散列表的有序性，PHP在散列函数与元素数组之间加了一层映射表，该映射表也是一个数组，大小与存储元素的数组相同，它存储的元素类型为整型，用于保存实际存储的有序数组中的下标：**元素按照先后顺序依次插入实际存储的数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中**，如下图所示。</code></pre>\n</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/A8DBDBE3688A48739E06BF38ACDA300F?method=download&shareKey=6e4969019969485debc917c11a87da4d\" alt=\"散列表映射关系\"></p>\n<p>原理如上，但实际上PHP是将这个映射表与arData放在一起，在数组初始化时会分配存储Bucket的内存，同时还会分配相同数量的uint32_t大小的空间，将arData偏移到存储元素数组的位置，这个中间映射表可以通过arData向前访问到。如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/358B60D6F6AA407E9B034BACE5E8ACB6?method=download&shareKey=e515e9d30e617ea6c6fa8b9475a9efeb\" alt=\"HashTable中间映射表\"></p>\n<h6 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h6><p>​        通常散列会数会以取模的方式给出，比如：<code>key-&gt;h%nTableSize</code>.但是PHP采用了另一种方式，因为散列表的大小为2的幂次方，所以通过<strong>或运算</strong>可以得到<code>[-1,nTableMask]</code>之间的散列值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nIndex &#x3D; h | ht-&gt;nTableMask</span><br></pre></td></tr></table></figure>\n\n\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h&#x3D;18003212</span><br><span class=\"line\">nTableSize&#x3D;8</span><br><span class=\"line\"></span><br><span class=\"line\">nTableMask&#x3D;-8</span><br><span class=\"line\">nIndex&#x3D;-4</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"数组的初始化\"><a href=\"#数组的初始化\" class=\"headerlink\" title=\"数组的初始化\"></a>数组的初始化</h6><p>​        数组初始化的过程主要是对<code>HashTable</code>中的成员进行设置，初始化时并不会立即分配<code>arData</code>的内存，<code>arData</code>的内存在<strong>插入第一个元素时才会分配</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL _zend_hash_init(HashTable *ht, <span class=\"keyword\">uint32_t</span> nSize, <span class=\"keyword\">dtor_func_t</span> pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化gc信息</span></span><br><span class=\"line\">\tGC_REFCOUNT(ht) = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tGC_TYPE_INFO(ht) = IS_ARRAY;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置flags</span></span><br><span class=\"line\">\tht-&gt;u.flags = (persistent ? HASH_FLAG_PERSISTENT : <span class=\"number\">0</span>) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;</span><br><span class=\"line\">\t<span class=\"comment\">// nTableMask的值是临时的</span></span><br><span class=\"line\">\tht-&gt;nTableMask = HT_MIN_MASK;</span><br><span class=\"line\">\t<span class=\"comment\">// 临时设置ht-&gt;arData</span></span><br><span class=\"line\">\tHT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket);</span><br><span class=\"line\">\tht-&gt;nNumUsed = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;nNumOfElements = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;nInternalPointer = HT_INVALID_IDX;</span><br><span class=\"line\">\tht-&gt;nNextFreeElement = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;pDestructor = pDestructor;</span><br><span class=\"line\">\t<span class=\"comment\">// 把数组的大小重置为2的幂次方</span></span><br><span class=\"line\">\tht-&gt;nTableSize = zend_hash_check_size(nSize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h6><p>​        插入时，会检查数组是否已经分配存储空间。PHP会在第一次插入时根据<code>nTableSize</code>的大小分配，分配完成后把<code>HashTable-&gt;u.flags</code>打上<code>HASH_FLAG_INITIALIZAED</code>掩码。</p>\n<ul>\n<li><p>分配内存<br>分配的内存包括映射表及元素数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nTableSize * (sizeof(Bucket) + sizeof(uint32_t))</span><br></pre></td></tr></table></figure>\n<p>分配完成后，将<code>HashTable-&gt;arData</code>指向第一个<code>Bucket</code>的位置。</p>\n</li>\n<li><p>插入数据<br>将元素按照顺序插入<code>arData</code>，然后将其在<code>arData</code>数组中的位置存储到根据<code>key</code>的<code>hash code</code>（即<code>key-&gt;h</code>）与<code>nTableMask</code>计算得到的中间映射表中的对应位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zend_hash.c</span><br><span class=\"line\"><span class=\"comment\">// _zend_hash_add_or_update_i:</span></span><br><span class=\"line\">add_to_hash:</span><br><span class=\"line\">\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t<span class=\"comment\">// idx为Bucket在arData中存储位置</span></span><br><span class=\"line\">\tidx = ht-&gt;nNumUsed++;</span><br><span class=\"line\">\tht-&gt;nNumOfElements++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ht-&gt;nInternalPointer == HT_INVALID_IDX) &#123;</span><br><span class=\"line\">\t\tht-&gt;nInternalPointer = idx;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((zend_long)h &gt;= (zend_long)ht-&gt;nNextFreeElement) &#123;</span><br><span class=\"line\">\t\tht-&gt;nNextFreeElement = h &lt; ZEND_LONG_MAX ? h + <span class=\"number\">1</span> : ZEND_LONG_MAX;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找到存储Bucket，设置key、value</span></span><br><span class=\"line\">\tp = ht-&gt;arData + idx;</span><br><span class=\"line\">\tp-&gt;h = h;</span><br><span class=\"line\">\tp-&gt;key = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算中间映射表的散列值，idx将保存在映射数组的nIndex位置</span></span><br><span class=\"line\">\tnIndex = h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t<span class=\"comment\">// 将映射表中原来的值保存到新Bucket中，哈希冲突时会用到</span></span><br><span class=\"line\">\tZVAL_COPY_VALUE(&amp;p-&gt;val, pData);</span><br><span class=\"line\">\t<span class=\"comment\">// 先把旧的值保存到新插入的元素中</span></span><br><span class=\"line\">\tZ_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class=\"line\">\t<span class=\"comment\">// 再把新元素数组存储位置更新到映射表中</span></span><br><span class=\"line\">\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);</span><br><span class=\"line\">\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;p-&gt;val;</span><br></pre></td></tr></table></figure>\n<h6 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h6><p>​        散列表中不同元素的<code>key</code>可能计算得到相同的哈希值，这些具有相同哈希值的元素在插入散列表时就会发生冲突，因为映射表只能存储一个元素。  </p>\n</li>\n</ul>\n<p><strong>常见的解决方式（PHP采用这种方式）：将冲突的Bucket串成链表，查找时需要遍历这个链表，逐个比较<code>key</code>，从而找到目标元素。</strong></p>\n<ul>\n<li>具体操作：<pre><code>    `HashTable`中的`Bucket`会记录与它冲突的元素在`arData`数组中的存储位置。在设置映射值时，如果发现映射表中要设置的位置已经被之前插入的元素占用了（值不等于初始化的-1），那么会把已经存在的值保存到新插入的`Bucket`中，然后将映射表中的值更新为新`Bucket`的存储位置（即每次都会把冲突的元素插到开头）。  </code></pre>\n<strong>冲突元素的保存位置为：</strong><code>Bucket.val.u2.next</code></li>\n</ul>\n<p><strong>示例</strong>：一个数组有三个元素，按照a、b、c的顺序插入，加入a、c两个key冲突了，则HashTable的结构如下：<br>$arr = [];<br>$arr[‘a’] = 11;<br>$arr[‘b’] = 22;<br>$arr[‘c’] = 33;<br><img src=\"https://note.youdao.com/yws/api/personal/file/C469391F27FF454698CCD908B98FB2B2?method=download&shareKey=9501d4a7b3029c279f3d545c7f9c18e2\" alt=\"哈希冲突链表\"></p>\n<h6 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h6><p>查找过程如下：</p>\n<ul>\n<li>①、根据<code>key</code>计算出<code>hash code</code>（即<code>zend_string-&gt;h</code>）与<code>nTableMask</code>计算得到散列值<code>nIndex</code>。</li>\n<li>②、根据散列值从中间映射表中得到存储元素在有序存储数组中的位置<code>idx</code>。</li>\n<li>③、根据<code>idx</code>从有序存储数组（<code>HashTable-&gt;arData</code>）中取出<code>Bucket</code></li>\n<li>④、从取出的<code>Bucket</code>进行遍历，判断Bucket的key是否是要查找的key，若是则停止遍历，否则继续根据<code>zval.u2.next</code>遍历比较。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_hash_find_bucket:</span></span><br><span class=\"line\"><span class=\"comment\">// 根据zend_string *key进行查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline Bucket *<span class=\"title\">zend_hash_find_bucket</span><span class=\"params\">(<span class=\"keyword\">const</span> HashTable *ht, zend_string *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tzend_ulong h;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> nIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> idx;</span><br><span class=\"line\">\tBucket *p, *arData;</span><br><span class=\"line\"></span><br><span class=\"line\">\th = zend_string_hash_val(key);</span><br><span class=\"line\">\tarData = ht-&gt;arData;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算散列值</span></span><br><span class=\"line\">\tnIndex = h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取Bucket存储位置</span></span><br><span class=\"line\">\tidx = HT_HASH_EX(arData, nIndex);</span><br><span class=\"line\">    <span class=\"comment\">// 遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (EXPECTED(idx != HT_INVALID_IDX)) &#123;</span><br><span class=\"line\">\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (EXPECTED(p-&gt;key == key)) &#123; <span class=\"comment\">/* check for the same interned string */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (EXPECTED(p-&gt;h == h) &amp;&amp; <span class=\"comment\">// 先比较hash code</span></span><br><span class=\"line\">\t\t     EXPECTED(p-&gt;key) &amp;&amp; </span><br><span class=\"line\">\t\t     <span class=\"comment\">// 在比较key长度，最后按字符比较是否相同</span></span><br><span class=\"line\">\t\t     EXPECTED(ZSTR_LEN(p-&gt;key) == ZSTR_LEN(key)) &amp;&amp;</span><br><span class=\"line\">\t\t     EXPECTED(<span class=\"built_in\">memcmp</span>(ZSTR_VAL(p-&gt;key), ZSTR_VAL(key), ZSTR_LEN(key)) == <span class=\"number\">0</span>)) &#123;<span class=\"comment\">// 比较查找的key与Bucket的key是否匹配</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 不匹配则继续遍历</span></span><br><span class=\"line\">\t\tidx = Z_NEXT(p-&gt;val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h6 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h6><p>​        数组的容量是有限的，最多可以存储<code>nTableSize</code>个元素，那么当数组空间已满还要继续插入时如何处理？  </p>\n<p><strong>问: PHP是怎样实现的自动扩容？</strong></p>\n<p>​        <strong>扩容的过程为</strong>：检查数组中已经删除的元素所占的比例（已经删除但未从存储数组中移除的元素）.若比例达到域值，则触发<strong>重建索引</strong>的操作，这个过程会把删除的Bucket移除，然后把后面的Bucket往前移补上空缺的Bucket；若还没有达到域值，则分配一个原数组大小2倍的新数组，然后把原数组的元素复制到新数组上，重建索引。 </p>\n<p><u>域值判断公式</u>如下，即域值为<code>nNumOfElement + (nNumElement / 32)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElement + (ht-&gt;nNumOfElement &gt;&gt; 5)</span><br></pre></td></tr></table></figure>\n\n<p>具体的处理过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">zend_hash_do_resize</span><span class=\"params\">(HashTable *ht)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tIS_CONSISTENT(ht);</span><br><span class=\"line\">\tHT_ASSERT(GC_REFCOUNT(ht) == <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; <span class=\"number\">5</span>)) &#123; <span class=\"comment\">// 无序扩容，将删除的Bucket移除，然后把后面的bucket往前补上空缺</span></span><br><span class=\"line\">\t\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 只有到达一定域值才进行rehash操作</span></span><br><span class=\"line\">\t\tzend_hash_rehash(ht); <span class=\"comment\">// 重建索引数组</span></span><br><span class=\"line\">\t\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ht-&gt;nTableSize &lt; HT_MAX_SIZE) &#123; <span class=\"comment\">// 扩容，分配原数组大小2倍的新数组。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span> *new_data, *old_data = HT_GET_DATA_ADDR(ht);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 扩大为2倍，加法比乘法快</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> nSize = ht-&gt;nTableSize + ht-&gt;nTableSize;</span><br><span class=\"line\">\t\tBucket *old_buckets = ht-&gt;arData;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 新分配arData空间，大小为(sizeof(Bucket) + sizeof(uint32_t)) * nSize;</span></span><br><span class=\"line\">\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class=\"line\">\t\tht-&gt;nTableSize = nSize;</span><br><span class=\"line\">\t\tht-&gt;nTableMask = -ht-&gt;nTableSize;</span><br><span class=\"line\">\t    <span class=\"comment\">// 将arData指针偏移到Bucket数组起始位置</span></span><br><span class=\"line\">\t\tHT_SET_DATA_ADDR(ht, new_data);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将旧的Bucket数组复制到新空间（此步只复制存储的元素，即HashTable-&gt;arData，不会复制中间映射表，因为扩容后旧的映射表已无法使用，key-value的映射关系需要重新计算，即重建索引）</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memcpy</span>(ht-&gt;arData, old_buckets, <span class=\"keyword\">sizeof</span>(Bucket) * ht-&gt;nNumUsed);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 释放旧空间</span></span><br><span class=\"line\">\t\tpefree(old_data, ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 重建索引数组：映射表</span></span><br><span class=\"line\">\t\tzend_hash_rehash(ht);</span><br><span class=\"line\">\t\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tzend_error_noreturn(E_ERROR, <span class=\"string\">&quot;Possible integer overflow in memory allocation (%zu * %zu + %zu)&quot;</span>, ht-&gt;nTableSize * <span class=\"number\">2</span>, <span class=\"keyword\">sizeof</span>(Bucket) + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">uint32_t</span>), <span class=\"keyword\">sizeof</span>(Bucket));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重建索引的过程实际上就是将所有元素重新插入一遍，其处理过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 遍历数组，重新设置中间映射表（索引表）</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">\t\t\tnIndex &#x3D; p-&gt;h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t\t\tZ_NEXT(p-&gt;val) &#x3D; HT_HASH(ht, nIndex);</span><br><span class=\"line\">\t\t\tHT_HASH(ht, nIndex) &#x3D; HT_IDX_TO_HASH(i);</span><br><span class=\"line\">\t\t\tp++;</span><br><span class=\"line\">\t\t&#125; while (++i &lt; ht-&gt;nNumUsed);</span><br></pre></td></tr></table></figure>\n<p>重建索引会将已删除的bucket移除，移除后会把这个Bucket之后的元素全部向前移动一个位置，所以<strong>重建索引后存储数组中元素全部紧密排列在一起</strong>。</p>\n<h5 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h5><p>​        引用类型是PHP中比较特殊的一种类型，它实际是指向另外一个PHP变量（<em>在PHP中通过<code>&amp;操作符</code>产生一个引用变量</em>），对它的修改会直接改动实际指向的zval，<u>可以简单的理解为C中的指针</u>。  </p>\n<p>操作步骤：</p>\n<ul>\n<li>首先为<code>&amp;</code>操作的变量分配一个<code>zend_reference结构</code>，其内嵌一个<code>zval</code>，这个<code>zval</code>的<code>value</code>指向原来<code>zval</code>的<code>value</code>(<strong>注: 如果是布尔、整形、浮点则直接复制原来的值</strong>)。</li>\n<li>然后将原<code>zval</code>的类型修改为<code>IS_REFERENCE</code>，原<code>zval</code>的<code>value</code>指向新创建的<code>zend_reference</code>结构。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_reference &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    zval              val; &#x2F;&#x2F; 指向原来的value</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n示例1：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; date(&#39;Y-m-d&#39;);</span><br><span class=\"line\">$b &#x3D; &amp;$a;</span><br></pre></td></tr></table></figure>\n<img src=\"https://note.youdao.com/yws/api/personal/file/A5F4C7219117457A88A7D7CC3AFB53A9?method=download&shareKey=3d6950341fd9f21fea74f78f022500fd\" alt=\"a与b内存引用关系\"></li>\n</ul>\n<p><strong>注：若此时将<code>$b</code>复制给其他变量，那么传递给新变量的value将实时及引用的值，而不是引用本身</strong>。PHP中的引用只有一级，不会出现一个引用指向另外一个引用的情况，即没有C语言中多级指针的概念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; date(&#39;Y-m-d&#39;);</span><br><span class=\"line\">$b &#x3D; &amp;$a;</span><br><span class=\"line\">$c &#x3D; $b; &#x2F;&#x2F; 若想让$c也指向$a&#x2F;$b引用的值，则：$c &#x3D; &amp;$b或$c &#x3D; &amp;$a;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/1E8C8DDDE51D479296CA8F63EA5353B7?method=download&shareKey=43183c8018d3140f9b924508528c2af2\" alt=\"a,b与c内存引用关系\"></p>\n<p>示例2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a    -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/697F728B851442D4AF142554DDF78333?method=download&shareKey=59d725805b5b7c8bc59c391e87607101\" alt=\"zend_ref\"></p>\n<p>注意：<strong>引用只能通过<code>&amp;</code>产生，无法通过赋值传递</strong>  </p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:</span><br><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a    -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$c &#x3D; $b;                    &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;2)</span><br><span class=\"line\">                            &#x2F;&#x2F;$c    -&gt; </span><br><span class=\"line\">right:</span><br><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a       -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b    -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$c &#x3D; &amp;$b;&#x2F;*或$c &#x3D; &amp;$a*&#x2F;     &#x2F;&#x2F;$a,$b,$c -&gt; zend_reference_1(refcount&#x3D;3) -&gt; zend_string_1(refcount&#x3D;1)                             </span><br></pre></td></tr></table></figure>\n<p>这个也表示PHP中的 <strong>引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况</strong> ，也就是没有C语言中指针的指针的概念。</p>\n<h5 id=\"对象-资源\"><a href=\"#对象-资源\" class=\"headerlink\" title=\"对象/资源\"></a>对象/资源</h5><p>对象比较常见，资源指的是tcp连接、文件句柄等等类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_object &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    uint32_t          handle;</span><br><span class=\"line\">    zend_class_entry *ce; &#x2F;&#x2F;对象对应的class类</span><br><span class=\"line\">    const zend_object_handlers *handlers;</span><br><span class=\"line\">    HashTable        *properties; &#x2F;&#x2F;对象属性哈希表</span><br><span class=\"line\">    zval              properties_table[1];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct _zend_resource &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    int               handle;</span><br><span class=\"line\">    int               type;</span><br><span class=\"line\">    void             *ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h5><p>​        PHP是弱类型语言，使用时不需要明确定义变量的类型，Zend虚拟机在执行PHP代码时，会根据具体的应用场景进行转换，也就是变量会按照类型转换规则将不合格变量转换给合格的变量，然后进行操作。</p>\n<p>例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; &quot;100&quot; + 200</span><br></pre></td></tr></table></figure>\n<p>执行时Zend发现相加的一个值为字符串，就会试图将<code>字符串100</code>转为数值类型（整型或浮点型），然后与200相加。<br><strong>注：转换的时候并不会改变原来的值，而是会生成一个新的变量进行处理。</strong></p>\n<h6 id=\"强制转换\"><a href=\"#强制转换\" class=\"headerlink\" title=\"强制转换\"></a>强制转换</h6><p>PHP提供了一种强制转换方式：</p>\n<ul>\n<li>(int)/(integer): 转换为整型integer</li>\n<li>(bool)/(boolean):转换为布尔类型boolean</li>\n<li>(flaot)/(double)/(real):转换为浮点型flaot</li>\n<li>(string):转换为字符串string</li>\n<li>(array):转换为数组array</li>\n<li>(object):转换为对象object</li>\n<li>(unset):转换为null</li>\n</ul>\n<p><em>注：有些类型之间是无法转换的，如：资源类型，无法将任何类型转换为资源类型。</em></p>\n<h6 id=\"转换为null\"><a href=\"#转换为null\" class=\"headerlink\" title=\"转换为null\"></a>转换为null</h6><p>​        任意类型都可以转为null，转换时直接将新的<code>zval类型</code>设置为<code>IS_NULL</code>。</p>\n<h6 id=\"转换为布尔型\"><a href=\"#转换为布尔型\" class=\"headerlink\" title=\"转换为布尔型\"></a>转换为布尔型</h6><p>​        当转换为布尔型时，根据原值的<code>true</code>、<code>false</code>决定转换后的结果，一些值被认为是<code>false</code>，除此之外的其他值通常被认为是<code>true</code>。</p>\n<p>被认为是false的值:</p>\n<ul>\n<li>布尔值false本身</li>\n<li>整型0</li>\n<li>浮点型值0.0</li>\n<li>==空字符串（‘’），以及字符串‘0’==</li>\n<li>空数组</li>\n<li>null</li>\n</ul>\n<h6 id=\"转换为整型\"><a href=\"#转换为整型\" class=\"headerlink\" title=\"转换为整型\"></a>转换为整型</h6><p>从<code>其他值</code>转换为<code>整型</code>的规则如下：</p>\n<ul>\n<li>null：转换为0</li>\n<li>布尔型：false转为0，true转为1</li>\n<li>浮点型：向下取整，比如，(int)2.8 = 2</li>\n<li>字符串：与C语言strtoll()的规则一致<ul>\n<li>字符串以合法数值(包含正负数)开始，就使用该数值</li>\n<li><strong>否则，其值为0</strong></li>\n</ul>\n</li>\n<li>数组：很多操作不支持将一个数组自动转为整型处理，比如array()+2将报error错误，但可以强制把数组转为整型：<ul>\n<li>非空数组：1</li>\n<li>空数组：0<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php &gt; $a = <span class=\"keyword\">array</span>()+<span class=\"number\">2</span>;</span><br><span class=\"line\">PHP Fatal <span class=\"built_in\">error</span>:  Unsupported operand types in php shell code on line <span class=\"number\">1</span></span><br><span class=\"line\">PHP Stack trace:</span><br><span class=\"line\">PHP   <span class=\"number\">1.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br><span class=\"line\">PHP   <span class=\"number\">2.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; $a = <span class=\"keyword\">array</span>();</span><br><span class=\"line\">php &gt; $b = (<span class=\"keyword\">int</span>)$a;</span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> $b;</span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>对象：与数组类似，很多操作也不支持将兑现个自动转为整型，但有些操作只会抛一个warning警告，还是会把对象转换为1.</li>\n<li>资源：转为分配给这个资源的唯一编号</li>\n</ul>\n<h6 id=\"转为浮点型\"><a href=\"#转为浮点型\" class=\"headerlink\" title=\"转为浮点型\"></a>转为浮点型</h6><p>​        除了字符串类型外，其他类型转换规则与整型基本一致，只是在整型转换结果上加了小数位，字符串转为浮点数有<code>zend_strtod</code>完成。</p>\n<h6 id=\"转换为字符串\"><a href=\"#转换为字符串\" class=\"headerlink\" title=\"转换为字符串\"></a>转换为字符串</h6><ul>\n<li>强制转换：<ul>\n<li>(string)</li>\n<li>strval()函数</li>\n</ul>\n</li>\n<li>自动转换：<ul>\n<li>需要字符串的表达式中，比如：函数echo或print时</li>\n<li>非string类型变量与一个string变量进行比较时<ul>\n<li>null/fasle:转为空字符串</li>\n<li>true：转为“1”</li>\n<li>整型：原样转为字符串，<strong>转换时将各位一次除10取余</strong></li>\n<li>浮点型：原样转为字符串</li>\n<li>资源：转为“Resource id#xxx”</li>\n<li>数组：转为“Array”，同时报Notice</li>\n<li>对象：不能转换，将报错,如下：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php &gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">php</span> &gt; </span>&#123;<span class=\"keyword\">public</span> $b;&#125;</span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; $a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;a= &#x27;</span> . $a;</span><br><span class=\"line\">PHP Catchable fatal <span class=\"built_in\">error</span>:  <span class=\"keyword\">Object</span> of <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">could</span> <span class=\"title\">not</span> <span class=\"title\">be</span> <span class=\"title\">converted</span> <span class=\"title\">to</span> <span class=\"title\">string</span> <span class=\"title\">in</span> <span class=\"title\">php</span> <span class=\"title\">shell</span> <span class=\"title\">code</span> <span class=\"title\">on</span> <span class=\"title\">line</span> 1</span></span><br><span class=\"line\">PHP Stack trace:</span><br><span class=\"line\">PHP   <span class=\"number\">1.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"转换为数组\"><a href=\"#转换为数组\" class=\"headerlink\" title=\"转换为数组\"></a>转换为数组</h6></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>若变量类型为<code>null</code>、<code>integer</code>、<code>float</code>、<code>string</code>、<code>boolean</code>和<code>resource</code>中的一个：将得到一个仅有一个元素的数组，其<code>下标为0</code>，即(array)$scalarValue与<code>array($scalarValue)</code>完全一样。</li>\n<li>若变量类型为object：其结果为一个数组，数组的元素为该对象的全部属性（包含public、private、protected），但他们也是有区别的，如下：<ul>\n<li>public的属性：key</li>\n<li>private的属性：key加类型作为前缀</li>\n<li>protected的属性：’*’加key作为前缀<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public $a &#x3D; 123;</span><br><span class=\"line\">    private $b &#x3D; &#39;bbb&#39;;</span><br><span class=\"line\">    protected $c &#x3D; &#39;ccc&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$test &#x3D; new test();</span><br><span class=\"line\">print_r((array)$test);</span><br></pre></td></tr></table></figure>\n以上例子将输出：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$php stat.php </span><br><span class=\"line\">Array</span><br><span class=\"line\">(</span><br><span class=\"line\">    [a] &#x3D;&gt; 123</span><br><span class=\"line\">    [testb] &#x3D;&gt; bbb</span><br><span class=\"line\">    [*c] &#x3D;&gt; ccc</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"转换为对象\"><a href=\"#转换为对象\" class=\"headerlink\" title=\"转换为对象\"></a>转换为对象</h6><p>其他任何类型的值被转换为对象，将会创建一个内置类stdClass的实例：</p>\n<ul>\n<li>若该值为null：新的实例为空</li>\n<li>array：转换成的object将以键名成为属性名，并具有相对应的值<ul>\n<li>数值索引的元素也将转为属性，但无法通过“-&gt;”访问，只能遍历获取</li>\n<li>非数值索引：会以‘scalar’作为属性名</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"变量的内部实现\"><a href=\"#变量的内部实现\" class=\"headerlink\" title=\"变量的内部实现\"></a>变量的内部实现</h4><p>​        变量是一个语言实现的基础，变量有两个组成部分：变量名、变量值，PHP中可以将其对应为：<code>zval</code>、<code>zend_value</code>，这两个概念一定要区分开，PHP中变量的内存是通过<code>引用计数</code>进行管理的，而且<strong>PHP7中引用计数是在<code>zend_value</code>而不是zval上，变量之间的传递、赋值通常也是针对zend_value</strong>。</p>","more":"<p>PHP中可以通过<code>$关键词</code>定义一个变量：<code>$a;</code>，在定义的同时可以进行初始化：<code>$a = &quot;hi~&quot;;</code><u>注意这实际是两步：定义、初始化</u>，只定义一个变量也是可以的，可以不给它赋值，比如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a;</span><br><span class=\"line\">$b = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>这段代码在执行时会分配两个zval。</p>\n<h4 id=\"变量的基础结构\"><a href=\"#变量的基础结构\" class=\"headerlink\" title=\"变量的基础结构\"></a>变量的基础结构</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//zend_types.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span>     <span class=\"title\">zval</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zval_struct</span> &#123;</span></span><br><span class=\"line\">    zend_value        value; <span class=\"comment\">//变量实际的value</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_4(  <span class=\"comment\">//这个是为了兼容大小字节序，小字节序就是下面的顺序，大字节序则下面4个顺序翻转</span></span><br><span class=\"line\">                zend_uchar    type,         <span class=\"comment\">//变量类型</span></span><br><span class=\"line\">                zend_uchar    type_flags,  <span class=\"comment\">//类型掩码，不同的类型会有不同的几种属性，内存管理会用到</span></span><br><span class=\"line\">                zend_uchar    const_flags,</span><br><span class=\"line\">                zend_uchar    reserved)     <span class=\"comment\">//call info，zend执行流程会用到</span></span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> type_info; <span class=\"comment\">//上面4个值的组合值，可以直接根据type_info取到4个对应位置的值</span></span><br><span class=\"line\">    &#125; u1;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     var_flags;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     next;                 <span class=\"comment\">//哈希表中解决哈希冲突时用到</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     cache_slot;           <span class=\"comment\">/* literal cache slot 运行时缓存会用到*/</span> </span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     lineno;               <span class=\"comment\">/* line number (for ast nodes) */</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     num_args;             <span class=\"comment\">/* arguments number for EX(This) */</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     fe_pos;               <span class=\"comment\">/* foreach position foreach遍历时会用到*/</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span>     fe_iter_idx;          <span class=\"comment\">/* foreach iterator index */</span></span><br><span class=\"line\">    &#125; u2; <span class=\"comment\">//一些辅助值</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>        zval</code>结构比较简单，内嵌一个union类型的<code>zend_value</code>保存具体变量类型的值或指针，zval中还有两个union：<code>u1</code>、<code>u2</code>:</p>\n<ul>\n<li><strong>u1</strong>: 它是联合了一个结构体<code>v</code>和一个32位无符号整型<code>type_info</code>；ZEND_ENDIAN_LOHI_4是一个宏，用于解决字节序问题的，他会根据系统字节序决定struct v中4个成员的顺序。v定义了4个成员变量，<strong>变量的类型就通过u1.v.type区分</strong>；另外一个值<code>type_flags</code>为类型掩码，在变量的内存管理、gc机制中会用到；至于后面两个const_flags、reserved暂且不管。</li>\n<li><strong>u2</strong>: 这个值纯粹是个辅助值，zval结构中value、u1分别占了8byte、4byte，一共12byte，假如zval只有:value、u1两个值，整个zval的大小也会对齐到16byte，既然不管有没有u2大小都是16byte，把多余的4byte拿出来用于一些特殊用途还是很划算的，比如next在哈希表解决哈希冲突时会用到，还有fe_pos在foreach会用到……  </li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> _zend_value &#123;</span><br><span class=\"line\">    zend_long         lval;    <span class=\"comment\">//int整形</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span>            dval;    <span class=\"comment\">//浮点型</span></span><br><span class=\"line\">    zend_refcounted  *counted;</span><br><span class=\"line\">    zend_string      *str;     <span class=\"comment\">//string字符串</span></span><br><span class=\"line\">    zend_array       *arr;     <span class=\"comment\">//array数组</span></span><br><span class=\"line\">    zend_object      *obj;     <span class=\"comment\">//object对象</span></span><br><span class=\"line\">    zend_resource    *res;     <span class=\"comment\">//resource资源类型</span></span><br><span class=\"line\">    zend_reference   *ref;     <span class=\"comment\">//引用类型，通过&amp;$var_name定义的</span></span><br><span class=\"line\">    zend_ast_ref     *ast;     <span class=\"comment\">//下面几个都是内核使用的value</span></span><br><span class=\"line\">    zval             *zv;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>             *ptr;</span><br><span class=\"line\">    zend_class_entry *ce;</span><br><span class=\"line\">    zend_function    *func;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> w1;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> w2;</span><br><span class=\"line\">    &#125; ww;</span><br><span class=\"line\">&#125; zend_value;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>​        <code>zend_value</code>是一个联合体，各个类型根据自己的类型选择使用不同的成员，<strong>从zend_value可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构</strong>。zend_value中没有布尔型，这是因为PHP7中将布尔型具体拆分为了true、false两种类型，通过zval.u1.v.type进行区分（注：老版本中，布尔型是通过整型进行区分的）</p>\n<h4 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h4><p><code>zval.u1.type</code>类型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* regular data types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_UNDEF                    0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_NULL                     1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_FALSE                    2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_TRUE                     3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_LONG                     4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_DOUBLE                   5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_STRING                   6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_ARRAY                    7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_OBJECT                   8</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_RESOURCE                 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_REFERENCE                10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* constant expressions */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CONSTANT                 11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CONSTANT_AST             12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* fake types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _IS_BOOL                    13</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_CALLABLE                 14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* internal types */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_INDIRECT                 15</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IS_PTR                      17</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"标量类型\"><a href=\"#标量类型\" class=\"headerlink\" title=\"标量类型\"></a>标量类型</h5><ul>\n<li>没有value，直接根据type区分的类型：<code>true</code>、<code>false</code>、<code>null</code></li>\n<li>值存于value中，无需额外的value指针：<code>zend_long</code>、 <code>double</code></li>\n</ul>\n<h5 id=\"字符串（zend-string）\"><a href=\"#字符串（zend-string）\" class=\"headerlink\" title=\"字符串（zend_string）\"></a>字符串（zend_string）</h5><p>​        PHP中没有使用<code>char</code>来表示字符串，而是为字符串单独定义了一个结构<code>zend_string</code>，其中除了存储字符串内容，还存储了其他信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_string</span> &#123;</span></span><br><span class=\"line\">    zend_refcounted_h gc; <span class=\"comment\">// 变量引用计数信息，用于内存管理。比如当前value的引用数，所有用到引用计数的变量类型都会有这个结构</span></span><br><span class=\"line\">    zend_ulong        h;  <span class=\"comment\">/* hash value 哈希值，数组中计算索引时会用到*/</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span>            len; <span class=\"comment\">// 字符串长度，通过这个值保证二进制安全</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>              val[<span class=\"number\">1</span>]; <span class=\"comment\">// 字符串内容，变长struct，分配时按len长度申请内存</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>​        字符串内容<code>val</code>是一个可变数组，在字符串分配时的操作为<code>malloc(sizeof(zend_string) + 字符串长度)</code>。<br><em>注：val中多出一个字节（val[1]而不是val[0]）用于存储字符串的最后一个字符”\\0”.</em></p>\n<p>例如：$a=”abc”，对应zend_string内存结构如下：<br><img src=\"https://note.youdao.com/yws/api/personal/file/39A4055CBC584591A643CF8855653427?method=download&shareKey=100018cf52486ade9a25e3f4d8227678\" alt=\"zend_string内存结构\"></p>\n<p>字符串具体分类：</p>\n<ul>\n<li><code>IS_STR_PERSISTENT</code>: 通过malloc分配。</li>\n<li><code>IS_STR_INTERNED</code>: php代码中写的一些字面量，如函数名、变量名。</li>\n<li><code>IS_STR_PERMERNENT</code>:永久值，生命周期大于request。</li>\n<li><code>IS_STR_CONSTANT</code>:常量。</li>\n<li><code>IS_STR_CONSTANT_UNQUALIFIED</code>:这个信息通过flag保存：zval.value-&gt;gc.u.flags</li>\n</ul>\n<h5 id=\"数组（array）\"><a href=\"#数组（array）\" class=\"headerlink\" title=\"数组（array）\"></a>数组（array）</h5><p>​        <code>Array</code>是PHP中非常强大的一个数据结构，它的<strong>底层实现为散列表（HashTable 哈希表）</strong>。<br>​        散列表是根据<code>key</code>直接进行访问的数据结构，它的<code>key-value</code>之间有一个映射函数，可以根据key通过映射函数直接索引到对应的value值，直接根据<code>“内存起始地址+偏移值”</code>进行寻址，加快查找速度。理想情况下，查找的期望时间复杂度为O(1).</p>\n<p>HashTable的数据结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_array</span> <span class=\"title\">HashTable</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_array</span> &#123;</span></span><br><span class=\"line\">    zend_refcounted_h gc; <span class=\"comment\">//引用计数信息，与字符串相同</span></span><br><span class=\"line\">    <span class=\"comment\">// 提供一些辅助的功能，比如，flag用来设置散列表的一些属性，是否持久化、是否已经初始化。</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_4(</span><br><span class=\"line\">                zend_uchar    flags,</span><br><span class=\"line\">                zend_uchar    nApplyCount,</span><br><span class=\"line\">                zend_uchar    nIteratorsCount,</span><br><span class=\"line\">                zend_uchar    reserve)</span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    &#125; u;</span><br><span class=\"line\">    <span class=\"comment\">// 用于散列函数映射存储元素在arData数组中的下标。其值实际是nTableSize的负数，即nTableMask=-nTableSize（nTableMask=~nTableSize+1）</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nTableMask; <span class=\"comment\">//计算bucket索引时的掩码</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储元素数组，每个元素的结构统一为Bucket，其内存是连续的，arData指向第一个Bucket（即指向数组的起始位置）</span></span><br><span class=\"line\">    Bucket           *arData; <span class=\"comment\">//bucket数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 当前已使用的Bucket数，但这些Bucket并不都是有效的，因此再删除一个数组元素时，并不会马上将其从数组中移除，而是将这个元素的类型表位IS_UNDEF，只有在数组容量超过限制，需要扩容时才会删除。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nNumUsed; </span><br><span class=\"line\">    <span class=\"comment\">// 数组实际存储的元素数（有效元素数）。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nNumOfElements; <span class=\"comment\">//已有元素数，nNumOfElements &lt;= nNumUsed，因为删除的并不是直接从arData中移除</span></span><br><span class=\"line\">    <span class=\"comment\">// 数组的总容量，其大小为2的幂次方，最小为8（即2^3）。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nTableSize; <span class=\"comment\">//数组的大小，为2^n</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span>          nInternalPointer; <span class=\"comment\">//数值索引</span></span><br><span class=\"line\">    <span class=\"comment\">// 下一个可用的数值索引，如arr[]=1;arr[&#x27;a&#x27;]=2;arr[]=3;则nNextFreeElement=2；该成员是给自动确定数值索引使用的。</span></span><br><span class=\"line\">    zend_long         nNextFreeElement;</span><br><span class=\"line\">    <span class=\"comment\">// 当删除或覆盖数组中的某个元素时，若提供了这个函数句柄，则会回调此函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">dtor_func_t</span>       pDestructor;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>Bucket的结构如下,主要用来保存元素的key及value。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">Bucket</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储的具体的value，这里嵌入了一个zval而不是一个指针。</span></span><br><span class=\"line\">\tzval              val;</span><br><span class=\"line\">\t<span class=\"comment\">// hash code，用来映射元素的存储位置。若元素是数值索引，那么他的值就是数值索引的值；若是字符串，那么这个只就是根据字符串key通过Time33算法计算得到的散列值。</span></span><br><span class=\"line\">\tzend_ulong        h;                <span class=\"comment\">/* hash value (or numeric index)   */</span></span><br><span class=\"line\">\t<span class=\"comment\">// 存储元素的key。</span></span><br><span class=\"line\">\tzend_string      *key;              <span class=\"comment\">/* string key or NULL for numerics */</span></span><br><span class=\"line\">&#125; Bucket;</span><br></pre></td></tr></table></figure>\n<h6 id=\"基本实现\"><a href=\"#基本实现\" class=\"headerlink\" title=\"基本实现\"></a>基本实现</h6><p>散列表主要由两部分组成：</p>\n<ul>\n<li>存储元素数组</li>\n<li>散列函数<br>一个简单的散列函数可以采用取模的方式，比如散列表的大小为8，那么在散列表初始化数组时就会分配8个元素大小的空间，根据key的hash code与8取模的到的值作为该元素在数组中的下标。其示意图如下：</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/F2CB6F384907410BB02F7F7411F4E341?method=download&shareKey=fc47b2317eb268543f1440ed7296beb0\" alt=\"散列表的基本实现\"></p>\n<p>**以散列函数的输出值作为该元素在存储元素数组中的下标的方式有一个问题: **元素在数组中的位置是随机的，它是无序的。</p>\n<ul>\n<li><strong>问：那么PHP是如何保证元素的顺序与其插入顺序一致？</strong> <pre><code>    为了实现散列表的有序性，PHP在散列函数与元素数组之间加了一层映射表，该映射表也是一个数组，大小与存储元素的数组相同，它存储的元素类型为整型，用于保存实际存储的有序数组中的下标：**元素按照先后顺序依次插入实际存储的数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中**，如下图所示。</code></pre>\n</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/A8DBDBE3688A48739E06BF38ACDA300F?method=download&shareKey=6e4969019969485debc917c11a87da4d\" alt=\"散列表映射关系\"></p>\n<p>原理如上，但实际上PHP是将这个映射表与arData放在一起，在数组初始化时会分配存储Bucket的内存，同时还会分配相同数量的uint32_t大小的空间，将arData偏移到存储元素数组的位置，这个中间映射表可以通过arData向前访问到。如下图所示：<br><img src=\"https://note.youdao.com/yws/api/personal/file/358B60D6F6AA407E9B034BACE5E8ACB6?method=download&shareKey=e515e9d30e617ea6c6fa8b9475a9efeb\" alt=\"HashTable中间映射表\"></p>\n<h6 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h6><p>​        通常散列会数会以取模的方式给出，比如：<code>key-&gt;h%nTableSize</code>.但是PHP采用了另一种方式，因为散列表的大小为2的幂次方，所以通过<strong>或运算</strong>可以得到<code>[-1,nTableMask]</code>之间的散列值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nIndex &#x3D; h | ht-&gt;nTableMask</span><br></pre></td></tr></table></figure>\n\n\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h&#x3D;18003212</span><br><span class=\"line\">nTableSize&#x3D;8</span><br><span class=\"line\"></span><br><span class=\"line\">nTableMask&#x3D;-8</span><br><span class=\"line\">nIndex&#x3D;-4</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"数组的初始化\"><a href=\"#数组的初始化\" class=\"headerlink\" title=\"数组的初始化\"></a>数组的初始化</h6><p>​        数组初始化的过程主要是对<code>HashTable</code>中的成员进行设置，初始化时并不会立即分配<code>arData</code>的内存，<code>arData</code>的内存在<strong>插入第一个元素时才会分配</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZEND_API <span class=\"keyword\">void</span> ZEND_FASTCALL _zend_hash_init(HashTable *ht, <span class=\"keyword\">uint32_t</span> nSize, <span class=\"keyword\">dtor_func_t</span> pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化gc信息</span></span><br><span class=\"line\">\tGC_REFCOUNT(ht) = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tGC_TYPE_INFO(ht) = IS_ARRAY;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置flags</span></span><br><span class=\"line\">\tht-&gt;u.flags = (persistent ? HASH_FLAG_PERSISTENT : <span class=\"number\">0</span>) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;</span><br><span class=\"line\">\t<span class=\"comment\">// nTableMask的值是临时的</span></span><br><span class=\"line\">\tht-&gt;nTableMask = HT_MIN_MASK;</span><br><span class=\"line\">\t<span class=\"comment\">// 临时设置ht-&gt;arData</span></span><br><span class=\"line\">\tHT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket);</span><br><span class=\"line\">\tht-&gt;nNumUsed = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;nNumOfElements = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;nInternalPointer = HT_INVALID_IDX;</span><br><span class=\"line\">\tht-&gt;nNextFreeElement = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tht-&gt;pDestructor = pDestructor;</span><br><span class=\"line\">\t<span class=\"comment\">// 把数组的大小重置为2的幂次方</span></span><br><span class=\"line\">\tht-&gt;nTableSize = zend_hash_check_size(nSize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h6><p>​        插入时，会检查数组是否已经分配存储空间。PHP会在第一次插入时根据<code>nTableSize</code>的大小分配，分配完成后把<code>HashTable-&gt;u.flags</code>打上<code>HASH_FLAG_INITIALIZAED</code>掩码。</p>\n<ul>\n<li><p>分配内存<br>分配的内存包括映射表及元素数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nTableSize * (sizeof(Bucket) + sizeof(uint32_t))</span><br></pre></td></tr></table></figure>\n<p>分配完成后，将<code>HashTable-&gt;arData</code>指向第一个<code>Bucket</code>的位置。</p>\n</li>\n<li><p>插入数据<br>将元素按照顺序插入<code>arData</code>，然后将其在<code>arData</code>数组中的位置存储到根据<code>key</code>的<code>hash code</code>（即<code>key-&gt;h</code>）与<code>nTableMask</code>计算得到的中间映射表中的对应位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zend_hash.c</span><br><span class=\"line\"><span class=\"comment\">// _zend_hash_add_or_update_i:</span></span><br><span class=\"line\">add_to_hash:</span><br><span class=\"line\">\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t<span class=\"comment\">// idx为Bucket在arData中存储位置</span></span><br><span class=\"line\">\tidx = ht-&gt;nNumUsed++;</span><br><span class=\"line\">\tht-&gt;nNumOfElements++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ht-&gt;nInternalPointer == HT_INVALID_IDX) &#123;</span><br><span class=\"line\">\t\tht-&gt;nInternalPointer = idx;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((zend_long)h &gt;= (zend_long)ht-&gt;nNextFreeElement) &#123;</span><br><span class=\"line\">\t\tht-&gt;nNextFreeElement = h &lt; ZEND_LONG_MAX ? h + <span class=\"number\">1</span> : ZEND_LONG_MAX;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找到存储Bucket，设置key、value</span></span><br><span class=\"line\">\tp = ht-&gt;arData + idx;</span><br><span class=\"line\">\tp-&gt;h = h;</span><br><span class=\"line\">\tp-&gt;key = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算中间映射表的散列值，idx将保存在映射数组的nIndex位置</span></span><br><span class=\"line\">\tnIndex = h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t<span class=\"comment\">// 将映射表中原来的值保存到新Bucket中，哈希冲突时会用到</span></span><br><span class=\"line\">\tZVAL_COPY_VALUE(&amp;p-&gt;val, pData);</span><br><span class=\"line\">\t<span class=\"comment\">// 先把旧的值保存到新插入的元素中</span></span><br><span class=\"line\">\tZ_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class=\"line\">\t<span class=\"comment\">// 再把新元素数组存储位置更新到映射表中</span></span><br><span class=\"line\">\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);</span><br><span class=\"line\">\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;p-&gt;val;</span><br></pre></td></tr></table></figure>\n<h6 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h6><p>​        散列表中不同元素的<code>key</code>可能计算得到相同的哈希值，这些具有相同哈希值的元素在插入散列表时就会发生冲突，因为映射表只能存储一个元素。  </p>\n</li>\n</ul>\n<p><strong>常见的解决方式（PHP采用这种方式）：将冲突的Bucket串成链表，查找时需要遍历这个链表，逐个比较<code>key</code>，从而找到目标元素。</strong></p>\n<ul>\n<li>具体操作：<pre><code>    `HashTable`中的`Bucket`会记录与它冲突的元素在`arData`数组中的存储位置。在设置映射值时，如果发现映射表中要设置的位置已经被之前插入的元素占用了（值不等于初始化的-1），那么会把已经存在的值保存到新插入的`Bucket`中，然后将映射表中的值更新为新`Bucket`的存储位置（即每次都会把冲突的元素插到开头）。  </code></pre>\n<strong>冲突元素的保存位置为：</strong><code>Bucket.val.u2.next</code></li>\n</ul>\n<p><strong>示例</strong>：一个数组有三个元素，按照a、b、c的顺序插入，加入a、c两个key冲突了，则HashTable的结构如下：<br>$arr = [];<br>$arr[‘a’] = 11;<br>$arr[‘b’] = 22;<br>$arr[‘c’] = 33;<br><img src=\"https://note.youdao.com/yws/api/personal/file/C469391F27FF454698CCD908B98FB2B2?method=download&shareKey=9501d4a7b3029c279f3d545c7f9c18e2\" alt=\"哈希冲突链表\"></p>\n<h6 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h6><p>查找过程如下：</p>\n<ul>\n<li>①、根据<code>key</code>计算出<code>hash code</code>（即<code>zend_string-&gt;h</code>）与<code>nTableMask</code>计算得到散列值<code>nIndex</code>。</li>\n<li>②、根据散列值从中间映射表中得到存储元素在有序存储数组中的位置<code>idx</code>。</li>\n<li>③、根据<code>idx</code>从有序存储数组（<code>HashTable-&gt;arData</code>）中取出<code>Bucket</code></li>\n<li>④、从取出的<code>Bucket</code>进行遍历，判断Bucket的key是否是要查找的key，若是则停止遍历，否则继续根据<code>zval.u2.next</code>遍历比较。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// zend_hash_find_bucket:</span></span><br><span class=\"line\"><span class=\"comment\">// 根据zend_string *key进行查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> zend_always_inline Bucket *<span class=\"title\">zend_hash_find_bucket</span><span class=\"params\">(<span class=\"keyword\">const</span> HashTable *ht, zend_string *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tzend_ulong h;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> nIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> idx;</span><br><span class=\"line\">\tBucket *p, *arData;</span><br><span class=\"line\"></span><br><span class=\"line\">\th = zend_string_hash_val(key);</span><br><span class=\"line\">\tarData = ht-&gt;arData;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算散列值</span></span><br><span class=\"line\">\tnIndex = h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取Bucket存储位置</span></span><br><span class=\"line\">\tidx = HT_HASH_EX(arData, nIndex);</span><br><span class=\"line\">    <span class=\"comment\">// 遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (EXPECTED(idx != HT_INVALID_IDX)) &#123;</span><br><span class=\"line\">\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (EXPECTED(p-&gt;key == key)) &#123; <span class=\"comment\">/* check for the same interned string */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (EXPECTED(p-&gt;h == h) &amp;&amp; <span class=\"comment\">// 先比较hash code</span></span><br><span class=\"line\">\t\t     EXPECTED(p-&gt;key) &amp;&amp; </span><br><span class=\"line\">\t\t     <span class=\"comment\">// 在比较key长度，最后按字符比较是否相同</span></span><br><span class=\"line\">\t\t     EXPECTED(ZSTR_LEN(p-&gt;key) == ZSTR_LEN(key)) &amp;&amp;</span><br><span class=\"line\">\t\t     EXPECTED(<span class=\"built_in\">memcmp</span>(ZSTR_VAL(p-&gt;key), ZSTR_VAL(key), ZSTR_LEN(key)) == <span class=\"number\">0</span>)) &#123;<span class=\"comment\">// 比较查找的key与Bucket的key是否匹配</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 不匹配则继续遍历</span></span><br><span class=\"line\">\t\tidx = Z_NEXT(p-&gt;val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h6 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h6><p>​        数组的容量是有限的，最多可以存储<code>nTableSize</code>个元素，那么当数组空间已满还要继续插入时如何处理？  </p>\n<p><strong>问: PHP是怎样实现的自动扩容？</strong></p>\n<p>​        <strong>扩容的过程为</strong>：检查数组中已经删除的元素所占的比例（已经删除但未从存储数组中移除的元素）.若比例达到域值，则触发<strong>重建索引</strong>的操作，这个过程会把删除的Bucket移除，然后把后面的Bucket往前移补上空缺的Bucket；若还没有达到域值，则分配一个原数组大小2倍的新数组，然后把原数组的元素复制到新数组上，重建索引。 </p>\n<p><u>域值判断公式</u>如下，即域值为<code>nNumOfElement + (nNumElement / 32)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElement + (ht-&gt;nNumOfElement &gt;&gt; 5)</span><br></pre></td></tr></table></figure>\n\n<p>具体的处理过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> ZEND_FASTCALL <span class=\"title\">zend_hash_do_resize</span><span class=\"params\">(HashTable *ht)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tIS_CONSISTENT(ht);</span><br><span class=\"line\">\tHT_ASSERT(GC_REFCOUNT(ht) == <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ht-&gt;nNumUsed &gt; ht-&gt;nNumOfElements + (ht-&gt;nNumOfElements &gt;&gt; <span class=\"number\">5</span>)) &#123; <span class=\"comment\">// 无序扩容，将删除的Bucket移除，然后把后面的bucket往前补上空缺</span></span><br><span class=\"line\">\t\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 只有到达一定域值才进行rehash操作</span></span><br><span class=\"line\">\t\tzend_hash_rehash(ht); <span class=\"comment\">// 重建索引数组</span></span><br><span class=\"line\">\t\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ht-&gt;nTableSize &lt; HT_MAX_SIZE) &#123; <span class=\"comment\">// 扩容，分配原数组大小2倍的新数组。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span> *new_data, *old_data = HT_GET_DATA_ADDR(ht);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 扩大为2倍，加法比乘法快</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> nSize = ht-&gt;nTableSize + ht-&gt;nTableSize;</span><br><span class=\"line\">\t\tBucket *old_buckets = ht-&gt;arData;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tHANDLE_BLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 新分配arData空间，大小为(sizeof(Bucket) + sizeof(uint32_t)) * nSize;</span></span><br><span class=\"line\">\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class=\"line\">\t\tht-&gt;nTableSize = nSize;</span><br><span class=\"line\">\t\tht-&gt;nTableMask = -ht-&gt;nTableSize;</span><br><span class=\"line\">\t    <span class=\"comment\">// 将arData指针偏移到Bucket数组起始位置</span></span><br><span class=\"line\">\t\tHT_SET_DATA_ADDR(ht, new_data);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将旧的Bucket数组复制到新空间（此步只复制存储的元素，即HashTable-&gt;arData，不会复制中间映射表，因为扩容后旧的映射表已无法使用，key-value的映射关系需要重新计算，即重建索引）</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memcpy</span>(ht-&gt;arData, old_buckets, <span class=\"keyword\">sizeof</span>(Bucket) * ht-&gt;nNumUsed);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 释放旧空间</span></span><br><span class=\"line\">\t\tpefree(old_data, ht-&gt;u.flags &amp; HASH_FLAG_PERSISTENT);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 重建索引数组：映射表</span></span><br><span class=\"line\">\t\tzend_hash_rehash(ht);</span><br><span class=\"line\">\t\tHANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tzend_error_noreturn(E_ERROR, <span class=\"string\">&quot;Possible integer overflow in memory allocation (%zu * %zu + %zu)&quot;</span>, ht-&gt;nTableSize * <span class=\"number\">2</span>, <span class=\"keyword\">sizeof</span>(Bucket) + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">uint32_t</span>), <span class=\"keyword\">sizeof</span>(Bucket));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重建索引的过程实际上就是将所有元素重新插入一遍，其处理过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 遍历数组，重新设置中间映射表（索引表）</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">\t\t\tnIndex &#x3D; p-&gt;h | ht-&gt;nTableMask;</span><br><span class=\"line\">\t\t\tZ_NEXT(p-&gt;val) &#x3D; HT_HASH(ht, nIndex);</span><br><span class=\"line\">\t\t\tHT_HASH(ht, nIndex) &#x3D; HT_IDX_TO_HASH(i);</span><br><span class=\"line\">\t\t\tp++;</span><br><span class=\"line\">\t\t&#125; while (++i &lt; ht-&gt;nNumUsed);</span><br></pre></td></tr></table></figure>\n<p>重建索引会将已删除的bucket移除，移除后会把这个Bucket之后的元素全部向前移动一个位置，所以<strong>重建索引后存储数组中元素全部紧密排列在一起</strong>。</p>\n<h5 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h5><p>​        引用类型是PHP中比较特殊的一种类型，它实际是指向另外一个PHP变量（<em>在PHP中通过<code>&amp;操作符</code>产生一个引用变量</em>），对它的修改会直接改动实际指向的zval，<u>可以简单的理解为C中的指针</u>。  </p>\n<p>操作步骤：</p>\n<ul>\n<li>首先为<code>&amp;</code>操作的变量分配一个<code>zend_reference结构</code>，其内嵌一个<code>zval</code>，这个<code>zval</code>的<code>value</code>指向原来<code>zval</code>的<code>value</code>(<strong>注: 如果是布尔、整形、浮点则直接复制原来的值</strong>)。</li>\n<li>然后将原<code>zval</code>的类型修改为<code>IS_REFERENCE</code>，原<code>zval</code>的<code>value</code>指向新创建的<code>zend_reference</code>结构。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_reference &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    zval              val; &#x2F;&#x2F; 指向原来的value</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n示例1：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; date(&#39;Y-m-d&#39;);</span><br><span class=\"line\">$b &#x3D; &amp;$a;</span><br></pre></td></tr></table></figure>\n<img src=\"https://note.youdao.com/yws/api/personal/file/A5F4C7219117457A88A7D7CC3AFB53A9?method=download&shareKey=3d6950341fd9f21fea74f78f022500fd\" alt=\"a与b内存引用关系\"></li>\n</ul>\n<p><strong>注：若此时将<code>$b</code>复制给其他变量，那么传递给新变量的value将实时及引用的值，而不是引用本身</strong>。PHP中的引用只有一级，不会出现一个引用指向另外一个引用的情况，即没有C语言中多级指针的概念。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; date(&#39;Y-m-d&#39;);</span><br><span class=\"line\">$b &#x3D; &amp;$a;</span><br><span class=\"line\">$c &#x3D; $b; &#x2F;&#x2F; 若想让$c也指向$a&#x2F;$b引用的值，则：$c &#x3D; &amp;$b或$c &#x3D; &amp;$a;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/1E8C8DDDE51D479296CA8F63EA5353B7?method=download&shareKey=43183c8018d3140f9b924508528c2af2\" alt=\"a,b与c内存引用关系\"></p>\n<p>示例2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a    -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/697F728B851442D4AF142554DDF78333?method=download&shareKey=59d725805b5b7c8bc59c391e87607101\" alt=\"zend_ref\"></p>\n<p>注意：<strong>引用只能通过<code>&amp;</code>产生，无法通过赋值传递</strong>  </p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error:</span><br><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a    -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$c &#x3D; $b;                    &#x2F;&#x2F;$a,$b -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;2)</span><br><span class=\"line\">                            &#x2F;&#x2F;$c    -&gt; </span><br><span class=\"line\">right:</span><br><span class=\"line\">$a &#x3D; &quot;time:&quot; . time();      &#x2F;&#x2F;$a       -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$b &#x3D; &amp;$a;                   &#x2F;&#x2F;$a,$b    -&gt; zend_reference_1(refcount&#x3D;2) -&gt; zend_string_1(refcount&#x3D;1)</span><br><span class=\"line\">$c &#x3D; &amp;$b;&#x2F;*或$c &#x3D; &amp;$a*&#x2F;     &#x2F;&#x2F;$a,$b,$c -&gt; zend_reference_1(refcount&#x3D;3) -&gt; zend_string_1(refcount&#x3D;1)                             </span><br></pre></td></tr></table></figure>\n<p>这个也表示PHP中的 <strong>引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况</strong> ，也就是没有C语言中指针的指针的概念。</p>\n<h5 id=\"对象-资源\"><a href=\"#对象-资源\" class=\"headerlink\" title=\"对象/资源\"></a>对象/资源</h5><p>对象比较常见，资源指的是tcp连接、文件句柄等等类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _zend_object &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    uint32_t          handle;</span><br><span class=\"line\">    zend_class_entry *ce; &#x2F;&#x2F;对象对应的class类</span><br><span class=\"line\">    const zend_object_handlers *handlers;</span><br><span class=\"line\">    HashTable        *properties; &#x2F;&#x2F;对象属性哈希表</span><br><span class=\"line\">    zval              properties_table[1];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct _zend_resource &#123;</span><br><span class=\"line\">    zend_refcounted_h gc;</span><br><span class=\"line\">    int               handle;</span><br><span class=\"line\">    int               type;</span><br><span class=\"line\">    void             *ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h5><p>​        PHP是弱类型语言，使用时不需要明确定义变量的类型，Zend虚拟机在执行PHP代码时，会根据具体的应用场景进行转换，也就是变量会按照类型转换规则将不合格变量转换给合格的变量，然后进行操作。</p>\n<p>例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a &#x3D; &quot;100&quot; + 200</span><br></pre></td></tr></table></figure>\n<p>执行时Zend发现相加的一个值为字符串，就会试图将<code>字符串100</code>转为数值类型（整型或浮点型），然后与200相加。<br><strong>注：转换的时候并不会改变原来的值，而是会生成一个新的变量进行处理。</strong></p>\n<h6 id=\"强制转换\"><a href=\"#强制转换\" class=\"headerlink\" title=\"强制转换\"></a>强制转换</h6><p>PHP提供了一种强制转换方式：</p>\n<ul>\n<li>(int)/(integer): 转换为整型integer</li>\n<li>(bool)/(boolean):转换为布尔类型boolean</li>\n<li>(flaot)/(double)/(real):转换为浮点型flaot</li>\n<li>(string):转换为字符串string</li>\n<li>(array):转换为数组array</li>\n<li>(object):转换为对象object</li>\n<li>(unset):转换为null</li>\n</ul>\n<p><em>注：有些类型之间是无法转换的，如：资源类型，无法将任何类型转换为资源类型。</em></p>\n<h6 id=\"转换为null\"><a href=\"#转换为null\" class=\"headerlink\" title=\"转换为null\"></a>转换为null</h6><p>​        任意类型都可以转为null，转换时直接将新的<code>zval类型</code>设置为<code>IS_NULL</code>。</p>\n<h6 id=\"转换为布尔型\"><a href=\"#转换为布尔型\" class=\"headerlink\" title=\"转换为布尔型\"></a>转换为布尔型</h6><p>​        当转换为布尔型时，根据原值的<code>true</code>、<code>false</code>决定转换后的结果，一些值被认为是<code>false</code>，除此之外的其他值通常被认为是<code>true</code>。</p>\n<p>被认为是false的值:</p>\n<ul>\n<li>布尔值false本身</li>\n<li>整型0</li>\n<li>浮点型值0.0</li>\n<li>==空字符串（‘’），以及字符串‘0’==</li>\n<li>空数组</li>\n<li>null</li>\n</ul>\n<h6 id=\"转换为整型\"><a href=\"#转换为整型\" class=\"headerlink\" title=\"转换为整型\"></a>转换为整型</h6><p>从<code>其他值</code>转换为<code>整型</code>的规则如下：</p>\n<ul>\n<li>null：转换为0</li>\n<li>布尔型：false转为0，true转为1</li>\n<li>浮点型：向下取整，比如，(int)2.8 = 2</li>\n<li>字符串：与C语言strtoll()的规则一致<ul>\n<li>字符串以合法数值(包含正负数)开始，就使用该数值</li>\n<li><strong>否则，其值为0</strong></li>\n</ul>\n</li>\n<li>数组：很多操作不支持将一个数组自动转为整型处理，比如array()+2将报error错误，但可以强制把数组转为整型：<ul>\n<li>非空数组：1</li>\n<li>空数组：0<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php &gt; $a = <span class=\"keyword\">array</span>()+<span class=\"number\">2</span>;</span><br><span class=\"line\">PHP Fatal <span class=\"built_in\">error</span>:  Unsupported operand types in php shell code on line <span class=\"number\">1</span></span><br><span class=\"line\">PHP Stack trace:</span><br><span class=\"line\">PHP   <span class=\"number\">1.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br><span class=\"line\">PHP   <span class=\"number\">2.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; $a = <span class=\"keyword\">array</span>();</span><br><span class=\"line\">php &gt; $b = (<span class=\"keyword\">int</span>)$a;</span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> $b;</span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>对象：与数组类似，很多操作也不支持将兑现个自动转为整型，但有些操作只会抛一个warning警告，还是会把对象转换为1.</li>\n<li>资源：转为分配给这个资源的唯一编号</li>\n</ul>\n<h6 id=\"转为浮点型\"><a href=\"#转为浮点型\" class=\"headerlink\" title=\"转为浮点型\"></a>转为浮点型</h6><p>​        除了字符串类型外，其他类型转换规则与整型基本一致，只是在整型转换结果上加了小数位，字符串转为浮点数有<code>zend_strtod</code>完成。</p>\n<h6 id=\"转换为字符串\"><a href=\"#转换为字符串\" class=\"headerlink\" title=\"转换为字符串\"></a>转换为字符串</h6><ul>\n<li>强制转换：<ul>\n<li>(string)</li>\n<li>strval()函数</li>\n</ul>\n</li>\n<li>自动转换：<ul>\n<li>需要字符串的表达式中，比如：函数echo或print时</li>\n<li>非string类型变量与一个string变量进行比较时<ul>\n<li>null/fasle:转为空字符串</li>\n<li>true：转为“1”</li>\n<li>整型：原样转为字符串，<strong>转换时将各位一次除10取余</strong></li>\n<li>浮点型：原样转为字符串</li>\n<li>资源：转为“Resource id#xxx”</li>\n<li>数组：转为“Array”，同时报Notice</li>\n<li>对象：不能转换，将报错,如下：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php &gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">php</span> &gt; </span>&#123;<span class=\"keyword\">public</span> $b;&#125;</span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; $a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">php &gt; </span><br><span class=\"line\">php &gt; <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;a= &#x27;</span> . $a;</span><br><span class=\"line\">PHP Catchable fatal <span class=\"built_in\">error</span>:  <span class=\"keyword\">Object</span> of <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"title\">could</span> <span class=\"title\">not</span> <span class=\"title\">be</span> <span class=\"title\">converted</span> <span class=\"title\">to</span> <span class=\"title\">string</span> <span class=\"title\">in</span> <span class=\"title\">php</span> <span class=\"title\">shell</span> <span class=\"title\">code</span> <span class=\"title\">on</span> <span class=\"title\">line</span> 1</span></span><br><span class=\"line\">PHP Stack trace:</span><br><span class=\"line\">PHP   <span class=\"number\">1.</span> &#123;main&#125;() php shell code:<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"转换为数组\"><a href=\"#转换为数组\" class=\"headerlink\" title=\"转换为数组\"></a>转换为数组</h6></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>若变量类型为<code>null</code>、<code>integer</code>、<code>float</code>、<code>string</code>、<code>boolean</code>和<code>resource</code>中的一个：将得到一个仅有一个元素的数组，其<code>下标为0</code>，即(array)$scalarValue与<code>array($scalarValue)</code>完全一样。</li>\n<li>若变量类型为object：其结果为一个数组，数组的元素为该对象的全部属性（包含public、private、protected），但他们也是有区别的，如下：<ul>\n<li>public的属性：key</li>\n<li>private的属性：key加类型作为前缀</li>\n<li>protected的属性：’*’加key作为前缀<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public $a &#x3D; 123;</span><br><span class=\"line\">    private $b &#x3D; &#39;bbb&#39;;</span><br><span class=\"line\">    protected $c &#x3D; &#39;ccc&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$test &#x3D; new test();</span><br><span class=\"line\">print_r((array)$test);</span><br></pre></td></tr></table></figure>\n以上例子将输出：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$php stat.php </span><br><span class=\"line\">Array</span><br><span class=\"line\">(</span><br><span class=\"line\">    [a] &#x3D;&gt; 123</span><br><span class=\"line\">    [testb] &#x3D;&gt; bbb</span><br><span class=\"line\">    [*c] &#x3D;&gt; ccc</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"转换为对象\"><a href=\"#转换为对象\" class=\"headerlink\" title=\"转换为对象\"></a>转换为对象</h6><p>其他任何类型的值被转换为对象，将会创建一个内置类stdClass的实例：</p>\n<ul>\n<li>若该值为null：新的实例为空</li>\n<li>array：转换成的object将以键名成为属性名，并具有相对应的值<ul>\n<li>数值索引的元素也将转为属性，但无法通过“-&gt;”访问，只能遍历获取</li>\n<li>非数值索引：会以‘scalar’作为属性名</li>\n</ul>\n</li>\n</ul>"},{"title":"Redis设计与实现-Redis对象","date":"2020-08-31T09:14:48.000Z","_content":"\n\n\nRedis基于其数据结构（例如，SDS、双端链表、字典、压缩列表、整数集合等）创建了一个对象系统，该系统包含`字符串对象`、`列表对象`、`哈希对象`、`集合对象`和`有序集合`对象这五种对象，每种对象都用到了至少一种数据结构。\n\n<!--more-->\n\n### 1 对象的类型与编码\n\nRedis使用`对象`来表示数据库中的健和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的健（键对象），另一个对象用作键值对的值（值对象）。\n\n\n\nRedis中每个对都由`redisObject`结构表示，如下所示：\n\n```c\ntypedef struct redisObject {\n    // 类型.\n    unsigned type:4;\n    // 编码.\n    unsigned encoding:4;\n    // 记录了对象最后一次被命令程序访问的时间。\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用次数\n    int refcount;\n    // 指向底层实现数据结构的指针。\n    void *ptr;\n} robj;\n```\n\n\n\n#### 1.1 类型\n\n对象的type属性记录了对象的类型，这个类型包括以下5中类型：\n\n- **REDIS_STRING**：字符串对象(type命令输出：“string”)\n- **REDIS_LIST**：列表对象(type命令输出：“list”)\n- **REDIS_HASH**：哈希对象(type命令输出：“hash”)\n- **REDIS_SET**：集合对象(type命令输出：“set”)\n- **REDIS_ZSET**：有序集合对象(type命令输出：“zset”)\n\n*使用`type命令`可以返回**数据库键对应的值对象类型***\n\n\n\n*对于Redis数据库保存的`键值`对来说，<u>键总是一个字符串对象</u>，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的一种，因此我们称“XX键”表示这个数据库键所对应的值为XX对象。*\n\n\n\n#### 1.2 编码和底层实现\n\n对象的`ptr`指向对象的底层实现数据结构，而这些数据结构由对象的`encoding`属性决定。\n\nencoding对象属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现，其对象的编码如下：\n\n- **REDIS_ENCODING_INT**：long类型的整数(object encoding命令输出：int)\n- **REDIS_ENCODING_EMBSTR**：embstr编码的简单动态字符串(object encoding命令输出：embstr)\n- **REDIS_ENCODING_RAW**：简单动态字符串(object encoding命令输出：raw)\n- **REDIS_ENCODING_HT**：字典(object encoding命令输出：hashtable)\n- **REDIS_ENCODING_LINKEDLIST**：双端链表(object encoding命令输出：linkedlist)\n- **REDIS_ENCODING_ZIPLIST**：压缩列表(object encoding命令输出：ziplist)\n- **REDIS_ENCODING_INTSET**：整数集合(object encoding命令输出：intset)\n- **REDIS_ENCODING_SKIPLIST**：跳跃表和字典(object encoding命令输出：skiplist)\n\n\n\n每种类型的对象都至少使用了两种不同的编码，如下所示：\n\n![每种类型的对象都至少使用了两种不同的编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/每种类型的对象都至少使用了两种不同的编码.png)\n\n*使用`object encoding命令`可以**查看一个数据库键的值对象的编码***\n\n\n\n**为什么Redis要使用encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码？**\n\n因为使用encoding属性设定编码方式可以<u>根据不同的适用场景设置不同的编码，从而优化对象在某一场景下的效率。</u>例如，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现，压缩列表比双向链表更节约内存，且在元素数量较少是，在内存中以连续块方式保存的压缩列表比起双向链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，是用压缩列表来保存元素的优势逐渐消失，对象就会将底层实现从压缩列表转向功能更强、也更合适保存大量元素的双端链表上。\n\n### 2 字符串对象\n\n字符串对象的编码可以是`int`、`raw`、`embstr`。\n\n- **int**：字符串对象保存的是`整数值，并且这个整数值可以用long类型类表示`，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *装换成long），并将字符串对象的编码设置为int。\n- **raw**：字符串对象保存的是一个`字符串值，并且这个字符串值的长度大于32字节`，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。\n- **embstr**：字符串对象保存的是一个`字符串值，并且这个字符串值的长度小于等于32字节`，那么字符串对象将使用embstr编码的方式来保存这个字符串值。\n\n示例：\n\n```bash\n127.0.0.1:6379> set number 10086\nOK\n127.0.0.1:6379> object encoding number\n\"int\"\n\n127.0.0.1:6379> set story \"Long, long ago there lived a king and a queen, they have a beautiful daughter...\"\nOK\n127.0.0.1:6379> strlen story\n(integer) 80\n127.0.0.1:6379> object encoding story\n\"raw\"\n\n127.0.0.1:6379> set msg \"hello\"\nOK\n127.0.0.1:6379> object encoding msg\n\"embstr\"\n```\n\n\n\n**问: 既然有raw编码方式，为什么还要有embstr编码呢？它们有什么异同点？**\n\n- 相同点:\n\n  - embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw一样，都是用redisObject结构和sdshdr结构来表示字符串对象。\n\n- 不同点：\n\n  - raw编码会<u>调用两次内存分配函数</u>分别创建redisObject结构和sdshdr结构。\n\n  - embstr则通过调用一次内存分配函数来分配<u>一块连续的空间</u>，空间中依次包含redisObject和sdshdr两个结构。\n\n    \n\n    embstr编码创建的内存块结构如下：\n\n![embstr编码创建的内存块结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/embstr编码创建的内存块结构.png)\n\n\n\n**问: 使用embstr编码的字符串对象来保存短字符串值有什么好处？**\n\n- ①、embstr编码将创建的字符串对象所需的内存分配次数从raw编码的两次降低为一次。\n- ②、释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。\n- ③、embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比raw编码的字符串对象能更好的利用缓存带来的优势。\n\n\n\n注：`long double类型表示的浮点数在Redis中也是作为字符串值来保存的`, 如下示例所示：\n\n```bash\n127.0.0.1:6379> set pi 3.14\nOK\n127.0.0.1:6379> object encoding pi\n\"embstr\"\n```\n\n\n\n下图为字符串对象保存各类型值的编码方式：\n\n![字符串对象保存各类型值的编码方式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/字符串对象保存各类型值的编码方式.png)\n\n\n\n#### 2.1 编码转换\n\n`int编码`的字符串对象和`embstr编码`的字符串对象在条件满足的情况下，会被转换为`raw编码`的字符串对象。\n\n- **int编码->raw编码**：执行一些命令，使得对象保存的值不再是整数值，而是一个字符串值时。例如APPEND命令。\n- **embstr编码->raw编码**：Redis并没有为embstr编码提供任何修改程序，因此`实际上embstr编码的字符串是只读的`，当对embstr编码的字符串进行修改时，程序会先将对象的编码从embstr转换为raw，再执行修改命令。\n\n\n\n示例1：\n\n```bash\n127.0.0.1:6379> set number 10086\nOK\n127.0.0.1:6379> object encoding number\n\"int\"\n127.0.0.1:6379> append number \" is a good number!\" # 使用append命令将对象变为一个字符串.\n(integer) 23\n127.0.0.1:6379> get number\n\"10086 is a good number!\"\n127.0.0.1:6379> object encoding number\n\"raw\"\n```\n\n示例2：\n\n```bash\n127.0.0.1:6379> set msg \"hello word\"\nOK\n127.0.0.1:6379> object encoding msg\n\"embstr\"\n127.0.0.1:6379> append msg \" again!\" # embstr字符串是只读的,当对其进行修改时,将强制转换为raw编码,再进行修改.\n(integer) 17\n127.0.0.1:6379> object encoding msg\n\"raw\"\n```\n\n\n\n#### 2.2 应用场景\n\n- 存储key-value键值对．\n\n\n\n### 3 列表对象\n\n列表对象的编码可以是`ziplist`或者`linkedlist`。\n\n- ziplist编码的列表对象: 使用`压缩列表`作为底层实现，每个压缩列表结点(entry)保存了一个列表元素。\n- linkedlist编码的列表对象: 使用`双端链表`作为底层实现，每个双端链表结点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。\n\n\n\n示例1：\n\n```bash\n127.0.0.1:6379> rpush numbers 1 \"three\" 5\n(integer) 3\n```\n\n`ziplist编码`的numbers列表对象如下：\n\n![ziplist编码的numbers列表对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的numbers列表对象.png)\n\n\n\nlinkedlist编码的numbers列表对象如下：\n\n![linkedlist编码的numbers列表对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/linkedlist编码的numbers列表对象.png)\n\n\n\n其中完整的StringObject表示方式如下：\n\n![完整的StringObject表示方式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/完整的StringObject表示方式.png)\n\n#### 3.1 编码转换\n\n当列表对象可以同时满足以下两个条件时，列表对象使用`ziplist`编码。其他情况下需要使用`linkedlist`编码。\n\n- ①、列表对象保存的所有字符串元素的长度都小于64字节（由配置`list-max-ziplist-value`决定）；\n- ②、列表对象保存的元素数量小于512个（由配置`hash-max-ziplist-entries`决定）。\n\n\n\n示例1：保存长度太大的元素而进行编码转换的情况。\n\n```bash\n127.0.0.1:6379> rpush blah \"hello\" \"world\" \"again\"\n(integer) 3\n127.0.0.1:6379> object encoding blah\n\"ziplist\"\n127.0.0.1:6379> rpush blah \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n(integer) 5\n127.0.0.1:6379> object encoding blah\n\"linkedlist\"\n```\n\n\n\n示例2：保存的元素数量过多而进行编码转换的情况。\n\n```bash\n# 俩比偶对象包含512个元素。\n127.0.0.1:6379> eval \"for i=1, 512 do redis.call('rpush', KEYS[1], i)end\" 1 \"integers\"\n(nil)\n# 获取列表长度.\n127.0.0.1:6379> llen integers\n(integer) 512\n127.0.0.1:6379> object encoding integers\n\"ziplist\"\n\n# 再向列表对象推入一个新元素，使得对象保存的元素数量达到513个。\n127.0.0.1:6379> rpush integers 512\n(integer) 513\n127.0.0.1:6379> object encoding integers\n\"linkedlist\"\n```\n\n\n\n#### 3.2 应用场景\n\n由于list是一个按照插入顺序排序的列表，所有应用场景还比较多，例如：\n\n- 消息队列：lpop和rpush能实现队列的功能．\n- 朋友圈的点赞列表，评论列表，排行榜：lpush和lrange命令能实现<u>最新列表的功能</u>．\n- 每次通过lpush命令往列表礼插入新的元素，然后通过lrange命令读取<u>最新的元素列表</u>．\n\n\n\n### 4 哈希对象\n\n哈希对象的编码可以是`ziplist`或者`hashtable`。\n\n- **ziplist编码**：ziplist编码作为哈希对象使用`压缩列表`作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。因此，`保存了同一键值对的两个结点总是紧挨在一起的，键结点在前，值结点在后`。\n\n- **hashtable编码**: 哈希对象使用`字典`作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：字典中每个键/值都是一个字符串对象，对象中保存了键值对的键/值。\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> hset profile name \"Tom\"\n(integer) 1\n127.0.0.1:6379> hset profile age 25\n(integer) 1\n127.0.0.1:6379> hset profile career \"Programmer\"\n(integer) 1\n```\n\n\n\nziplist编码的profile哈希对象的底层实现如下：\n\n![ziplist编码的profile哈希对象的底层实现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的profile哈希对象的底层实现.png)\n\n\n\nhashtable编码的profile哈希对象底层实现如下：\n\n![hashtable编码的profile哈希对象底层实现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/hashtable编码的profile哈希对象底层实现.png)\n\n#### 4.1 编码转换\n\n**问: 什么情况下，哈希对象使用ziplist编码？**\n\n当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：\n\n- ①、哈希对象保存的所有键值对的键和值的字符串长度都小于64字节（`hash-max-ziplist-value`）；\n- ②、哈希对象保存的键值对数量小于512个（`hash-max-ziplist-entries`）；\n\n当以上两个条件任何一个不满足时，都会进行编码装换为hashtable。\n\n\n\n示例1：键值对的键太大而引起的编码转换。\n\n```bash\n127.0.0.1:6379> hset book name \"Mastering C++ in 21 days\"\n(integer) 1\n127.0.0.1:6379> object encoding book\n\"ziplist\"\n127.0.0.1:6379> hset book long_long_long_long_long_long_long_long_long_long_long_long_long_long_description \"content\"\n(integer) 1\n127.0.0.1:6379> object encoding book\n\"hashtable\"\n```\n\n\n\n示例2： 哈希对象因为包含的键值对数量过多而引起编码转换。\n\n```bash\n127.0.0.1:6379> EVAL \"for i=1, 512 do redis.call('HSET', KEYS[1], i, i)end\" 1 \"numbers\"\n(nil)\n127.0.0.1:6379> hlen numbers\n(integer) 512\n127.0.0.1:6379> object encoding numbers\n\"ziplist\"\n127.0.0.1:6379> hmset numbers \"key\" \"value\"\nOK\n127.0.0.1:6379> object encoding numbers\n\"hashtable\"\n```\n\n\n\n#### 4.2 应用场景\n\n例如：\n\n- 购物车：`hset [key] [field] [value]`命令，可以存储以`uid`，`商品id为field`，`商品数量为value`的数据，刚好是购物车的三要素．\n- 存储对象：`hash`类型的`(key, field, value)`的结构与对象的`(对象id, 属性, 值)`的结构相似，也可以用来存储对象。\n\n\n\n### 5 集合对象\n\n集合对象的编码可以是`intset`或者`hashtable`。\n\n- intset编码的集合对象: 使用`整数集合`作为底层实现，集合对象包含的所有元素都被存在整数集合里。\n- hashtable编码的集合对象: 使用`字典`作为底层实现，`字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为null。`\n\n\n\n示例：\n\n```bash\n# intset\n127.0.0.1:6379> sadd numbers 1 3 5\n(integer) 3\n127.0.0.1:6379> object encoding numbers\n\"intset\"\n\n#hashtable\n127.0.0.1:6379> sadd fruits \"apple\" \"banana\" \"cherry\"\n(integer) 3\n127.0.0.1:6379> object encoding fruits\n\"hashtable\"\n```\n\n\n\nintset编码的numbers集合对象\n\n![intset编码的numbers集合对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/intset编码的numbers集合对象.png)\n\nhashtable编码的fruits集合对象\n\n![hashtable编码的fruits集合对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/hashtable编码的fruits集合对象.png)\n\n#### 5.1 编码的转换\n\n**问: 什么情况下，集合对象使用intset编码？**\n\n当集合对象同时满足以下两个条件时，对象使用intset编码：\n\n- ①、结合兑现个保存的所有元素都是整数值；\n- ②、集合对象保存的元素数量不超过512个（`set-max-intset-entries`）。\n\n当其中一个条件不满足时，intset编码方式将自动变为hashtable编码方式。\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> sadd numbers 1 3 5\n(integer) 3\n127.0.0.1:6379> object encoding numbers\n\"intset\"\n127.0.0.1:6379> sadd numbers \"seven\" # 添加非整数元素, 使得集合编码变为为hashtable.\n(integer) 1\n127.0.0.1:6379> object encoding numbers\n\"hashtable\"\n```\n\n\n\n#### 5.2 应用场景\n\n例如：\n\n- 好友，关注，粉丝，感兴趣的人的集合：\n  - `sinter`命令可以获取A和B两个用户的共同好友；\n  - `sismember`可以判断A是否时B的好友；\n  - `scard`命令可以获取好友数量;\n  - 关注时，`smove`命令可以将B从A的粉丝集合转移到A的好友集合．\n- 首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而`srandmember`命令则可以从中随机获取几个。\n- 存储某活动中奖的用户ID，因为具有去重功能，可以保证同一个用户不会中奖两次．\n\n\n\n### 6 有序集合对象\n\n有序集合的编码可以是`ziplist`或者`skiplist`。\n\n- **ziplist编码**：ziplist编码的压缩列表对象使用`压缩列表`作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，`第一个节点保存元素的成员，第二个元素保存元素的分值`。`压缩列表内的集合元素按分值从小到大进行排序`，分值较小的元素被放置在靠近表头的方向，分值较大的元素则被放置在靠近表尾的方向。\n\n- **skiplist编码**：skiplist编码的有序集合对象使用`zset结构`作为底层实现，`一个zset结构同时包含一个字典和一个跳跃表`。\n\n\n\nzset结构如下：\n\n```c\ntypedef struct zset {\n    // 该字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了元素的成员，字典的值则保存了元素的分值。\n    dict *dict;\n    // 按分值从小到大保存了所有集合的元素。\n    zskiplist *zsl;\n} zset;\n```\n\n*注：有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。<u>跳跃表和字典均是通过指针来共享元素的成员和分值，因此同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会因此而浪费额外的内存</u>。*\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> zadd price 8.5 apple 5.0 banana 6.0 cherry\n(integer) 3\n```\n\n\n\nziplist编码的price对象：\n\n![ziplist编码的price对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的price对象.png)\n\n\n\nskiplist编码的price对象：\n\n![skiplist编码的price对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/skiplist编码的price对象.png)\n\n\n\n**问: 为什么有序集合需要同时使用跳跃表和字典来实现？**\n\n理论上，有序集合可以单独使用字典或者跳跃表的其中一个数据结构来实现，但无论单独使用字典还是跳跃表，其性能上对比同时视同字典和跳跃表都会有所降低。\n\n- 若单独使用字典来实现有序集合，那么虽然查找时时间复杂度保留，仍然是O(1)，但是当执行范围操作时，程序都要需要对所有元素进行排序操作。而完成排序操作至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间用于保存排序后的数组。\n- 若单独使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1上升为O(logN)。\n\n\n\n#### 6.1 应用场景\n\n- 排行榜，但是和list不同的是它能够实现动态的排序，例如：可以用来存储粉丝列表，value值时粉丝的用户ID，score是关注时间，然后可以对粉丝列表按关注时间进行排序．\n- 存储学生成绩，`value` 值是学生的 ID, `score` 是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。\n\n\n\n### 7 内存回收\n\nRedis在自己的对象系统中构建了一个`引用计数`技术实现内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象，并进行内存回收。\n\n每个对象的计数信息由`redisObject结构`中有一个`refcount属性`记录：\n\n```c\ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用计数。\n    int refcount;\n    void *ptr;\n} robj;\n```\n\n\n\n对象的引用计数信息会随着对象的使用状态而不断变化：\n\n- ①、在创建一个新对象时，引用计数的值会被初始化为1；\n- ②、当对象被一个新程序使用时，它的引用计数值会被赠一；\n- ③、当对象不再被一个程序引用时，它的引用计数值会被减一；\n- ④、当对象的引用计数值变为0时，对象所占用的内存会被释放掉。\n\n通过以下命令可以查键对应的值对象的引用计数：\n\n`object refcount xxx`\n\n\n\n示例：\n\n```\n127.0.0.1:6379> set a 100\nOK\n127.0.0.1:6379> object refcount a\n(integer) 2\n```\n\n**问: 为什么此处引用计数是为2呢？**\n\n因为对象引用计数属性还带有对象共享的作用，redis在初始化服务器时，创建一万个字符对象，这些对象包括从0到9999的所有整数值，当服务器需要用到这些值时，服务器就会使用这些共享对象，而不是新创建对象。\n\n\n\n此处持有这个值对象的两个程序分别是，其示意图如下：\n\n- ①、这个值对象的服务器程序；\n- ②、共享这个值对象的键a；\n\n![持有同一值对象的两个程序](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/持有同一值对象的两个程序.png)\n\n注：Redis会共享值为0~9999的字符串对象。\n\n\n\n**问: 为什么Redis不共享包含字符串的对象？**\n\n当服务器服务器考虑将一个共享对象设置为键的值对象时，程序需要先根据给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就越高，消耗的CPU时间也会越多。\n\n- 若共享对象是保存的整数值的字符串对象，那么验证操作的复杂度就是O(1).\n- 若共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)。\n- 若共享对象是包含多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。\n\n因此，尽管共享更复杂的对象可以节约更多的内存，但是收到CPU时间的限制，Redis值对包含整数值的字符串对象进行共享。\n\n\n\n### 8 对象的空转时长\n\nredisObject结构还包含一个`lru属性`，该属性`用于记录对象最后一次被命令程序访问的时间`：\n\n```c\ntypedef struct redisObject {\n    // 类型.\n    unsigned type:4;\n    // 编码.\n    unsigned encoding:4;\n    // 记录了对象最后一次被命令程序访问的时间。\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用次数\n    int refcount;\n    // 指向底层实现数据结构的指针。\n    void *ptr;\n} robj;\n```\n\n`空转时长`：通过当前时间减去键的值对象的lru时间计算得出的，通过以下命令可打印出给定键的空转时长：\n\n`object idletime xxx`\n\n*注：该命令的实现是特殊的，执行时并不会修改值的lru属性。*\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> set msg \"hello world\"\nOK\n127.0.0.1:6379> object idletime msg\n(integer) 8\n# 访问msg键的值\n127.0.0.1:6379> get msg\n\"hello world\"\n# 键处于活跃状态，空转时长为0.\n127.0.0.1:6379> object idletime msg\n(integer) 0\n```\n\n空转时长还有一项作用，若服务器打开了`maxmemory`选项，并且服务器用于回收内存算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那么部分键会优先被服务器释放，从而回收内存。\n\n\n\n------\n\n### 参考资料\n\nredis设计与实现（第二版） 黄健宏\n[一口气说出Redis 5种数据结构及对应使用场景，面试要加分的](https://zhuanlan.zhihu.com/p/107439357)","source":"_posts/Redis设计与实现-Redis对象.md","raw":"---\ntitle: Redis设计与实现-Redis对象\ndate: 2020-08-31 17:14:48\ntags: [\"Redis\",\"Note\",\"Redis设计与实现\"]\ncategories: [\"Redis\"]\n---\n\n\n\nRedis基于其数据结构（例如，SDS、双端链表、字典、压缩列表、整数集合等）创建了一个对象系统，该系统包含`字符串对象`、`列表对象`、`哈希对象`、`集合对象`和`有序集合`对象这五种对象，每种对象都用到了至少一种数据结构。\n\n<!--more-->\n\n### 1 对象的类型与编码\n\nRedis使用`对象`来表示数据库中的健和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的健（键对象），另一个对象用作键值对的值（值对象）。\n\n\n\nRedis中每个对都由`redisObject`结构表示，如下所示：\n\n```c\ntypedef struct redisObject {\n    // 类型.\n    unsigned type:4;\n    // 编码.\n    unsigned encoding:4;\n    // 记录了对象最后一次被命令程序访问的时间。\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用次数\n    int refcount;\n    // 指向底层实现数据结构的指针。\n    void *ptr;\n} robj;\n```\n\n\n\n#### 1.1 类型\n\n对象的type属性记录了对象的类型，这个类型包括以下5中类型：\n\n- **REDIS_STRING**：字符串对象(type命令输出：“string”)\n- **REDIS_LIST**：列表对象(type命令输出：“list”)\n- **REDIS_HASH**：哈希对象(type命令输出：“hash”)\n- **REDIS_SET**：集合对象(type命令输出：“set”)\n- **REDIS_ZSET**：有序集合对象(type命令输出：“zset”)\n\n*使用`type命令`可以返回**数据库键对应的值对象类型***\n\n\n\n*对于Redis数据库保存的`键值`对来说，<u>键总是一个字符串对象</u>，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的一种，因此我们称“XX键”表示这个数据库键所对应的值为XX对象。*\n\n\n\n#### 1.2 编码和底层实现\n\n对象的`ptr`指向对象的底层实现数据结构，而这些数据结构由对象的`encoding`属性决定。\n\nencoding对象属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现，其对象的编码如下：\n\n- **REDIS_ENCODING_INT**：long类型的整数(object encoding命令输出：int)\n- **REDIS_ENCODING_EMBSTR**：embstr编码的简单动态字符串(object encoding命令输出：embstr)\n- **REDIS_ENCODING_RAW**：简单动态字符串(object encoding命令输出：raw)\n- **REDIS_ENCODING_HT**：字典(object encoding命令输出：hashtable)\n- **REDIS_ENCODING_LINKEDLIST**：双端链表(object encoding命令输出：linkedlist)\n- **REDIS_ENCODING_ZIPLIST**：压缩列表(object encoding命令输出：ziplist)\n- **REDIS_ENCODING_INTSET**：整数集合(object encoding命令输出：intset)\n- **REDIS_ENCODING_SKIPLIST**：跳跃表和字典(object encoding命令输出：skiplist)\n\n\n\n每种类型的对象都至少使用了两种不同的编码，如下所示：\n\n![每种类型的对象都至少使用了两种不同的编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/每种类型的对象都至少使用了两种不同的编码.png)\n\n*使用`object encoding命令`可以**查看一个数据库键的值对象的编码***\n\n\n\n**为什么Redis要使用encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码？**\n\n因为使用encoding属性设定编码方式可以<u>根据不同的适用场景设置不同的编码，从而优化对象在某一场景下的效率。</u>例如，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现，压缩列表比双向链表更节约内存，且在元素数量较少是，在内存中以连续块方式保存的压缩列表比起双向链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，是用压缩列表来保存元素的优势逐渐消失，对象就会将底层实现从压缩列表转向功能更强、也更合适保存大量元素的双端链表上。\n\n### 2 字符串对象\n\n字符串对象的编码可以是`int`、`raw`、`embstr`。\n\n- **int**：字符串对象保存的是`整数值，并且这个整数值可以用long类型类表示`，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *装换成long），并将字符串对象的编码设置为int。\n- **raw**：字符串对象保存的是一个`字符串值，并且这个字符串值的长度大于32字节`，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。\n- **embstr**：字符串对象保存的是一个`字符串值，并且这个字符串值的长度小于等于32字节`，那么字符串对象将使用embstr编码的方式来保存这个字符串值。\n\n示例：\n\n```bash\n127.0.0.1:6379> set number 10086\nOK\n127.0.0.1:6379> object encoding number\n\"int\"\n\n127.0.0.1:6379> set story \"Long, long ago there lived a king and a queen, they have a beautiful daughter...\"\nOK\n127.0.0.1:6379> strlen story\n(integer) 80\n127.0.0.1:6379> object encoding story\n\"raw\"\n\n127.0.0.1:6379> set msg \"hello\"\nOK\n127.0.0.1:6379> object encoding msg\n\"embstr\"\n```\n\n\n\n**问: 既然有raw编码方式，为什么还要有embstr编码呢？它们有什么异同点？**\n\n- 相同点:\n\n  - embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw一样，都是用redisObject结构和sdshdr结构来表示字符串对象。\n\n- 不同点：\n\n  - raw编码会<u>调用两次内存分配函数</u>分别创建redisObject结构和sdshdr结构。\n\n  - embstr则通过调用一次内存分配函数来分配<u>一块连续的空间</u>，空间中依次包含redisObject和sdshdr两个结构。\n\n    \n\n    embstr编码创建的内存块结构如下：\n\n![embstr编码创建的内存块结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/embstr编码创建的内存块结构.png)\n\n\n\n**问: 使用embstr编码的字符串对象来保存短字符串值有什么好处？**\n\n- ①、embstr编码将创建的字符串对象所需的内存分配次数从raw编码的两次降低为一次。\n- ②、释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。\n- ③、embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比raw编码的字符串对象能更好的利用缓存带来的优势。\n\n\n\n注：`long double类型表示的浮点数在Redis中也是作为字符串值来保存的`, 如下示例所示：\n\n```bash\n127.0.0.1:6379> set pi 3.14\nOK\n127.0.0.1:6379> object encoding pi\n\"embstr\"\n```\n\n\n\n下图为字符串对象保存各类型值的编码方式：\n\n![字符串对象保存各类型值的编码方式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/字符串对象保存各类型值的编码方式.png)\n\n\n\n#### 2.1 编码转换\n\n`int编码`的字符串对象和`embstr编码`的字符串对象在条件满足的情况下，会被转换为`raw编码`的字符串对象。\n\n- **int编码->raw编码**：执行一些命令，使得对象保存的值不再是整数值，而是一个字符串值时。例如APPEND命令。\n- **embstr编码->raw编码**：Redis并没有为embstr编码提供任何修改程序，因此`实际上embstr编码的字符串是只读的`，当对embstr编码的字符串进行修改时，程序会先将对象的编码从embstr转换为raw，再执行修改命令。\n\n\n\n示例1：\n\n```bash\n127.0.0.1:6379> set number 10086\nOK\n127.0.0.1:6379> object encoding number\n\"int\"\n127.0.0.1:6379> append number \" is a good number!\" # 使用append命令将对象变为一个字符串.\n(integer) 23\n127.0.0.1:6379> get number\n\"10086 is a good number!\"\n127.0.0.1:6379> object encoding number\n\"raw\"\n```\n\n示例2：\n\n```bash\n127.0.0.1:6379> set msg \"hello word\"\nOK\n127.0.0.1:6379> object encoding msg\n\"embstr\"\n127.0.0.1:6379> append msg \" again!\" # embstr字符串是只读的,当对其进行修改时,将强制转换为raw编码,再进行修改.\n(integer) 17\n127.0.0.1:6379> object encoding msg\n\"raw\"\n```\n\n\n\n#### 2.2 应用场景\n\n- 存储key-value键值对．\n\n\n\n### 3 列表对象\n\n列表对象的编码可以是`ziplist`或者`linkedlist`。\n\n- ziplist编码的列表对象: 使用`压缩列表`作为底层实现，每个压缩列表结点(entry)保存了一个列表元素。\n- linkedlist编码的列表对象: 使用`双端链表`作为底层实现，每个双端链表结点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。\n\n\n\n示例1：\n\n```bash\n127.0.0.1:6379> rpush numbers 1 \"three\" 5\n(integer) 3\n```\n\n`ziplist编码`的numbers列表对象如下：\n\n![ziplist编码的numbers列表对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的numbers列表对象.png)\n\n\n\nlinkedlist编码的numbers列表对象如下：\n\n![linkedlist编码的numbers列表对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/linkedlist编码的numbers列表对象.png)\n\n\n\n其中完整的StringObject表示方式如下：\n\n![完整的StringObject表示方式](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/完整的StringObject表示方式.png)\n\n#### 3.1 编码转换\n\n当列表对象可以同时满足以下两个条件时，列表对象使用`ziplist`编码。其他情况下需要使用`linkedlist`编码。\n\n- ①、列表对象保存的所有字符串元素的长度都小于64字节（由配置`list-max-ziplist-value`决定）；\n- ②、列表对象保存的元素数量小于512个（由配置`hash-max-ziplist-entries`决定）。\n\n\n\n示例1：保存长度太大的元素而进行编码转换的情况。\n\n```bash\n127.0.0.1:6379> rpush blah \"hello\" \"world\" \"again\"\n(integer) 3\n127.0.0.1:6379> object encoding blah\n\"ziplist\"\n127.0.0.1:6379> rpush blah \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n(integer) 5\n127.0.0.1:6379> object encoding blah\n\"linkedlist\"\n```\n\n\n\n示例2：保存的元素数量过多而进行编码转换的情况。\n\n```bash\n# 俩比偶对象包含512个元素。\n127.0.0.1:6379> eval \"for i=1, 512 do redis.call('rpush', KEYS[1], i)end\" 1 \"integers\"\n(nil)\n# 获取列表长度.\n127.0.0.1:6379> llen integers\n(integer) 512\n127.0.0.1:6379> object encoding integers\n\"ziplist\"\n\n# 再向列表对象推入一个新元素，使得对象保存的元素数量达到513个。\n127.0.0.1:6379> rpush integers 512\n(integer) 513\n127.0.0.1:6379> object encoding integers\n\"linkedlist\"\n```\n\n\n\n#### 3.2 应用场景\n\n由于list是一个按照插入顺序排序的列表，所有应用场景还比较多，例如：\n\n- 消息队列：lpop和rpush能实现队列的功能．\n- 朋友圈的点赞列表，评论列表，排行榜：lpush和lrange命令能实现<u>最新列表的功能</u>．\n- 每次通过lpush命令往列表礼插入新的元素，然后通过lrange命令读取<u>最新的元素列表</u>．\n\n\n\n### 4 哈希对象\n\n哈希对象的编码可以是`ziplist`或者`hashtable`。\n\n- **ziplist编码**：ziplist编码作为哈希对象使用`压缩列表`作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。因此，`保存了同一键值对的两个结点总是紧挨在一起的，键结点在前，值结点在后`。\n\n- **hashtable编码**: 哈希对象使用`字典`作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：字典中每个键/值都是一个字符串对象，对象中保存了键值对的键/值。\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> hset profile name \"Tom\"\n(integer) 1\n127.0.0.1:6379> hset profile age 25\n(integer) 1\n127.0.0.1:6379> hset profile career \"Programmer\"\n(integer) 1\n```\n\n\n\nziplist编码的profile哈希对象的底层实现如下：\n\n![ziplist编码的profile哈希对象的底层实现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的profile哈希对象的底层实现.png)\n\n\n\nhashtable编码的profile哈希对象底层实现如下：\n\n![hashtable编码的profile哈希对象底层实现](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/hashtable编码的profile哈希对象底层实现.png)\n\n#### 4.1 编码转换\n\n**问: 什么情况下，哈希对象使用ziplist编码？**\n\n当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：\n\n- ①、哈希对象保存的所有键值对的键和值的字符串长度都小于64字节（`hash-max-ziplist-value`）；\n- ②、哈希对象保存的键值对数量小于512个（`hash-max-ziplist-entries`）；\n\n当以上两个条件任何一个不满足时，都会进行编码装换为hashtable。\n\n\n\n示例1：键值对的键太大而引起的编码转换。\n\n```bash\n127.0.0.1:6379> hset book name \"Mastering C++ in 21 days\"\n(integer) 1\n127.0.0.1:6379> object encoding book\n\"ziplist\"\n127.0.0.1:6379> hset book long_long_long_long_long_long_long_long_long_long_long_long_long_long_description \"content\"\n(integer) 1\n127.0.0.1:6379> object encoding book\n\"hashtable\"\n```\n\n\n\n示例2： 哈希对象因为包含的键值对数量过多而引起编码转换。\n\n```bash\n127.0.0.1:6379> EVAL \"for i=1, 512 do redis.call('HSET', KEYS[1], i, i)end\" 1 \"numbers\"\n(nil)\n127.0.0.1:6379> hlen numbers\n(integer) 512\n127.0.0.1:6379> object encoding numbers\n\"ziplist\"\n127.0.0.1:6379> hmset numbers \"key\" \"value\"\nOK\n127.0.0.1:6379> object encoding numbers\n\"hashtable\"\n```\n\n\n\n#### 4.2 应用场景\n\n例如：\n\n- 购物车：`hset [key] [field] [value]`命令，可以存储以`uid`，`商品id为field`，`商品数量为value`的数据，刚好是购物车的三要素．\n- 存储对象：`hash`类型的`(key, field, value)`的结构与对象的`(对象id, 属性, 值)`的结构相似，也可以用来存储对象。\n\n\n\n### 5 集合对象\n\n集合对象的编码可以是`intset`或者`hashtable`。\n\n- intset编码的集合对象: 使用`整数集合`作为底层实现，集合对象包含的所有元素都被存在整数集合里。\n- hashtable编码的集合对象: 使用`字典`作为底层实现，`字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为null。`\n\n\n\n示例：\n\n```bash\n# intset\n127.0.0.1:6379> sadd numbers 1 3 5\n(integer) 3\n127.0.0.1:6379> object encoding numbers\n\"intset\"\n\n#hashtable\n127.0.0.1:6379> sadd fruits \"apple\" \"banana\" \"cherry\"\n(integer) 3\n127.0.0.1:6379> object encoding fruits\n\"hashtable\"\n```\n\n\n\nintset编码的numbers集合对象\n\n![intset编码的numbers集合对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/intset编码的numbers集合对象.png)\n\nhashtable编码的fruits集合对象\n\n![hashtable编码的fruits集合对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/hashtable编码的fruits集合对象.png)\n\n#### 5.1 编码的转换\n\n**问: 什么情况下，集合对象使用intset编码？**\n\n当集合对象同时满足以下两个条件时，对象使用intset编码：\n\n- ①、结合兑现个保存的所有元素都是整数值；\n- ②、集合对象保存的元素数量不超过512个（`set-max-intset-entries`）。\n\n当其中一个条件不满足时，intset编码方式将自动变为hashtable编码方式。\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> sadd numbers 1 3 5\n(integer) 3\n127.0.0.1:6379> object encoding numbers\n\"intset\"\n127.0.0.1:6379> sadd numbers \"seven\" # 添加非整数元素, 使得集合编码变为为hashtable.\n(integer) 1\n127.0.0.1:6379> object encoding numbers\n\"hashtable\"\n```\n\n\n\n#### 5.2 应用场景\n\n例如：\n\n- 好友，关注，粉丝，感兴趣的人的集合：\n  - `sinter`命令可以获取A和B两个用户的共同好友；\n  - `sismember`可以判断A是否时B的好友；\n  - `scard`命令可以获取好友数量;\n  - 关注时，`smove`命令可以将B从A的粉丝集合转移到A的好友集合．\n- 首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而`srandmember`命令则可以从中随机获取几个。\n- 存储某活动中奖的用户ID，因为具有去重功能，可以保证同一个用户不会中奖两次．\n\n\n\n### 6 有序集合对象\n\n有序集合的编码可以是`ziplist`或者`skiplist`。\n\n- **ziplist编码**：ziplist编码的压缩列表对象使用`压缩列表`作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，`第一个节点保存元素的成员，第二个元素保存元素的分值`。`压缩列表内的集合元素按分值从小到大进行排序`，分值较小的元素被放置在靠近表头的方向，分值较大的元素则被放置在靠近表尾的方向。\n\n- **skiplist编码**：skiplist编码的有序集合对象使用`zset结构`作为底层实现，`一个zset结构同时包含一个字典和一个跳跃表`。\n\n\n\nzset结构如下：\n\n```c\ntypedef struct zset {\n    // 该字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了元素的成员，字典的值则保存了元素的分值。\n    dict *dict;\n    // 按分值从小到大保存了所有集合的元素。\n    zskiplist *zsl;\n} zset;\n```\n\n*注：有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。<u>跳跃表和字典均是通过指针来共享元素的成员和分值，因此同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会因此而浪费额外的内存</u>。*\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> zadd price 8.5 apple 5.0 banana 6.0 cherry\n(integer) 3\n```\n\n\n\nziplist编码的price对象：\n\n![ziplist编码的price对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/ziplist编码的price对象.png)\n\n\n\nskiplist编码的price对象：\n\n![skiplist编码的price对象](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/skiplist编码的price对象.png)\n\n\n\n**问: 为什么有序集合需要同时使用跳跃表和字典来实现？**\n\n理论上，有序集合可以单独使用字典或者跳跃表的其中一个数据结构来实现，但无论单独使用字典还是跳跃表，其性能上对比同时视同字典和跳跃表都会有所降低。\n\n- 若单独使用字典来实现有序集合，那么虽然查找时时间复杂度保留，仍然是O(1)，但是当执行范围操作时，程序都要需要对所有元素进行排序操作。而完成排序操作至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间用于保存排序后的数组。\n- 若单独使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1上升为O(logN)。\n\n\n\n#### 6.1 应用场景\n\n- 排行榜，但是和list不同的是它能够实现动态的排序，例如：可以用来存储粉丝列表，value值时粉丝的用户ID，score是关注时间，然后可以对粉丝列表按关注时间进行排序．\n- 存储学生成绩，`value` 值是学生的 ID, `score` 是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。\n\n\n\n### 7 内存回收\n\nRedis在自己的对象系统中构建了一个`引用计数`技术实现内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象，并进行内存回收。\n\n每个对象的计数信息由`redisObject结构`中有一个`refcount属性`记录：\n\n```c\ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用计数。\n    int refcount;\n    void *ptr;\n} robj;\n```\n\n\n\n对象的引用计数信息会随着对象的使用状态而不断变化：\n\n- ①、在创建一个新对象时，引用计数的值会被初始化为1；\n- ②、当对象被一个新程序使用时，它的引用计数值会被赠一；\n- ③、当对象不再被一个程序引用时，它的引用计数值会被减一；\n- ④、当对象的引用计数值变为0时，对象所占用的内存会被释放掉。\n\n通过以下命令可以查键对应的值对象的引用计数：\n\n`object refcount xxx`\n\n\n\n示例：\n\n```\n127.0.0.1:6379> set a 100\nOK\n127.0.0.1:6379> object refcount a\n(integer) 2\n```\n\n**问: 为什么此处引用计数是为2呢？**\n\n因为对象引用计数属性还带有对象共享的作用，redis在初始化服务器时，创建一万个字符对象，这些对象包括从0到9999的所有整数值，当服务器需要用到这些值时，服务器就会使用这些共享对象，而不是新创建对象。\n\n\n\n此处持有这个值对象的两个程序分别是，其示意图如下：\n\n- ①、这个值对象的服务器程序；\n- ②、共享这个值对象的键a；\n\n![持有同一值对象的两个程序](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-Redis对象/持有同一值对象的两个程序.png)\n\n注：Redis会共享值为0~9999的字符串对象。\n\n\n\n**问: 为什么Redis不共享包含字符串的对象？**\n\n当服务器服务器考虑将一个共享对象设置为键的值对象时，程序需要先根据给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就越高，消耗的CPU时间也会越多。\n\n- 若共享对象是保存的整数值的字符串对象，那么验证操作的复杂度就是O(1).\n- 若共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)。\n- 若共享对象是包含多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。\n\n因此，尽管共享更复杂的对象可以节约更多的内存，但是收到CPU时间的限制，Redis值对包含整数值的字符串对象进行共享。\n\n\n\n### 8 对象的空转时长\n\nredisObject结构还包含一个`lru属性`，该属性`用于记录对象最后一次被命令程序访问的时间`：\n\n```c\ntypedef struct redisObject {\n    // 类型.\n    unsigned type:4;\n    // 编码.\n    unsigned encoding:4;\n    // 记录了对象最后一次被命令程序访问的时间。\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    // 引用次数\n    int refcount;\n    // 指向底层实现数据结构的指针。\n    void *ptr;\n} robj;\n```\n\n`空转时长`：通过当前时间减去键的值对象的lru时间计算得出的，通过以下命令可打印出给定键的空转时长：\n\n`object idletime xxx`\n\n*注：该命令的实现是特殊的，执行时并不会修改值的lru属性。*\n\n\n\n示例：\n\n```bash\n127.0.0.1:6379> set msg \"hello world\"\nOK\n127.0.0.1:6379> object idletime msg\n(integer) 8\n# 访问msg键的值\n127.0.0.1:6379> get msg\n\"hello world\"\n# 键处于活跃状态，空转时长为0.\n127.0.0.1:6379> object idletime msg\n(integer) 0\n```\n\n空转时长还有一项作用，若服务器打开了`maxmemory`选项，并且服务器用于回收内存算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那么部分键会优先被服务器释放，从而回收内存。\n\n\n\n------\n\n### 参考资料\n\nredis设计与实现（第二版） 黄健宏\n[一口气说出Redis 5种数据结构及对应使用场景，面试要加分的](https://zhuanlan.zhihu.com/p/107439357)","slug":"Redis设计与实现-Redis对象","published":1,"updated":"2020-09-24T10:00:59.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabna006d45g369wshumf","content":"<p>Redis基于其数据结构（例如，SDS、双端链表、字典、压缩列表、整数集合等）创建了一个对象系统，该系统包含<code>字符串对象</code>、<code>列表对象</code>、<code>哈希对象</code>、<code>集合对象</code>和<code>有序集合</code>对象这五种对象，每种对象都用到了至少一种数据结构。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-对象的类型与编码\"><a href=\"#1-对象的类型与编码\" class=\"headerlink\" title=\"1 对象的类型与编码\"></a>1 对象的类型与编码</h3><p>Redis使用<code>对象</code>来表示数据库中的健和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的健（键对象），另一个对象用作键值对的值（值对象）。</p>\n<p>Redis中每个对都由<code>redisObject</code>结构表示，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录了对象最后一次被命令程序访问的时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-1-类型\"><a href=\"#1-1-类型\" class=\"headerlink\" title=\"1.1 类型\"></a>1.1 类型</h4><p>对象的type属性记录了对象的类型，这个类型包括以下5中类型：</p>\n<ul>\n<li><strong>REDIS_STRING</strong>：字符串对象(type命令输出：“string”)</li>\n<li><strong>REDIS_LIST</strong>：列表对象(type命令输出：“list”)</li>\n<li><strong>REDIS_HASH</strong>：哈希对象(type命令输出：“hash”)</li>\n<li><strong>REDIS_SET</strong>：集合对象(type命令输出：“set”)</li>\n<li><strong>REDIS_ZSET</strong>：有序集合对象(type命令输出：“zset”)</li>\n</ul>\n<p><em>使用<code>type命令</code>可以返回<strong>数据库键对应的值对象类型</strong></em></p>\n<p><em>对于Redis数据库保存的<code>键值</code>对来说，<u>键总是一个字符串对象</u>，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的一种，因此我们称“XX键”表示这个数据库键所对应的值为XX对象。</em></p>\n<h4 id=\"1-2-编码和底层实现\"><a href=\"#1-2-编码和底层实现\" class=\"headerlink\" title=\"1.2 编码和底层实现\"></a>1.2 编码和底层实现</h4><p>对象的<code>ptr</code>指向对象的底层实现数据结构，而这些数据结构由对象的<code>encoding</code>属性决定。</p>\n<p>encoding对象属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现，其对象的编码如下：</p>\n<ul>\n<li><strong>REDIS_ENCODING_INT</strong>：long类型的整数(object encoding命令输出：int)</li>\n<li><strong>REDIS_ENCODING_EMBSTR</strong>：embstr编码的简单动态字符串(object encoding命令输出：embstr)</li>\n<li><strong>REDIS_ENCODING_RAW</strong>：简单动态字符串(object encoding命令输出：raw)</li>\n<li><strong>REDIS_ENCODING_HT</strong>：字典(object encoding命令输出：hashtable)</li>\n<li><strong>REDIS_ENCODING_LINKEDLIST</strong>：双端链表(object encoding命令输出：linkedlist)</li>\n<li><strong>REDIS_ENCODING_ZIPLIST</strong>：压缩列表(object encoding命令输出：ziplist)</li>\n<li><strong>REDIS_ENCODING_INTSET</strong>：整数集合(object encoding命令输出：intset)</li>\n<li><strong>REDIS_ENCODING_SKIPLIST</strong>：跳跃表和字典(object encoding命令输出：skiplist)</li>\n</ul>\n<p>每种类型的对象都至少使用了两种不同的编码，如下所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%83%BD%E8%87%B3%E5%B0%91%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E7%A0%81.png\" alt=\"每种类型的对象都至少使用了两种不同的编码\"></p>\n<p><em>使用<code>object encoding命令</code>可以<strong>查看一个数据库键的值对象的编码</strong></em></p>\n<p><strong>为什么Redis要使用encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码？</strong></p>\n<p>因为使用encoding属性设定编码方式可以<u>根据不同的适用场景设置不同的编码，从而优化对象在某一场景下的效率。</u>例如，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现，压缩列表比双向链表更节约内存，且在元素数量较少是，在内存中以连续块方式保存的压缩列表比起双向链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，是用压缩列表来保存元素的优势逐渐消失，对象就会将底层实现从压缩列表转向功能更强、也更合适保存大量元素的双端链表上。</p>\n<h3 id=\"2-字符串对象\"><a href=\"#2-字符串对象\" class=\"headerlink\" title=\"2 字符串对象\"></a>2 字符串对象</h3><p>字符串对象的编码可以是<code>int</code>、<code>raw</code>、<code>embstr</code>。</p>\n<ul>\n<li><strong>int</strong>：字符串对象保存的是<code>整数值，并且这个整数值可以用long类型类表示</code>，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *装换成long），并将字符串对象的编码设置为int。</li>\n<li><strong>raw</strong>：字符串对象保存的是一个<code>字符串值，并且这个字符串值的长度大于32字节</code>，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li>\n<li><strong>embstr</strong>：字符串对象保存的是一个<code>字符串值，并且这个字符串值的长度小于等于32字节</code>，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> number 10086</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;int&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> story <span class=\"string\">&quot;Long, long ago there lived a king and a queen, they have a beautiful daughter...&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; strlen story</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 80</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding story</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>问: 既然有raw编码方式，为什么还要有embstr编码呢？它们有什么异同点？</strong></p>\n<ul>\n<li><p>相同点:</p>\n<ul>\n<li>embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw一样，都是用redisObject结构和sdshdr结构来表示字符串对象。</li>\n</ul>\n</li>\n<li><p>不同点：</p>\n<ul>\n<li><p>raw编码会<u>调用两次内存分配函数</u>分别创建redisObject结构和sdshdr结构。</p>\n</li>\n<li><p>embstr则通过调用一次内存分配函数来分配<u>一块连续的空间</u>，空间中依次包含redisObject和sdshdr两个结构。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>embstr编码创建的内存块结构如下：</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/embstr%E7%BC%96%E7%A0%81%E5%88%9B%E5%BB%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E7%BB%93%E6%9E%84.png\" alt=\"embstr编码创建的内存块结构\"></p>\n<p><strong>问: 使用embstr编码的字符串对象来保存短字符串值有什么好处？</strong></p>\n<ul>\n<li>①、embstr编码将创建的字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li>\n<li>②、释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li>\n<li>③、embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比raw编码的字符串对象能更好的利用缓存带来的优势。</li>\n</ul>\n<p>注：<code>long double类型表示的浮点数在Redis中也是作为字符串值来保存的</code>, 如下示例所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> pi 3.14</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding pi</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>下图为字符串对象保存各类型值的编码方式：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E4%BF%9D%E5%AD%98%E5%90%84%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png\" alt=\"字符串对象保存各类型值的编码方式\"></p>\n<h4 id=\"2-1-编码转换\"><a href=\"#2-1-编码转换\" class=\"headerlink\" title=\"2.1 编码转换\"></a>2.1 编码转换</h4><p><code>int编码</code>的字符串对象和<code>embstr编码</code>的字符串对象在条件满足的情况下，会被转换为<code>raw编码</code>的字符串对象。</p>\n<ul>\n<li><strong>int编码-&gt;raw编码</strong>：执行一些命令，使得对象保存的值不再是整数值，而是一个字符串值时。例如APPEND命令。</li>\n<li><strong>embstr编码-&gt;raw编码</strong>：Redis并没有为embstr编码提供任何修改程序，因此<code>实际上embstr编码的字符串是只读的</code>，当对embstr编码的字符串进行修改时，程序会先将对象的编码从embstr转换为raw，再执行修改命令。</li>\n</ul>\n<p>示例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> number 10086</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;int&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append number <span class=\"string\">&quot; is a good number!&quot;</span> <span class=\"comment\"># 使用append命令将对象变为一个字符串.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 23</span><br><span class=\"line\">127.0.0.1:6379&gt; get number</span><br><span class=\"line\"><span class=\"string\">&quot;10086 is a good number!&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>示例2：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello word&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append msg <span class=\"string\">&quot; again!&quot;</span> <span class=\"comment\"># embstr字符串是只读的,当对其进行修改时,将强制转换为raw编码,再进行修改.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 17</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-应用场景\"><a href=\"#2-2-应用场景\" class=\"headerlink\" title=\"2.2 应用场景\"></a>2.2 应用场景</h4><ul>\n<li>存储key-value键值对．</li>\n</ul>\n<h3 id=\"3-列表对象\"><a href=\"#3-列表对象\" class=\"headerlink\" title=\"3 列表对象\"></a>3 列表对象</h3><p>列表对象的编码可以是<code>ziplist</code>或者<code>linkedlist</code>。</p>\n<ul>\n<li>ziplist编码的列表对象: 使用<code>压缩列表</code>作为底层实现，每个压缩列表结点(entry)保存了一个列表元素。</li>\n<li>linkedlist编码的列表对象: 使用<code>双端链表</code>作为底层实现，每个双端链表结点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</li>\n</ul>\n<p>示例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush numbers 1 <span class=\"string\">&quot;three&quot;</span> 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n\n<p><code>ziplist编码</code>的numbers列表对象如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84numbers%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1.png\" alt=\"ziplist编码的numbers列表对象\"></p>\n<p>linkedlist编码的numbers列表对象如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/linkedlist%E7%BC%96%E7%A0%81%E7%9A%84numbers%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1.png\" alt=\"linkedlist编码的numbers列表对象\"></p>\n<p>其中完整的StringObject表示方式如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E5%AE%8C%E6%95%B4%E7%9A%84StringObject%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F.png\" alt=\"完整的StringObject表示方式\"></p>\n<h4 id=\"3-1-编码转换\"><a href=\"#3-1-编码转换\" class=\"headerlink\" title=\"3.1 编码转换\"></a>3.1 编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用<code>ziplist</code>编码。其他情况下需要使用<code>linkedlist</code>编码。</p>\n<ul>\n<li>①、列表对象保存的所有字符串元素的长度都小于64字节（由配置<code>list-max-ziplist-value</code>决定）；</li>\n<li>②、列表对象保存的元素数量小于512个（由配置<code>hash-max-ziplist-entries</code>决定）。</li>\n</ul>\n<p>示例1：保存长度太大的元素而进行编码转换的情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush blah <span class=\"string\">&quot;hello&quot;</span> <span class=\"string\">&quot;world&quot;</span> <span class=\"string\">&quot;again&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding blah</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush blah <span class=\"string\">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding blah</span><br><span class=\"line\"><span class=\"string\">&quot;linkedlist&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例2：保存的元素数量过多而进行编码转换的情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 俩比偶对象包含512个元素。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">eval</span> <span class=\"string\">&quot;for i=1, 512 do redis.call(&#x27;rpush&#x27;, KEYS[1], i)end&quot;</span> 1 <span class=\"string\">&quot;integers&quot;</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"comment\"># 获取列表长度.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; llen integers</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding integers</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再向列表对象推入一个新元素，使得对象保存的元素数量达到513个。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush integers 512</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 513</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding integers</span><br><span class=\"line\"><span class=\"string\">&quot;linkedlist&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-应用场景\"><a href=\"#3-2-应用场景\" class=\"headerlink\" title=\"3.2 应用场景\"></a>3.2 应用场景</h4><p>由于list是一个按照插入顺序排序的列表，所有应用场景还比较多，例如：</p>\n<ul>\n<li>消息队列：lpop和rpush能实现队列的功能．</li>\n<li>朋友圈的点赞列表，评论列表，排行榜：lpush和lrange命令能实现<u>最新列表的功能</u>．</li>\n<li>每次通过lpush命令往列表礼插入新的元素，然后通过lrange命令读取<u>最新的元素列表</u>．</li>\n</ul>\n<h3 id=\"4-哈希对象\"><a href=\"#4-哈希对象\" class=\"headerlink\" title=\"4 哈希对象\"></a>4 哈希对象</h3><p>哈希对象的编码可以是<code>ziplist</code>或者<code>hashtable</code>。</p>\n<ul>\n<li><p><strong>ziplist编码</strong>：ziplist编码作为哈希对象使用<code>压缩列表</code>作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。因此，<code>保存了同一键值对的两个结点总是紧挨在一起的，键结点在前，值结点在后</code>。</p>\n</li>\n<li><p><strong>hashtable编码</strong>: 哈希对象使用<code>字典</code>作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：字典中每个键/值都是一个字符串对象，对象中保存了键值对的键/值。</p>\n</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hset profile name <span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hset profile age 25</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hset profile career <span class=\"string\">&quot;Programmer&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ziplist编码的profile哈希对象的底层实现如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84profile%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png\" alt=\"ziplist编码的profile哈希对象的底层实现\"></p>\n<p>hashtable编码的profile哈希对象底层实现如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/hashtable%E7%BC%96%E7%A0%81%E7%9A%84profile%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png\" alt=\"hashtable编码的profile哈希对象底层实现\"></p>\n<h4 id=\"4-1-编码转换\"><a href=\"#4-1-编码转换\" class=\"headerlink\" title=\"4.1 编码转换\"></a>4.1 编码转换</h4><p><strong>问: 什么情况下，哈希对象使用ziplist编码？</strong></p>\n<p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p>\n<ul>\n<li>①、哈希对象保存的所有键值对的键和值的字符串长度都小于64字节（<code>hash-max-ziplist-value</code>）；</li>\n<li>②、哈希对象保存的键值对数量小于512个（<code>hash-max-ziplist-entries</code>）；</li>\n</ul>\n<p>当以上两个条件任何一个不满足时，都会进行编码装换为hashtable。</p>\n<p>示例1：键值对的键太大而引起的编码转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hset book name <span class=\"string\">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding book</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hset book long_long_long_long_long_long_long_long_long_long_long_long_long_long_description <span class=\"string\">&quot;content&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding book</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例2： 哈希对象因为包含的键值对数量过多而引起编码转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; EVAL <span class=\"string\">&quot;for i=1, 512 do redis.call(&#x27;HSET&#x27;, KEYS[1], i, i)end&quot;</span> 1 <span class=\"string\">&quot;numbers&quot;</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; hlen numbers</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hmset numbers <span class=\"string\">&quot;key&quot;</span> <span class=\"string\">&quot;value&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-2-应用场景\"><a href=\"#4-2-应用场景\" class=\"headerlink\" title=\"4.2 应用场景\"></a>4.2 应用场景</h4><p>例如：</p>\n<ul>\n<li>购物车：<code>hset [key] [field] [value]</code>命令，可以存储以<code>uid</code>，<code>商品id为field</code>，<code>商品数量为value</code>的数据，刚好是购物车的三要素．</li>\n<li>存储对象：<code>hash</code>类型的<code>(key, field, value)</code>的结构与对象的<code>(对象id, 属性, 值)</code>的结构相似，也可以用来存储对象。</li>\n</ul>\n<h3 id=\"5-集合对象\"><a href=\"#5-集合对象\" class=\"headerlink\" title=\"5 集合对象\"></a>5 集合对象</h3><p>集合对象的编码可以是<code>intset</code>或者<code>hashtable</code>。</p>\n<ul>\n<li>intset编码的集合对象: 使用<code>整数集合</code>作为底层实现，集合对象包含的所有元素都被存在整数集合里。</li>\n<li>hashtable编码的集合对象: 使用<code>字典</code>作为底层实现，<code>字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为null。</code></li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># intset</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd numbers 1 3 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;intset&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#hashtable</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd fruits <span class=\"string\">&quot;apple&quot;</span> <span class=\"string\">&quot;banana&quot;</span> <span class=\"string\">&quot;cherry&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding fruits</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>intset编码的numbers集合对象</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/intset%E7%BC%96%E7%A0%81%E7%9A%84numbers%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png\" alt=\"intset编码的numbers集合对象\"></p>\n<p>hashtable编码的fruits集合对象</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/hashtable%E7%BC%96%E7%A0%81%E7%9A%84fruits%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png\" alt=\"hashtable编码的fruits集合对象\"></p>\n<h4 id=\"5-1-编码的转换\"><a href=\"#5-1-编码的转换\" class=\"headerlink\" title=\"5.1 编码的转换\"></a>5.1 编码的转换</h4><p><strong>问: 什么情况下，集合对象使用intset编码？</strong></p>\n<p>当集合对象同时满足以下两个条件时，对象使用intset编码：</p>\n<ul>\n<li>①、结合兑现个保存的所有元素都是整数值；</li>\n<li>②、集合对象保存的元素数量不超过512个（<code>set-max-intset-entries</code>）。</li>\n</ul>\n<p>当其中一个条件不满足时，intset编码方式将自动变为hashtable编码方式。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sadd numbers 1 3 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;intset&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd numbers <span class=\"string\">&quot;seven&quot;</span> <span class=\"comment\"># 添加非整数元素, 使得集合编码变为为hashtable.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-2-应用场景\"><a href=\"#5-2-应用场景\" class=\"headerlink\" title=\"5.2 应用场景\"></a>5.2 应用场景</h4><p>例如：</p>\n<ul>\n<li>好友，关注，粉丝，感兴趣的人的集合：<ul>\n<li><code>sinter</code>命令可以获取A和B两个用户的共同好友；</li>\n<li><code>sismember</code>可以判断A是否时B的好友；</li>\n<li><code>scard</code>命令可以获取好友数量;</li>\n<li>关注时，<code>smove</code>命令可以将B从A的粉丝集合转移到A的好友集合．</li>\n</ul>\n</li>\n<li>首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而<code>srandmember</code>命令则可以从中随机获取几个。</li>\n<li>存储某活动中奖的用户ID，因为具有去重功能，可以保证同一个用户不会中奖两次．</li>\n</ul>\n<h3 id=\"6-有序集合对象\"><a href=\"#6-有序集合对象\" class=\"headerlink\" title=\"6 有序集合对象\"></a>6 有序集合对象</h3><p>有序集合的编码可以是<code>ziplist</code>或者<code>skiplist</code>。</p>\n<ul>\n<li><p><strong>ziplist编码</strong>：ziplist编码的压缩列表对象使用<code>压缩列表</code>作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，<code>第一个节点保存元素的成员，第二个元素保存元素的分值</code>。<code>压缩列表内的集合元素按分值从小到大进行排序</code>，分值较小的元素被放置在靠近表头的方向，分值较大的元素则被放置在靠近表尾的方向。</p>\n</li>\n<li><p><strong>skiplist编码</strong>：skiplist编码的有序集合对象使用<code>zset结构</code>作为底层实现，<code>一个zset结构同时包含一个字典和一个跳跃表</code>。</p>\n</li>\n</ul>\n<p>zset结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 该字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了元素的成员，字典的值则保存了元素的分值。</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    <span class=\"comment\">// 按分值从小到大保存了所有集合的元素。</span></span><br><span class=\"line\">    zskiplist *zsl;</span><br><span class=\"line\">&#125; zset;</span><br></pre></td></tr></table></figure>\n\n<p><em>注：有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。<u>跳跃表和字典均是通过指针来共享元素的成员和分值，因此同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会因此而浪费额外的内存</u>。</em></p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zadd price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ziplist编码的price对象：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84price%E5%AF%B9%E8%B1%A1.png\" alt=\"ziplist编码的price对象\"></p>\n<p>skiplist编码的price对象：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/skiplist%E7%BC%96%E7%A0%81%E7%9A%84price%E5%AF%B9%E8%B1%A1.png\" alt=\"skiplist编码的price对象\"></p>\n<p><strong>问: 为什么有序集合需要同时使用跳跃表和字典来实现？</strong></p>\n<p>理论上，有序集合可以单独使用字典或者跳跃表的其中一个数据结构来实现，但无论单独使用字典还是跳跃表，其性能上对比同时视同字典和跳跃表都会有所降低。</p>\n<ul>\n<li>若单独使用字典来实现有序集合，那么虽然查找时时间复杂度保留，仍然是O(1)，但是当执行范围操作时，程序都要需要对所有元素进行排序操作。而完成排序操作至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间用于保存排序后的数组。</li>\n<li>若单独使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1上升为O(logN)。</li>\n</ul>\n<h4 id=\"6-1-应用场景\"><a href=\"#6-1-应用场景\" class=\"headerlink\" title=\"6.1 应用场景\"></a>6.1 应用场景</h4><ul>\n<li>排行榜，但是和list不同的是它能够实现动态的排序，例如：可以用来存储粉丝列表，value值时粉丝的用户ID，score是关注时间，然后可以对粉丝列表按关注时间进行排序．</li>\n<li>存储学生成绩，<code>value</code> 值是学生的 ID, <code>score</code> 是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。</li>\n</ul>\n<h3 id=\"7-内存回收\"><a href=\"#7-内存回收\" class=\"headerlink\" title=\"7 内存回收\"></a>7 内存回收</h3><p>Redis在自己的对象系统中构建了一个<code>引用计数</code>技术实现内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象，并进行内存回收。</p>\n<p>每个对象的计数信息由<code>redisObject结构</code>中有一个<code>refcount属性</code>记录：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>\n<ul>\n<li>①、在创建一个新对象时，引用计数的值会被初始化为1；</li>\n<li>②、当对象被一个新程序使用时，它的引用计数值会被赠一；</li>\n<li>③、当对象不再被一个程序引用时，它的引用计数值会被减一；</li>\n<li>④、当对象的引用计数值变为0时，对象所占用的内存会被释放掉。</li>\n</ul>\n<p>通过以下命令可以查键对应的值对象的引用计数：</p>\n<p><code>object refcount xxx</code></p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set a 100</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object refcount a</span><br><span class=\"line\">(integer) 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>问: 为什么此处引用计数是为2呢？</strong></p>\n<p>因为对象引用计数属性还带有对象共享的作用，redis在初始化服务器时，创建一万个字符对象，这些对象包括从0到9999的所有整数值，当服务器需要用到这些值时，服务器就会使用这些共享对象，而不是新创建对象。</p>\n<p>此处持有这个值对象的两个程序分别是，其示意图如下：</p>\n<ul>\n<li>①、这个值对象的服务器程序；</li>\n<li>②、共享这个值对象的键a；</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E6%8C%81%E6%9C%89%E5%90%8C%E4%B8%80%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%A8%8B%E5%BA%8F.png\" alt=\"持有同一值对象的两个程序\"></p>\n<p>注：Redis会共享值为0~9999的字符串对象。</p>\n<p><strong>问: 为什么Redis不共享包含字符串的对象？</strong></p>\n<p>当服务器服务器考虑将一个共享对象设置为键的值对象时，程序需要先根据给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就越高，消耗的CPU时间也会越多。</p>\n<ul>\n<li>若共享对象是保存的整数值的字符串对象，那么验证操作的复杂度就是O(1).</li>\n<li>若共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)。</li>\n<li>若共享对象是包含多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。</li>\n</ul>\n<p>因此，尽管共享更复杂的对象可以节约更多的内存，但是收到CPU时间的限制，Redis值对包含整数值的字符串对象进行共享。</p>\n<h3 id=\"8-对象的空转时长\"><a href=\"#8-对象的空转时长\" class=\"headerlink\" title=\"8 对象的空转时长\"></a>8 对象的空转时长</h3><p>redisObject结构还包含一个<code>lru属性</code>，该属性<code>用于记录对象最后一次被命令程序访问的时间</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录了对象最后一次被命令程序访问的时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n<p><code>空转时长</code>：通过当前时间减去键的值对象的lru时间计算得出的，通过以下命令可打印出给定键的空转时长：</p>\n<p><code>object idletime xxx</code></p>\n<p><em>注：该命令的实现是特殊的，执行时并不会修改值的lru属性。</em></p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object idletime msg</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 8</span><br><span class=\"line\"><span class=\"comment\"># 访问msg键的值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get msg</span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 键处于活跃状态，空转时长为0.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; object idletime msg</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n\n<p>空转时长还有一项作用，若服务器打开了<code>maxmemory</code>选项，并且服务器用于回收内存算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那么部分键会优先被服务器释放，从而回收内存。</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>redis设计与实现（第二版） 黄健宏<br><a href=\"https://zhuanlan.zhihu.com/p/107439357\">一口气说出Redis 5种数据结构及对应使用场景，面试要加分的</a></p>\n","site":{"data":{}},"excerpt":"<p>Redis基于其数据结构（例如，SDS、双端链表、字典、压缩列表、整数集合等）创建了一个对象系统，该系统包含<code>字符串对象</code>、<code>列表对象</code>、<code>哈希对象</code>、<code>集合对象</code>和<code>有序集合</code>对象这五种对象，每种对象都用到了至少一种数据结构。</p>","more":"<h3 id=\"1-对象的类型与编码\"><a href=\"#1-对象的类型与编码\" class=\"headerlink\" title=\"1 对象的类型与编码\"></a>1 对象的类型与编码</h3><p>Redis使用<code>对象</code>来表示数据库中的健和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的健（键对象），另一个对象用作键值对的值（值对象）。</p>\n<p>Redis中每个对都由<code>redisObject</code>结构表示，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录了对象最后一次被命令程序访问的时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-1-类型\"><a href=\"#1-1-类型\" class=\"headerlink\" title=\"1.1 类型\"></a>1.1 类型</h4><p>对象的type属性记录了对象的类型，这个类型包括以下5中类型：</p>\n<ul>\n<li><strong>REDIS_STRING</strong>：字符串对象(type命令输出：“string”)</li>\n<li><strong>REDIS_LIST</strong>：列表对象(type命令输出：“list”)</li>\n<li><strong>REDIS_HASH</strong>：哈希对象(type命令输出：“hash”)</li>\n<li><strong>REDIS_SET</strong>：集合对象(type命令输出：“set”)</li>\n<li><strong>REDIS_ZSET</strong>：有序集合对象(type命令输出：“zset”)</li>\n</ul>\n<p><em>使用<code>type命令</code>可以返回<strong>数据库键对应的值对象类型</strong></em></p>\n<p><em>对于Redis数据库保存的<code>键值</code>对来说，<u>键总是一个字符串对象</u>，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的一种，因此我们称“XX键”表示这个数据库键所对应的值为XX对象。</em></p>\n<h4 id=\"1-2-编码和底层实现\"><a href=\"#1-2-编码和底层实现\" class=\"headerlink\" title=\"1.2 编码和底层实现\"></a>1.2 编码和底层实现</h4><p>对象的<code>ptr</code>指向对象的底层实现数据结构，而这些数据结构由对象的<code>encoding</code>属性决定。</p>\n<p>encoding对象属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现，其对象的编码如下：</p>\n<ul>\n<li><strong>REDIS_ENCODING_INT</strong>：long类型的整数(object encoding命令输出：int)</li>\n<li><strong>REDIS_ENCODING_EMBSTR</strong>：embstr编码的简单动态字符串(object encoding命令输出：embstr)</li>\n<li><strong>REDIS_ENCODING_RAW</strong>：简单动态字符串(object encoding命令输出：raw)</li>\n<li><strong>REDIS_ENCODING_HT</strong>：字典(object encoding命令输出：hashtable)</li>\n<li><strong>REDIS_ENCODING_LINKEDLIST</strong>：双端链表(object encoding命令输出：linkedlist)</li>\n<li><strong>REDIS_ENCODING_ZIPLIST</strong>：压缩列表(object encoding命令输出：ziplist)</li>\n<li><strong>REDIS_ENCODING_INTSET</strong>：整数集合(object encoding命令输出：intset)</li>\n<li><strong>REDIS_ENCODING_SKIPLIST</strong>：跳跃表和字典(object encoding命令输出：skiplist)</li>\n</ul>\n<p>每种类型的对象都至少使用了两种不同的编码，如下所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%83%BD%E8%87%B3%E5%B0%91%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E7%A0%81.png\" alt=\"每种类型的对象都至少使用了两种不同的编码\"></p>\n<p><em>使用<code>object encoding命令</code>可以<strong>查看一个数据库键的值对象的编码</strong></em></p>\n<p><strong>为什么Redis要使用encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码？</strong></p>\n<p>因为使用encoding属性设定编码方式可以<u>根据不同的适用场景设置不同的编码，从而优化对象在某一场景下的效率。</u>例如，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现，压缩列表比双向链表更节约内存，且在元素数量较少是，在内存中以连续块方式保存的压缩列表比起双向链表可以更快被载入到缓存中。随着列表对象包含的元素越来越多，是用压缩列表来保存元素的优势逐渐消失，对象就会将底层实现从压缩列表转向功能更强、也更合适保存大量元素的双端链表上。</p>\n<h3 id=\"2-字符串对象\"><a href=\"#2-字符串对象\" class=\"headerlink\" title=\"2 字符串对象\"></a>2 字符串对象</h3><p>字符串对象的编码可以是<code>int</code>、<code>raw</code>、<code>embstr</code>。</p>\n<ul>\n<li><strong>int</strong>：字符串对象保存的是<code>整数值，并且这个整数值可以用long类型类表示</code>，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *装换成long），并将字符串对象的编码设置为int。</li>\n<li><strong>raw</strong>：字符串对象保存的是一个<code>字符串值，并且这个字符串值的长度大于32字节</code>，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</li>\n<li><strong>embstr</strong>：字符串对象保存的是一个<code>字符串值，并且这个字符串值的长度小于等于32字节</code>，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> number 10086</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;int&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> story <span class=\"string\">&quot;Long, long ago there lived a king and a queen, they have a beautiful daughter...&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; strlen story</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 80</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding story</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>问: 既然有raw编码方式，为什么还要有embstr编码呢？它们有什么异同点？</strong></p>\n<ul>\n<li><p>相同点:</p>\n<ul>\n<li>embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw一样，都是用redisObject结构和sdshdr结构来表示字符串对象。</li>\n</ul>\n</li>\n<li><p>不同点：</p>\n<ul>\n<li><p>raw编码会<u>调用两次内存分配函数</u>分别创建redisObject结构和sdshdr结构。</p>\n</li>\n<li><p>embstr则通过调用一次内存分配函数来分配<u>一块连续的空间</u>，空间中依次包含redisObject和sdshdr两个结构。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>embstr编码创建的内存块结构如下：</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/embstr%E7%BC%96%E7%A0%81%E5%88%9B%E5%BB%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E7%BB%93%E6%9E%84.png\" alt=\"embstr编码创建的内存块结构\"></p>\n<p><strong>问: 使用embstr编码的字符串对象来保存短字符串值有什么好处？</strong></p>\n<ul>\n<li>①、embstr编码将创建的字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li>\n<li>②、释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li>\n<li>③、embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比raw编码的字符串对象能更好的利用缓存带来的优势。</li>\n</ul>\n<p>注：<code>long double类型表示的浮点数在Redis中也是作为字符串值来保存的</code>, 如下示例所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> pi 3.14</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding pi</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>下图为字符串对象保存各类型值的编码方式：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E4%BF%9D%E5%AD%98%E5%90%84%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png\" alt=\"字符串对象保存各类型值的编码方式\"></p>\n<h4 id=\"2-1-编码转换\"><a href=\"#2-1-编码转换\" class=\"headerlink\" title=\"2.1 编码转换\"></a>2.1 编码转换</h4><p><code>int编码</code>的字符串对象和<code>embstr编码</code>的字符串对象在条件满足的情况下，会被转换为<code>raw编码</code>的字符串对象。</p>\n<ul>\n<li><strong>int编码-&gt;raw编码</strong>：执行一些命令，使得对象保存的值不再是整数值，而是一个字符串值时。例如APPEND命令。</li>\n<li><strong>embstr编码-&gt;raw编码</strong>：Redis并没有为embstr编码提供任何修改程序，因此<code>实际上embstr编码的字符串是只读的</code>，当对embstr编码的字符串进行修改时，程序会先将对象的编码从embstr转换为raw，再执行修改命令。</li>\n</ul>\n<p>示例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> number 10086</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;int&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append number <span class=\"string\">&quot; is a good number!&quot;</span> <span class=\"comment\"># 使用append命令将对象变为一个字符串.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 23</span><br><span class=\"line\">127.0.0.1:6379&gt; get number</span><br><span class=\"line\"><span class=\"string\">&quot;10086 is a good number!&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding number</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>示例2：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello word&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;embstr&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; append msg <span class=\"string\">&quot; again!&quot;</span> <span class=\"comment\"># embstr字符串是只读的,当对其进行修改时,将强制转换为raw编码,再进行修改.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 17</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding msg</span><br><span class=\"line\"><span class=\"string\">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-应用场景\"><a href=\"#2-2-应用场景\" class=\"headerlink\" title=\"2.2 应用场景\"></a>2.2 应用场景</h4><ul>\n<li>存储key-value键值对．</li>\n</ul>\n<h3 id=\"3-列表对象\"><a href=\"#3-列表对象\" class=\"headerlink\" title=\"3 列表对象\"></a>3 列表对象</h3><p>列表对象的编码可以是<code>ziplist</code>或者<code>linkedlist</code>。</p>\n<ul>\n<li>ziplist编码的列表对象: 使用<code>压缩列表</code>作为底层实现，每个压缩列表结点(entry)保存了一个列表元素。</li>\n<li>linkedlist编码的列表对象: 使用<code>双端链表</code>作为底层实现，每个双端链表结点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</li>\n</ul>\n<p>示例1：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush numbers 1 <span class=\"string\">&quot;three&quot;</span> 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n\n<p><code>ziplist编码</code>的numbers列表对象如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84numbers%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1.png\" alt=\"ziplist编码的numbers列表对象\"></p>\n<p>linkedlist编码的numbers列表对象如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/linkedlist%E7%BC%96%E7%A0%81%E7%9A%84numbers%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1.png\" alt=\"linkedlist编码的numbers列表对象\"></p>\n<p>其中完整的StringObject表示方式如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E5%AE%8C%E6%95%B4%E7%9A%84StringObject%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F.png\" alt=\"完整的StringObject表示方式\"></p>\n<h4 id=\"3-1-编码转换\"><a href=\"#3-1-编码转换\" class=\"headerlink\" title=\"3.1 编码转换\"></a>3.1 编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用<code>ziplist</code>编码。其他情况下需要使用<code>linkedlist</code>编码。</p>\n<ul>\n<li>①、列表对象保存的所有字符串元素的长度都小于64字节（由配置<code>list-max-ziplist-value</code>决定）；</li>\n<li>②、列表对象保存的元素数量小于512个（由配置<code>hash-max-ziplist-entries</code>决定）。</li>\n</ul>\n<p>示例1：保存长度太大的元素而进行编码转换的情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush blah <span class=\"string\">&quot;hello&quot;</span> <span class=\"string\">&quot;world&quot;</span> <span class=\"string\">&quot;again&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding blah</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush blah <span class=\"string\">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 5</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding blah</span><br><span class=\"line\"><span class=\"string\">&quot;linkedlist&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例2：保存的元素数量过多而进行编码转换的情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 俩比偶对象包含512个元素。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">eval</span> <span class=\"string\">&quot;for i=1, 512 do redis.call(&#x27;rpush&#x27;, KEYS[1], i)end&quot;</span> 1 <span class=\"string\">&quot;integers&quot;</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"comment\"># 获取列表长度.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; llen integers</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding integers</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再向列表对象推入一个新元素，使得对象保存的元素数量达到513个。</span></span><br><span class=\"line\">127.0.0.1:6379&gt; rpush integers 512</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 513</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding integers</span><br><span class=\"line\"><span class=\"string\">&quot;linkedlist&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-应用场景\"><a href=\"#3-2-应用场景\" class=\"headerlink\" title=\"3.2 应用场景\"></a>3.2 应用场景</h4><p>由于list是一个按照插入顺序排序的列表，所有应用场景还比较多，例如：</p>\n<ul>\n<li>消息队列：lpop和rpush能实现队列的功能．</li>\n<li>朋友圈的点赞列表，评论列表，排行榜：lpush和lrange命令能实现<u>最新列表的功能</u>．</li>\n<li>每次通过lpush命令往列表礼插入新的元素，然后通过lrange命令读取<u>最新的元素列表</u>．</li>\n</ul>\n<h3 id=\"4-哈希对象\"><a href=\"#4-哈希对象\" class=\"headerlink\" title=\"4 哈希对象\"></a>4 哈希对象</h3><p>哈希对象的编码可以是<code>ziplist</code>或者<code>hashtable</code>。</p>\n<ul>\n<li><p><strong>ziplist编码</strong>：ziplist编码作为哈希对象使用<code>压缩列表</code>作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。因此，<code>保存了同一键值对的两个结点总是紧挨在一起的，键结点在前，值结点在后</code>。</p>\n</li>\n<li><p><strong>hashtable编码</strong>: 哈希对象使用<code>字典</code>作为底层实现，哈希对象中的每个键值对都是用一个字典键值对来保存：字典中每个键/值都是一个字符串对象，对象中保存了键值对的键/值。</p>\n</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hset profile name <span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hset profile age 25</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; hset profile career <span class=\"string\">&quot;Programmer&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ziplist编码的profile哈希对象的底层实现如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84profile%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png\" alt=\"ziplist编码的profile哈希对象的底层实现\"></p>\n<p>hashtable编码的profile哈希对象底层实现如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/hashtable%E7%BC%96%E7%A0%81%E7%9A%84profile%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png\" alt=\"hashtable编码的profile哈希对象底层实现\"></p>\n<h4 id=\"4-1-编码转换\"><a href=\"#4-1-编码转换\" class=\"headerlink\" title=\"4.1 编码转换\"></a>4.1 编码转换</h4><p><strong>问: 什么情况下，哈希对象使用ziplist编码？</strong></p>\n<p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p>\n<ul>\n<li>①、哈希对象保存的所有键值对的键和值的字符串长度都小于64字节（<code>hash-max-ziplist-value</code>）；</li>\n<li>②、哈希对象保存的键值对数量小于512个（<code>hash-max-ziplist-entries</code>）；</li>\n</ul>\n<p>当以上两个条件任何一个不满足时，都会进行编码装换为hashtable。</p>\n<p>示例1：键值对的键太大而引起的编码转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hset book name <span class=\"string\">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding book</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hset book long_long_long_long_long_long_long_long_long_long_long_long_long_long_description <span class=\"string\">&quot;content&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding book</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例2： 哈希对象因为包含的键值对数量过多而引起编码转换。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; EVAL <span class=\"string\">&quot;for i=1, 512 do redis.call(&#x27;HSET&#x27;, KEYS[1], i, i)end&quot;</span> 1 <span class=\"string\">&quot;numbers&quot;</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; hlen numbers</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 512</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;ziplist&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; hmset numbers <span class=\"string\">&quot;key&quot;</span> <span class=\"string\">&quot;value&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-2-应用场景\"><a href=\"#4-2-应用场景\" class=\"headerlink\" title=\"4.2 应用场景\"></a>4.2 应用场景</h4><p>例如：</p>\n<ul>\n<li>购物车：<code>hset [key] [field] [value]</code>命令，可以存储以<code>uid</code>，<code>商品id为field</code>，<code>商品数量为value</code>的数据，刚好是购物车的三要素．</li>\n<li>存储对象：<code>hash</code>类型的<code>(key, field, value)</code>的结构与对象的<code>(对象id, 属性, 值)</code>的结构相似，也可以用来存储对象。</li>\n</ul>\n<h3 id=\"5-集合对象\"><a href=\"#5-集合对象\" class=\"headerlink\" title=\"5 集合对象\"></a>5 集合对象</h3><p>集合对象的编码可以是<code>intset</code>或者<code>hashtable</code>。</p>\n<ul>\n<li>intset编码的集合对象: 使用<code>整数集合</code>作为底层实现，集合对象包含的所有元素都被存在整数集合里。</li>\n<li>hashtable编码的集合对象: 使用<code>字典</code>作为底层实现，<code>字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为null。</code></li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># intset</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd numbers 1 3 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;intset&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#hashtable</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd fruits <span class=\"string\">&quot;apple&quot;</span> <span class=\"string\">&quot;banana&quot;</span> <span class=\"string\">&quot;cherry&quot;</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding fruits</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>intset编码的numbers集合对象</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/intset%E7%BC%96%E7%A0%81%E7%9A%84numbers%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png\" alt=\"intset编码的numbers集合对象\"></p>\n<p>hashtable编码的fruits集合对象</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/hashtable%E7%BC%96%E7%A0%81%E7%9A%84fruits%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1.png\" alt=\"hashtable编码的fruits集合对象\"></p>\n<h4 id=\"5-1-编码的转换\"><a href=\"#5-1-编码的转换\" class=\"headerlink\" title=\"5.1 编码的转换\"></a>5.1 编码的转换</h4><p><strong>问: 什么情况下，集合对象使用intset编码？</strong></p>\n<p>当集合对象同时满足以下两个条件时，对象使用intset编码：</p>\n<ul>\n<li>①、结合兑现个保存的所有元素都是整数值；</li>\n<li>②、集合对象保存的元素数量不超过512个（<code>set-max-intset-entries</code>）。</li>\n</ul>\n<p>当其中一个条件不满足时，intset编码方式将自动变为hashtable编码方式。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sadd numbers 1 3 5</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;intset&quot;</span></span><br><span class=\"line\">127.0.0.1:6379&gt; sadd numbers <span class=\"string\">&quot;seven&quot;</span> <span class=\"comment\"># 添加非整数元素, 使得集合编码变为为hashtable.</span></span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; object encoding numbers</span><br><span class=\"line\"><span class=\"string\">&quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-2-应用场景\"><a href=\"#5-2-应用场景\" class=\"headerlink\" title=\"5.2 应用场景\"></a>5.2 应用场景</h4><p>例如：</p>\n<ul>\n<li>好友，关注，粉丝，感兴趣的人的集合：<ul>\n<li><code>sinter</code>命令可以获取A和B两个用户的共同好友；</li>\n<li><code>sismember</code>可以判断A是否时B的好友；</li>\n<li><code>scard</code>命令可以获取好友数量;</li>\n<li>关注时，<code>smove</code>命令可以将B从A的粉丝集合转移到A的好友集合．</li>\n</ul>\n</li>\n<li>首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而<code>srandmember</code>命令则可以从中随机获取几个。</li>\n<li>存储某活动中奖的用户ID，因为具有去重功能，可以保证同一个用户不会中奖两次．</li>\n</ul>\n<h3 id=\"6-有序集合对象\"><a href=\"#6-有序集合对象\" class=\"headerlink\" title=\"6 有序集合对象\"></a>6 有序集合对象</h3><p>有序集合的编码可以是<code>ziplist</code>或者<code>skiplist</code>。</p>\n<ul>\n<li><p><strong>ziplist编码</strong>：ziplist编码的压缩列表对象使用<code>压缩列表</code>作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，<code>第一个节点保存元素的成员，第二个元素保存元素的分值</code>。<code>压缩列表内的集合元素按分值从小到大进行排序</code>，分值较小的元素被放置在靠近表头的方向，分值较大的元素则被放置在靠近表尾的方向。</p>\n</li>\n<li><p><strong>skiplist编码</strong>：skiplist编码的有序集合对象使用<code>zset结构</code>作为底层实现，<code>一个zset结构同时包含一个字典和一个跳跃表</code>。</p>\n</li>\n</ul>\n<p>zset结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 该字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了元素的成员，字典的值则保存了元素的分值。</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    <span class=\"comment\">// 按分值从小到大保存了所有集合的元素。</span></span><br><span class=\"line\">    zskiplist *zsl;</span><br><span class=\"line\">&#125; zset;</span><br></pre></td></tr></table></figure>\n\n<p><em>注：有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。<u>跳跃表和字典均是通过指针来共享元素的成员和分值，因此同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会因此而浪费额外的内存</u>。</em></p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zadd price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 3</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ziplist编码的price对象：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/ziplist%E7%BC%96%E7%A0%81%E7%9A%84price%E5%AF%B9%E8%B1%A1.png\" alt=\"ziplist编码的price对象\"></p>\n<p>skiplist编码的price对象：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/skiplist%E7%BC%96%E7%A0%81%E7%9A%84price%E5%AF%B9%E8%B1%A1.png\" alt=\"skiplist编码的price对象\"></p>\n<p><strong>问: 为什么有序集合需要同时使用跳跃表和字典来实现？</strong></p>\n<p>理论上，有序集合可以单独使用字典或者跳跃表的其中一个数据结构来实现，但无论单独使用字典还是跳跃表，其性能上对比同时视同字典和跳跃表都会有所降低。</p>\n<ul>\n<li>若单独使用字典来实现有序集合，那么虽然查找时时间复杂度保留，仍然是O(1)，但是当执行范围操作时，程序都要需要对所有元素进行排序操作。而完成排序操作至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间用于保存排序后的数组。</li>\n<li>若单独使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1上升为O(logN)。</li>\n</ul>\n<h4 id=\"6-1-应用场景\"><a href=\"#6-1-应用场景\" class=\"headerlink\" title=\"6.1 应用场景\"></a>6.1 应用场景</h4><ul>\n<li>排行榜，但是和list不同的是它能够实现动态的排序，例如：可以用来存储粉丝列表，value值时粉丝的用户ID，score是关注时间，然后可以对粉丝列表按关注时间进行排序．</li>\n<li>存储学生成绩，<code>value</code> 值是学生的 ID, <code>score</code> 是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。</li>\n</ul>\n<h3 id=\"7-内存回收\"><a href=\"#7-内存回收\" class=\"headerlink\" title=\"7 内存回收\"></a>7 内存回收</h3><p>Redis在自己的对象系统中构建了一个<code>引用计数</code>技术实现内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象，并进行内存回收。</p>\n<p>每个对象的计数信息由<code>redisObject结构</code>中有一个<code>refcount属性</code>记录：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用计数。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>\n<ul>\n<li>①、在创建一个新对象时，引用计数的值会被初始化为1；</li>\n<li>②、当对象被一个新程序使用时，它的引用计数值会被赠一；</li>\n<li>③、当对象不再被一个程序引用时，它的引用计数值会被减一；</li>\n<li>④、当对象的引用计数值变为0时，对象所占用的内存会被释放掉。</li>\n</ul>\n<p>通过以下命令可以查键对应的值对象的引用计数：</p>\n<p><code>object refcount xxx</code></p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set a 100</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object refcount a</span><br><span class=\"line\">(integer) 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>问: 为什么此处引用计数是为2呢？</strong></p>\n<p>因为对象引用计数属性还带有对象共享的作用，redis在初始化服务器时，创建一万个字符对象，这些对象包括从0到9999的所有整数值，当服务器需要用到这些值时，服务器就会使用这些共享对象，而不是新创建对象。</p>\n<p>此处持有这个值对象的两个程序分别是，其示意图如下：</p>\n<ul>\n<li>①、这个值对象的服务器程序；</li>\n<li>②、共享这个值对象的键a；</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Redis%E5%AF%B9%E8%B1%A1/%E6%8C%81%E6%9C%89%E5%90%8C%E4%B8%80%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%A8%8B%E5%BA%8F.png\" alt=\"持有同一值对象的两个程序\"></p>\n<p>注：Redis会共享值为0~9999的字符串对象。</p>\n<p><strong>问: 为什么Redis不共享包含字符串的对象？</strong></p>\n<p>当服务器服务器考虑将一个共享对象设置为键的值对象时，程序需要先根据给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就越高，消耗的CPU时间也会越多。</p>\n<ul>\n<li>若共享对象是保存的整数值的字符串对象，那么验证操作的复杂度就是O(1).</li>\n<li>若共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)。</li>\n<li>若共享对象是包含多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。</li>\n</ul>\n<p>因此，尽管共享更复杂的对象可以节约更多的内存，但是收到CPU时间的限制，Redis值对包含整数值的字符串对象进行共享。</p>\n<h3 id=\"8-对象的空转时长\"><a href=\"#8-对象的空转时长\" class=\"headerlink\" title=\"8 对象的空转时长\"></a>8 对象的空转时长</h3><p>redisObject结构还包含一个<code>lru属性</code>，该属性<code>用于记录对象最后一次被命令程序访问的时间</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 编码.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 记录了对象最后一次被命令程序访问的时间。</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS; <span class=\"comment\">/* lru time (relative to server.lruclock) */</span></span><br><span class=\"line\">    <span class=\"comment\">// 引用次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;</span><br><span class=\"line\">    <span class=\"comment\">// 指向底层实现数据结构的指针。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n\n<p><code>空转时长</code>：通过当前时间减去键的值对象的lru时间计算得出的，通过以下命令可打印出给定键的空转时长：</p>\n<p><code>object idletime xxx</code></p>\n<p><em>注：该命令的实现是特殊的，执行时并不会修改值的lru属性。</em></p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> msg <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; object idletime msg</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 8</span><br><span class=\"line\"><span class=\"comment\"># 访问msg键的值</span></span><br><span class=\"line\">127.0.0.1:6379&gt; get msg</span><br><span class=\"line\"><span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 键处于活跃状态，空转时长为0.</span></span><br><span class=\"line\">127.0.0.1:6379&gt; object idletime msg</span><br><span class=\"line\">(<span class=\"built_in\">integer</span>) 0</span><br></pre></td></tr></table></figure>\n\n<p>空转时长还有一项作用，若服务器打开了<code>maxmemory</code>选项，并且服务器用于回收内存算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那么部分键会优先被服务器释放，从而回收内存。</p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>redis设计与实现（第二版） 黄健宏<br><a href=\"https://zhuanlan.zhihu.com/p/107439357\">一口气说出Redis 5种数据结构及对应使用场景，面试要加分的</a></p>"},{"title":"Redis设计与实现-数据结构","date":"2020-08-25T08:30:57.000Z","_content":"\n### 1 简单动态字符串(SDS)\n\nRedis中有两种字符串表示：\n\n- **①、C字符串**：C字符串只会作为字符串字面量（string literal），用在一些无须对字符串值进行修改的地方，如打印日志。\n\n- **②、简单动态字符串**：简单动态字符串（`simple dynamic string, SDS`）是redis构建一种字符串的抽象类型，是redis的默认字符串表示。如字符串键值对、缓冲区等都有SDS实现。\n\n<!--more-->\n\n#### 1.1 SDS的定义\n\nsds.h/sdshdr结构表示一个SDS的值，如：\n\n```c\nstruct sdshdr {\n    // 记录bug数组汇总已使用字节的数量.\n    // 等于SDS所保存字符串的长度\n    unsigned int len;\n    // 记录buf数组中未使用字节的数量.\n    unsigned int free;\n    // 字节数组，用于保存字符串.\n    char buf[];\n};\n\n```\n\n*注：SDS遵循C字符串以`空字符（'\\0'）`结尾，但这个字节的空间不计算在SDS的`len属性`中。*\n\n#### 1.2、SDS字符串相对于C字符串的优点\n\n- 常数复杂度获取字符串长度\n  - C字符串，没有记录自身的长度信息，获取C字符串长度时需进行遍历，其复杂度为O(N)。\n  - SDS字符串，有len属性，获取长度的复杂度为O(1)。\n\n- 杜绝缓冲区溢出: SDS相对于C字符串，根据其空间分配策略，杜绝了发生缓冲区溢出的可能性。\n\n- 减少修改字符串时带来的内存重新分配次数: SDS通过未使用空间`free记录`，实现`空间预分配`和`惰性空间释放`两种优化策略。\n- 二进制安全\n- 兼容部分C字符串函数\n\n\n\n##### 1.2.1 空间预分配\n\n空间预分配用于优化SDS的字符串`增长操作`，当SDS的API对SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。\n\n分配策略：\n\n- 若对SDS修改过后，len属性的值小于1MB，则分配与len属性同样大小的未使用空间，即此时len和free属性大小一致。\n- 若对SDS修改过后，len属性的值大于1MB，则分配1MB的未使用空间。\n\n##### 1.2.2 惰性空间释放\n\n惰性空间释放用于优化SDS的字符串`缩短操作`，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等待将来使用。\n\n\n\n### 2 链表\n\n链表作为一种常用的数据结构，在Redis中应用广泛，如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。此外，还有打不与订阅、慢查询、监视器等功能也用到了链表。\n\n*注：Redis的链表为<u>双向链表</u>。*\n\n#### 2.1 链表和链表节点的实现\n\n链表节点，使用一个`adlist.h/listNode结构`来表示：\n\n```c\ntypedef struct listNode {\n    struct listNode *prev;\n    struct listNode *next;\n    void *value;\n} listNode;\n```\n\n多个listNode可以通过prev和next指针组成**双向链表**，如下图所示：\n\n![双向链表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/双向链表.png)\n\n链表，使用`adlist.h/list结构`表示：\n\n```c\ntypedef struct list {\n    // 表头节点\n    listNode *head;\n    // 表尾结点\n    listNode *tail;\n    // 节点值赋值函数\n    void *(*dup)(void *ptr);\n    // 节点值释放函数\n    void (*free)(void *ptr);\n    // 节点值比对函数，比对链表节点梭堡村的值和另一个输入值是否相等\n    int (*match)(void *ptr, void *key);\n    // 链表所包含的节点数量\n    unsigned long len;\n} list;\n```\n\n示例：下图为一个list结构和三个listNode结构组成的链表。\n\n![list结构和三个listNode结构组成的链表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/list结构和三个listNode结构组成的链表.png)\n\n\n\n### 3 字典\n\n字典，又称为符号表（symbol table）、关联数组（assiciative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典中每个键都是独一无二的。\n\n字典的应用：字典在Redis的应用广泛，如Redis的数据库就是使用字典来作为底层实现的。此外字典还是哈希键的底层实现之一。\n\n#### 3.1 字典的实现\n\n<u>Redis的字典使用`哈希表`作为底层实现</u>，<u>一个哈希表里面可以有多个哈希表结点</u>，<u>而每个哈希表结点就保存了一个字段中的键值对</u>。\n\n##### 3.1.1 哈希表\n\nRedis字典所使用的哈希表由`dict.h/dictht结构`定义：\n\n```c\ntypedef struct dictht {\n    // 哈希表数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个结构保存着一个键值对。\n    dictEntry **table;\n    // 哈希表大小.\n    unsigned long size;\n    // 哈希表大小掩码，用于计算索引值.\n    // 总是等于size-1.\n    unsigned long sizemask;\n    // 该哈希表已有结点的数量.\n    unsigned long used;\n} dictht;\n```\n\n示例：下图为一个大小为4的空哈希表。（没有任何键值对）\n\n![大小为4的空哈希表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/大小为4的空哈希表.png)\n\n##### 3.1.2 哈希表结点\n\n哈希表结点使用`dictEntry结构`表示，每个dictEntry结构都保存着一个键值对：\n\n```c\ntypedef struct dictEntry {\n    // 键\n    void *key;\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    // 指向下一个哈希表结点,形成链表,用以解决哈希冲突的问题.\n    struct dictEntry *next;\n} dictEntry;\n```\n\n示例：下图是通过`next指针`,将两个指引着相同的键`k1`和`k0`连接的数据结构.\n\n![通过next指针,将两个索引值相同的键k1和k0连接的数据结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/通过next指针,将两个索引值相同的键k1和k0连接的数据结构.png)\n\n##### 3.1.3 字典\n\nRedis中的字典由`dict.h/dict结构`表示：\n\n```c\ntypedef struct dict {\n    // 类型特定函数.Redis会为用途不同的字典设置不同的类型特定函数。\n    dictType *type;\n    // 私有数据.保存了需要传给那些类型特定函数的可选参数。\n    void *privdata;\n    // 哈希表.包含了两个项的数组，每个项都是dictht哈希表，通常，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用。\n    dictht ht[2];\n    // rehash索引.记录rehash的进度，若当前没有进行rehash，那么它的值为-1.\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n```\n\n其中`type`和`privdata`属性是<u>针对不同类型的键值对,为创建多态字典而设置</u>。\n\n\n\ntype特定函数结构：\n\n```c\ntypedef struct dictType {\n    // 计算哈希值的函数。\n    unsigned int (*hashFunction)(const void *key);\n    // 复制键的函数。\n    void *(*keyDup)(void *privdata, const void *key);\n    // 复制值的函数。\n    void *(*valDup)(void *privdata, const void *obj);\n    // 对比键的函数.\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);\n    // 销毁键的函数。\n    void (*keyDestructor)(void *privdata, void *key);\n    // 销毁值的函数。\n    void (*valDestructor)(void *privdata, void *obj);\n} dictType;\n```\n\n示例：下图为普通状态的下的字典示例。\n\n![普通状态下的字典示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/普通状态下的字典示例.png)\n\n#### 3.2 哈希算法\n\n要将一个新的键值对添加到字典中时，程序需先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表结点放到哈希表数组的指定索引上面。\n\n\n\n**Redis计算哈希值方式？**\n\n使用字典设置的哈希函数，计算键key的哈希值：\n\n```\nhash = dict->type->hashFunction(key);\n```\n\n\n\n**Redis计算索引值的方式？**\n\n根据哈希表的`sizemask属性`和哈希值计算出索引值，其中根据情况不同，ht[x]可以使ht[0]或ht[1]。\n\n```\nindex = hash & dict->ht[x].sizemask;\n```\n\n注：当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。\n\n\n\n#### 3.3 解决键冲突\n\n当有两个或者以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了`冲突（collision）`。\n\n\n\n**Redis怎样解决键冲突？**\n\nRedis的哈希表使用`链地址法`来解决键冲突。\n\n每个哈希表结点都有一个`next指针`，多个哈希表结点可以用next指针构成一个<u>单向链表</u>，被分配到同一个索引上的多个结点可以用这个单向链表连接起来，解决键冲突的问题。\n\n*注：由于dictEntry结点组成的链表没有指向链表表尾的指针，所以程序总是将新节点添加到链表的表头位置（复杂度为O(1)）*\n\n\n\n示例：k2与k1发生了键冲突，k2后添加，如下图所示。\n\n![k2与k1发生了键冲突,k2后添加](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/k2与k1发生了键冲突,k2后添加.png)\n\n#### 3.4 rehash\n\n随着操作的不断执行，哈希表保存的键值对会逐渐增减，为了让哈希表的负载因子维持在一个合理的范围内，需对哈希表的大小进行相应的扩展或收缩。这个过程就是rehash。\n\n**Redis是怎样对字典的哈希表执行rehash的（rehash的步骤）？**\n\n- ①、为字典的`h[1]`哈希表分配空间。\n  - 扩展操作：`ht[1]`的大小为第一个大于等于`ht[0].used*2的2^n`(2的n次方幂)；\n  - 收缩操作：`ht[1]`的大小为第一个大于等于`ht[0].used的2^n`。\n- ②、将保存在`ht[0]`中的所有键值对rehash到`ht[1]`上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。\n- ③、当`ht[0]`包含的所有键值对都前移到了`ht[1]`后，释放`ht[0]`，将`ht[1]`设置为`ht[0]`，并在`ht[1]`新创建一个空白哈希表，为下一次rehash做准备。\n\n\n\n示例：假设ht[0].used当前的值为4，要对进行扩展操作，则ht[1]的大小为4*2=8，刚好为2^3，所以ht[1]哈希表的大小设置为8.\n\n\n\n**哈希表的扩展与收缩都与负载因子有关，那么什么是负载因子呢？怎样计算负载因子？**\n\nRedis的负载因子为哈希表以保存结点的数量与哈希表的大小的比值，计算方法如下：\n\n```\nload_factor = ht[0].used / ht[0].size\n```\n\n示例：对于一个大小为512，包含256个键值对的哈希表说，这个哈希表的负载因子为：\n\nload_factor = 256 / 512 = 0.5\n\n\n\n**什么情况下程序会自动对哈希表执行扩展操作？**\n\n- ①、服务器没有在执行`BGSAVE`或者`BGREWRITEAOF`命令，并且哈希表的负载因子<u>大于等于1</u>.\n- ②、服务器正在执行`BGSAVE`或者`BGREWRITEAOF`命令，并且哈希表的负载因子<u>大于等于5</u>.\n\n*注：在执行BGSAVE或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入，最大限度地节约内存。*\n\n\n\n**什么情况下程序会对哈希表执行收缩操作？**\n\n当哈希表的负载因子<u>小于0.1</u>时，程序自动开始对哈希表执行收缩操作。\n\n\n\n#### 3.5 渐进式rehash\n\n扩展或收缩哈希表需要将`ht[0]`里面的键值对rehash到`ht[1]`里面，但是这个rehash动作并不是一次性、集中式完成的，而是分多次、<u>渐进式</u>地完成的。\n\n\n\n**为什么要渐进式完成rehash？**\n\n为了<u>避免大量键值对rehash对服务器性能造成影响</u>。采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。\n\n\n\n**哈希表是怎样渐进式rehash的（rehash的详细步骤）？**\n\n- ①、为`ht[1]`分配空间，让字典同时持有ht[0]和ht[1]两个哈希表、\n- ②、在字典中维持一个`rehashidx`，并将它的值设置为0，表示rehash工作正式开始。\n- ③、在rehash进行期间，每次对字段执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增加一。\n- ④、随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]上，这是程序将rehashidx属性设为-1，表示rehash操作已完成。\n\n\n\n**渐进式rehash执行期间会涉及到ht[0]和ht[1]两个哈希表，是怎样操作的呢？**\n\n- 针对删除、查找、更新操作，会在两个哈希表上进行，例如，查找一个键时，程序会在ht[0]上查找，若没有找到，会继续到ht[1]里面进行查找。\n- 对于新增操作，新增加到字典的键值对一律被保存到ht[1]里面，而ht[0]则不再进行任何操作。\n\n\n\n### 4 跳跃表\n\n跳跃表是一种`有序数据结构`，它<u>通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</u>。\n\nRedis使用跳跃表作为`有序集合键`的底层实现之一，若一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，跳跃表还在集群节点中用作内部数据结构。\n\n#### 4.1 跳跃表结点的实现\n\nRedis跳跃表由`redis.h/zskiplistNode和redis.h/zskiplist`两个结构定义。\n\n跳跃表示例如下：\n\n![跳跃表示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/跳跃表示例.png)\n\n\n\n`zskiplistNode结构`用于表示跳跃表的结点。\n\n```c\ntypedef struct zskiplistNode {\n    // 成员对象.示例图中o1，o2，o3是结点所保存的成员对象。\n    robj *obj;\n    // 分值. 跳跃表中，结点按照各自所保存的分值从小到大排列。\n    double score;\n    // 后退指针.指向当前的结点的前一个结点，后退指针在程序从表尾想表头遍历时使用。示例图上用BW标识结点的后退指针。\n    struct zskiplistNode *backward;\n    // 层.每个层都有两个属性：前进指针和跨度。\n    struct zskiplistLevel {\n        // 前进指针.前进指针用于访问表尾方向的其他节点。示例图上的带有数字的剪头就表示前进指针。\n        struct zskiplostNode *forward;\n        // 跨度.跨度记录了前进指针所指向结点和当前结点的距离。示例图上箭头上的数字就表示跨度。\n        unsigned int span;\n    } level[];\n} zskiplistNode;\n```\n\n##### 4.1.1 层\n\n跳跃表节点的`level数组`可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。一般来说，层的数量越多，访问其他节点的速度就越快。\n\n每次创建一个新跳跃表节点的时候，程序都根据<u>幂次定律</u>(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。\n\n示例：下图为三个高度分别为1层、3层、5层的节点。\n\n![高度分别为1层,3层,5层的节点](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/高度分别为1层,3层,5层的节点.png)\n\n##### 4.1.2 前进指针\n\n每个层都有一个指向表尾党项的`前进指针`（`level[i].forward`属性），用于从表头向表尾方向访问节点。\n\n\n\n**跳跃表是怎样遍历所有节点的呢？**\n\n示例图如下：\n\n![跳跃表遍历](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/跳跃表遍历.png)\n\n- ①、迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中第二个节点。\n- ②、在第二个结点时，程序沿着第二层的前进指针移动到表中第三个节点。\n- ③、在第三个节点时，程序沿着第二层的前进指针移动到表中的第四个结点。\n- ④、当程序在此沿着第四个节点的前进指针移动时，它碰到了一个NULL，程序知道这时已经到达了跳跃表的表尾，结束遍历。\n\n*注：遍历操作只使用前进指针就能完成。*\n\n\n\n##### 4.1.3 跨度\n\n层的跨度（`level[i].span`属性）用于记录两个结点之间的距离，两个结点之间跨度越大，他们相距得就越远；指向`null`的所有前进指针的跨度都为0，因为他们没有指向任何节点。\n\n<u>跨度实际上是用来计算排位的</u>：在查找某个结点的过程中，将访问过的所有层的跨度累计起来，得到的结果就是目标结点在跳跃表中的排位。\n\n\n\n##### 4.1.4 后退指针\n\n节点的后退指针(`backward`属性)用于从<u>表尾向表头</u>方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。\n\n\n\n##### 4.1.5 分值和成员\n\n节点的分值(`score`属性)是一个`double类型的浮点数`，跳跃表中的所有结点都按分值<u>从小到大来排序</u>。\n\n节点的成员对象(obj属性)是一个指针，他指向一个字符串对象，而字符串对象则保存着一个SDS值。\n\n注：**同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但多个结点保存的分值却可以是相同的**。分值相同的结点将按照成员对象在字典序中的大小来进行排序，成员对象较小的结点会排在前面（靠近表头的方向）。\n\n\n\n#### 4.2 跳跃表的实现\n\n仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个`zskiplist结构`来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或快速地获取跳跃表节点的数量等信息。\n\n`zskiplist结构`如下：\n\n```c\ntypedef struct zskiplist {\n    // header 指向跳跃表的表头节点。\n    // tail 指向跳跃表的表位节点.\n    struct zskiplistNode *header, *tail;\n    // 记录跳跃表的长度，即跳跃表目前包含结点的数量（表头节点不计算在内）\n    unsigned long length;\n    // level 记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。\n    int level;\n} zskiplist;\n```\n\n*注：level表头节点的层高并不计算在内。*\n\n\n\n### 五、整数集合\n\n整数集合是`集合键`的底层实现之一，当一个**集合只包含整数值元素，并且这个集合的元素数量不多时**，Redis就会使用整数集合作为集合键得底层实现。\n\n（<u>注：整数集合是只包含整数值元素的集合。</u>）\n\n\n\n#### 5.1 整数集合的实现\n\n整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为`int16_t`、`int32_t`或者`int64_t`的整数值，并保证集合中不会出现重复元素。\n\n每个`intset.h/intset结构`表示一个整数集合：\n\n```c\ntypedef struct intset {\n    // 编码方式.\n    uint_32_t encoding;\n    // 集合包含的元素数量.即contents数组的长度。\n    uint32_t length;\n    // 保存元素的数组.\n    int8_t contents[];\n}\n```\n\n\n\n**整数集合的底层实现是什么？**\n\n整数集合的底层是通过<u>数组</u>（`contents`属性）实现的，整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小<u>从小到大</u>有序地排列，并且数组中不包含任何重复项。\n\n\n\n注：\n\n①、数组元素在底层是有进行从小到大的排序的。\n\n②、虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存int8_t类型的值，contents数组的真正类型取决于encoding属性的值。\n\nencoding属性的取值包括以下内容：\n\n- **INTSET_ENC_INT16**:表示`int16_t`类型的数组，数组里面每个项都是一个int16_t类型的整数值（2^15 ~2^(15)-1）。\n- **INTSET_ENC_INT32**:表示`int32_t`类型的数组，数组里面每个项都是一个int32_t类型的整数值(2^31 ~2^(31)-1)。\n- **INTSET_ENC_INT64**:表示`int64_t`类型的数组，数组里面每个项都是一个int64_t类型的整数值(2^63 ~2^(63)-1)。\n\n\n\n#### 5.2 升级\n\n当添加新元素到整数集合中时，<u>新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先升级，然后才能将新元素添加到整数集合里面</u>。\n\n\n\n**Redis是怎样升级整数集合并添加新元素的呢（升级及添加新元素的步骤）？**\n\n升级整数集合并添加新元素共分为三步进行：\n\n- ①、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。\n- ②、将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在防止元素的过程中，需要继续维持底层数组的有序性质不变。\n- ③、将新元素添加到底层数组里面。\n\n*注：每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中又有的元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。*\n\n\n\n升级时新元素的摆放位置，要引发升级，那么要么新元素大于所有现有元素，要么小于现有所有元素，因此摆放位置应该在数组的两端。\n\n为什么要进行升级，而不是直接采用int64_t类型？\n\n- ①、提高灵活性。\n- ②、节约内存。\n\n\n\n#### 5.3 降级\n\n整数集合**不支持降级操作**，一旦对数组进行了升级，编码就会一直保持升级后的状态。\n\n\n\n### 六、压缩列表\n\n压缩列表（ziplist）是`列表键`和`哈希键`的底层实现之一。\n\n\n\n压缩列表(ziplist)在Redis的应用场景有哪些？\n\n- ①、当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。\n\n\n- ②、当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。\n\n\n\n\n#### 6.1 压缩列表的构成\n\n压缩列表是Redis为了<u>节约内存</u>而开发的，是由一系列特殊编码的<u>连续内存块组成</u>的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。\n\n压缩列表的各个组成部分如下图：\n\n![压缩表各部分组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩表各部分组成.png)\n\n下表中记录了各个组成部分的类型、长度以及用途。\n\n![压缩表各组成部分的类型,长度以及用途](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩表各组成部分的类型,长度以及用途.png)\n\n示例：包含三个节点的压缩列表\n\n![包含三个节点的压缩列表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/包含三个节点的压缩列表.png)\n\n其中：\n\n- `zlbytes`的属性值为0x50,表示压缩列表的总长为80.\n- `zltail`属性的值为0x3c，表示有一个指向压缩列表起始地址的指针p，在指针p加上偏移量60，就可以计算出表尾节点entry3的地址。\n- `zllen`属性值为0x3，表示压缩列表包含三个节点。\n- `zlend`属性值为特殊值，用于标记压缩列表的末端。\n\n\n\n#### 6.2 压缩列表节点的构成\n\n每个压缩列表节点可以保存<u>一个字节数组</u>或者<u>一个整数值</u>。\n\n- **字节数组**可以是以下三中长度的其中一种：\n  - 长度小于等于63（2^6-1）字节的字节数组。\n  - 长度小于等于16383（2^14-1）字节的字节数组。\n  - 长度小于等于4294967295（2^32-1）字节的字节数组。\n- **整数值**可以是以下六种长度的其中一种：\n  - 4位长，介于0~12之间的无符号整数；\n  - 1字节长的有符号整数；\n  - 3字节长的有符号整数；\n  - int16_t类型整数；\n  - int32_t类型整数；\n  - int64_t类型整数。\n\n\n\n`压缩列表结点的组成部分`如下：\n\n![压缩列表结点的组成部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩列表结点的组成部分.png)\n\n##### 6.2.1 previous_entry_length\n\n`previous_entry_length属性`以`字节`为单位，记录了压缩列表中前一个节点的长度，`previous_entry_length`属性的长度可以是1字节或者5字节。\n\n- 若前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。\n- 若前一节点的长度大于等于254字节，那么previoud_entry_length属性的长度为5字节，其中第一字节会被设置为0xFE，而后的四个字节则用于保存前一节点的长度。\n\n根据previous_entry_length属性可以计算得到前一个节点的起始地址。通过这一原理，即可实现从表尾向表头遍历。\n\n\n\n##### 6.2.2 encoding\n\n节点的`encoding`属性记录了节点的content属性所保存数据的类型及长度：\n\n**字节数组编码**：一字节、两字节或者五字节，encoding最高位为**00、01、10表示字节数组编码**，除去最高两位后表示数组的长度。\n\n![encoding属性数组编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/encoding属性数组编码.png)\n\n\n\n**整数编码**：一字节，**encoding最高位为11**，除去最高两位后的其他位记录整数值的类型和长度。\n\n![encoding属性整数编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/encoding属性整数编码.png)\n\n##### 6.2.3 content\n\n节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由encoding属性决定。\n\n示例1：以下示例展示了一个保存字节数组的节点示例。\n\n![保存字节数组的节点示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/保存字节数组的节点示例.png)\n\n其中：\n\n- encoding的最高两位为00，表示一个字节数组。\n- encoding的后六位001011记录了字节数组的长度为11.\n- content属性保存着节点的值“hello world”\n\n示例2：以下示例展示了一个保存整数值的节点示例。\n\n![保存整数值的节点示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/保存整数值的节点示例.png)\n\n其中：\n\n- encoding表示节点保存的是int16_t类型的整数值。\n- content属性保存着节点的值10086.\n\n\n\n#### 6.3 连锁更新\n\n**什么情况下会发生连锁更新？**\n\n比如当前所有结点长度均小于254字节情况下，新添加一个长度大于254字节的节点到压缩列表的表头，此时需对压缩列表执行空间重分配操作，扩展后面的previous_entry_length属性空间。\n\n定义：Redis将这种特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。\n\n连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。\n\n\n\n### 参考资料\n\n1. redis设计与实现（第二版） 黄健宏","source":"_posts/Redis设计与实现-数据结构.md","raw":"---\ntitle: Redis设计与实现-数据结构\ndate: 2020-08-25 16:30:57\ntags: [\"Redis\",\"Note\",\"Redis设计与实现\"]\ncategories: [\"Redis\"]\n---\n\n### 1 简单动态字符串(SDS)\n\nRedis中有两种字符串表示：\n\n- **①、C字符串**：C字符串只会作为字符串字面量（string literal），用在一些无须对字符串值进行修改的地方，如打印日志。\n\n- **②、简单动态字符串**：简单动态字符串（`simple dynamic string, SDS`）是redis构建一种字符串的抽象类型，是redis的默认字符串表示。如字符串键值对、缓冲区等都有SDS实现。\n\n<!--more-->\n\n#### 1.1 SDS的定义\n\nsds.h/sdshdr结构表示一个SDS的值，如：\n\n```c\nstruct sdshdr {\n    // 记录bug数组汇总已使用字节的数量.\n    // 等于SDS所保存字符串的长度\n    unsigned int len;\n    // 记录buf数组中未使用字节的数量.\n    unsigned int free;\n    // 字节数组，用于保存字符串.\n    char buf[];\n};\n\n```\n\n*注：SDS遵循C字符串以`空字符（'\\0'）`结尾，但这个字节的空间不计算在SDS的`len属性`中。*\n\n#### 1.2、SDS字符串相对于C字符串的优点\n\n- 常数复杂度获取字符串长度\n  - C字符串，没有记录自身的长度信息，获取C字符串长度时需进行遍历，其复杂度为O(N)。\n  - SDS字符串，有len属性，获取长度的复杂度为O(1)。\n\n- 杜绝缓冲区溢出: SDS相对于C字符串，根据其空间分配策略，杜绝了发生缓冲区溢出的可能性。\n\n- 减少修改字符串时带来的内存重新分配次数: SDS通过未使用空间`free记录`，实现`空间预分配`和`惰性空间释放`两种优化策略。\n- 二进制安全\n- 兼容部分C字符串函数\n\n\n\n##### 1.2.1 空间预分配\n\n空间预分配用于优化SDS的字符串`增长操作`，当SDS的API对SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。\n\n分配策略：\n\n- 若对SDS修改过后，len属性的值小于1MB，则分配与len属性同样大小的未使用空间，即此时len和free属性大小一致。\n- 若对SDS修改过后，len属性的值大于1MB，则分配1MB的未使用空间。\n\n##### 1.2.2 惰性空间释放\n\n惰性空间释放用于优化SDS的字符串`缩短操作`，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等待将来使用。\n\n\n\n### 2 链表\n\n链表作为一种常用的数据结构，在Redis中应用广泛，如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。此外，还有打不与订阅、慢查询、监视器等功能也用到了链表。\n\n*注：Redis的链表为<u>双向链表</u>。*\n\n#### 2.1 链表和链表节点的实现\n\n链表节点，使用一个`adlist.h/listNode结构`来表示：\n\n```c\ntypedef struct listNode {\n    struct listNode *prev;\n    struct listNode *next;\n    void *value;\n} listNode;\n```\n\n多个listNode可以通过prev和next指针组成**双向链表**，如下图所示：\n\n![双向链表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/双向链表.png)\n\n链表，使用`adlist.h/list结构`表示：\n\n```c\ntypedef struct list {\n    // 表头节点\n    listNode *head;\n    // 表尾结点\n    listNode *tail;\n    // 节点值赋值函数\n    void *(*dup)(void *ptr);\n    // 节点值释放函数\n    void (*free)(void *ptr);\n    // 节点值比对函数，比对链表节点梭堡村的值和另一个输入值是否相等\n    int (*match)(void *ptr, void *key);\n    // 链表所包含的节点数量\n    unsigned long len;\n} list;\n```\n\n示例：下图为一个list结构和三个listNode结构组成的链表。\n\n![list结构和三个listNode结构组成的链表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/list结构和三个listNode结构组成的链表.png)\n\n\n\n### 3 字典\n\n字典，又称为符号表（symbol table）、关联数组（assiciative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典中每个键都是独一无二的。\n\n字典的应用：字典在Redis的应用广泛，如Redis的数据库就是使用字典来作为底层实现的。此外字典还是哈希键的底层实现之一。\n\n#### 3.1 字典的实现\n\n<u>Redis的字典使用`哈希表`作为底层实现</u>，<u>一个哈希表里面可以有多个哈希表结点</u>，<u>而每个哈希表结点就保存了一个字段中的键值对</u>。\n\n##### 3.1.1 哈希表\n\nRedis字典所使用的哈希表由`dict.h/dictht结构`定义：\n\n```c\ntypedef struct dictht {\n    // 哈希表数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个结构保存着一个键值对。\n    dictEntry **table;\n    // 哈希表大小.\n    unsigned long size;\n    // 哈希表大小掩码，用于计算索引值.\n    // 总是等于size-1.\n    unsigned long sizemask;\n    // 该哈希表已有结点的数量.\n    unsigned long used;\n} dictht;\n```\n\n示例：下图为一个大小为4的空哈希表。（没有任何键值对）\n\n![大小为4的空哈希表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/大小为4的空哈希表.png)\n\n##### 3.1.2 哈希表结点\n\n哈希表结点使用`dictEntry结构`表示，每个dictEntry结构都保存着一个键值对：\n\n```c\ntypedef struct dictEntry {\n    // 键\n    void *key;\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    // 指向下一个哈希表结点,形成链表,用以解决哈希冲突的问题.\n    struct dictEntry *next;\n} dictEntry;\n```\n\n示例：下图是通过`next指针`,将两个指引着相同的键`k1`和`k0`连接的数据结构.\n\n![通过next指针,将两个索引值相同的键k1和k0连接的数据结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/通过next指针,将两个索引值相同的键k1和k0连接的数据结构.png)\n\n##### 3.1.3 字典\n\nRedis中的字典由`dict.h/dict结构`表示：\n\n```c\ntypedef struct dict {\n    // 类型特定函数.Redis会为用途不同的字典设置不同的类型特定函数。\n    dictType *type;\n    // 私有数据.保存了需要传给那些类型特定函数的可选参数。\n    void *privdata;\n    // 哈希表.包含了两个项的数组，每个项都是dictht哈希表，通常，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用。\n    dictht ht[2];\n    // rehash索引.记录rehash的进度，若当前没有进行rehash，那么它的值为-1.\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n```\n\n其中`type`和`privdata`属性是<u>针对不同类型的键值对,为创建多态字典而设置</u>。\n\n\n\ntype特定函数结构：\n\n```c\ntypedef struct dictType {\n    // 计算哈希值的函数。\n    unsigned int (*hashFunction)(const void *key);\n    // 复制键的函数。\n    void *(*keyDup)(void *privdata, const void *key);\n    // 复制值的函数。\n    void *(*valDup)(void *privdata, const void *obj);\n    // 对比键的函数.\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);\n    // 销毁键的函数。\n    void (*keyDestructor)(void *privdata, void *key);\n    // 销毁值的函数。\n    void (*valDestructor)(void *privdata, void *obj);\n} dictType;\n```\n\n示例：下图为普通状态的下的字典示例。\n\n![普通状态下的字典示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/普通状态下的字典示例.png)\n\n#### 3.2 哈希算法\n\n要将一个新的键值对添加到字典中时，程序需先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表结点放到哈希表数组的指定索引上面。\n\n\n\n**Redis计算哈希值方式？**\n\n使用字典设置的哈希函数，计算键key的哈希值：\n\n```\nhash = dict->type->hashFunction(key);\n```\n\n\n\n**Redis计算索引值的方式？**\n\n根据哈希表的`sizemask属性`和哈希值计算出索引值，其中根据情况不同，ht[x]可以使ht[0]或ht[1]。\n\n```\nindex = hash & dict->ht[x].sizemask;\n```\n\n注：当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。\n\n\n\n#### 3.3 解决键冲突\n\n当有两个或者以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了`冲突（collision）`。\n\n\n\n**Redis怎样解决键冲突？**\n\nRedis的哈希表使用`链地址法`来解决键冲突。\n\n每个哈希表结点都有一个`next指针`，多个哈希表结点可以用next指针构成一个<u>单向链表</u>，被分配到同一个索引上的多个结点可以用这个单向链表连接起来，解决键冲突的问题。\n\n*注：由于dictEntry结点组成的链表没有指向链表表尾的指针，所以程序总是将新节点添加到链表的表头位置（复杂度为O(1)）*\n\n\n\n示例：k2与k1发生了键冲突，k2后添加，如下图所示。\n\n![k2与k1发生了键冲突,k2后添加](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/k2与k1发生了键冲突,k2后添加.png)\n\n#### 3.4 rehash\n\n随着操作的不断执行，哈希表保存的键值对会逐渐增减，为了让哈希表的负载因子维持在一个合理的范围内，需对哈希表的大小进行相应的扩展或收缩。这个过程就是rehash。\n\n**Redis是怎样对字典的哈希表执行rehash的（rehash的步骤）？**\n\n- ①、为字典的`h[1]`哈希表分配空间。\n  - 扩展操作：`ht[1]`的大小为第一个大于等于`ht[0].used*2的2^n`(2的n次方幂)；\n  - 收缩操作：`ht[1]`的大小为第一个大于等于`ht[0].used的2^n`。\n- ②、将保存在`ht[0]`中的所有键值对rehash到`ht[1]`上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。\n- ③、当`ht[0]`包含的所有键值对都前移到了`ht[1]`后，释放`ht[0]`，将`ht[1]`设置为`ht[0]`，并在`ht[1]`新创建一个空白哈希表，为下一次rehash做准备。\n\n\n\n示例：假设ht[0].used当前的值为4，要对进行扩展操作，则ht[1]的大小为4*2=8，刚好为2^3，所以ht[1]哈希表的大小设置为8.\n\n\n\n**哈希表的扩展与收缩都与负载因子有关，那么什么是负载因子呢？怎样计算负载因子？**\n\nRedis的负载因子为哈希表以保存结点的数量与哈希表的大小的比值，计算方法如下：\n\n```\nload_factor = ht[0].used / ht[0].size\n```\n\n示例：对于一个大小为512，包含256个键值对的哈希表说，这个哈希表的负载因子为：\n\nload_factor = 256 / 512 = 0.5\n\n\n\n**什么情况下程序会自动对哈希表执行扩展操作？**\n\n- ①、服务器没有在执行`BGSAVE`或者`BGREWRITEAOF`命令，并且哈希表的负载因子<u>大于等于1</u>.\n- ②、服务器正在执行`BGSAVE`或者`BGREWRITEAOF`命令，并且哈希表的负载因子<u>大于等于5</u>.\n\n*注：在执行BGSAVE或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入，最大限度地节约内存。*\n\n\n\n**什么情况下程序会对哈希表执行收缩操作？**\n\n当哈希表的负载因子<u>小于0.1</u>时，程序自动开始对哈希表执行收缩操作。\n\n\n\n#### 3.5 渐进式rehash\n\n扩展或收缩哈希表需要将`ht[0]`里面的键值对rehash到`ht[1]`里面，但是这个rehash动作并不是一次性、集中式完成的，而是分多次、<u>渐进式</u>地完成的。\n\n\n\n**为什么要渐进式完成rehash？**\n\n为了<u>避免大量键值对rehash对服务器性能造成影响</u>。采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。\n\n\n\n**哈希表是怎样渐进式rehash的（rehash的详细步骤）？**\n\n- ①、为`ht[1]`分配空间，让字典同时持有ht[0]和ht[1]两个哈希表、\n- ②、在字典中维持一个`rehashidx`，并将它的值设置为0，表示rehash工作正式开始。\n- ③、在rehash进行期间，每次对字段执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增加一。\n- ④、随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]上，这是程序将rehashidx属性设为-1，表示rehash操作已完成。\n\n\n\n**渐进式rehash执行期间会涉及到ht[0]和ht[1]两个哈希表，是怎样操作的呢？**\n\n- 针对删除、查找、更新操作，会在两个哈希表上进行，例如，查找一个键时，程序会在ht[0]上查找，若没有找到，会继续到ht[1]里面进行查找。\n- 对于新增操作，新增加到字典的键值对一律被保存到ht[1]里面，而ht[0]则不再进行任何操作。\n\n\n\n### 4 跳跃表\n\n跳跃表是一种`有序数据结构`，它<u>通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</u>。\n\nRedis使用跳跃表作为`有序集合键`的底层实现之一，若一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，跳跃表还在集群节点中用作内部数据结构。\n\n#### 4.1 跳跃表结点的实现\n\nRedis跳跃表由`redis.h/zskiplistNode和redis.h/zskiplist`两个结构定义。\n\n跳跃表示例如下：\n\n![跳跃表示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/跳跃表示例.png)\n\n\n\n`zskiplistNode结构`用于表示跳跃表的结点。\n\n```c\ntypedef struct zskiplistNode {\n    // 成员对象.示例图中o1，o2，o3是结点所保存的成员对象。\n    robj *obj;\n    // 分值. 跳跃表中，结点按照各自所保存的分值从小到大排列。\n    double score;\n    // 后退指针.指向当前的结点的前一个结点，后退指针在程序从表尾想表头遍历时使用。示例图上用BW标识结点的后退指针。\n    struct zskiplistNode *backward;\n    // 层.每个层都有两个属性：前进指针和跨度。\n    struct zskiplistLevel {\n        // 前进指针.前进指针用于访问表尾方向的其他节点。示例图上的带有数字的剪头就表示前进指针。\n        struct zskiplostNode *forward;\n        // 跨度.跨度记录了前进指针所指向结点和当前结点的距离。示例图上箭头上的数字就表示跨度。\n        unsigned int span;\n    } level[];\n} zskiplistNode;\n```\n\n##### 4.1.1 层\n\n跳跃表节点的`level数组`可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。一般来说，层的数量越多，访问其他节点的速度就越快。\n\n每次创建一个新跳跃表节点的时候，程序都根据<u>幂次定律</u>(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。\n\n示例：下图为三个高度分别为1层、3层、5层的节点。\n\n![高度分别为1层,3层,5层的节点](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/高度分别为1层,3层,5层的节点.png)\n\n##### 4.1.2 前进指针\n\n每个层都有一个指向表尾党项的`前进指针`（`level[i].forward`属性），用于从表头向表尾方向访问节点。\n\n\n\n**跳跃表是怎样遍历所有节点的呢？**\n\n示例图如下：\n\n![跳跃表遍历](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/跳跃表遍历.png)\n\n- ①、迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中第二个节点。\n- ②、在第二个结点时，程序沿着第二层的前进指针移动到表中第三个节点。\n- ③、在第三个节点时，程序沿着第二层的前进指针移动到表中的第四个结点。\n- ④、当程序在此沿着第四个节点的前进指针移动时，它碰到了一个NULL，程序知道这时已经到达了跳跃表的表尾，结束遍历。\n\n*注：遍历操作只使用前进指针就能完成。*\n\n\n\n##### 4.1.3 跨度\n\n层的跨度（`level[i].span`属性）用于记录两个结点之间的距离，两个结点之间跨度越大，他们相距得就越远；指向`null`的所有前进指针的跨度都为0，因为他们没有指向任何节点。\n\n<u>跨度实际上是用来计算排位的</u>：在查找某个结点的过程中，将访问过的所有层的跨度累计起来，得到的结果就是目标结点在跳跃表中的排位。\n\n\n\n##### 4.1.4 后退指针\n\n节点的后退指针(`backward`属性)用于从<u>表尾向表头</u>方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。\n\n\n\n##### 4.1.5 分值和成员\n\n节点的分值(`score`属性)是一个`double类型的浮点数`，跳跃表中的所有结点都按分值<u>从小到大来排序</u>。\n\n节点的成员对象(obj属性)是一个指针，他指向一个字符串对象，而字符串对象则保存着一个SDS值。\n\n注：**同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但多个结点保存的分值却可以是相同的**。分值相同的结点将按照成员对象在字典序中的大小来进行排序，成员对象较小的结点会排在前面（靠近表头的方向）。\n\n\n\n#### 4.2 跳跃表的实现\n\n仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个`zskiplist结构`来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或快速地获取跳跃表节点的数量等信息。\n\n`zskiplist结构`如下：\n\n```c\ntypedef struct zskiplist {\n    // header 指向跳跃表的表头节点。\n    // tail 指向跳跃表的表位节点.\n    struct zskiplistNode *header, *tail;\n    // 记录跳跃表的长度，即跳跃表目前包含结点的数量（表头节点不计算在内）\n    unsigned long length;\n    // level 记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。\n    int level;\n} zskiplist;\n```\n\n*注：level表头节点的层高并不计算在内。*\n\n\n\n### 五、整数集合\n\n整数集合是`集合键`的底层实现之一，当一个**集合只包含整数值元素，并且这个集合的元素数量不多时**，Redis就会使用整数集合作为集合键得底层实现。\n\n（<u>注：整数集合是只包含整数值元素的集合。</u>）\n\n\n\n#### 5.1 整数集合的实现\n\n整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为`int16_t`、`int32_t`或者`int64_t`的整数值，并保证集合中不会出现重复元素。\n\n每个`intset.h/intset结构`表示一个整数集合：\n\n```c\ntypedef struct intset {\n    // 编码方式.\n    uint_32_t encoding;\n    // 集合包含的元素数量.即contents数组的长度。\n    uint32_t length;\n    // 保存元素的数组.\n    int8_t contents[];\n}\n```\n\n\n\n**整数集合的底层实现是什么？**\n\n整数集合的底层是通过<u>数组</u>（`contents`属性）实现的，整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小<u>从小到大</u>有序地排列，并且数组中不包含任何重复项。\n\n\n\n注：\n\n①、数组元素在底层是有进行从小到大的排序的。\n\n②、虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存int8_t类型的值，contents数组的真正类型取决于encoding属性的值。\n\nencoding属性的取值包括以下内容：\n\n- **INTSET_ENC_INT16**:表示`int16_t`类型的数组，数组里面每个项都是一个int16_t类型的整数值（2^15 ~2^(15)-1）。\n- **INTSET_ENC_INT32**:表示`int32_t`类型的数组，数组里面每个项都是一个int32_t类型的整数值(2^31 ~2^(31)-1)。\n- **INTSET_ENC_INT64**:表示`int64_t`类型的数组，数组里面每个项都是一个int64_t类型的整数值(2^63 ~2^(63)-1)。\n\n\n\n#### 5.2 升级\n\n当添加新元素到整数集合中时，<u>新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先升级，然后才能将新元素添加到整数集合里面</u>。\n\n\n\n**Redis是怎样升级整数集合并添加新元素的呢（升级及添加新元素的步骤）？**\n\n升级整数集合并添加新元素共分为三步进行：\n\n- ①、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。\n- ②、将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在防止元素的过程中，需要继续维持底层数组的有序性质不变。\n- ③、将新元素添加到底层数组里面。\n\n*注：每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中又有的元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。*\n\n\n\n升级时新元素的摆放位置，要引发升级，那么要么新元素大于所有现有元素，要么小于现有所有元素，因此摆放位置应该在数组的两端。\n\n为什么要进行升级，而不是直接采用int64_t类型？\n\n- ①、提高灵活性。\n- ②、节约内存。\n\n\n\n#### 5.3 降级\n\n整数集合**不支持降级操作**，一旦对数组进行了升级，编码就会一直保持升级后的状态。\n\n\n\n### 六、压缩列表\n\n压缩列表（ziplist）是`列表键`和`哈希键`的底层实现之一。\n\n\n\n压缩列表(ziplist)在Redis的应用场景有哪些？\n\n- ①、当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。\n\n\n- ②、当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。\n\n\n\n\n#### 6.1 压缩列表的构成\n\n压缩列表是Redis为了<u>节约内存</u>而开发的，是由一系列特殊编码的<u>连续内存块组成</u>的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。\n\n压缩列表的各个组成部分如下图：\n\n![压缩表各部分组成](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩表各部分组成.png)\n\n下表中记录了各个组成部分的类型、长度以及用途。\n\n![压缩表各组成部分的类型,长度以及用途](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩表各组成部分的类型,长度以及用途.png)\n\n示例：包含三个节点的压缩列表\n\n![包含三个节点的压缩列表](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/包含三个节点的压缩列表.png)\n\n其中：\n\n- `zlbytes`的属性值为0x50,表示压缩列表的总长为80.\n- `zltail`属性的值为0x3c，表示有一个指向压缩列表起始地址的指针p，在指针p加上偏移量60，就可以计算出表尾节点entry3的地址。\n- `zllen`属性值为0x3，表示压缩列表包含三个节点。\n- `zlend`属性值为特殊值，用于标记压缩列表的末端。\n\n\n\n#### 6.2 压缩列表节点的构成\n\n每个压缩列表节点可以保存<u>一个字节数组</u>或者<u>一个整数值</u>。\n\n- **字节数组**可以是以下三中长度的其中一种：\n  - 长度小于等于63（2^6-1）字节的字节数组。\n  - 长度小于等于16383（2^14-1）字节的字节数组。\n  - 长度小于等于4294967295（2^32-1）字节的字节数组。\n- **整数值**可以是以下六种长度的其中一种：\n  - 4位长，介于0~12之间的无符号整数；\n  - 1字节长的有符号整数；\n  - 3字节长的有符号整数；\n  - int16_t类型整数；\n  - int32_t类型整数；\n  - int64_t类型整数。\n\n\n\n`压缩列表结点的组成部分`如下：\n\n![压缩列表结点的组成部分](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/压缩列表结点的组成部分.png)\n\n##### 6.2.1 previous_entry_length\n\n`previous_entry_length属性`以`字节`为单位，记录了压缩列表中前一个节点的长度，`previous_entry_length`属性的长度可以是1字节或者5字节。\n\n- 若前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。\n- 若前一节点的长度大于等于254字节，那么previoud_entry_length属性的长度为5字节，其中第一字节会被设置为0xFE，而后的四个字节则用于保存前一节点的长度。\n\n根据previous_entry_length属性可以计算得到前一个节点的起始地址。通过这一原理，即可实现从表尾向表头遍历。\n\n\n\n##### 6.2.2 encoding\n\n节点的`encoding`属性记录了节点的content属性所保存数据的类型及长度：\n\n**字节数组编码**：一字节、两字节或者五字节，encoding最高位为**00、01、10表示字节数组编码**，除去最高两位后表示数组的长度。\n\n![encoding属性数组编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/encoding属性数组编码.png)\n\n\n\n**整数编码**：一字节，**encoding最高位为11**，除去最高两位后的其他位记录整数值的类型和长度。\n\n![encoding属性整数编码](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/encoding属性整数编码.png)\n\n##### 6.2.3 content\n\n节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由encoding属性决定。\n\n示例1：以下示例展示了一个保存字节数组的节点示例。\n\n![保存字节数组的节点示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/保存字节数组的节点示例.png)\n\n其中：\n\n- encoding的最高两位为00，表示一个字节数组。\n- encoding的后六位001011记录了字节数组的长度为11.\n- content属性保存着节点的值“hello world”\n\n示例2：以下示例展示了一个保存整数值的节点示例。\n\n![保存整数值的节点示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis设计与实现-数据结构/保存整数值的节点示例.png)\n\n其中：\n\n- encoding表示节点保存的是int16_t类型的整数值。\n- content属性保存着节点的值10086.\n\n\n\n#### 6.3 连锁更新\n\n**什么情况下会发生连锁更新？**\n\n比如当前所有结点长度均小于254字节情况下，新添加一个长度大于254字节的节点到压缩列表的表头，此时需对压缩列表执行空间重分配操作，扩展后面的previous_entry_length属性空间。\n\n定义：Redis将这种特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。\n\n连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。\n\n\n\n### 参考资料\n\n1. redis设计与实现（第二版） 黄健宏","slug":"Redis设计与实现-数据结构","published":1,"updated":"2020-09-24T09:28:37.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabng006g45g3g64f5s7g","content":"<h3 id=\"1-简单动态字符串-SDS\"><a href=\"#1-简单动态字符串-SDS\" class=\"headerlink\" title=\"1 简单动态字符串(SDS)\"></a>1 简单动态字符串(SDS)</h3><p>Redis中有两种字符串表示：</p>\n<ul>\n<li><p><strong>①、C字符串</strong>：C字符串只会作为字符串字面量（string literal），用在一些无须对字符串值进行修改的地方，如打印日志。</p>\n</li>\n<li><p><strong>②、简单动态字符串</strong>：简单动态字符串（<code>simple dynamic string, SDS</code>）是redis构建一种字符串的抽象类型，是redis的默认字符串表示。如字符串键值对、缓冲区等都有SDS实现。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<h4 id=\"1-1-SDS的定义\"><a href=\"#1-1-SDS的定义\" class=\"headerlink\" title=\"1.1 SDS的定义\"></a>1.1 SDS的定义</h4><p>sds.h/sdshdr结构表示一个SDS的值，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录bug数组汇总已使用字节的数量.</span></span><br><span class=\"line\">    <span class=\"comment\">// 等于SDS所保存字符串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">// 记录buf数组中未使用字节的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 字节数组，用于保存字符串.</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><em>注：SDS遵循C字符串以<code>空字符（&#39;\\0&#39;）</code>结尾，但这个字节的空间不计算在SDS的<code>len属性</code>中。</em></p>\n<h4 id=\"1-2、SDS字符串相对于C字符串的优点\"><a href=\"#1-2、SDS字符串相对于C字符串的优点\" class=\"headerlink\" title=\"1.2、SDS字符串相对于C字符串的优点\"></a>1.2、SDS字符串相对于C字符串的优点</h4><ul>\n<li><p>常数复杂度获取字符串长度</p>\n<ul>\n<li>C字符串，没有记录自身的长度信息，获取C字符串长度时需进行遍历，其复杂度为O(N)。</li>\n<li>SDS字符串，有len属性，获取长度的复杂度为O(1)。</li>\n</ul>\n</li>\n<li><p>杜绝缓冲区溢出: SDS相对于C字符串，根据其空间分配策略，杜绝了发生缓冲区溢出的可能性。</p>\n</li>\n<li><p>减少修改字符串时带来的内存重新分配次数: SDS通过未使用空间<code>free记录</code>，实现<code>空间预分配</code>和<code>惰性空间释放</code>两种优化策略。</p>\n</li>\n<li><p>二进制安全</p>\n</li>\n<li><p>兼容部分C字符串函数</p>\n</li>\n</ul>\n<h5 id=\"1-2-1-空间预分配\"><a href=\"#1-2-1-空间预分配\" class=\"headerlink\" title=\"1.2.1 空间预分配\"></a>1.2.1 空间预分配</h5><p>空间预分配用于优化SDS的字符串<code>增长操作</code>，当SDS的API对SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。</p>\n<p>分配策略：</p>\n<ul>\n<li>若对SDS修改过后，len属性的值小于1MB，则分配与len属性同样大小的未使用空间，即此时len和free属性大小一致。</li>\n<li>若对SDS修改过后，len属性的值大于1MB，则分配1MB的未使用空间。</li>\n</ul>\n<h5 id=\"1-2-2-惰性空间释放\"><a href=\"#1-2-2-惰性空间释放\" class=\"headerlink\" title=\"1.2.2 惰性空间释放\"></a>1.2.2 惰性空间释放</h5><p>惰性空间释放用于优化SDS的字符串<code>缩短操作</code>，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等待将来使用。</p>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2 链表\"></a>2 链表</h3><p>链表作为一种常用的数据结构，在Redis中应用广泛，如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。此外，还有打不与订阅、慢查询、监视器等功能也用到了链表。</p>\n<p><em>注：Redis的链表为<u>双向链表</u>。</em></p>\n<h4 id=\"2-1-链表和链表节点的实现\"><a href=\"#2-1-链表和链表节点的实现\" class=\"headerlink\" title=\"2.1 链表和链表节点的实现\"></a>2.1 链表和链表节点的实现</h4><p>链表节点，使用一个<code>adlist.h/listNode结构</code>来表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n\n<p>多个listNode可以通过prev和next指针组成<strong>双向链表</strong>，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\" alt=\"双向链表\"></p>\n<p>链表，使用<code>adlist.h/list结构</code>表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\">    <span class=\"comment\">// 表尾结点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\">    <span class=\"comment\">// 节点值赋值函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 节点值比对函数，比对链表节点梭堡村的值和另一个输入值是否相等</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为一个list结构和三个listNode结构组成的链表。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/list%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%89%E4%B8%AAlistNode%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90%E7%9A%84%E9%93%BE%E8%A1%A8.png\" alt=\"list结构和三个listNode结构组成的链表\"></p>\n<h3 id=\"3-字典\"><a href=\"#3-字典\" class=\"headerlink\" title=\"3 字典\"></a>3 字典</h3><p>字典，又称为符号表（symbol table）、关联数组（assiciative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典中每个键都是独一无二的。</p>\n<p>字典的应用：字典在Redis的应用广泛，如Redis的数据库就是使用字典来作为底层实现的。此外字典还是哈希键的底层实现之一。</p>\n<h4 id=\"3-1-字典的实现\"><a href=\"#3-1-字典的实现\" class=\"headerlink\" title=\"3.1 字典的实现\"></a>3.1 字典的实现</h4><p><u>Redis的字典使用<code>哈希表</code>作为底层实现</u>，<u>一个哈希表里面可以有多个哈希表结点</u>，<u>而每个哈希表结点就保存了一个字段中的键值对</u>。</p>\n<h5 id=\"3-1-1-哈希表\"><a href=\"#3-1-1-哈希表\" class=\"headerlink\" title=\"3.1.1 哈希表\"></a>3.1.1 哈希表</h5><p>Redis字典所使用的哈希表由<code>dict.h/dictht结构</code>定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个结构保存着一个键值对。</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小掩码，用于计算索引值.</span></span><br><span class=\"line\">    <span class=\"comment\">// 总是等于size-1.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"comment\">// 该哈希表已有结点的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为一个大小为4的空哈希表。（没有任何键值对）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E5%B0%8F%E4%B8%BA4%E7%9A%84%E7%A9%BA%E5%93%88%E5%B8%8C%E8%A1%A8.png\" alt=\"大小为4的空哈希表\"></p>\n<h5 id=\"3-1-2-哈希表结点\"><a href=\"#3-1-2-哈希表结点\" class=\"headerlink\" title=\"3.1.2 哈希表结点\"></a>3.1.2 哈希表结点</h5><p>哈希表结点使用<code>dictEntry结构</code>表示，每个dictEntry结构都保存着一个键值对：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"comment\">// 指向下一个哈希表结点,形成链表,用以解决哈希冲突的问题.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图是通过<code>next指针</code>,将两个指引着相同的键<code>k1</code>和<code>k0</code>连接的数据结构.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%9A%E8%BF%87next%E6%8C%87%E9%92%88,%E5%B0%86%E4%B8%A4%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%80%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E9%94%AEk1%E5%92%8Ck0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png\" alt=\"通过next指针,将两个索引值相同的键k1和k0连接的数据结构\"></p>\n<h5 id=\"3-1-3-字典\"><a href=\"#3-1-3-字典\" class=\"headerlink\" title=\"3.1.3 字典\"></a>3.1.3 字典</h5><p>Redis中的字典由<code>dict.h/dict结构</code>表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型特定函数.Redis会为用途不同的字典设置不同的类型特定函数。</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"comment\">// 私有数据.保存了需要传给那些类型特定函数的可选参数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表.包含了两个项的数组，每个项都是dictht哈希表，通常，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用。</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">// rehash索引.记录rehash的进度，若当前没有进行rehash，那么它的值为-1.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>type</code>和<code>privdata</code>属性是<u>针对不同类型的键值对,为创建多态字典而设置</u>。</p>\n<p>type特定函数结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictType</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 计算哈希值的函数。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">int</span> <span class=\"params\">(*hashFunction)</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 复制键的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*keyDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制值的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*valDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">    <span class=\"comment\">// 对比键的函数.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keyCompare)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁键的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*keyDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁值的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*valDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为普通状态的下的字典示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%99%AE%E9%80%9A%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AD%97%E5%85%B8%E7%A4%BA%E4%BE%8B.png\" alt=\"普通状态下的字典示例\"></p>\n<h4 id=\"3-2-哈希算法\"><a href=\"#3-2-哈希算法\" class=\"headerlink\" title=\"3.2 哈希算法\"></a>3.2 哈希算法</h4><p>要将一个新的键值对添加到字典中时，程序需先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表结点放到哈希表数组的指定索引上面。</p>\n<p><strong>Redis计算哈希值方式？</strong></p>\n<p>使用字典设置的哈希函数，计算键key的哈希值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Redis计算索引值的方式？</strong></p>\n<p>根据哈希表的<code>sizemask属性</code>和哈希值计算出索引值，其中根据情况不同，ht[x]可以使ht[0]或ht[1]。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index &#x3D; hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n\n<p>注：当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</p>\n<h4 id=\"3-3-解决键冲突\"><a href=\"#3-3-解决键冲突\" class=\"headerlink\" title=\"3.3 解决键冲突\"></a>3.3 解决键冲突</h4><p>当有两个或者以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了<code>冲突（collision）</code>。</p>\n<p><strong>Redis怎样解决键冲突？</strong></p>\n<p>Redis的哈希表使用<code>链地址法</code>来解决键冲突。</p>\n<p>每个哈希表结点都有一个<code>next指针</code>，多个哈希表结点可以用next指针构成一个<u>单向链表</u>，被分配到同一个索引上的多个结点可以用这个单向链表连接起来，解决键冲突的问题。</p>\n<p><em>注：由于dictEntry结点组成的链表没有指向链表表尾的指针，所以程序总是将新节点添加到链表的表头位置（复杂度为O(1)）</em></p>\n<p>示例：k2与k1发生了键冲突，k2后添加，如下图所示。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/k2%E4%B8%8Ek1%E5%8F%91%E7%94%9F%E4%BA%86%E9%94%AE%E5%86%B2%E7%AA%81,k2%E5%90%8E%E6%B7%BB%E5%8A%A0.png\" alt=\"k2与k1发生了键冲突,k2后添加\"></p>\n<h4 id=\"3-4-rehash\"><a href=\"#3-4-rehash\" class=\"headerlink\" title=\"3.4 rehash\"></a>3.4 rehash</h4><p>随着操作的不断执行，哈希表保存的键值对会逐渐增减，为了让哈希表的负载因子维持在一个合理的范围内，需对哈希表的大小进行相应的扩展或收缩。这个过程就是rehash。</p>\n<p><strong>Redis是怎样对字典的哈希表执行rehash的（rehash的步骤）？</strong></p>\n<ul>\n<li>①、为字典的<code>h[1]</code>哈希表分配空间。<ul>\n<li>扩展操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used*2的2^n</code>(2的n次方幂)；</li>\n<li>收缩操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used的2^n</code>。</li>\n</ul>\n</li>\n<li>②、将保存在<code>ht[0]</code>中的所有键值对rehash到<code>ht[1]</code>上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li>\n<li>③、当<code>ht[0]</code>包含的所有键值对都前移到了<code>ht[1]</code>后，释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新创建一个空白哈希表，为下一次rehash做准备。</li>\n</ul>\n<p>示例：假设ht[0].used当前的值为4，要对进行扩展操作，则ht[1]的大小为4*2=8，刚好为2^3，所以ht[1]哈希表的大小设置为8.</p>\n<p><strong>哈希表的扩展与收缩都与负载因子有关，那么什么是负载因子呢？怎样计算负载因子？</strong></p>\n<p>Redis的负载因子为哈希表以保存结点的数量与哈希表的大小的比值，计算方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">load_factor &#x3D; ht[0].used &#x2F; ht[0].size</span><br></pre></td></tr></table></figure>\n\n<p>示例：对于一个大小为512，包含256个键值对的哈希表说，这个哈希表的负载因子为：</p>\n<p>load_factor = 256 / 512 = 0.5</p>\n<p><strong>什么情况下程序会自动对哈希表执行扩展操作？</strong></p>\n<ul>\n<li>①、服务器没有在执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子<u>大于等于1</u>.</li>\n<li>②、服务器正在执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子<u>大于等于5</u>.</li>\n</ul>\n<p><em>注：在执行BGSAVE或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入，最大限度地节约内存。</em></p>\n<p><strong>什么情况下程序会对哈希表执行收缩操作？</strong></p>\n<p>当哈希表的负载因子<u>小于0.1</u>时，程序自动开始对哈希表执行收缩操作。</p>\n<h4 id=\"3-5-渐进式rehash\"><a href=\"#3-5-渐进式rehash\" class=\"headerlink\" title=\"3.5 渐进式rehash\"></a>3.5 渐进式rehash</h4><p>扩展或收缩哈希表需要将<code>ht[0]</code>里面的键值对rehash到<code>ht[1]</code>里面，但是这个rehash动作并不是一次性、集中式完成的，而是分多次、<u>渐进式</u>地完成的。</p>\n<p><strong>为什么要渐进式完成rehash？</strong></p>\n<p>为了<u>避免大量键值对rehash对服务器性能造成影响</u>。采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</p>\n<p><strong>哈希表是怎样渐进式rehash的（rehash的详细步骤）？</strong></p>\n<ul>\n<li>①、为<code>ht[1]</code>分配空间，让字典同时持有ht[0]和ht[1]两个哈希表、</li>\n<li>②、在字典中维持一个<code>rehashidx</code>，并将它的值设置为0，表示rehash工作正式开始。</li>\n<li>③、在rehash进行期间，每次对字段执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增加一。</li>\n<li>④、随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]上，这是程序将rehashidx属性设为-1，表示rehash操作已完成。</li>\n</ul>\n<p><strong>渐进式rehash执行期间会涉及到ht[0]和ht[1]两个哈希表，是怎样操作的呢？</strong></p>\n<ul>\n<li>针对删除、查找、更新操作，会在两个哈希表上进行，例如，查找一个键时，程序会在ht[0]上查找，若没有找到，会继续到ht[1]里面进行查找。</li>\n<li>对于新增操作，新增加到字典的键值对一律被保存到ht[1]里面，而ht[0]则不再进行任何操作。</li>\n</ul>\n<h3 id=\"4-跳跃表\"><a href=\"#4-跳跃表\" class=\"headerlink\" title=\"4 跳跃表\"></a>4 跳跃表</h3><p>跳跃表是一种<code>有序数据结构</code>，它<u>通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</u>。</p>\n<p>Redis使用跳跃表作为<code>有序集合键</code>的底层实现之一，若一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，跳跃表还在集群节点中用作内部数据结构。</p>\n<h4 id=\"4-1-跳跃表结点的实现\"><a href=\"#4-1-跳跃表结点的实现\" class=\"headerlink\" title=\"4.1 跳跃表结点的实现\"></a>4.1 跳跃表结点的实现</h4><p>Redis跳跃表由<code>redis.h/zskiplistNode和redis.h/zskiplist</code>两个结构定义。</p>\n<p>跳跃表示例如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%A4%BA%E4%BE%8B.png\" alt=\"跳跃表示例\"></p>\n<p><code>zskiplistNode结构</code>用于表示跳跃表的结点。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员对象.示例图中o1，o2，o3是结点所保存的成员对象。</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\">    <span class=\"comment\">// 分值. 跳跃表中，结点按照各自所保存的分值从小到大排列。</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">    <span class=\"comment\">// 后退指针.指向当前的结点的前一个结点，后退指针在程序从表尾想表头遍历时使用。示例图上用BW标识结点的后退指针。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 层.每个层都有两个属性：前进指针和跨度。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// 前进指针.前进指针用于访问表尾方向的其他节点。示例图上的带有数字的剪头就表示前进指针。</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplostNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\">        <span class=\"comment\">// 跨度.跨度记录了前进指针所指向结点和当前结点的距离。示例图上箭头上的数字就表示跨度。</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-1-1-层\"><a href=\"#4-1-1-层\" class=\"headerlink\" title=\"4.1.1 层\"></a>4.1.1 层</h5><p>跳跃表节点的<code>level数组</code>可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。一般来说，层的数量越多，访问其他节点的速度就越快。</p>\n<p>每次创建一个新跳跃表节点的时候，程序都根据<u>幂次定律</u>(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。</p>\n<p>示例：下图为三个高度分别为1层、3层、5层的节点。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E5%BA%A6%E5%88%86%E5%88%AB%E4%B8%BA1%E5%B1%82,3%E5%B1%82,5%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9.png\" alt=\"高度分别为1层,3层,5层的节点\"></p>\n<h5 id=\"4-1-2-前进指针\"><a href=\"#4-1-2-前进指针\" class=\"headerlink\" title=\"4.1.2 前进指针\"></a>4.1.2 前进指针</h5><p>每个层都有一个指向表尾党项的<code>前进指针</code>（<code>level[i].forward</code>属性），用于从表头向表尾方向访问节点。</p>\n<p><strong>跳跃表是怎样遍历所有节点的呢？</strong></p>\n<p>示例图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86.png\" alt=\"跳跃表遍历\"></p>\n<ul>\n<li>①、迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中第二个节点。</li>\n<li>②、在第二个结点时，程序沿着第二层的前进指针移动到表中第三个节点。</li>\n<li>③、在第三个节点时，程序沿着第二层的前进指针移动到表中的第四个结点。</li>\n<li>④、当程序在此沿着第四个节点的前进指针移动时，它碰到了一个NULL，程序知道这时已经到达了跳跃表的表尾，结束遍历。</li>\n</ul>\n<p><em>注：遍历操作只使用前进指针就能完成。</em></p>\n<h5 id=\"4-1-3-跨度\"><a href=\"#4-1-3-跨度\" class=\"headerlink\" title=\"4.1.3 跨度\"></a>4.1.3 跨度</h5><p>层的跨度（<code>level[i].span</code>属性）用于记录两个结点之间的距离，两个结点之间跨度越大，他们相距得就越远；指向<code>null</code>的所有前进指针的跨度都为0，因为他们没有指向任何节点。</p>\n<p><u>跨度实际上是用来计算排位的</u>：在查找某个结点的过程中，将访问过的所有层的跨度累计起来，得到的结果就是目标结点在跳跃表中的排位。</p>\n<h5 id=\"4-1-4-后退指针\"><a href=\"#4-1-4-后退指针\" class=\"headerlink\" title=\"4.1.4 后退指针\"></a>4.1.4 后退指针</h5><p>节点的后退指针(<code>backward</code>属性)用于从<u>表尾向表头</u>方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>\n<h5 id=\"4-1-5-分值和成员\"><a href=\"#4-1-5-分值和成员\" class=\"headerlink\" title=\"4.1.5 分值和成员\"></a>4.1.5 分值和成员</h5><p>节点的分值(<code>score</code>属性)是一个<code>double类型的浮点数</code>，跳跃表中的所有结点都按分值<u>从小到大来排序</u>。</p>\n<p>节点的成员对象(obj属性)是一个指针，他指向一个字符串对象，而字符串对象则保存着一个SDS值。</p>\n<p>注：<strong>同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但多个结点保存的分值却可以是相同的</strong>。分值相同的结点将按照成员对象在字典序中的大小来进行排序，成员对象较小的结点会排在前面（靠近表头的方向）。</p>\n<h4 id=\"4-2-跳跃表的实现\"><a href=\"#4-2-跳跃表的实现\" class=\"headerlink\" title=\"4.2 跳跃表的实现\"></a>4.2 跳跃表的实现</h4><p>仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个<code>zskiplist结构</code>来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或快速地获取跳跃表节点的数量等信息。</p>\n<p><code>zskiplist结构</code>如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// header 指向跳跃表的表头节点。</span></span><br><span class=\"line\">    <span class=\"comment\">// tail 指向跳跃表的表位节点.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录跳跃表的长度，即跳跃表目前包含结点的数量（表头节点不计算在内）</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\">    <span class=\"comment\">// level 记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n\n<p><em>注：level表头节点的层高并不计算在内。</em></p>\n<h3 id=\"五、整数集合\"><a href=\"#五、整数集合\" class=\"headerlink\" title=\"五、整数集合\"></a>五、整数集合</h3><p>整数集合是<code>集合键</code>的底层实现之一，当一个<strong>集合只包含整数值元素，并且这个集合的元素数量不多时</strong>，Redis就会使用整数集合作为集合键得底层实现。</p>\n<p>（<u>注：整数集合是只包含整数值元素的集合。</u>）</p>\n<h4 id=\"5-1-整数集合的实现\"><a href=\"#5-1-整数集合的实现\" class=\"headerlink\" title=\"5.1 整数集合的实现\"></a>5.1 整数集合的实现</h4><p>整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为<code>int16_t</code>、<code>int32_t</code>或者<code>int64_t</code>的整数值，并保证集合中不会出现重复元素。</p>\n<p>每个<code>intset.h/intset结构</code>表示一个整数集合：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 编码方式.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint_32_t</span> encoding;</span><br><span class=\"line\">    <span class=\"comment\">// 集合包含的元素数量.即contents数组的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;</span><br><span class=\"line\">    <span class=\"comment\">// 保存元素的数组.</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>整数集合的底层实现是什么？</strong></p>\n<p>整数集合的底层是通过<u>数组</u>（<code>contents</code>属性）实现的，整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小<u>从小到大</u>有序地排列，并且数组中不包含任何重复项。</p>\n<p>注：</p>\n<p>①、数组元素在底层是有进行从小到大的排序的。</p>\n<p>②、虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存int8_t类型的值，contents数组的真正类型取决于encoding属性的值。</p>\n<p>encoding属性的取值包括以下内容：</p>\n<ul>\n<li><strong>INTSET_ENC_INT16</strong>:表示<code>int16_t</code>类型的数组，数组里面每个项都是一个int16_t类型的整数值（2^15 ~2^(15)-1）。</li>\n<li><strong>INTSET_ENC_INT32</strong>:表示<code>int32_t</code>类型的数组，数组里面每个项都是一个int32_t类型的整数值(2^31 ~2^(31)-1)。</li>\n<li><strong>INTSET_ENC_INT64</strong>:表示<code>int64_t</code>类型的数组，数组里面每个项都是一个int64_t类型的整数值(2^63 ~2^(63)-1)。</li>\n</ul>\n<h4 id=\"5-2-升级\"><a href=\"#5-2-升级\" class=\"headerlink\" title=\"5.2 升级\"></a>5.2 升级</h4><p>当添加新元素到整数集合中时，<u>新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先升级，然后才能将新元素添加到整数集合里面</u>。</p>\n<p><strong>Redis是怎样升级整数集合并添加新元素的呢（升级及添加新元素的步骤）？</strong></p>\n<p>升级整数集合并添加新元素共分为三步进行：</p>\n<ul>\n<li>①、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>\n<li>②、将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在防止元素的过程中，需要继续维持底层数组的有序性质不变。</li>\n<li>③、将新元素添加到底层数组里面。</li>\n</ul>\n<p><em>注：每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中又有的元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。</em></p>\n<p>升级时新元素的摆放位置，要引发升级，那么要么新元素大于所有现有元素，要么小于现有所有元素，因此摆放位置应该在数组的两端。</p>\n<p>为什么要进行升级，而不是直接采用int64_t类型？</p>\n<ul>\n<li>①、提高灵活性。</li>\n<li>②、节约内存。</li>\n</ul>\n<h4 id=\"5-3-降级\"><a href=\"#5-3-降级\" class=\"headerlink\" title=\"5.3 降级\"></a>5.3 降级</h4><p>整数集合<strong>不支持降级操作</strong>，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>\n<h3 id=\"六、压缩列表\"><a href=\"#六、压缩列表\" class=\"headerlink\" title=\"六、压缩列表\"></a>六、压缩列表</h3><p>压缩列表（ziplist）是<code>列表键</code>和<code>哈希键</code>的底层实现之一。</p>\n<p>压缩列表(ziplist)在Redis的应用场景有哪些？</p>\n<ul>\n<li>①、当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</li>\n</ul>\n<ul>\n<li>②、当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</li>\n</ul>\n<h4 id=\"6-1-压缩列表的构成\"><a href=\"#6-1-压缩列表的构成\" class=\"headerlink\" title=\"6.1 压缩列表的构成\"></a>6.1 压缩列表的构成</h4><p>压缩列表是Redis为了<u>节约内存</u>而开发的，是由一系列特殊编码的<u>连续内存块组成</u>的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。</p>\n<p>压缩列表的各个组成部分如下图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E8%A1%A8%E5%90%84%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png\" alt=\"压缩表各部分组成\"></p>\n<p>下表中记录了各个组成部分的类型、长度以及用途。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E8%A1%A8%E5%90%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E7%9A%84%E7%B1%BB%E5%9E%8B,%E9%95%BF%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%94%A8%E9%80%94.png\" alt=\"压缩表各组成部分的类型,长度以及用途\"></p>\n<p>示例：包含三个节点的压缩列表</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8C%85%E5%90%AB%E4%B8%89%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png\" alt=\"包含三个节点的压缩列表\"></p>\n<p>其中：</p>\n<ul>\n<li><code>zlbytes</code>的属性值为0x50,表示压缩列表的总长为80.</li>\n<li><code>zltail</code>属性的值为0x3c，表示有一个指向压缩列表起始地址的指针p，在指针p加上偏移量60，就可以计算出表尾节点entry3的地址。</li>\n<li><code>zllen</code>属性值为0x3，表示压缩列表包含三个节点。</li>\n<li><code>zlend</code>属性值为特殊值，用于标记压缩列表的末端。</li>\n</ul>\n<h4 id=\"6-2-压缩列表节点的构成\"><a href=\"#6-2-压缩列表节点的构成\" class=\"headerlink\" title=\"6.2 压缩列表节点的构成\"></a>6.2 压缩列表节点的构成</h4><p>每个压缩列表节点可以保存<u>一个字节数组</u>或者<u>一个整数值</u>。</p>\n<ul>\n<li><strong>字节数组</strong>可以是以下三中长度的其中一种：<ul>\n<li>长度小于等于63（2^6-1）字节的字节数组。</li>\n<li>长度小于等于16383（2^14-1）字节的字节数组。</li>\n<li>长度小于等于4294967295（2^32-1）字节的字节数组。</li>\n</ul>\n</li>\n<li><strong>整数值</strong>可以是以下六种长度的其中一种：<ul>\n<li>4位长，介于0~12之间的无符号整数；</li>\n<li>1字节长的有符号整数；</li>\n<li>3字节长的有符号整数；</li>\n<li>int16_t类型整数；</li>\n<li>int32_t类型整数；</li>\n<li>int64_t类型整数。</li>\n</ul>\n</li>\n</ul>\n<p><code>压缩列表结点的组成部分</code>如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E7%82%B9%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png\" alt=\"压缩列表结点的组成部分\"></p>\n<h5 id=\"6-2-1-previous-entry-length\"><a href=\"#6-2-1-previous-entry-length\" class=\"headerlink\" title=\"6.2.1 previous_entry_length\"></a>6.2.1 previous_entry_length</h5><p><code>previous_entry_length属性</code>以<code>字节</code>为单位，记录了压缩列表中前一个节点的长度，<code>previous_entry_length</code>属性的长度可以是1字节或者5字节。</p>\n<ul>\n<li>若前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。</li>\n<li>若前一节点的长度大于等于254字节，那么previoud_entry_length属性的长度为5字节，其中第一字节会被设置为0xFE，而后的四个字节则用于保存前一节点的长度。</li>\n</ul>\n<p>根据previous_entry_length属性可以计算得到前一个节点的起始地址。通过这一原理，即可实现从表尾向表头遍历。</p>\n<h5 id=\"6-2-2-encoding\"><a href=\"#6-2-2-encoding\" class=\"headerlink\" title=\"6.2.2 encoding\"></a>6.2.2 encoding</h5><p>节点的<code>encoding</code>属性记录了节点的content属性所保存数据的类型及长度：</p>\n<p><strong>字节数组编码</strong>：一字节、两字节或者五字节，encoding最高位为<strong>00、01、10表示字节数组编码</strong>，除去最高两位后表示数组的长度。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/encoding%E5%B1%9E%E6%80%A7%E6%95%B0%E7%BB%84%E7%BC%96%E7%A0%81.png\" alt=\"encoding属性数组编码\"></p>\n<p><strong>整数编码</strong>：一字节，<strong>encoding最高位为11</strong>，除去最高两位后的其他位记录整数值的类型和长度。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/encoding%E5%B1%9E%E6%80%A7%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81.png\" alt=\"encoding属性整数编码\"></p>\n<h5 id=\"6-2-3-content\"><a href=\"#6-2-3-content\" class=\"headerlink\" title=\"6.2.3 content\"></a>6.2.3 content</h5><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由encoding属性决定。</p>\n<p>示例1：以下示例展示了一个保存字节数组的节点示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BF%9D%E5%AD%98%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%9A%84%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png\" alt=\"保存字节数组的节点示例\"></p>\n<p>其中：</p>\n<ul>\n<li>encoding的最高两位为00，表示一个字节数组。</li>\n<li>encoding的后六位001011记录了字节数组的长度为11.</li>\n<li>content属性保存着节点的值“hello world”</li>\n</ul>\n<p>示例2：以下示例展示了一个保存整数值的节点示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BF%9D%E5%AD%98%E6%95%B4%E6%95%B0%E5%80%BC%E7%9A%84%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png\" alt=\"保存整数值的节点示例\"></p>\n<p>其中：</p>\n<ul>\n<li>encoding表示节点保存的是int16_t类型的整数值。</li>\n<li>content属性保存着节点的值10086.</li>\n</ul>\n<h4 id=\"6-3-连锁更新\"><a href=\"#6-3-连锁更新\" class=\"headerlink\" title=\"6.3 连锁更新\"></a>6.3 连锁更新</h4><p><strong>什么情况下会发生连锁更新？</strong></p>\n<p>比如当前所有结点长度均小于254字节情况下，新添加一个长度大于254字节的节点到压缩列表的表头，此时需对压缩列表执行空间重分配操作，扩展后面的previous_entry_length属性空间。</p>\n<p>定义：Redis将这种特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。</p>\n<p>连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li>redis设计与实现（第二版） 黄健宏</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-简单动态字符串-SDS\"><a href=\"#1-简单动态字符串-SDS\" class=\"headerlink\" title=\"1 简单动态字符串(SDS)\"></a>1 简单动态字符串(SDS)</h3><p>Redis中有两种字符串表示：</p>\n<ul>\n<li><p><strong>①、C字符串</strong>：C字符串只会作为字符串字面量（string literal），用在一些无须对字符串值进行修改的地方，如打印日志。</p>\n</li>\n<li><p><strong>②、简单动态字符串</strong>：简单动态字符串（<code>simple dynamic string, SDS</code>）是redis构建一种字符串的抽象类型，是redis的默认字符串表示。如字符串键值对、缓冲区等都有SDS实现。</p>\n</li>\n</ul>","more":"<h4 id=\"1-1-SDS的定义\"><a href=\"#1-1-SDS的定义\" class=\"headerlink\" title=\"1.1 SDS的定义\"></a>1.1 SDS的定义</h4><p>sds.h/sdshdr结构表示一个SDS的值，如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录bug数组汇总已使用字节的数量.</span></span><br><span class=\"line\">    <span class=\"comment\">// 等于SDS所保存字符串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">// 记录buf数组中未使用字节的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 字节数组，用于保存字符串.</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><em>注：SDS遵循C字符串以<code>空字符（&#39;\\0&#39;）</code>结尾，但这个字节的空间不计算在SDS的<code>len属性</code>中。</em></p>\n<h4 id=\"1-2、SDS字符串相对于C字符串的优点\"><a href=\"#1-2、SDS字符串相对于C字符串的优点\" class=\"headerlink\" title=\"1.2、SDS字符串相对于C字符串的优点\"></a>1.2、SDS字符串相对于C字符串的优点</h4><ul>\n<li><p>常数复杂度获取字符串长度</p>\n<ul>\n<li>C字符串，没有记录自身的长度信息，获取C字符串长度时需进行遍历，其复杂度为O(N)。</li>\n<li>SDS字符串，有len属性，获取长度的复杂度为O(1)。</li>\n</ul>\n</li>\n<li><p>杜绝缓冲区溢出: SDS相对于C字符串，根据其空间分配策略，杜绝了发生缓冲区溢出的可能性。</p>\n</li>\n<li><p>减少修改字符串时带来的内存重新分配次数: SDS通过未使用空间<code>free记录</code>，实现<code>空间预分配</code>和<code>惰性空间释放</code>两种优化策略。</p>\n</li>\n<li><p>二进制安全</p>\n</li>\n<li><p>兼容部分C字符串函数</p>\n</li>\n</ul>\n<h5 id=\"1-2-1-空间预分配\"><a href=\"#1-2-1-空间预分配\" class=\"headerlink\" title=\"1.2.1 空间预分配\"></a>1.2.1 空间预分配</h5><p>空间预分配用于优化SDS的字符串<code>增长操作</code>，当SDS的API对SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。</p>\n<p>分配策略：</p>\n<ul>\n<li>若对SDS修改过后，len属性的值小于1MB，则分配与len属性同样大小的未使用空间，即此时len和free属性大小一致。</li>\n<li>若对SDS修改过后，len属性的值大于1MB，则分配1MB的未使用空间。</li>\n</ul>\n<h5 id=\"1-2-2-惰性空间释放\"><a href=\"#1-2-2-惰性空间释放\" class=\"headerlink\" title=\"1.2.2 惰性空间释放\"></a>1.2.2 惰性空间释放</h5><p>惰性空间释放用于优化SDS的字符串<code>缩短操作</code>，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重新分配来回收缩短后多出来的字节，而是使用free属性将这些字节数量记录起来，并等待将来使用。</p>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2 链表\"></a>2 链表</h3><p>链表作为一种常用的数据结构，在Redis中应用广泛，如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。此外，还有打不与订阅、慢查询、监视器等功能也用到了链表。</p>\n<p><em>注：Redis的链表为<u>双向链表</u>。</em></p>\n<h4 id=\"2-1-链表和链表节点的实现\"><a href=\"#2-1-链表和链表节点的实现\" class=\"headerlink\" title=\"2.1 链表和链表节点的实现\"></a>2.1 链表和链表节点的实现</h4><p>链表节点，使用一个<code>adlist.h/listNode结构</code>来表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n\n<p>多个listNode可以通过prev和next指针组成<strong>双向链表</strong>，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\" alt=\"双向链表\"></p>\n<p>链表，使用<code>adlist.h/list结构</code>表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\">    <span class=\"comment\">// 表尾结点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\">    <span class=\"comment\">// 节点值赋值函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 节点值比对函数，比对链表节点梭堡村的值和另一个输入值是否相等</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为一个list结构和三个listNode结构组成的链表。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/list%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%89%E4%B8%AAlistNode%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90%E7%9A%84%E9%93%BE%E8%A1%A8.png\" alt=\"list结构和三个listNode结构组成的链表\"></p>\n<h3 id=\"3-字典\"><a href=\"#3-字典\" class=\"headerlink\" title=\"3 字典\"></a>3 字典</h3><p>字典，又称为符号表（symbol table）、关联数组（assiciative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典中每个键都是独一无二的。</p>\n<p>字典的应用：字典在Redis的应用广泛，如Redis的数据库就是使用字典来作为底层实现的。此外字典还是哈希键的底层实现之一。</p>\n<h4 id=\"3-1-字典的实现\"><a href=\"#3-1-字典的实现\" class=\"headerlink\" title=\"3.1 字典的实现\"></a>3.1 字典的实现</h4><p><u>Redis的字典使用<code>哈希表</code>作为底层实现</u>，<u>一个哈希表里面可以有多个哈希表结点</u>，<u>而每个哈希表结点就保存了一个字段中的键值对</u>。</p>\n<h5 id=\"3-1-1-哈希表\"><a href=\"#3-1-1-哈希表\" class=\"headerlink\" title=\"3.1.1 哈希表\"></a>3.1.1 哈希表</h5><p>Redis字典所使用的哈希表由<code>dict.h/dictht结构</code>定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个结构保存着一个键值对。</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小掩码，用于计算索引值.</span></span><br><span class=\"line\">    <span class=\"comment\">// 总是等于size-1.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">    <span class=\"comment\">// 该哈希表已有结点的数量.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为一个大小为4的空哈希表。（没有任何键值对）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7%E5%B0%8F%E4%B8%BA4%E7%9A%84%E7%A9%BA%E5%93%88%E5%B8%8C%E8%A1%A8.png\" alt=\"大小为4的空哈希表\"></p>\n<h5 id=\"3-1-2-哈希表结点\"><a href=\"#3-1-2-哈希表结点\" class=\"headerlink\" title=\"3.1.2 哈希表结点\"></a>3.1.2 哈希表结点</h5><p>哈希表结点使用<code>dictEntry结构</code>表示，每个dictEntry结构都保存着一个键值对：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    <span class=\"comment\">// 指向下一个哈希表结点,形成链表,用以解决哈希冲突的问题.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图是通过<code>next指针</code>,将两个指引着相同的键<code>k1</code>和<code>k0</code>连接的数据结构.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%9A%E8%BF%87next%E6%8C%87%E9%92%88,%E5%B0%86%E4%B8%A4%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%80%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E9%94%AEk1%E5%92%8Ck0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png\" alt=\"通过next指针,将两个索引值相同的键k1和k0连接的数据结构\"></p>\n<h5 id=\"3-1-3-字典\"><a href=\"#3-1-3-字典\" class=\"headerlink\" title=\"3.1.3 字典\"></a>3.1.3 字典</h5><p>Redis中的字典由<code>dict.h/dict结构</code>表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 类型特定函数.Redis会为用途不同的字典设置不同的类型特定函数。</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    <span class=\"comment\">// 私有数据.保存了需要传给那些类型特定函数的可选参数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表.包含了两个项的数组，每个项都是dictht哈希表，通常，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]进行rehash时使用。</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">// rehash索引.记录rehash的进度，若当前没有进行rehash，那么它的值为-1.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>type</code>和<code>privdata</code>属性是<u>针对不同类型的键值对,为创建多态字典而设置</u>。</p>\n<p>type特定函数结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictType</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 计算哈希值的函数。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"title\">int</span> <span class=\"params\">(*hashFunction)</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 复制键的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*keyDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 复制值的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*valDup)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">    <span class=\"comment\">// 对比键的函数.</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*keyCompare)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key1, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key2);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁键的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*keyDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁值的函数。</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*valDestructor)(<span class=\"keyword\">void</span> *privdata, <span class=\"keyword\">void</span> *obj);</span><br><span class=\"line\">&#125; dictType;</span><br></pre></td></tr></table></figure>\n\n<p>示例：下图为普通状态的下的字典示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%99%AE%E9%80%9A%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AD%97%E5%85%B8%E7%A4%BA%E4%BE%8B.png\" alt=\"普通状态下的字典示例\"></p>\n<h4 id=\"3-2-哈希算法\"><a href=\"#3-2-哈希算法\" class=\"headerlink\" title=\"3.2 哈希算法\"></a>3.2 哈希算法</h4><p>要将一个新的键值对添加到字典中时，程序需先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表结点放到哈希表数组的指定索引上面。</p>\n<p><strong>Redis计算哈希值方式？</strong></p>\n<p>使用字典设置的哈希函数，计算键key的哈希值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Redis计算索引值的方式？</strong></p>\n<p>根据哈希表的<code>sizemask属性</code>和哈希值计算出索引值，其中根据情况不同，ht[x]可以使ht[0]或ht[1]。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index &#x3D; hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>\n\n<p>注：当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</p>\n<h4 id=\"3-3-解决键冲突\"><a href=\"#3-3-解决键冲突\" class=\"headerlink\" title=\"3.3 解决键冲突\"></a>3.3 解决键冲突</h4><p>当有两个或者以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了<code>冲突（collision）</code>。</p>\n<p><strong>Redis怎样解决键冲突？</strong></p>\n<p>Redis的哈希表使用<code>链地址法</code>来解决键冲突。</p>\n<p>每个哈希表结点都有一个<code>next指针</code>，多个哈希表结点可以用next指针构成一个<u>单向链表</u>，被分配到同一个索引上的多个结点可以用这个单向链表连接起来，解决键冲突的问题。</p>\n<p><em>注：由于dictEntry结点组成的链表没有指向链表表尾的指针，所以程序总是将新节点添加到链表的表头位置（复杂度为O(1)）</em></p>\n<p>示例：k2与k1发生了键冲突，k2后添加，如下图所示。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/k2%E4%B8%8Ek1%E5%8F%91%E7%94%9F%E4%BA%86%E9%94%AE%E5%86%B2%E7%AA%81,k2%E5%90%8E%E6%B7%BB%E5%8A%A0.png\" alt=\"k2与k1发生了键冲突,k2后添加\"></p>\n<h4 id=\"3-4-rehash\"><a href=\"#3-4-rehash\" class=\"headerlink\" title=\"3.4 rehash\"></a>3.4 rehash</h4><p>随着操作的不断执行，哈希表保存的键值对会逐渐增减，为了让哈希表的负载因子维持在一个合理的范围内，需对哈希表的大小进行相应的扩展或收缩。这个过程就是rehash。</p>\n<p><strong>Redis是怎样对字典的哈希表执行rehash的（rehash的步骤）？</strong></p>\n<ul>\n<li>①、为字典的<code>h[1]</code>哈希表分配空间。<ul>\n<li>扩展操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used*2的2^n</code>(2的n次方幂)；</li>\n<li>收缩操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used的2^n</code>。</li>\n</ul>\n</li>\n<li>②、将保存在<code>ht[0]</code>中的所有键值对rehash到<code>ht[1]</code>上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li>\n<li>③、当<code>ht[0]</code>包含的所有键值对都前移到了<code>ht[1]</code>后，释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新创建一个空白哈希表，为下一次rehash做准备。</li>\n</ul>\n<p>示例：假设ht[0].used当前的值为4，要对进行扩展操作，则ht[1]的大小为4*2=8，刚好为2^3，所以ht[1]哈希表的大小设置为8.</p>\n<p><strong>哈希表的扩展与收缩都与负载因子有关，那么什么是负载因子呢？怎样计算负载因子？</strong></p>\n<p>Redis的负载因子为哈希表以保存结点的数量与哈希表的大小的比值，计算方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">load_factor &#x3D; ht[0].used &#x2F; ht[0].size</span><br></pre></td></tr></table></figure>\n\n<p>示例：对于一个大小为512，包含256个键值对的哈希表说，这个哈希表的负载因子为：</p>\n<p>load_factor = 256 / 512 = 0.5</p>\n<p><strong>什么情况下程序会自动对哈希表执行扩展操作？</strong></p>\n<ul>\n<li>①、服务器没有在执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子<u>大于等于1</u>.</li>\n<li>②、服务器正在执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子<u>大于等于5</u>.</li>\n</ul>\n<p><em>注：在执行BGSAVE或者BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而避免在子进程存在期间进行哈希表扩展操作，避免不必要的内存写入，最大限度地节约内存。</em></p>\n<p><strong>什么情况下程序会对哈希表执行收缩操作？</strong></p>\n<p>当哈希表的负载因子<u>小于0.1</u>时，程序自动开始对哈希表执行收缩操作。</p>\n<h4 id=\"3-5-渐进式rehash\"><a href=\"#3-5-渐进式rehash\" class=\"headerlink\" title=\"3.5 渐进式rehash\"></a>3.5 渐进式rehash</h4><p>扩展或收缩哈希表需要将<code>ht[0]</code>里面的键值对rehash到<code>ht[1]</code>里面，但是这个rehash动作并不是一次性、集中式完成的，而是分多次、<u>渐进式</u>地完成的。</p>\n<p><strong>为什么要渐进式完成rehash？</strong></p>\n<p>为了<u>避免大量键值对rehash对服务器性能造成影响</u>。采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</p>\n<p><strong>哈希表是怎样渐进式rehash的（rehash的详细步骤）？</strong></p>\n<ul>\n<li>①、为<code>ht[1]</code>分配空间，让字典同时持有ht[0]和ht[1]两个哈希表、</li>\n<li>②、在字典中维持一个<code>rehashidx</code>，并将它的值设置为0，表示rehash工作正式开始。</li>\n<li>③、在rehash进行期间，每次对字段执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增加一。</li>\n<li>④、随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]上，这是程序将rehashidx属性设为-1，表示rehash操作已完成。</li>\n</ul>\n<p><strong>渐进式rehash执行期间会涉及到ht[0]和ht[1]两个哈希表，是怎样操作的呢？</strong></p>\n<ul>\n<li>针对删除、查找、更新操作，会在两个哈希表上进行，例如，查找一个键时，程序会在ht[0]上查找，若没有找到，会继续到ht[1]里面进行查找。</li>\n<li>对于新增操作，新增加到字典的键值对一律被保存到ht[1]里面，而ht[0]则不再进行任何操作。</li>\n</ul>\n<h3 id=\"4-跳跃表\"><a href=\"#4-跳跃表\" class=\"headerlink\" title=\"4 跳跃表\"></a>4 跳跃表</h3><p>跳跃表是一种<code>有序数据结构</code>，它<u>通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</u>。</p>\n<p>Redis使用跳跃表作为<code>有序集合键</code>的底层实现之一，若一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，跳跃表还在集群节点中用作内部数据结构。</p>\n<h4 id=\"4-1-跳跃表结点的实现\"><a href=\"#4-1-跳跃表结点的实现\" class=\"headerlink\" title=\"4.1 跳跃表结点的实现\"></a>4.1 跳跃表结点的实现</h4><p>Redis跳跃表由<code>redis.h/zskiplistNode和redis.h/zskiplist</code>两个结构定义。</p>\n<p>跳跃表示例如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%A4%BA%E4%BE%8B.png\" alt=\"跳跃表示例\"></p>\n<p><code>zskiplistNode结构</code>用于表示跳跃表的结点。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 成员对象.示例图中o1，o2，o3是结点所保存的成员对象。</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\">    <span class=\"comment\">// 分值. 跳跃表中，结点按照各自所保存的分值从小到大排列。</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">    <span class=\"comment\">// 后退指针.指向当前的结点的前一个结点，后退指针在程序从表尾想表头遍历时使用。示例图上用BW标识结点的后退指针。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 层.每个层都有两个属性：前进指针和跨度。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// 前进指针.前进指针用于访问表尾方向的其他节点。示例图上的带有数字的剪头就表示前进指针。</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplostNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\">        <span class=\"comment\">// 跨度.跨度记录了前进指针所指向结点和当前结点的距离。示例图上箭头上的数字就表示跨度。</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-1-1-层\"><a href=\"#4-1-1-层\" class=\"headerlink\" title=\"4.1.1 层\"></a>4.1.1 层</h5><p>跳跃表节点的<code>level数组</code>可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。一般来说，层的数量越多，访问其他节点的速度就越快。</p>\n<p>每次创建一个新跳跃表节点的时候，程序都根据<u>幂次定律</u>(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。</p>\n<p>示例：下图为三个高度分别为1层、3层、5层的节点。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E5%BA%A6%E5%88%86%E5%88%AB%E4%B8%BA1%E5%B1%82,3%E5%B1%82,5%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9.png\" alt=\"高度分别为1层,3层,5层的节点\"></p>\n<h5 id=\"4-1-2-前进指针\"><a href=\"#4-1-2-前进指针\" class=\"headerlink\" title=\"4.1.2 前进指针\"></a>4.1.2 前进指针</h5><p>每个层都有一个指向表尾党项的<code>前进指针</code>（<code>level[i].forward</code>属性），用于从表头向表尾方向访问节点。</p>\n<p><strong>跳跃表是怎样遍历所有节点的呢？</strong></p>\n<p>示例图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86.png\" alt=\"跳跃表遍历\"></p>\n<ul>\n<li>①、迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中第二个节点。</li>\n<li>②、在第二个结点时，程序沿着第二层的前进指针移动到表中第三个节点。</li>\n<li>③、在第三个节点时，程序沿着第二层的前进指针移动到表中的第四个结点。</li>\n<li>④、当程序在此沿着第四个节点的前进指针移动时，它碰到了一个NULL，程序知道这时已经到达了跳跃表的表尾，结束遍历。</li>\n</ul>\n<p><em>注：遍历操作只使用前进指针就能完成。</em></p>\n<h5 id=\"4-1-3-跨度\"><a href=\"#4-1-3-跨度\" class=\"headerlink\" title=\"4.1.3 跨度\"></a>4.1.3 跨度</h5><p>层的跨度（<code>level[i].span</code>属性）用于记录两个结点之间的距离，两个结点之间跨度越大，他们相距得就越远；指向<code>null</code>的所有前进指针的跨度都为0，因为他们没有指向任何节点。</p>\n<p><u>跨度实际上是用来计算排位的</u>：在查找某个结点的过程中，将访问过的所有层的跨度累计起来，得到的结果就是目标结点在跳跃表中的排位。</p>\n<h5 id=\"4-1-4-后退指针\"><a href=\"#4-1-4-后退指针\" class=\"headerlink\" title=\"4.1.4 后退指针\"></a>4.1.4 后退指针</h5><p>节点的后退指针(<code>backward</code>属性)用于从<u>表尾向表头</u>方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>\n<h5 id=\"4-1-5-分值和成员\"><a href=\"#4-1-5-分值和成员\" class=\"headerlink\" title=\"4.1.5 分值和成员\"></a>4.1.5 分值和成员</h5><p>节点的分值(<code>score</code>属性)是一个<code>double类型的浮点数</code>，跳跃表中的所有结点都按分值<u>从小到大来排序</u>。</p>\n<p>节点的成员对象(obj属性)是一个指针，他指向一个字符串对象，而字符串对象则保存着一个SDS值。</p>\n<p>注：<strong>同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但多个结点保存的分值却可以是相同的</strong>。分值相同的结点将按照成员对象在字典序中的大小来进行排序，成员对象较小的结点会排在前面（靠近表头的方向）。</p>\n<h4 id=\"4-2-跳跃表的实现\"><a href=\"#4-2-跳跃表的实现\" class=\"headerlink\" title=\"4.2 跳跃表的实现\"></a>4.2 跳跃表的实现</h4><p>仅靠多个跳跃表节点就可以组成一个跳跃表，但通过一个<code>zskiplist结构</code>来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或快速地获取跳跃表节点的数量等信息。</p>\n<p><code>zskiplist结构</code>如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// header 指向跳跃表的表头节点。</span></span><br><span class=\"line\">    <span class=\"comment\">// tail 指向跳跃表的表位节点.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录跳跃表的长度，即跳跃表目前包含结点的数量（表头节点不计算在内）</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\">    <span class=\"comment\">// level 记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n\n<p><em>注：level表头节点的层高并不计算在内。</em></p>\n<h3 id=\"五、整数集合\"><a href=\"#五、整数集合\" class=\"headerlink\" title=\"五、整数集合\"></a>五、整数集合</h3><p>整数集合是<code>集合键</code>的底层实现之一，当一个<strong>集合只包含整数值元素，并且这个集合的元素数量不多时</strong>，Redis就会使用整数集合作为集合键得底层实现。</p>\n<p>（<u>注：整数集合是只包含整数值元素的集合。</u>）</p>\n<h4 id=\"5-1-整数集合的实现\"><a href=\"#5-1-整数集合的实现\" class=\"headerlink\" title=\"5.1 整数集合的实现\"></a>5.1 整数集合的实现</h4><p>整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为<code>int16_t</code>、<code>int32_t</code>或者<code>int64_t</code>的整数值，并保证集合中不会出现重复元素。</p>\n<p>每个<code>intset.h/intset结构</code>表示一个整数集合：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 编码方式.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint_32_t</span> encoding;</span><br><span class=\"line\">    <span class=\"comment\">// 集合包含的元素数量.即contents数组的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;</span><br><span class=\"line\">    <span class=\"comment\">// 保存元素的数组.</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>整数集合的底层实现是什么？</strong></p>\n<p>整数集合的底层是通过<u>数组</u>（<code>contents</code>属性）实现的，整数集合的每个元素都是contents数组的一个数组项(item)，各个项在数组中按值的大小<u>从小到大</u>有序地排列，并且数组中不包含任何重复项。</p>\n<p>注：</p>\n<p>①、数组元素在底层是有进行从小到大的排序的。</p>\n<p>②、虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存int8_t类型的值，contents数组的真正类型取决于encoding属性的值。</p>\n<p>encoding属性的取值包括以下内容：</p>\n<ul>\n<li><strong>INTSET_ENC_INT16</strong>:表示<code>int16_t</code>类型的数组，数组里面每个项都是一个int16_t类型的整数值（2^15 ~2^(15)-1）。</li>\n<li><strong>INTSET_ENC_INT32</strong>:表示<code>int32_t</code>类型的数组，数组里面每个项都是一个int32_t类型的整数值(2^31 ~2^(31)-1)。</li>\n<li><strong>INTSET_ENC_INT64</strong>:表示<code>int64_t</code>类型的数组，数组里面每个项都是一个int64_t类型的整数值(2^63 ~2^(63)-1)。</li>\n</ul>\n<h4 id=\"5-2-升级\"><a href=\"#5-2-升级\" class=\"headerlink\" title=\"5.2 升级\"></a>5.2 升级</h4><p>当添加新元素到整数集合中时，<u>新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先升级，然后才能将新元素添加到整数集合里面</u>。</p>\n<p><strong>Redis是怎样升级整数集合并添加新元素的呢（升级及添加新元素的步骤）？</strong></p>\n<p>升级整数集合并添加新元素共分为三步进行：</p>\n<ul>\n<li>①、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>\n<li>②、将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在防止元素的过程中，需要继续维持底层数组的有序性质不变。</li>\n<li>③、将新元素添加到底层数组里面。</li>\n</ul>\n<p><em>注：每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中又有的元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。</em></p>\n<p>升级时新元素的摆放位置，要引发升级，那么要么新元素大于所有现有元素，要么小于现有所有元素，因此摆放位置应该在数组的两端。</p>\n<p>为什么要进行升级，而不是直接采用int64_t类型？</p>\n<ul>\n<li>①、提高灵活性。</li>\n<li>②、节约内存。</li>\n</ul>\n<h4 id=\"5-3-降级\"><a href=\"#5-3-降级\" class=\"headerlink\" title=\"5.3 降级\"></a>5.3 降级</h4><p>整数集合<strong>不支持降级操作</strong>，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>\n<h3 id=\"六、压缩列表\"><a href=\"#六、压缩列表\" class=\"headerlink\" title=\"六、压缩列表\"></a>六、压缩列表</h3><p>压缩列表（ziplist）是<code>列表键</code>和<code>哈希键</code>的底层实现之一。</p>\n<p>压缩列表(ziplist)在Redis的应用场景有哪些？</p>\n<ul>\n<li>①、当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</li>\n</ul>\n<ul>\n<li>②、当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</li>\n</ul>\n<h4 id=\"6-1-压缩列表的构成\"><a href=\"#6-1-压缩列表的构成\" class=\"headerlink\" title=\"6.1 压缩列表的构成\"></a>6.1 压缩列表的构成</h4><p>压缩列表是Redis为了<u>节约内存</u>而开发的，是由一系列特殊编码的<u>连续内存块组成</u>的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。</p>\n<p>压缩列表的各个组成部分如下图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E8%A1%A8%E5%90%84%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png\" alt=\"压缩表各部分组成\"></p>\n<p>下表中记录了各个组成部分的类型、长度以及用途。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E8%A1%A8%E5%90%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E7%9A%84%E7%B1%BB%E5%9E%8B,%E9%95%BF%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%94%A8%E9%80%94.png\" alt=\"压缩表各组成部分的类型,长度以及用途\"></p>\n<p>示例：包含三个节点的压缩列表</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8C%85%E5%90%AB%E4%B8%89%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png\" alt=\"包含三个节点的压缩列表\"></p>\n<p>其中：</p>\n<ul>\n<li><code>zlbytes</code>的属性值为0x50,表示压缩列表的总长为80.</li>\n<li><code>zltail</code>属性的值为0x3c，表示有一个指向压缩列表起始地址的指针p，在指针p加上偏移量60，就可以计算出表尾节点entry3的地址。</li>\n<li><code>zllen</code>属性值为0x3，表示压缩列表包含三个节点。</li>\n<li><code>zlend</code>属性值为特殊值，用于标记压缩列表的末端。</li>\n</ul>\n<h4 id=\"6-2-压缩列表节点的构成\"><a href=\"#6-2-压缩列表节点的构成\" class=\"headerlink\" title=\"6.2 压缩列表节点的构成\"></a>6.2 压缩列表节点的构成</h4><p>每个压缩列表节点可以保存<u>一个字节数组</u>或者<u>一个整数值</u>。</p>\n<ul>\n<li><strong>字节数组</strong>可以是以下三中长度的其中一种：<ul>\n<li>长度小于等于63（2^6-1）字节的字节数组。</li>\n<li>长度小于等于16383（2^14-1）字节的字节数组。</li>\n<li>长度小于等于4294967295（2^32-1）字节的字节数组。</li>\n</ul>\n</li>\n<li><strong>整数值</strong>可以是以下六种长度的其中一种：<ul>\n<li>4位长，介于0~12之间的无符号整数；</li>\n<li>1字节长的有符号整数；</li>\n<li>3字节长的有符号整数；</li>\n<li>int16_t类型整数；</li>\n<li>int32_t类型整数；</li>\n<li>int64_t类型整数。</li>\n</ul>\n</li>\n</ul>\n<p><code>压缩列表结点的组成部分</code>如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E7%82%B9%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png\" alt=\"压缩列表结点的组成部分\"></p>\n<h5 id=\"6-2-1-previous-entry-length\"><a href=\"#6-2-1-previous-entry-length\" class=\"headerlink\" title=\"6.2.1 previous_entry_length\"></a>6.2.1 previous_entry_length</h5><p><code>previous_entry_length属性</code>以<code>字节</code>为单位，记录了压缩列表中前一个节点的长度，<code>previous_entry_length</code>属性的长度可以是1字节或者5字节。</p>\n<ul>\n<li>若前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。</li>\n<li>若前一节点的长度大于等于254字节，那么previoud_entry_length属性的长度为5字节，其中第一字节会被设置为0xFE，而后的四个字节则用于保存前一节点的长度。</li>\n</ul>\n<p>根据previous_entry_length属性可以计算得到前一个节点的起始地址。通过这一原理，即可实现从表尾向表头遍历。</p>\n<h5 id=\"6-2-2-encoding\"><a href=\"#6-2-2-encoding\" class=\"headerlink\" title=\"6.2.2 encoding\"></a>6.2.2 encoding</h5><p>节点的<code>encoding</code>属性记录了节点的content属性所保存数据的类型及长度：</p>\n<p><strong>字节数组编码</strong>：一字节、两字节或者五字节，encoding最高位为<strong>00、01、10表示字节数组编码</strong>，除去最高两位后表示数组的长度。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/encoding%E5%B1%9E%E6%80%A7%E6%95%B0%E7%BB%84%E7%BC%96%E7%A0%81.png\" alt=\"encoding属性数组编码\"></p>\n<p><strong>整数编码</strong>：一字节，<strong>encoding最高位为11</strong>，除去最高两位后的其他位记录整数值的类型和长度。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/encoding%E5%B1%9E%E6%80%A7%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81.png\" alt=\"encoding属性整数编码\"></p>\n<h5 id=\"6-2-3-content\"><a href=\"#6-2-3-content\" class=\"headerlink\" title=\"6.2.3 content\"></a>6.2.3 content</h5><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由encoding属性决定。</p>\n<p>示例1：以下示例展示了一个保存字节数组的节点示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BF%9D%E5%AD%98%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%9A%84%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png\" alt=\"保存字节数组的节点示例\"></p>\n<p>其中：</p>\n<ul>\n<li>encoding的最高两位为00，表示一个字节数组。</li>\n<li>encoding的后六位001011记录了字节数组的长度为11.</li>\n<li>content属性保存着节点的值“hello world”</li>\n</ul>\n<p>示例2：以下示例展示了一个保存整数值的节点示例。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BF%9D%E5%AD%98%E6%95%B4%E6%95%B0%E5%80%BC%E7%9A%84%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png\" alt=\"保存整数值的节点示例\"></p>\n<p>其中：</p>\n<ul>\n<li>encoding表示节点保存的是int16_t类型的整数值。</li>\n<li>content属性保存着节点的值10086.</li>\n</ul>\n<h4 id=\"6-3-连锁更新\"><a href=\"#6-3-连锁更新\" class=\"headerlink\" title=\"6.3 连锁更新\"></a>6.3 连锁更新</h4><p><strong>什么情况下会发生连锁更新？</strong></p>\n<p>比如当前所有结点长度均小于254字节情况下，新添加一个长度大于254字节的节点到压缩列表的表头，此时需对压缩列表执行空间重分配操作，扩展后面的previous_entry_length属性空间。</p>\n<p>定义：Redis将这种特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”。</p>\n<p>连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li>redis设计与实现（第二版） 黄健宏</li>\n</ol>"},{"title":"Ubuntu16.04-搭建Hexo-Blog","date":"2020-08-20T09:19:56.000Z","_content":"\n#### 1 简介\n\nGitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，通过构建过程运行文件，然后发布网站。 Hexo是高效的静态站点生成框架，它基于Node.js. 通过Hexo，可以直接使用Markdown语法来撰写博客。\n\n<!--more-->\n\n#### 2 配置Git\n\n配置方式参考：[Ubuntu16.04 Github配置及使用](https://jovry-lee.github.io/2020/08/18/Ubuntu16-04-Github%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/#more)\n\n#### 3 安装node.js\n\n安装方式参考：[Ubuntu16.04 Node.js安装.note](https://jovry-lee.github.io/2020/08/21/Ubuntu16-04-Nodejs%E5%AE%89%E8%A3%85/)\n\n#### 4 安装Hexo\n\n安装命令：\n\n```bash\n$ npm install -g hexo-cli\n```\n\n检查hexo是否安装成功：\n\n```bash\n$ hexo -v\n```\n\n*得到hexo-cli：4.2.0等一串数据，安装成功。*\n\n#### 5 Hexo创建本地博客\n\n- 初始化本地站点\n\n  本地博客路径在`~/ProjectWork/githubBlog`下,本地博客搭建操作在此路径下进行操作.\n\n  ```bash\n  $ cd ~/ProjectWork\n  $ mkdir githubBlog # 创建本地博客路径\n  $ hexo init # 初始化本地站点\n  ```\n\n*注：hexo init 命令要求该当前文件夹为空文件夹。*\n\n- 安装依赖包\n\n```bash\n$ npm install\n```\n\n- 生成网页\n\n```bash\n$ hexo g\n```\n\n*注：由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。*\n\n- 将网页放在本地服务器\n\n```bash\n$ hexo s\n```\n\n- 测试本地博客\n\n  在浏览器里输入http://localhost:4000/ \n\n- 发布一篇博客\n\n  在本地博客路径下执行以下命令, 此时source/\\_posts下会生成一个“日志名.md”的文件，该文件即是日志文件。\n\n```bash\n$ hexo new \"<日志名>\"\n```\n\n- 生成网页并放到本地服务器\n\n```bash\n$ hexo g \n$ hexo s\n```\n\n#### 6 将本地Hexo博客部署到Github上\n\n##### 6.1 创建代码仓库\n\n- 在Github中创建一个以.github.io结尾的Repository。\n\n- - ①、Repository name:  `Jovry-Lee.github.io`\n  - ②、勾选 Initialize this repository with a README\n  - ③、Create repository\n\n- 简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog.. 保存(Commit changes)。\n\n- 打开网页：`jovry-Lee.github.io` 这里就可以看到 README.md 里的内容了。\n\n\n##### 6.2 配置本地代码仓库\n\n- 获取Github对应的Repository的链接。（git@github.com:Jovry-Lee/Jovry-Lee.github.io.git）\n\n\n- 修改本地站点配置文件。\n\n\n```bash\n$ sudo vim _config.yml # 打开配置文件\n```\n\n- 找到#Deployment，填入以下内容：\n\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/Jovry-Lee/Jovry-Lee.github.io.git\n  branch: master\n```\n\n- 部署\n\n```bash\n$ npm install hexo-deployer-git --save # 安装hexo-deployer-git，该步骤只需要做一次\n$ hexo d\n```\n\n*得到 INFO Deploy done: git 即为部署成功*\n\n此时访问`Jovry-Lee.github.io`即可看到博客页面。\n\n#### 7 使用Next主题\n\n##### 7.1 配置NexT主题\n\n- 获取主题代码\n\n​\t克隆主题代码到本地博客`themes/next`路径下.\t\n\n```bash\n$ git clone https://github.com/next-theme/hexo-theme-next.git themes/next\n```\n\n- 修改博客配置文件\n  - 打开 `~/ProjectWork/githubBlog/_config.yml`\n\n  - 找到 theme:\n\n  - 把 Hexo 默认的 lanscape 修改成 next。 即 theme: next\n\n  - 找到 # Site，添加博客名称，作者名字等。\n\n  - 在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。\n\n  - 找到 # URL, 填入 url。比如 url:https://jovry-lee.github.io/\n\n    \n\n    当前本地配置如下:\n\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n\n...\n\n# Site\ntitle: Jovry's blog\nsubtitle: ''\ndescription: Keeping learning and improving!\nkeywords:\nauthor: Jovry Lee\nlanguage: en\ntimezone: 'Asia/Shanghai'\n\n...\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: https://jovry-Lee.github.io\n```\n\n- 清除旧配置\n\n​\t*注意：修改配置后最好都进行一下清理操作，不然可能不生效。*\n\n```bash\n$ hexo clean\n```\n\n- 重新生成部署\n\n\n```bash\n$ hexo g -d\n```\n\n##### 7.2 NexT主题优化\n\n###### 7.2.1 修改NexT主题Scheme\n\n​\tNexT当前支持4种风格,默认为Muse,在NexT主题配置文件(`themes/next/_config.yml`)中可以修改Scheme,配置如下:\n\n```\n# Schemes\n#scheme: Muse\n#scheme: Mist\n#scheme: Pisces\nscheme: Gemini\n```\n\n###### 7.2.2 添加访问统计\n\n​\t通过配置NexT主题配置文件,修改busuanzi_count.配置如下:\n\n```\n# Show Views / Visitors of the website / page with busuanzi.\n# Get more information on http://ibruce.info/2015/04/04/busuanzi\nbusuanzi_count:\n  enable: true\n  total_visitors: true\n  total_visitors_icon: fa fa-user\n  total_views: true\n  total_views_icon: fa fa-eye\n  post_views: true\n  post_views_icon: far fa-eye\n```\n\n###### 7.2.3 添加头像\n\n​\t添加的头像可以保存到主站目录下,或者主题目录下.\n\n- Site路径: 保存到`~/ProjectWork/Jovry-Lee.github.io/public/uploads`路径下.\n- theme路径下:`~/ProjectWork/Jovry-Lee.github.io/themes/next/source/images`路径下\n\n配置NexT主题配置文件,修改avatar项:\n\n```\n# Sidebar Avatar\navatar:\n  # in theme directory(source/images): /images/avatar.gif\n  # in site  directory(source/uploads): /uploads/avatar.gif\n  # Replace the default image and set the url here.\n  url: /uploads/princess.jpeg\n  # 配置为true时,头像会在一个圈圈中.\n  rounded: true\n  # 配置为true时,鼠标放在头像上,头像有旋转效果.\n  rotated: true\n```\n\n###### 7.2.4 添加About/Tags/Categories等页面\n\n​\t默认情况下,About页面是不存在的,即使将主页展示了About的图标,若不进行页面配置,点击跳转会报404. 配置方式如下:\n\n- 进入博客Bash路径,生成about等页面.\n\n```bash\n$ cd ~/ProjectWork/Jovry-Lee.github.io\n$ hexo new page \"about\" # 生成about页面\n$ hexo new page \"tags\" # 生成tags页面\n$ hexo new page \"categories\" # 生成分类页面\n```\n\n- 配置NexT主题配置文件,修改`munu`项,启用图标, 修改如下:\n\n```\nmenu:\n  home: / || fa fa-home\n  about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  categories: /categories/ || fa fa-th\n  archives: /archives/ || fa fa-archive\n  #schedule: /schedule/ || fa fa-calendar\n  #sitemap: /sitemap.xml || fa fa-sitemap\n  #commonweal: /404/ || fa fa-heartbeat\n```\n\n- ​\t添加about个人介绍,直接在`~/ProjectWork/Jovry-Lee.github.io/source/about/index.md`文件上进行编辑即可.\n\n###### 7.2.5 分类和标签页自动生成categories&tags\n\n- 分类页面配置\n\n​\t在生成的分类页面`~/ProjectWork/Jovry-Lee.github.io/source/categories/index.md`上进行如下修改:\n\n```\n---\ntitle: categories\ndate: 2020-08-21 15:08:25\ntype: \"categories\"\n---\n```\n\n- 标签页面配置\n\n​\t在生成的分类页面`~/ProjectWork/Jovry-Lee.github.io/source/tags/index.md`上进行如下修改:\t\n\n```\n---\ntitle: tags\ndate: 2020-08-19 15:30:01\ntype: tags\n---\n```\n\n###### 7.2.6 去掉目录栏序号\n\n由于本地写文章时，已经对文章标题进行编号，而NexT主题默认是自动添加目录编号，因此，这里选择关闭该功能．\n\n修改NexT主题配置文件`toc`项,将`number`项设置为`false`, 修改如下:\n\n```\n# Table of Contents in the Sidebar\n# Front-matter variable (unsupport wrap expand_all).\ntoc:\n  enable: true\n  # Automatically add list number to toc.\n  number: false\n```\n\n###### 7.2.7 设置侧边栏社交链接\n\n社交连接也是在NexT配置文件中进行修改, 关键字`social`,进行修改,去掉`#`,添加个人链接即可.\n\n###### 7.2.8 设置Post Body字体大小\n\n由于NexT主题中Post Body部分的字体大小默认为1.125em，个人觉得不是很好看，因此自定义修改该字体的大小．\n\n通过查看`<site>/themes/next/source/css/_variables/base.styl`文件中定义了一系列`Font Size`．其中`post-body`默认使用的font-size-large，即1.125em大小．对`<site>/themes/next/source/css/_common/components/post/post-body.styl`进行设置．\n\n```css <site>/themes/next/source/css/_common/components/post/post-body.styl\n.post-body {\n  font-family: $font-family-posts;\n  word-wrap();\n\n  +desktop-large() {\n    // font-size: $font-size-large;\n    font-size: font-size-medium;\n  }\n```\n\n###### 7.2.9 设置代码高亮样式\n\n在[NexT Highlight Theme Preview](https://theme-next.js.org/highlight/#)中找到自己喜欢的格式，然后进行配置．\n\n当前使用默认的Highlight.js插件，选用atelier-seaside-light样式，对NexT主题配置如下：\n\n```tex /themes/next/_config.yml\ncodeblock:\n  # Code Highlight theme\n  # All available themes: https://theme-next.js.org/highlight/\n  theme:\n    light: atelier-seaside-light\n    dark: atelier-seaside-dark\n  ．．．\n```\n\n##### 7.3 基于NexT主题开启评论功能——Gitalk\n\n该评论功能使用Gitalk服务实现。\n\n###### 7.3.1 注册OAuth Application\n\n- 登录GitHub\n- 前往 `https://github.com/settings/profile`\n- 点击左侧下方的 `Developer settings`\n- 点击绿色 `Register a new application`\n- 填写以下内容：\n\n```\nApplication name：gitalk-comment\nHomepage URL：https://jovry-lee.github.io/\nApplication description：Blog comment system\nAuthorization callback URL：https://jovry-lee.github.io/\n```\n\n- 点击 Register application\n\n- 得到：\n\n```\nClient ID：xxx \n\nClient Secret： xxxx\n```\n\n###### 7.3.2 创建存放Gitalk-comments的repository\n\n- 创建 repository。 Repository name 为：`gitalk-comments`\n- 地址：`https://github.com/Jovry-Lee/gitalk-comments`\n- 注意稍后配置中填的是 `gitalk-comments`，<u>不是地址</u>。\n\n###### 7.3.3 添加Gitalk到博客\n\n- 打开本地博客路径下next主题的配置文件\n\n```bash\n$ vim ~/ProjectWork/Jovry-Lee.github.io/themes/next/_config.yml\n```\n\n- 找到gitalk，进行如下修改：\n\n```\n# Gitalk\n# For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk\ngitalk:\n  enable: true\n  github_id: Jovry-Lee # GitHub repo owner\n  repo: gitalk-comments # Repository name to store issues\n  client_id: xxx # GitHub Application Client ID\n  client_secret: xxxx # GitHub Application Client Secret\n  admin_user: Jovry-Lee # GitHub repo owner and collaborators, only these guys can initialize gitHub issues\n  distraction_free_mode: true # Facebook-like distraction free mode\n  # Gitalk's display language depends on user's browser or system environment\n  # If you want everyone visiting your site to see a uniform language, you can set a force language value\n  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW\n  language: en\n```\n\n- 重新部署\n\n```bash\n$ hexo clean \n\n$ hexo g -d\n```\n\n\n\n#### 8 多端使用Hexo博客\n\n首先应该确保某一台电脑搭建好了Hexo博客，然后进行后续操作。\n\n##### 8.1 主端配置\n\n- ①、登录Github，在`username.github.io`仓库上新建hexo分支。\n\n  在博客仓库上新建一个分支，例如“hexo”，切换到该分支，并设置该分支为默认分支（Setting->Branches->Default branch）\n\n- ②、克隆博客仓库到本地\n\n\n*注：不是本地Hexo目录。*\n\n```shell\n$ git clone git@github.com:Jovry-Lee/Jovry-Lee.github.io.git\n```\n\n查看当前分支，确保为新建的hexo分支\n\n```shell\n$ cd Jovry-Lee.github.io/ $ git branch * hexo\n```\n\n`后续操作均是在Jovry-Lee.github.io目录(Jovry-Lee.github.io与githubBlog目录同级)下完成。`\n\n- ③、拷贝本地博客的部署文件（Hexo目录下的全部文件到`username.github.io`文件目录中），然后删除`themes`目录中主题下的`.git`目录（如果存在的话），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后提交。\n\n\n```bash\n# 拷贝Hexo目录内容\n$ sudo cp -r ~/ProjectWork/githubBlog/* ./\n# 删除themes目录下主题的.git目录，我本地用的next主题\n$ sudo rm -r themes/next/.git\n# 提交修改\n$ git add .\n$ git commit -m \"back up hexo files\"\n$ git push\n```\n\n- ④、后续写博客，即在`username.github.io`文件目录中进行了，由于仓库有个`gitignore`文件，里面忽略掉了`node_modules`文件夹，也就是说仓库的`hexo分支`并没有存储该目录，所以需要重新install一下。\n\n\n```bash\n$ npm install\n```\n\n##### 8.2 其他电脑端配置\n\n​\t安装Hexo环境，然后克隆`username.github.io`仓库的hexo分支到本地，此时本地git仓库处于hexo分支；切换到username.github.io目录，安装依赖包。\n\n```bash\n $ git clone git@github.com:Jovry-Lee/Jovry-Lee.github.io.git\n $ cd Jovry-Lee.github.io\n $ npm install\n```\n\n这里，如果npm install出错，如”npm ERR! Unexpected end of JSON input while parsing near”,可尝试：\n\n- 删除package-lock.json文件\n- 清除cache: npm cache clean --force\n- 不要用淘宝镜像：npm set registry https://registry.npmjs.org/\n\n##### 8.3 发布更新博客\n\n更新博客内容后提交到github,执行以下操作进行提交及其部署.\n\n```bash\n$ git add .\n$ git commint -m \"注释\"\n$ git push\n$ hexo d -g\n```\n\n*注：每次操作时，最好先git pull 一下。*\n\n\n\n#### 9 设置图床\n\n为了解决图片的存储问题，使用第三方静态资源库，即图床，获取图片Url，目前可供选择的图床很多，小众一些的容易挂，大厂存储服务又需要花钱，因此，这里使用Github + jsDelivr + PicGo + Imagine打造自己的图床。\n\n##### 9.1 配置Github\n\n- 创建仓库\n\n- - 输入项目名称\n  - 选择权限为公开\n  - 初始化一个READMEmd文件\n  - 创建项目\n\n- 生成一个Token\n\n  - 点击用户头像->选择”Settings“->点击”Developer settings“->点击”Personal access tokens“->点击”Generate new token“\n  - 在“Node”栏键入token的备注\n  - 在“Select scopes”中勾选“repo”\n  - 点击“Generate token”按钮\n\n- 获取Token秘钥：<u>该秘钥只会显示一次，注意自己保存一下，方便后续使用</u>。\n\n##### 9.2 配置PicGo，并使用jsdelivr作为CDN加速\n\n- 下载PicGo\n\n- - [下载地址](https://github.com/Molunerfinn/PicGo)\n  - Linux系统下载`AppImage`文件，更改其权限为可执行，双击即可显示应用图标。\n\n- 右键点击图标选择“打开详细窗口”->点击“图床设置”->选择“GitHub图床”，进行GitHub设置\n\n  - 设定仓库名：Jovry-Lee/cdn\n\n  - 设定分支名：master\n\n  - 设定Token：<Github配置时生成的那个秘钥>\n\n  - 指定存储路径：img/   *(注: 指定存储路径，将会在仓库下创建设置名称的文件夹（eg：img），上传的图片将保存在里面。)*\n\n  - 设定自定义域名： eg：`https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn`  *(注: 自定义域名的作用是，在图片上传后，PicGo会按照自定义域名+上传图片名的方式生成访问链接，放到粘贴板上。因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名。)*\n\n\n##### 9.3 图片压缩工具\n\n通常情况下，图片大小都是超过200KB的，网页加载会比较慢，所以需要对图片进行压缩。\n\n- 在线网站压缩\n\n  [网站地址](https://tinypng.com/)\n\n- Imagine工具压缩\n\n  [下载地址](https://github.com/meowtec/Imagine)\n\n##### 9.4 图片上传/获取\n\n- 上传: 上传区进行图片上传，PicGo工具支持多个图床,需要选择上传的图床,选择`GitHub图床`。\n\n\n- 获取: PicGo应用点击`相册`，选择图床，即可显示该图床下的所有图片。\n\n\n\n\n生成的图片的链接示例：`https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E7%9F%A9%E5%BD%A2@3x.png`\n\n\n\n#### Markdown编辑器安装\n\nGitHub page支持Markdown语法,推荐使用Markdown进行编辑.\n\n##### Typora\n\n[Typora官网](https://typora.io/)\n\n安装方法：\n\n- 命令行安装\n\n```bash\n# or run:\n# sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE\n$ wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\n\n# add Typora's repository\n$ sudo add-apt-repository 'deb https://typora.io/linux ./'\n$ sudo apt-get update\n\n# install typora\n$ sudo apt-get install typora\n```\n\n- 源文件安装\n  - 官网下载二进制文件\n  - 解压到指定目录\n  - 配置环境变量\n\n```bash\n$ wget https://typora.io/linux/Typora-linux-x64.tar.gz\n$ sudo tar zxvf Typora-linux-x64.tar.gz -d /usr/local\n$ sudo vim ~/.bashrc\n```\n\n填入以下信息:\n\n```\n#set typora\nexport TYPORA_HOME=/usr/local/Typora-linux-x64\nexport PAHT=$TYPORA_HOME:$PATH\n```\n\n```bash\n$ source ~/.bashrc\n```\n\n\n\n---\n\n#### 参考资料\n\n[用 Hexo 和 GitHub Pages 搭建博客](https://ryanluoxu.github.io/2017/11/24/用-Hexo-和-GitHub-Pages-搭建博客/)\n\n[Ubuntu 16.04下Github配置](https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/) \n\n[Next使用文档](http://theme-next.iissnan.com/getting-started.html)\n\n[Getting Started](https://theme-next.js.org/docs/getting-started/)\n\n[Hexo中如何给一篇文章加多个tags？](https://www.zhihu.com/question/43517242)\n\n[创建分类页面](https://github.com/iissnan/hexo-theme-next/wiki/创建分类页面)\n\n[hexo之next主题添加分类](https://blog.csdn.net/u011240016/article/details/79422462)\n\n[使用多台电脑写Hexo博客](https://cccshuang.github.io/2018/09/28/使用多台电脑写Hexo博客/)\n\n[在WSL下快速搭建hexo](https://www.vivatakethat.com/2016/07/07/在Windows下快速搭建hexo/)\n\n[Hexo官网](https://hexo.io/zh-cn/)\n\n[Hexo Blog折腾笔记](https://ghamster0.github.io/2019/03/12/Hexo Blog折腾笔记/)\n\n[GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床 ](https://www.cnblogs.com/sitoi/p/11848816.html)\n\n[Hexo 的 Next 主题优化](https://ryanluoxu.github.io/2017/11/26/Hexo-的-Next-主题优化)\n\n[Hexo+Next主题优化](https://zhuanlan.zhihu.com/p/30836436)","source":"_posts/Ubuntu16-04-搭建Hexo-Blog.md","raw":"---\ntitle: Ubuntu16.04-搭建Hexo-Blog\ndate: 2020-08-20 17:19:56\ntags: [\"Ubuntu\",\"Config\",\"Hexo\"]\ncategories: [\"Ubuntu\", \"Config\"]\n---\n\n#### 1 简介\n\nGitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，通过构建过程运行文件，然后发布网站。 Hexo是高效的静态站点生成框架，它基于Node.js. 通过Hexo，可以直接使用Markdown语法来撰写博客。\n\n<!--more-->\n\n#### 2 配置Git\n\n配置方式参考：[Ubuntu16.04 Github配置及使用](https://jovry-lee.github.io/2020/08/18/Ubuntu16-04-Github%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/#more)\n\n#### 3 安装node.js\n\n安装方式参考：[Ubuntu16.04 Node.js安装.note](https://jovry-lee.github.io/2020/08/21/Ubuntu16-04-Nodejs%E5%AE%89%E8%A3%85/)\n\n#### 4 安装Hexo\n\n安装命令：\n\n```bash\n$ npm install -g hexo-cli\n```\n\n检查hexo是否安装成功：\n\n```bash\n$ hexo -v\n```\n\n*得到hexo-cli：4.2.0等一串数据，安装成功。*\n\n#### 5 Hexo创建本地博客\n\n- 初始化本地站点\n\n  本地博客路径在`~/ProjectWork/githubBlog`下,本地博客搭建操作在此路径下进行操作.\n\n  ```bash\n  $ cd ~/ProjectWork\n  $ mkdir githubBlog # 创建本地博客路径\n  $ hexo init # 初始化本地站点\n  ```\n\n*注：hexo init 命令要求该当前文件夹为空文件夹。*\n\n- 安装依赖包\n\n```bash\n$ npm install\n```\n\n- 生成网页\n\n```bash\n$ hexo g\n```\n\n*注：由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。*\n\n- 将网页放在本地服务器\n\n```bash\n$ hexo s\n```\n\n- 测试本地博客\n\n  在浏览器里输入http://localhost:4000/ \n\n- 发布一篇博客\n\n  在本地博客路径下执行以下命令, 此时source/\\_posts下会生成一个“日志名.md”的文件，该文件即是日志文件。\n\n```bash\n$ hexo new \"<日志名>\"\n```\n\n- 生成网页并放到本地服务器\n\n```bash\n$ hexo g \n$ hexo s\n```\n\n#### 6 将本地Hexo博客部署到Github上\n\n##### 6.1 创建代码仓库\n\n- 在Github中创建一个以.github.io结尾的Repository。\n\n- - ①、Repository name:  `Jovry-Lee.github.io`\n  - ②、勾选 Initialize this repository with a README\n  - ③、Create repository\n\n- 简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog.. 保存(Commit changes)。\n\n- 打开网页：`jovry-Lee.github.io` 这里就可以看到 README.md 里的内容了。\n\n\n##### 6.2 配置本地代码仓库\n\n- 获取Github对应的Repository的链接。（git@github.com:Jovry-Lee/Jovry-Lee.github.io.git）\n\n\n- 修改本地站点配置文件。\n\n\n```bash\n$ sudo vim _config.yml # 打开配置文件\n```\n\n- 找到#Deployment，填入以下内容：\n\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/Jovry-Lee/Jovry-Lee.github.io.git\n  branch: master\n```\n\n- 部署\n\n```bash\n$ npm install hexo-deployer-git --save # 安装hexo-deployer-git，该步骤只需要做一次\n$ hexo d\n```\n\n*得到 INFO Deploy done: git 即为部署成功*\n\n此时访问`Jovry-Lee.github.io`即可看到博客页面。\n\n#### 7 使用Next主题\n\n##### 7.1 配置NexT主题\n\n- 获取主题代码\n\n​\t克隆主题代码到本地博客`themes/next`路径下.\t\n\n```bash\n$ git clone https://github.com/next-theme/hexo-theme-next.git themes/next\n```\n\n- 修改博客配置文件\n  - 打开 `~/ProjectWork/githubBlog/_config.yml`\n\n  - 找到 theme:\n\n  - 把 Hexo 默认的 lanscape 修改成 next。 即 theme: next\n\n  - 找到 # Site，添加博客名称，作者名字等。\n\n  - 在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。\n\n  - 找到 # URL, 填入 url。比如 url:https://jovry-lee.github.io/\n\n    \n\n    当前本地配置如下:\n\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n\n...\n\n# Site\ntitle: Jovry's blog\nsubtitle: ''\ndescription: Keeping learning and improving!\nkeywords:\nauthor: Jovry Lee\nlanguage: en\ntimezone: 'Asia/Shanghai'\n\n...\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: https://jovry-Lee.github.io\n```\n\n- 清除旧配置\n\n​\t*注意：修改配置后最好都进行一下清理操作，不然可能不生效。*\n\n```bash\n$ hexo clean\n```\n\n- 重新生成部署\n\n\n```bash\n$ hexo g -d\n```\n\n##### 7.2 NexT主题优化\n\n###### 7.2.1 修改NexT主题Scheme\n\n​\tNexT当前支持4种风格,默认为Muse,在NexT主题配置文件(`themes/next/_config.yml`)中可以修改Scheme,配置如下:\n\n```\n# Schemes\n#scheme: Muse\n#scheme: Mist\n#scheme: Pisces\nscheme: Gemini\n```\n\n###### 7.2.2 添加访问统计\n\n​\t通过配置NexT主题配置文件,修改busuanzi_count.配置如下:\n\n```\n# Show Views / Visitors of the website / page with busuanzi.\n# Get more information on http://ibruce.info/2015/04/04/busuanzi\nbusuanzi_count:\n  enable: true\n  total_visitors: true\n  total_visitors_icon: fa fa-user\n  total_views: true\n  total_views_icon: fa fa-eye\n  post_views: true\n  post_views_icon: far fa-eye\n```\n\n###### 7.2.3 添加头像\n\n​\t添加的头像可以保存到主站目录下,或者主题目录下.\n\n- Site路径: 保存到`~/ProjectWork/Jovry-Lee.github.io/public/uploads`路径下.\n- theme路径下:`~/ProjectWork/Jovry-Lee.github.io/themes/next/source/images`路径下\n\n配置NexT主题配置文件,修改avatar项:\n\n```\n# Sidebar Avatar\navatar:\n  # in theme directory(source/images): /images/avatar.gif\n  # in site  directory(source/uploads): /uploads/avatar.gif\n  # Replace the default image and set the url here.\n  url: /uploads/princess.jpeg\n  # 配置为true时,头像会在一个圈圈中.\n  rounded: true\n  # 配置为true时,鼠标放在头像上,头像有旋转效果.\n  rotated: true\n```\n\n###### 7.2.4 添加About/Tags/Categories等页面\n\n​\t默认情况下,About页面是不存在的,即使将主页展示了About的图标,若不进行页面配置,点击跳转会报404. 配置方式如下:\n\n- 进入博客Bash路径,生成about等页面.\n\n```bash\n$ cd ~/ProjectWork/Jovry-Lee.github.io\n$ hexo new page \"about\" # 生成about页面\n$ hexo new page \"tags\" # 生成tags页面\n$ hexo new page \"categories\" # 生成分类页面\n```\n\n- 配置NexT主题配置文件,修改`munu`项,启用图标, 修改如下:\n\n```\nmenu:\n  home: / || fa fa-home\n  about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  categories: /categories/ || fa fa-th\n  archives: /archives/ || fa fa-archive\n  #schedule: /schedule/ || fa fa-calendar\n  #sitemap: /sitemap.xml || fa fa-sitemap\n  #commonweal: /404/ || fa fa-heartbeat\n```\n\n- ​\t添加about个人介绍,直接在`~/ProjectWork/Jovry-Lee.github.io/source/about/index.md`文件上进行编辑即可.\n\n###### 7.2.5 分类和标签页自动生成categories&tags\n\n- 分类页面配置\n\n​\t在生成的分类页面`~/ProjectWork/Jovry-Lee.github.io/source/categories/index.md`上进行如下修改:\n\n```\n---\ntitle: categories\ndate: 2020-08-21 15:08:25\ntype: \"categories\"\n---\n```\n\n- 标签页面配置\n\n​\t在生成的分类页面`~/ProjectWork/Jovry-Lee.github.io/source/tags/index.md`上进行如下修改:\t\n\n```\n---\ntitle: tags\ndate: 2020-08-19 15:30:01\ntype: tags\n---\n```\n\n###### 7.2.6 去掉目录栏序号\n\n由于本地写文章时，已经对文章标题进行编号，而NexT主题默认是自动添加目录编号，因此，这里选择关闭该功能．\n\n修改NexT主题配置文件`toc`项,将`number`项设置为`false`, 修改如下:\n\n```\n# Table of Contents in the Sidebar\n# Front-matter variable (unsupport wrap expand_all).\ntoc:\n  enable: true\n  # Automatically add list number to toc.\n  number: false\n```\n\n###### 7.2.7 设置侧边栏社交链接\n\n社交连接也是在NexT配置文件中进行修改, 关键字`social`,进行修改,去掉`#`,添加个人链接即可.\n\n###### 7.2.8 设置Post Body字体大小\n\n由于NexT主题中Post Body部分的字体大小默认为1.125em，个人觉得不是很好看，因此自定义修改该字体的大小．\n\n通过查看`<site>/themes/next/source/css/_variables/base.styl`文件中定义了一系列`Font Size`．其中`post-body`默认使用的font-size-large，即1.125em大小．对`<site>/themes/next/source/css/_common/components/post/post-body.styl`进行设置．\n\n```css <site>/themes/next/source/css/_common/components/post/post-body.styl\n.post-body {\n  font-family: $font-family-posts;\n  word-wrap();\n\n  +desktop-large() {\n    // font-size: $font-size-large;\n    font-size: font-size-medium;\n  }\n```\n\n###### 7.2.9 设置代码高亮样式\n\n在[NexT Highlight Theme Preview](https://theme-next.js.org/highlight/#)中找到自己喜欢的格式，然后进行配置．\n\n当前使用默认的Highlight.js插件，选用atelier-seaside-light样式，对NexT主题配置如下：\n\n```tex /themes/next/_config.yml\ncodeblock:\n  # Code Highlight theme\n  # All available themes: https://theme-next.js.org/highlight/\n  theme:\n    light: atelier-seaside-light\n    dark: atelier-seaside-dark\n  ．．．\n```\n\n##### 7.3 基于NexT主题开启评论功能——Gitalk\n\n该评论功能使用Gitalk服务实现。\n\n###### 7.3.1 注册OAuth Application\n\n- 登录GitHub\n- 前往 `https://github.com/settings/profile`\n- 点击左侧下方的 `Developer settings`\n- 点击绿色 `Register a new application`\n- 填写以下内容：\n\n```\nApplication name：gitalk-comment\nHomepage URL：https://jovry-lee.github.io/\nApplication description：Blog comment system\nAuthorization callback URL：https://jovry-lee.github.io/\n```\n\n- 点击 Register application\n\n- 得到：\n\n```\nClient ID：xxx \n\nClient Secret： xxxx\n```\n\n###### 7.3.2 创建存放Gitalk-comments的repository\n\n- 创建 repository。 Repository name 为：`gitalk-comments`\n- 地址：`https://github.com/Jovry-Lee/gitalk-comments`\n- 注意稍后配置中填的是 `gitalk-comments`，<u>不是地址</u>。\n\n###### 7.3.3 添加Gitalk到博客\n\n- 打开本地博客路径下next主题的配置文件\n\n```bash\n$ vim ~/ProjectWork/Jovry-Lee.github.io/themes/next/_config.yml\n```\n\n- 找到gitalk，进行如下修改：\n\n```\n# Gitalk\n# For more information: https://gitalk.github.io, https://github.com/gitalk/gitalk\ngitalk:\n  enable: true\n  github_id: Jovry-Lee # GitHub repo owner\n  repo: gitalk-comments # Repository name to store issues\n  client_id: xxx # GitHub Application Client ID\n  client_secret: xxxx # GitHub Application Client Secret\n  admin_user: Jovry-Lee # GitHub repo owner and collaborators, only these guys can initialize gitHub issues\n  distraction_free_mode: true # Facebook-like distraction free mode\n  # Gitalk's display language depends on user's browser or system environment\n  # If you want everyone visiting your site to see a uniform language, you can set a force language value\n  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW\n  language: en\n```\n\n- 重新部署\n\n```bash\n$ hexo clean \n\n$ hexo g -d\n```\n\n\n\n#### 8 多端使用Hexo博客\n\n首先应该确保某一台电脑搭建好了Hexo博客，然后进行后续操作。\n\n##### 8.1 主端配置\n\n- ①、登录Github，在`username.github.io`仓库上新建hexo分支。\n\n  在博客仓库上新建一个分支，例如“hexo”，切换到该分支，并设置该分支为默认分支（Setting->Branches->Default branch）\n\n- ②、克隆博客仓库到本地\n\n\n*注：不是本地Hexo目录。*\n\n```shell\n$ git clone git@github.com:Jovry-Lee/Jovry-Lee.github.io.git\n```\n\n查看当前分支，确保为新建的hexo分支\n\n```shell\n$ cd Jovry-Lee.github.io/ $ git branch * hexo\n```\n\n`后续操作均是在Jovry-Lee.github.io目录(Jovry-Lee.github.io与githubBlog目录同级)下完成。`\n\n- ③、拷贝本地博客的部署文件（Hexo目录下的全部文件到`username.github.io`文件目录中），然后删除`themes`目录中主题下的`.git`目录（如果存在的话），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后提交。\n\n\n```bash\n# 拷贝Hexo目录内容\n$ sudo cp -r ~/ProjectWork/githubBlog/* ./\n# 删除themes目录下主题的.git目录，我本地用的next主题\n$ sudo rm -r themes/next/.git\n# 提交修改\n$ git add .\n$ git commit -m \"back up hexo files\"\n$ git push\n```\n\n- ④、后续写博客，即在`username.github.io`文件目录中进行了，由于仓库有个`gitignore`文件，里面忽略掉了`node_modules`文件夹，也就是说仓库的`hexo分支`并没有存储该目录，所以需要重新install一下。\n\n\n```bash\n$ npm install\n```\n\n##### 8.2 其他电脑端配置\n\n​\t安装Hexo环境，然后克隆`username.github.io`仓库的hexo分支到本地，此时本地git仓库处于hexo分支；切换到username.github.io目录，安装依赖包。\n\n```bash\n $ git clone git@github.com:Jovry-Lee/Jovry-Lee.github.io.git\n $ cd Jovry-Lee.github.io\n $ npm install\n```\n\n这里，如果npm install出错，如”npm ERR! Unexpected end of JSON input while parsing near”,可尝试：\n\n- 删除package-lock.json文件\n- 清除cache: npm cache clean --force\n- 不要用淘宝镜像：npm set registry https://registry.npmjs.org/\n\n##### 8.3 发布更新博客\n\n更新博客内容后提交到github,执行以下操作进行提交及其部署.\n\n```bash\n$ git add .\n$ git commint -m \"注释\"\n$ git push\n$ hexo d -g\n```\n\n*注：每次操作时，最好先git pull 一下。*\n\n\n\n#### 9 设置图床\n\n为了解决图片的存储问题，使用第三方静态资源库，即图床，获取图片Url，目前可供选择的图床很多，小众一些的容易挂，大厂存储服务又需要花钱，因此，这里使用Github + jsDelivr + PicGo + Imagine打造自己的图床。\n\n##### 9.1 配置Github\n\n- 创建仓库\n\n- - 输入项目名称\n  - 选择权限为公开\n  - 初始化一个READMEmd文件\n  - 创建项目\n\n- 生成一个Token\n\n  - 点击用户头像->选择”Settings“->点击”Developer settings“->点击”Personal access tokens“->点击”Generate new token“\n  - 在“Node”栏键入token的备注\n  - 在“Select scopes”中勾选“repo”\n  - 点击“Generate token”按钮\n\n- 获取Token秘钥：<u>该秘钥只会显示一次，注意自己保存一下，方便后续使用</u>。\n\n##### 9.2 配置PicGo，并使用jsdelivr作为CDN加速\n\n- 下载PicGo\n\n- - [下载地址](https://github.com/Molunerfinn/PicGo)\n  - Linux系统下载`AppImage`文件，更改其权限为可执行，双击即可显示应用图标。\n\n- 右键点击图标选择“打开详细窗口”->点击“图床设置”->选择“GitHub图床”，进行GitHub设置\n\n  - 设定仓库名：Jovry-Lee/cdn\n\n  - 设定分支名：master\n\n  - 设定Token：<Github配置时生成的那个秘钥>\n\n  - 指定存储路径：img/   *(注: 指定存储路径，将会在仓库下创建设置名称的文件夹（eg：img），上传的图片将保存在里面。)*\n\n  - 设定自定义域名： eg：`https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn`  *(注: 自定义域名的作用是，在图片上传后，PicGo会按照自定义域名+上传图片名的方式生成访问链接，放到粘贴板上。因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名。)*\n\n\n##### 9.3 图片压缩工具\n\n通常情况下，图片大小都是超过200KB的，网页加载会比较慢，所以需要对图片进行压缩。\n\n- 在线网站压缩\n\n  [网站地址](https://tinypng.com/)\n\n- Imagine工具压缩\n\n  [下载地址](https://github.com/meowtec/Imagine)\n\n##### 9.4 图片上传/获取\n\n- 上传: 上传区进行图片上传，PicGo工具支持多个图床,需要选择上传的图床,选择`GitHub图床`。\n\n\n- 获取: PicGo应用点击`相册`，选择图床，即可显示该图床下的所有图片。\n\n\n\n\n生成的图片的链接示例：`https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E7%9F%A9%E5%BD%A2@3x.png`\n\n\n\n#### Markdown编辑器安装\n\nGitHub page支持Markdown语法,推荐使用Markdown进行编辑.\n\n##### Typora\n\n[Typora官网](https://typora.io/)\n\n安装方法：\n\n- 命令行安装\n\n```bash\n# or run:\n# sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE\n$ wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\n\n# add Typora's repository\n$ sudo add-apt-repository 'deb https://typora.io/linux ./'\n$ sudo apt-get update\n\n# install typora\n$ sudo apt-get install typora\n```\n\n- 源文件安装\n  - 官网下载二进制文件\n  - 解压到指定目录\n  - 配置环境变量\n\n```bash\n$ wget https://typora.io/linux/Typora-linux-x64.tar.gz\n$ sudo tar zxvf Typora-linux-x64.tar.gz -d /usr/local\n$ sudo vim ~/.bashrc\n```\n\n填入以下信息:\n\n```\n#set typora\nexport TYPORA_HOME=/usr/local/Typora-linux-x64\nexport PAHT=$TYPORA_HOME:$PATH\n```\n\n```bash\n$ source ~/.bashrc\n```\n\n\n\n---\n\n#### 参考资料\n\n[用 Hexo 和 GitHub Pages 搭建博客](https://ryanluoxu.github.io/2017/11/24/用-Hexo-和-GitHub-Pages-搭建博客/)\n\n[Ubuntu 16.04下Github配置](https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/) \n\n[Next使用文档](http://theme-next.iissnan.com/getting-started.html)\n\n[Getting Started](https://theme-next.js.org/docs/getting-started/)\n\n[Hexo中如何给一篇文章加多个tags？](https://www.zhihu.com/question/43517242)\n\n[创建分类页面](https://github.com/iissnan/hexo-theme-next/wiki/创建分类页面)\n\n[hexo之next主题添加分类](https://blog.csdn.net/u011240016/article/details/79422462)\n\n[使用多台电脑写Hexo博客](https://cccshuang.github.io/2018/09/28/使用多台电脑写Hexo博客/)\n\n[在WSL下快速搭建hexo](https://www.vivatakethat.com/2016/07/07/在Windows下快速搭建hexo/)\n\n[Hexo官网](https://hexo.io/zh-cn/)\n\n[Hexo Blog折腾笔记](https://ghamster0.github.io/2019/03/12/Hexo Blog折腾笔记/)\n\n[GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床 ](https://www.cnblogs.com/sitoi/p/11848816.html)\n\n[Hexo 的 Next 主题优化](https://ryanluoxu.github.io/2017/11/26/Hexo-的-Next-主题优化)\n\n[Hexo+Next主题优化](https://zhuanlan.zhihu.com/p/30836436)","slug":"Ubuntu16-04-搭建Hexo-Blog","published":1,"updated":"2020-09-10T07:47:25.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabo4006k45g3cmon9eaz","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，通过构建过程运行文件，然后发布网站。 Hexo是高效的静态站点生成框架，它基于Node.js. 通过Hexo，可以直接使用Markdown语法来撰写博客。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"2-配置Git\"><a href=\"#2-配置Git\" class=\"headerlink\" title=\"2 配置Git\"></a>2 配置Git</h4><p>配置方式参考：<a href=\"https://jovry-lee.github.io/2020/08/18/Ubuntu16-04-Github%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/#more\">Ubuntu16.04 Github配置及使用</a></p>\n<h4 id=\"3-安装node-js\"><a href=\"#3-安装node-js\" class=\"headerlink\" title=\"3 安装node.js\"></a>3 安装node.js</h4><p>安装方式参考：<a href=\"https://jovry-lee.github.io/2020/08/21/Ubuntu16-04-Nodejs%E5%AE%89%E8%A3%85/\">Ubuntu16.04 Node.js安装.note</a></p>\n<h4 id=\"4-安装Hexo\"><a href=\"#4-安装Hexo\" class=\"headerlink\" title=\"4 安装Hexo\"></a>4 安装Hexo</h4><p>安装命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>检查hexo是否安装成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n\n<p><em>得到hexo-cli：4.2.0等一串数据，安装成功。</em></p>\n<h4 id=\"5-Hexo创建本地博客\"><a href=\"#5-Hexo创建本地博客\" class=\"headerlink\" title=\"5 Hexo创建本地博客\"></a>5 Hexo创建本地博客</h4><ul>\n<li><p>初始化本地站点</p>\n<p>本地博客路径在<code>~/ProjectWork/githubBlog</code>下,本地博客搭建操作在此路径下进行操作.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/ProjectWork</span><br><span class=\"line\">$ mkdir githubBlog <span class=\"comment\"># 创建本地博客路径</span></span><br><span class=\"line\">$ hexo init <span class=\"comment\"># 初始化本地站点</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><em>注：hexo init 命令要求该当前文件夹为空文件夹。</em></p>\n<ul>\n<li>安装依赖包</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成网页</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<p><em>注：由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</em></p>\n<ul>\n<li>将网页放在本地服务器</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>测试本地博客</p>\n<p>在浏览器里输入<a href=\"http://localhost:4000/\">http://localhost:4000/</a> </p>\n</li>\n<li><p>发布一篇博客</p>\n<p>在本地博客路径下执行以下命令, 此时source/_posts下会生成一个“日志名.md”的文件，该文件即是日志文件。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;&lt;日志名&gt;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成网页并放到本地服务器</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g </span><br><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-将本地Hexo博客部署到Github上\"><a href=\"#6-将本地Hexo博客部署到Github上\" class=\"headerlink\" title=\"6 将本地Hexo博客部署到Github上\"></a>6 将本地Hexo博客部署到Github上</h4><h5 id=\"6-1-创建代码仓库\"><a href=\"#6-1-创建代码仓库\" class=\"headerlink\" title=\"6.1 创建代码仓库\"></a>6.1 创建代码仓库</h5><ul>\n<li><p>在Github中创建一个以.github.io结尾的Repository。</p>\n</li>\n<li><ul>\n<li>①、Repository name:  <code>Jovry-Lee.github.io</code></li>\n<li>②、勾选 Initialize this repository with a README</li>\n<li>③、Create repository</li>\n</ul>\n</li>\n<li><p>简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog.. 保存(Commit changes)。</p>\n</li>\n<li><p>打开网页：<code>jovry-Lee.github.io</code> 这里就可以看到 README.md 里的内容了。</p>\n</li>\n</ul>\n<h5 id=\"6-2-配置本地代码仓库\"><a href=\"#6-2-配置本地代码仓库\" class=\"headerlink\" title=\"6.2 配置本地代码仓库\"></a>6.2 配置本地代码仓库</h5><ul>\n<li>获取Github对应的Repository的链接。（<a href=\"mailto:&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;\">&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:Jovry-Lee/Jovry-Lee.github.io.git）</li>\n</ul>\n<ul>\n<li>修改本地站点配置文件。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vim _config.yml <span class=\"comment\"># 打开配置文件</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到#Deployment，填入以下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: https:&#x2F;&#x2F;github.com&#x2F;Jovry-Lee&#x2F;Jovry-Lee.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save <span class=\"comment\"># 安装hexo-deployer-git，该步骤只需要做一次</span></span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<p><em>得到 INFO Deploy done: git 即为部署成功</em></p>\n<p>此时访问<code>Jovry-Lee.github.io</code>即可看到博客页面。</p>\n<h4 id=\"7-使用Next主题\"><a href=\"#7-使用Next主题\" class=\"headerlink\" title=\"7 使用Next主题\"></a>7 使用Next主题</h4><h5 id=\"7-1-配置NexT主题\"><a href=\"#7-1-配置NexT主题\" class=\"headerlink\" title=\"7.1 配置NexT主题\"></a>7.1 配置NexT主题</h5><ul>\n<li>获取主题代码</li>\n</ul>\n<p>​    克隆主题代码到本地博客<code>themes/next</code>路径下.    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/next-theme/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>修改博客配置文件</p>\n<ul>\n<li><p>打开 <code>~/ProjectWork/githubBlog/_config.yml</code></p>\n</li>\n<li><p>找到 theme:</p>\n</li>\n<li><p>把 Hexo 默认的 lanscape 修改成 next。 即 theme: next</p>\n</li>\n<li><p>找到 # Site，添加博客名称，作者名字等。</p>\n</li>\n<li><p>在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。</p>\n</li>\n<li><p>找到 # URL, 填入 url。比如 url:<a href=\"https://jovry-lee.github.io/\">https://jovry-lee.github.io/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>当前本地配置如下:</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class=\"line\">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class=\"line\">theme: next</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># Site</span><br><span class=\"line\">title: Jovry&#39;s blog</span><br><span class=\"line\">subtitle: &#39;&#39;</span><br><span class=\"line\">description: Keeping learning and improving!</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: Jovry Lee</span><br><span class=\"line\">language: en</span><br><span class=\"line\">timezone: &#39;Asia&#x2F;Shanghai&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># URL</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class=\"line\">url: https:&#x2F;&#x2F;jovry-Lee.github.io</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>清除旧配置</li>\n</ul>\n<p>​    <em>注意：修改配置后最好都进行一下清理操作，不然可能不生效。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重新生成部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"7-2-NexT主题优化\"><a href=\"#7-2-NexT主题优化\" class=\"headerlink\" title=\"7.2 NexT主题优化\"></a>7.2 NexT主题优化</h5><h6 id=\"7-2-1-修改NexT主题Scheme\"><a href=\"#7-2-1-修改NexT主题Scheme\" class=\"headerlink\" title=\"7.2.1 修改NexT主题Scheme\"></a>7.2.1 修改NexT主题Scheme</h6><p>​    NexT当前支持4种风格,默认为Muse,在NexT主题配置文件(<code>themes/next/_config.yml</code>)中可以修改Scheme,配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">#scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">scheme: Gemini</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-2-添加访问统计\"><a href=\"#7-2-2-添加访问统计\" class=\"headerlink\" title=\"7.2.2 添加访问统计\"></a>7.2.2 添加访问统计</h6><p>​    通过配置NexT主题配置文件,修改busuanzi_count.配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Show Views &#x2F; Visitors of the website &#x2F; page with busuanzi.</span><br><span class=\"line\"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi</span><br><span class=\"line\">busuanzi_count:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  total_visitors: true</span><br><span class=\"line\">  total_visitors_icon: fa fa-user</span><br><span class=\"line\">  total_views: true</span><br><span class=\"line\">  total_views_icon: fa fa-eye</span><br><span class=\"line\">  post_views: true</span><br><span class=\"line\">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-3-添加头像\"><a href=\"#7-2-3-添加头像\" class=\"headerlink\" title=\"7.2.3 添加头像\"></a>7.2.3 添加头像</h6><p>​    添加的头像可以保存到主站目录下,或者主题目录下.</p>\n<ul>\n<li>Site路径: 保存到<code>~/ProjectWork/Jovry-Lee.github.io/public/uploads</code>路径下.</li>\n<li>theme路径下:<code>~/ProjectWork/Jovry-Lee.github.io/themes/next/source/images</code>路径下</li>\n</ul>\n<p>配置NexT主题配置文件,修改avatar项:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Sidebar Avatar</span><br><span class=\"line\">avatar:</span><br><span class=\"line\">  # in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif</span><br><span class=\"line\">  # in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif</span><br><span class=\"line\">  # Replace the default image and set the url here.</span><br><span class=\"line\">  url: &#x2F;uploads&#x2F;princess.jpeg</span><br><span class=\"line\">  # 配置为true时,头像会在一个圈圈中.</span><br><span class=\"line\">  rounded: true</span><br><span class=\"line\">  # 配置为true时,鼠标放在头像上,头像有旋转效果.</span><br><span class=\"line\">  rotated: true</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-4-添加About-Tags-Categories等页面\"><a href=\"#7-2-4-添加About-Tags-Categories等页面\" class=\"headerlink\" title=\"7.2.4 添加About/Tags/Categories等页面\"></a>7.2.4 添加About/Tags/Categories等页面</h6><p>​    默认情况下,About页面是不存在的,即使将主页展示了About的图标,若不进行页面配置,点击跳转会报404. 配置方式如下:</p>\n<ul>\n<li>进入博客Bash路径,生成about等页面.</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/ProjectWork/Jovry-Lee.github.io</span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;about&quot;</span> <span class=\"comment\"># 生成about页面</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;tags&quot;</span> <span class=\"comment\"># 生成tags页面</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;categories&quot;</span> <span class=\"comment\"># 生成分类页面</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置NexT主题配置文件,修改<code>munu</code>项,启用图标, 修改如下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F; || fa fa-home</span><br><span class=\"line\">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class=\"line\">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class=\"line\">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class=\"line\">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class=\"line\">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class=\"line\">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class=\"line\">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>​    添加about个人介绍,直接在<code>~/ProjectWork/Jovry-Lee.github.io/source/about/index.md</code>文件上进行编辑即可.</li>\n</ul>\n<h6 id=\"7-2-5-分类和标签页自动生成categories-amp-tags\"><a href=\"#7-2-5-分类和标签页自动生成categories-amp-tags\" class=\"headerlink\" title=\"7.2.5 分类和标签页自动生成categories&amp;tags\"></a>7.2.5 分类和标签页自动生成categories&amp;tags</h6><ul>\n<li>分类页面配置</li>\n</ul>\n<p>​    在生成的分类页面<code>~/ProjectWork/Jovry-Lee.github.io/source/categories/index.md</code>上进行如下修改:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: categories</span><br><span class=\"line\">date: 2020-08-21 15:08:25</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>标签页面配置</li>\n</ul>\n<p>​    在生成的分类页面<code>~/ProjectWork/Jovry-Lee.github.io/source/tags/index.md</code>上进行如下修改:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2020-08-19 15:30:01</span><br><span class=\"line\">type: tags</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-6-去掉目录栏序号\"><a href=\"#7-2-6-去掉目录栏序号\" class=\"headerlink\" title=\"7.2.6 去掉目录栏序号\"></a>7.2.6 去掉目录栏序号</h6><p>由于本地写文章时，已经对文章标题进行编号，而NexT主题默认是自动添加目录编号，因此，这里选择关闭该功能．</p>\n<p>修改NexT主题配置文件<code>toc</code>项,将<code>number</code>项设置为<code>false</code>, 修改如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Table of Contents in the Sidebar</span><br><span class=\"line\"># Front-matter variable (unsupport wrap expand_all).</span><br><span class=\"line\">toc:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # Automatically add list number to toc.</span><br><span class=\"line\">  number: false</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-7-设置侧边栏社交链接\"><a href=\"#7-2-7-设置侧边栏社交链接\" class=\"headerlink\" title=\"7.2.7 设置侧边栏社交链接\"></a>7.2.7 设置侧边栏社交链接</h6><p>社交连接也是在NexT配置文件中进行修改, 关键字<code>social</code>,进行修改,去掉<code>#</code>,添加个人链接即可.</p>\n<h6 id=\"7-2-8-设置Post-Body字体大小\"><a href=\"#7-2-8-设置Post-Body字体大小\" class=\"headerlink\" title=\"7.2.8 设置Post Body字体大小\"></a>7.2.8 设置Post Body字体大小</h6><p>由于NexT主题中Post Body部分的字体大小默认为1.125em，个人觉得不是很好看，因此自定义修改该字体的大小．</p>\n<p>通过查看<code>&lt;site&gt;/themes/next/source/css/_variables/base.styl</code>文件中定义了一系列<code>Font Size</code>．其中<code>post-body</code>默认使用的font-size-large，即1.125em大小．对<code>&lt;site&gt;/themes/next/source/css/_common/components/post/post-body.styl</code>进行设置．</p>\n<figure class=\"highlight css\"><figcaption><span><site>/themes/next/source/css/_common/components/post/post-body.styl</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.post-body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: $font-family-posts;</span><br><span class=\"line\">  word-wrap();</span><br><span class=\"line\"></span><br><span class=\"line\">  +<span class=\"selector-tag\">desktop-large</span>() &#123;</span><br><span class=\"line\">    // font-size: $font-size-large;</span><br><span class=\"line\">    <span class=\"selector-tag\">font-size</span>: <span class=\"selector-tag\">font-size-medium</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-9-设置代码高亮样式\"><a href=\"#7-2-9-设置代码高亮样式\" class=\"headerlink\" title=\"7.2.9 设置代码高亮样式\"></a>7.2.9 设置代码高亮样式</h6><p>在<a href=\"https://theme-next.js.org/highlight/#\">NexT Highlight Theme Preview</a>中找到自己喜欢的格式，然后进行配置．</p>\n<p>当前使用默认的Highlight.js插件，选用atelier-seaside-light样式，对NexT主题配置如下：</p>\n<figure class=\"highlight tex\"><figcaption><span>/themes/next/_config.yml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codeblock:</span><br><span class=\"line\">  # Code Highlight theme</span><br><span class=\"line\">  # All available themes: https://theme-next.js.org/highlight/</span><br><span class=\"line\">  theme:</span><br><span class=\"line\">    light: atelier-seaside-light</span><br><span class=\"line\">    dark: atelier-seaside-dark</span><br><span class=\"line\">  ．．．</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"7-3-基于NexT主题开启评论功能——Gitalk\"><a href=\"#7-3-基于NexT主题开启评论功能——Gitalk\" class=\"headerlink\" title=\"7.3 基于NexT主题开启评论功能——Gitalk\"></a>7.3 基于NexT主题开启评论功能——Gitalk</h5><p>该评论功能使用Gitalk服务实现。</p>\n<h6 id=\"7-3-1-注册OAuth-Application\"><a href=\"#7-3-1-注册OAuth-Application\" class=\"headerlink\" title=\"7.3.1 注册OAuth Application\"></a>7.3.1 注册OAuth Application</h6><ul>\n<li>登录GitHub</li>\n<li>前往 <code>https://github.com/settings/profile</code></li>\n<li>点击左侧下方的 <code>Developer settings</code></li>\n<li>点击绿色 <code>Register a new application</code></li>\n<li>填写以下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application name：gitalk-comment</span><br><span class=\"line\">Homepage URL：https:&#x2F;&#x2F;jovry-lee.github.io&#x2F;</span><br><span class=\"line\">Application description：Blog comment system</span><br><span class=\"line\">Authorization callback URL：https:&#x2F;&#x2F;jovry-lee.github.io&#x2F;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>点击 Register application</p>\n</li>\n<li><p>得到：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Client ID：xxx </span><br><span class=\"line\"></span><br><span class=\"line\">Client Secret： xxxx</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-3-2-创建存放Gitalk-comments的repository\"><a href=\"#7-3-2-创建存放Gitalk-comments的repository\" class=\"headerlink\" title=\"7.3.2 创建存放Gitalk-comments的repository\"></a>7.3.2 创建存放Gitalk-comments的repository</h6><ul>\n<li>创建 repository。 Repository name 为：<code>gitalk-comments</code></li>\n<li>地址：<code>https://github.com/Jovry-Lee/gitalk-comments</code></li>\n<li>注意稍后配置中填的是 <code>gitalk-comments</code>，<u>不是地址</u>。</li>\n</ul>\n<h6 id=\"7-3-3-添加Gitalk到博客\"><a href=\"#7-3-3-添加Gitalk到博客\" class=\"headerlink\" title=\"7.3.3 添加Gitalk到博客\"></a>7.3.3 添加Gitalk到博客</h6><ul>\n<li>打开本地博客路径下next主题的配置文件</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim ~/ProjectWork/Jovry-Lee.github.io/themes/next/_config.yml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到gitalk，进行如下修改：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Gitalk</span><br><span class=\"line\"># For more information: https:&#x2F;&#x2F;gitalk.github.io, https:&#x2F;&#x2F;github.com&#x2F;gitalk&#x2F;gitalk</span><br><span class=\"line\">gitalk:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  github_id: Jovry-Lee # GitHub repo owner</span><br><span class=\"line\">  repo: gitalk-comments # Repository name to store issues</span><br><span class=\"line\">  client_id: xxx # GitHub Application Client ID</span><br><span class=\"line\">  client_secret: xxxx # GitHub Application Client Secret</span><br><span class=\"line\">  admin_user: Jovry-Lee # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class=\"line\">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class=\"line\">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class=\"line\">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class=\"line\">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class=\"line\">  language: en</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重新部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean </span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"8-多端使用Hexo博客\"><a href=\"#8-多端使用Hexo博客\" class=\"headerlink\" title=\"8 多端使用Hexo博客\"></a>8 多端使用Hexo博客</h4><p>首先应该确保某一台电脑搭建好了Hexo博客，然后进行后续操作。</p>\n<h5 id=\"8-1-主端配置\"><a href=\"#8-1-主端配置\" class=\"headerlink\" title=\"8.1 主端配置\"></a>8.1 主端配置</h5><ul>\n<li><p>①、登录Github，在<code>username.github.io</code>仓库上新建hexo分支。</p>\n<p>在博客仓库上新建一个分支，例如“hexo”，切换到该分支，并设置该分支为默认分支（Setting-&gt;Branches-&gt;Default branch）</p>\n</li>\n<li><p>②、克隆博客仓库到本地</p>\n</li>\n</ul>\n<p><em>注：不是本地Hexo目录。</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git@github.com:Jovry-Lee/Jovry-Lee.github.io.git</span></span><br></pre></td></tr></table></figure>\n\n<p>查看当前分支，确保为新建的hexo分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> Jovry-Lee.github.io/ $ git branch * hexo</span></span><br></pre></td></tr></table></figure>\n\n<p><code>后续操作均是在Jovry-Lee.github.io目录(Jovry-Lee.github.io与githubBlog目录同级)下完成。</code></p>\n<ul>\n<li>③、拷贝本地博客的部署文件（Hexo目录下的全部文件到<code>username.github.io</code>文件目录中），然后删除<code>themes</code>目录中主题下的<code>.git</code>目录（如果存在的话），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后提交。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拷贝Hexo目录内容</span></span><br><span class=\"line\">$ sudo cp -r ~/ProjectWork/githubBlog/* ./</span><br><span class=\"line\"><span class=\"comment\"># 删除themes目录下主题的.git目录，我本地用的next主题</span></span><br><span class=\"line\">$ sudo rm -r themes/next/.git</span><br><span class=\"line\"><span class=\"comment\"># 提交修改</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;back up hexo files&quot;</span></span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>④、后续写博客，即在<code>username.github.io</code>文件目录中进行了，由于仓库有个<code>gitignore</code>文件，里面忽略掉了<code>node_modules</code>文件夹，也就是说仓库的<code>hexo分支</code>并没有存储该目录，所以需要重新install一下。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"8-2-其他电脑端配置\"><a href=\"#8-2-其他电脑端配置\" class=\"headerlink\" title=\"8.2 其他电脑端配置\"></a>8.2 其他电脑端配置</h5><p>​    安装Hexo环境，然后克隆<code>username.github.io</code>仓库的hexo分支到本地，此时本地git仓库处于hexo分支；切换到username.github.io目录，安装依赖包。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:Jovry-Lee/Jovry-Lee.github.io.git</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> Jovry-Lee.github.io</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果npm install出错，如”npm ERR! Unexpected end of JSON input while parsing near”,可尝试：</p>\n<ul>\n<li>删除package-lock.json文件</li>\n<li>清除cache: npm cache clean –force</li>\n<li>不要用淘宝镜像：npm set registry <a href=\"https://registry.npmjs.org/\">https://registry.npmjs.org/</a></li>\n</ul>\n<h5 id=\"8-3-发布更新博客\"><a href=\"#8-3-发布更新博客\" class=\"headerlink\" title=\"8.3 发布更新博客\"></a>8.3 发布更新博客</h5><p>更新博客内容后提交到github,执行以下操作进行提交及其部署.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commint -m <span class=\"string\">&quot;注释&quot;</span></span><br><span class=\"line\">$ git push</span><br><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p><em>注：每次操作时，最好先git pull 一下。</em></p>\n<h4 id=\"9-设置图床\"><a href=\"#9-设置图床\" class=\"headerlink\" title=\"9 设置图床\"></a>9 设置图床</h4><p>为了解决图片的存储问题，使用第三方静态资源库，即图床，获取图片Url，目前可供选择的图床很多，小众一些的容易挂，大厂存储服务又需要花钱，因此，这里使用Github + jsDelivr + PicGo + Imagine打造自己的图床。</p>\n<h5 id=\"9-1-配置Github\"><a href=\"#9-1-配置Github\" class=\"headerlink\" title=\"9.1 配置Github\"></a>9.1 配置Github</h5><ul>\n<li><p>创建仓库</p>\n</li>\n<li><ul>\n<li>输入项目名称</li>\n<li>选择权限为公开</li>\n<li>初始化一个READMEmd文件</li>\n<li>创建项目</li>\n</ul>\n</li>\n<li><p>生成一个Token</p>\n<ul>\n<li>点击用户头像-&gt;选择”Settings“-&gt;点击”Developer settings“-&gt;点击”Personal access tokens“-&gt;点击”Generate new token“</li>\n<li>在“Node”栏键入token的备注</li>\n<li>在“Select scopes”中勾选“repo”</li>\n<li>点击“Generate token”按钮</li>\n</ul>\n</li>\n<li><p>获取Token秘钥：<u>该秘钥只会显示一次，注意自己保存一下，方便后续使用</u>。</p>\n</li>\n</ul>\n<h5 id=\"9-2-配置PicGo，并使用jsdelivr作为CDN加速\"><a href=\"#9-2-配置PicGo，并使用jsdelivr作为CDN加速\" class=\"headerlink\" title=\"9.2 配置PicGo，并使用jsdelivr作为CDN加速\"></a>9.2 配置PicGo，并使用jsdelivr作为CDN加速</h5><ul>\n<li><p>下载PicGo</p>\n</li>\n<li><ul>\n<li><a href=\"https://github.com/Molunerfinn/PicGo\">下载地址</a></li>\n<li>Linux系统下载<code>AppImage</code>文件，更改其权限为可执行，双击即可显示应用图标。</li>\n</ul>\n</li>\n<li><p>右键点击图标选择“打开详细窗口”-&gt;点击“图床设置”-&gt;选择“GitHub图床”，进行GitHub设置</p>\n<ul>\n<li><p>设定仓库名：Jovry-Lee/cdn</p>\n</li>\n<li><p>设定分支名：master</p>\n</li>\n<li><p>设定Token：&lt;Github配置时生成的那个秘钥&gt;</p>\n</li>\n<li><p>指定存储路径：img/   <em>(注: 指定存储路径，将会在仓库下创建设置名称的文件夹（eg：img），上传的图片将保存在里面。)</em></p>\n</li>\n<li><p>设定自定义域名： eg：<code>https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn</code>  <em>(注: 自定义域名的作用是，在图片上传后，PicGo会按照自定义域名+上传图片名的方式生成访问链接，放到粘贴板上。因为我们要使用 jsDelivr 加速访问，所以可以设置为<a href=\"https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D%E3%80%82\">https://cdn.jsdelivr.net/gh/用户名/图床仓库名。</a>)</em></p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"9-3-图片压缩工具\"><a href=\"#9-3-图片压缩工具\" class=\"headerlink\" title=\"9.3 图片压缩工具\"></a>9.3 图片压缩工具</h5><p>通常情况下，图片大小都是超过200KB的，网页加载会比较慢，所以需要对图片进行压缩。</p>\n<ul>\n<li><p>在线网站压缩</p>\n<p><a href=\"https://tinypng.com/\">网站地址</a></p>\n</li>\n<li><p>Imagine工具压缩</p>\n<p><a href=\"https://github.com/meowtec/Imagine\">下载地址</a></p>\n</li>\n</ul>\n<h5 id=\"9-4-图片上传-获取\"><a href=\"#9-4-图片上传-获取\" class=\"headerlink\" title=\"9.4 图片上传/获取\"></a>9.4 图片上传/获取</h5><ul>\n<li>上传: 上传区进行图片上传，PicGo工具支持多个图床,需要选择上传的图床,选择<code>GitHub图床</code>。</li>\n</ul>\n<ul>\n<li>获取: PicGo应用点击<code>相册</code>，选择图床，即可显示该图床下的所有图片。</li>\n</ul>\n<p>生成的图片的链接示例：<code>https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E7%9F%A9%E5%BD%A2@3x.png</code></p>\n<h4 id=\"Markdown编辑器安装\"><a href=\"#Markdown编辑器安装\" class=\"headerlink\" title=\"Markdown编辑器安装\"></a>Markdown编辑器安装</h4><p>GitHub page支持Markdown语法,推荐使用Markdown进行编辑.</p>\n<h5 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h5><p><a href=\"https://typora.io/\">Typora官网</a></p>\n<p>安装方法：</p>\n<ul>\n<li>命令行安装</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># or run:</span></span><br><span class=\"line\"><span class=\"comment\"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span></span><br><span class=\"line\">$ wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># add Typora&#x27;s repository</span></span><br><span class=\"line\">$ sudo add-apt-repository <span class=\"string\">&#x27;deb https://typora.io/linux ./&#x27;</span></span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># install typora</span></span><br><span class=\"line\">$ sudo apt-get install typora</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>源文件安装<ul>\n<li>官网下载二进制文件</li>\n<li>解压到指定目录</li>\n<li>配置环境变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://typora.io/linux/Typora-linux-x64.tar.gz</span><br><span class=\"line\">$ sudo tar zxvf Typora-linux-x64.tar.gz -d /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\">$ sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>填入以下信息:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#set typora</span><br><span class=\"line\">export TYPORA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Typora-linux-x64</span><br><span class=\"line\">export PAHT&#x3D;$TYPORA_HOME:$PATH</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://ryanluoxu.github.io/2017/11/24/%E7%94%A8-Hexo-%E5%92%8C-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\">用 Hexo 和 GitHub Pages 搭建博客</a></p>\n<p><a href=\"https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/\">Ubuntu 16.04下Github配置</a> </p>\n<p><a href=\"http://theme-next.iissnan.com/getting-started.html\">Next使用文档</a></p>\n<p><a href=\"https://theme-next.js.org/docs/getting-started/\">Getting Started</a></p>\n<p><a href=\"https://www.zhihu.com/question/43517242\">Hexo中如何给一篇文章加多个tags？</a></p>\n<p><a href=\"https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2\">创建分类页面</a></p>\n<p><a href=\"https://blog.csdn.net/u011240016/article/details/79422462\">hexo之next主题添加分类</a></p>\n<p><a href=\"https://cccshuang.github.io/2018/09/28/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%86%99Hexo%E5%8D%9A%E5%AE%A2/\">使用多台电脑写Hexo博客</a></p>\n<p><a href=\"https://www.vivatakethat.com/2016/07/07/%E5%9C%A8Windows%E4%B8%8B%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo/\">在WSL下快速搭建hexo</a></p>\n<p><a href=\"https://hexo.io/zh-cn/\">Hexo官网</a></p>\n<p>[Hexo Blog折腾笔记](<a href=\"https://ghamster0.github.io/2019/03/12/Hexo\">https://ghamster0.github.io/2019/03/12/Hexo</a> Blog折腾笔记/)</p>\n<p><a href=\"https://www.cnblogs.com/sitoi/p/11848816.html\">GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床 </a></p>\n<p><a href=\"https://ryanluoxu.github.io/2017/11/26/Hexo-%E7%9A%84-Next-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96\">Hexo 的 Next 主题优化</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/30836436\">Hexo+Next主题优化</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，通过构建过程运行文件，然后发布网站。 Hexo是高效的静态站点生成框架，它基于Node.js. 通过Hexo，可以直接使用Markdown语法来撰写博客。</p>","more":"<h4 id=\"2-配置Git\"><a href=\"#2-配置Git\" class=\"headerlink\" title=\"2 配置Git\"></a>2 配置Git</h4><p>配置方式参考：<a href=\"https://jovry-lee.github.io/2020/08/18/Ubuntu16-04-Github%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/#more\">Ubuntu16.04 Github配置及使用</a></p>\n<h4 id=\"3-安装node-js\"><a href=\"#3-安装node-js\" class=\"headerlink\" title=\"3 安装node.js\"></a>3 安装node.js</h4><p>安装方式参考：<a href=\"https://jovry-lee.github.io/2020/08/21/Ubuntu16-04-Nodejs%E5%AE%89%E8%A3%85/\">Ubuntu16.04 Node.js安装.note</a></p>\n<h4 id=\"4-安装Hexo\"><a href=\"#4-安装Hexo\" class=\"headerlink\" title=\"4 安装Hexo\"></a>4 安装Hexo</h4><p>安装命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>检查hexo是否安装成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n\n<p><em>得到hexo-cli：4.2.0等一串数据，安装成功。</em></p>\n<h4 id=\"5-Hexo创建本地博客\"><a href=\"#5-Hexo创建本地博客\" class=\"headerlink\" title=\"5 Hexo创建本地博客\"></a>5 Hexo创建本地博客</h4><ul>\n<li><p>初始化本地站点</p>\n<p>本地博客路径在<code>~/ProjectWork/githubBlog</code>下,本地博客搭建操作在此路径下进行操作.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/ProjectWork</span><br><span class=\"line\">$ mkdir githubBlog <span class=\"comment\"># 创建本地博客路径</span></span><br><span class=\"line\">$ hexo init <span class=\"comment\"># 初始化本地站点</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><em>注：hexo init 命令要求该当前文件夹为空文件夹。</em></p>\n<ul>\n<li>安装依赖包</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成网页</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<p><em>注：由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</em></p>\n<ul>\n<li>将网页放在本地服务器</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>测试本地博客</p>\n<p>在浏览器里输入<a href=\"http://localhost:4000/\">http://localhost:4000/</a> </p>\n</li>\n<li><p>发布一篇博客</p>\n<p>在本地博客路径下执行以下命令, 此时source/_posts下会生成一个“日志名.md”的文件，该文件即是日志文件。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;&lt;日志名&gt;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成网页并放到本地服务器</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g </span><br><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-将本地Hexo博客部署到Github上\"><a href=\"#6-将本地Hexo博客部署到Github上\" class=\"headerlink\" title=\"6 将本地Hexo博客部署到Github上\"></a>6 将本地Hexo博客部署到Github上</h4><h5 id=\"6-1-创建代码仓库\"><a href=\"#6-1-创建代码仓库\" class=\"headerlink\" title=\"6.1 创建代码仓库\"></a>6.1 创建代码仓库</h5><ul>\n<li><p>在Github中创建一个以.github.io结尾的Repository。</p>\n</li>\n<li><ul>\n<li>①、Repository name:  <code>Jovry-Lee.github.io</code></li>\n<li>②、勾选 Initialize this repository with a README</li>\n<li>③、Create repository</li>\n</ul>\n</li>\n<li><p>简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog.. 保存(Commit changes)。</p>\n</li>\n<li><p>打开网页：<code>jovry-Lee.github.io</code> 这里就可以看到 README.md 里的内容了。</p>\n</li>\n</ul>\n<h5 id=\"6-2-配置本地代码仓库\"><a href=\"#6-2-配置本地代码仓库\" class=\"headerlink\" title=\"6.2 配置本地代码仓库\"></a>6.2 配置本地代码仓库</h5><ul>\n<li>获取Github对应的Repository的链接。（<a href=\"mailto:&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;\">&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:Jovry-Lee/Jovry-Lee.github.io.git）</li>\n</ul>\n<ul>\n<li>修改本地站点配置文件。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vim _config.yml <span class=\"comment\"># 打开配置文件</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到#Deployment，填入以下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: https:&#x2F;&#x2F;github.com&#x2F;Jovry-Lee&#x2F;Jovry-Lee.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save <span class=\"comment\"># 安装hexo-deployer-git，该步骤只需要做一次</span></span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<p><em>得到 INFO Deploy done: git 即为部署成功</em></p>\n<p>此时访问<code>Jovry-Lee.github.io</code>即可看到博客页面。</p>\n<h4 id=\"7-使用Next主题\"><a href=\"#7-使用Next主题\" class=\"headerlink\" title=\"7 使用Next主题\"></a>7 使用Next主题</h4><h5 id=\"7-1-配置NexT主题\"><a href=\"#7-1-配置NexT主题\" class=\"headerlink\" title=\"7.1 配置NexT主题\"></a>7.1 配置NexT主题</h5><ul>\n<li>获取主题代码</li>\n</ul>\n<p>​    克隆主题代码到本地博客<code>themes/next</code>路径下.    </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/next-theme/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>修改博客配置文件</p>\n<ul>\n<li><p>打开 <code>~/ProjectWork/githubBlog/_config.yml</code></p>\n</li>\n<li><p>找到 theme:</p>\n</li>\n<li><p>把 Hexo 默认的 lanscape 修改成 next。 即 theme: next</p>\n</li>\n<li><p>找到 # Site，添加博客名称，作者名字等。</p>\n</li>\n<li><p>在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。</p>\n</li>\n<li><p>找到 # URL, 填入 url。比如 url:<a href=\"https://jovry-lee.github.io/\">https://jovry-lee.github.io/</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>当前本地配置如下:</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class=\"line\">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class=\"line\">theme: next</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># Site</span><br><span class=\"line\">title: Jovry&#39;s blog</span><br><span class=\"line\">subtitle: &#39;&#39;</span><br><span class=\"line\">description: Keeping learning and improving!</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: Jovry Lee</span><br><span class=\"line\">language: en</span><br><span class=\"line\">timezone: &#39;Asia&#x2F;Shanghai&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># URL</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class=\"line\">url: https:&#x2F;&#x2F;jovry-Lee.github.io</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>清除旧配置</li>\n</ul>\n<p>​    <em>注意：修改配置后最好都进行一下清理操作，不然可能不生效。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重新生成部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"7-2-NexT主题优化\"><a href=\"#7-2-NexT主题优化\" class=\"headerlink\" title=\"7.2 NexT主题优化\"></a>7.2 NexT主题优化</h5><h6 id=\"7-2-1-修改NexT主题Scheme\"><a href=\"#7-2-1-修改NexT主题Scheme\" class=\"headerlink\" title=\"7.2.1 修改NexT主题Scheme\"></a>7.2.1 修改NexT主题Scheme</h6><p>​    NexT当前支持4种风格,默认为Muse,在NexT主题配置文件(<code>themes/next/_config.yml</code>)中可以修改Scheme,配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">#scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">scheme: Gemini</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-2-添加访问统计\"><a href=\"#7-2-2-添加访问统计\" class=\"headerlink\" title=\"7.2.2 添加访问统计\"></a>7.2.2 添加访问统计</h6><p>​    通过配置NexT主题配置文件,修改busuanzi_count.配置如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Show Views &#x2F; Visitors of the website &#x2F; page with busuanzi.</span><br><span class=\"line\"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi</span><br><span class=\"line\">busuanzi_count:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  total_visitors: true</span><br><span class=\"line\">  total_visitors_icon: fa fa-user</span><br><span class=\"line\">  total_views: true</span><br><span class=\"line\">  total_views_icon: fa fa-eye</span><br><span class=\"line\">  post_views: true</span><br><span class=\"line\">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-3-添加头像\"><a href=\"#7-2-3-添加头像\" class=\"headerlink\" title=\"7.2.3 添加头像\"></a>7.2.3 添加头像</h6><p>​    添加的头像可以保存到主站目录下,或者主题目录下.</p>\n<ul>\n<li>Site路径: 保存到<code>~/ProjectWork/Jovry-Lee.github.io/public/uploads</code>路径下.</li>\n<li>theme路径下:<code>~/ProjectWork/Jovry-Lee.github.io/themes/next/source/images</code>路径下</li>\n</ul>\n<p>配置NexT主题配置文件,修改avatar项:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Sidebar Avatar</span><br><span class=\"line\">avatar:</span><br><span class=\"line\">  # in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif</span><br><span class=\"line\">  # in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif</span><br><span class=\"line\">  # Replace the default image and set the url here.</span><br><span class=\"line\">  url: &#x2F;uploads&#x2F;princess.jpeg</span><br><span class=\"line\">  # 配置为true时,头像会在一个圈圈中.</span><br><span class=\"line\">  rounded: true</span><br><span class=\"line\">  # 配置为true时,鼠标放在头像上,头像有旋转效果.</span><br><span class=\"line\">  rotated: true</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-4-添加About-Tags-Categories等页面\"><a href=\"#7-2-4-添加About-Tags-Categories等页面\" class=\"headerlink\" title=\"7.2.4 添加About/Tags/Categories等页面\"></a>7.2.4 添加About/Tags/Categories等页面</h6><p>​    默认情况下,About页面是不存在的,即使将主页展示了About的图标,若不进行页面配置,点击跳转会报404. 配置方式如下:</p>\n<ul>\n<li>进入博客Bash路径,生成about等页面.</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/ProjectWork/Jovry-Lee.github.io</span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;about&quot;</span> <span class=\"comment\"># 生成about页面</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;tags&quot;</span> <span class=\"comment\"># 生成tags页面</span></span><br><span class=\"line\">$ hexo new page <span class=\"string\">&quot;categories&quot;</span> <span class=\"comment\"># 生成分类页面</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置NexT主题配置文件,修改<code>munu</code>项,启用图标, 修改如下:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F; || fa fa-home</span><br><span class=\"line\">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class=\"line\">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class=\"line\">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class=\"line\">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class=\"line\">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class=\"line\">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class=\"line\">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>​    添加about个人介绍,直接在<code>~/ProjectWork/Jovry-Lee.github.io/source/about/index.md</code>文件上进行编辑即可.</li>\n</ul>\n<h6 id=\"7-2-5-分类和标签页自动生成categories-amp-tags\"><a href=\"#7-2-5-分类和标签页自动生成categories-amp-tags\" class=\"headerlink\" title=\"7.2.5 分类和标签页自动生成categories&amp;tags\"></a>7.2.5 分类和标签页自动生成categories&amp;tags</h6><ul>\n<li>分类页面配置</li>\n</ul>\n<p>​    在生成的分类页面<code>~/ProjectWork/Jovry-Lee.github.io/source/categories/index.md</code>上进行如下修改:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: categories</span><br><span class=\"line\">date: 2020-08-21 15:08:25</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>标签页面配置</li>\n</ul>\n<p>​    在生成的分类页面<code>~/ProjectWork/Jovry-Lee.github.io/source/tags/index.md</code>上进行如下修改:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: tags</span><br><span class=\"line\">date: 2020-08-19 15:30:01</span><br><span class=\"line\">type: tags</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-6-去掉目录栏序号\"><a href=\"#7-2-6-去掉目录栏序号\" class=\"headerlink\" title=\"7.2.6 去掉目录栏序号\"></a>7.2.6 去掉目录栏序号</h6><p>由于本地写文章时，已经对文章标题进行编号，而NexT主题默认是自动添加目录编号，因此，这里选择关闭该功能．</p>\n<p>修改NexT主题配置文件<code>toc</code>项,将<code>number</code>项设置为<code>false</code>, 修改如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Table of Contents in the Sidebar</span><br><span class=\"line\"># Front-matter variable (unsupport wrap expand_all).</span><br><span class=\"line\">toc:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # Automatically add list number to toc.</span><br><span class=\"line\">  number: false</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-7-设置侧边栏社交链接\"><a href=\"#7-2-7-设置侧边栏社交链接\" class=\"headerlink\" title=\"7.2.7 设置侧边栏社交链接\"></a>7.2.7 设置侧边栏社交链接</h6><p>社交连接也是在NexT配置文件中进行修改, 关键字<code>social</code>,进行修改,去掉<code>#</code>,添加个人链接即可.</p>\n<h6 id=\"7-2-8-设置Post-Body字体大小\"><a href=\"#7-2-8-设置Post-Body字体大小\" class=\"headerlink\" title=\"7.2.8 设置Post Body字体大小\"></a>7.2.8 设置Post Body字体大小</h6><p>由于NexT主题中Post Body部分的字体大小默认为1.125em，个人觉得不是很好看，因此自定义修改该字体的大小．</p>\n<p>通过查看<code>&lt;site&gt;/themes/next/source/css/_variables/base.styl</code>文件中定义了一系列<code>Font Size</code>．其中<code>post-body</code>默认使用的font-size-large，即1.125em大小．对<code>&lt;site&gt;/themes/next/source/css/_common/components/post/post-body.styl</code>进行设置．</p>\n<figure class=\"highlight css\"><figcaption><span><site>/themes/next/source/css/_common/components/post/post-body.styl</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.post-body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: $font-family-posts;</span><br><span class=\"line\">  word-wrap();</span><br><span class=\"line\"></span><br><span class=\"line\">  +<span class=\"selector-tag\">desktop-large</span>() &#123;</span><br><span class=\"line\">    // font-size: $font-size-large;</span><br><span class=\"line\">    <span class=\"selector-tag\">font-size</span>: <span class=\"selector-tag\">font-size-medium</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-2-9-设置代码高亮样式\"><a href=\"#7-2-9-设置代码高亮样式\" class=\"headerlink\" title=\"7.2.9 设置代码高亮样式\"></a>7.2.9 设置代码高亮样式</h6><p>在<a href=\"https://theme-next.js.org/highlight/#\">NexT Highlight Theme Preview</a>中找到自己喜欢的格式，然后进行配置．</p>\n<p>当前使用默认的Highlight.js插件，选用atelier-seaside-light样式，对NexT主题配置如下：</p>\n<figure class=\"highlight tex\"><figcaption><span>/themes/next/_config.yml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codeblock:</span><br><span class=\"line\">  # Code Highlight theme</span><br><span class=\"line\">  # All available themes: https://theme-next.js.org/highlight/</span><br><span class=\"line\">  theme:</span><br><span class=\"line\">    light: atelier-seaside-light</span><br><span class=\"line\">    dark: atelier-seaside-dark</span><br><span class=\"line\">  ．．．</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"7-3-基于NexT主题开启评论功能——Gitalk\"><a href=\"#7-3-基于NexT主题开启评论功能——Gitalk\" class=\"headerlink\" title=\"7.3 基于NexT主题开启评论功能——Gitalk\"></a>7.3 基于NexT主题开启评论功能——Gitalk</h5><p>该评论功能使用Gitalk服务实现。</p>\n<h6 id=\"7-3-1-注册OAuth-Application\"><a href=\"#7-3-1-注册OAuth-Application\" class=\"headerlink\" title=\"7.3.1 注册OAuth Application\"></a>7.3.1 注册OAuth Application</h6><ul>\n<li>登录GitHub</li>\n<li>前往 <code>https://github.com/settings/profile</code></li>\n<li>点击左侧下方的 <code>Developer settings</code></li>\n<li>点击绿色 <code>Register a new application</code></li>\n<li>填写以下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Application name：gitalk-comment</span><br><span class=\"line\">Homepage URL：https:&#x2F;&#x2F;jovry-lee.github.io&#x2F;</span><br><span class=\"line\">Application description：Blog comment system</span><br><span class=\"line\">Authorization callback URL：https:&#x2F;&#x2F;jovry-lee.github.io&#x2F;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>点击 Register application</p>\n</li>\n<li><p>得到：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Client ID：xxx </span><br><span class=\"line\"></span><br><span class=\"line\">Client Secret： xxxx</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"7-3-2-创建存放Gitalk-comments的repository\"><a href=\"#7-3-2-创建存放Gitalk-comments的repository\" class=\"headerlink\" title=\"7.3.2 创建存放Gitalk-comments的repository\"></a>7.3.2 创建存放Gitalk-comments的repository</h6><ul>\n<li>创建 repository。 Repository name 为：<code>gitalk-comments</code></li>\n<li>地址：<code>https://github.com/Jovry-Lee/gitalk-comments</code></li>\n<li>注意稍后配置中填的是 <code>gitalk-comments</code>，<u>不是地址</u>。</li>\n</ul>\n<h6 id=\"7-3-3-添加Gitalk到博客\"><a href=\"#7-3-3-添加Gitalk到博客\" class=\"headerlink\" title=\"7.3.3 添加Gitalk到博客\"></a>7.3.3 添加Gitalk到博客</h6><ul>\n<li>打开本地博客路径下next主题的配置文件</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim ~/ProjectWork/Jovry-Lee.github.io/themes/next/_config.yml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到gitalk，进行如下修改：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Gitalk</span><br><span class=\"line\"># For more information: https:&#x2F;&#x2F;gitalk.github.io, https:&#x2F;&#x2F;github.com&#x2F;gitalk&#x2F;gitalk</span><br><span class=\"line\">gitalk:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  github_id: Jovry-Lee # GitHub repo owner</span><br><span class=\"line\">  repo: gitalk-comments # Repository name to store issues</span><br><span class=\"line\">  client_id: xxx # GitHub Application Client ID</span><br><span class=\"line\">  client_secret: xxxx # GitHub Application Client Secret</span><br><span class=\"line\">  admin_user: Jovry-Lee # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class=\"line\">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class=\"line\">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class=\"line\">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class=\"line\">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class=\"line\">  language: en</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>重新部署</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean </span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"8-多端使用Hexo博客\"><a href=\"#8-多端使用Hexo博客\" class=\"headerlink\" title=\"8 多端使用Hexo博客\"></a>8 多端使用Hexo博客</h4><p>首先应该确保某一台电脑搭建好了Hexo博客，然后进行后续操作。</p>\n<h5 id=\"8-1-主端配置\"><a href=\"#8-1-主端配置\" class=\"headerlink\" title=\"8.1 主端配置\"></a>8.1 主端配置</h5><ul>\n<li><p>①、登录Github，在<code>username.github.io</code>仓库上新建hexo分支。</p>\n<p>在博客仓库上新建一个分支，例如“hexo”，切换到该分支，并设置该分支为默认分支（Setting-&gt;Branches-&gt;Default branch）</p>\n</li>\n<li><p>②、克隆博客仓库到本地</p>\n</li>\n</ul>\n<p><em>注：不是本地Hexo目录。</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git@github.com:Jovry-Lee/Jovry-Lee.github.io.git</span></span><br></pre></td></tr></table></figure>\n\n<p>查看当前分支，确保为新建的hexo分支</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> Jovry-Lee.github.io/ $ git branch * hexo</span></span><br></pre></td></tr></table></figure>\n\n<p><code>后续操作均是在Jovry-Lee.github.io目录(Jovry-Lee.github.io与githubBlog目录同级)下完成。</code></p>\n<ul>\n<li>③、拷贝本地博客的部署文件（Hexo目录下的全部文件到<code>username.github.io</code>文件目录中），然后删除<code>themes</code>目录中主题下的<code>.git</code>目录（如果存在的话），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。然后提交。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拷贝Hexo目录内容</span></span><br><span class=\"line\">$ sudo cp -r ~/ProjectWork/githubBlog/* ./</span><br><span class=\"line\"><span class=\"comment\"># 删除themes目录下主题的.git目录，我本地用的next主题</span></span><br><span class=\"line\">$ sudo rm -r themes/next/.git</span><br><span class=\"line\"><span class=\"comment\"># 提交修改</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;back up hexo files&quot;</span></span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>④、后续写博客，即在<code>username.github.io</code>文件目录中进行了，由于仓库有个<code>gitignore</code>文件，里面忽略掉了<code>node_modules</code>文件夹，也就是说仓库的<code>hexo分支</code>并没有存储该目录，所以需要重新install一下。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"8-2-其他电脑端配置\"><a href=\"#8-2-其他电脑端配置\" class=\"headerlink\" title=\"8.2 其他电脑端配置\"></a>8.2 其他电脑端配置</h5><p>​    安装Hexo环境，然后克隆<code>username.github.io</code>仓库的hexo分支到本地，此时本地git仓库处于hexo分支；切换到username.github.io目录，安装依赖包。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:Jovry-Lee/Jovry-Lee.github.io.git</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> Jovry-Lee.github.io</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果npm install出错，如”npm ERR! Unexpected end of JSON input while parsing near”,可尝试：</p>\n<ul>\n<li>删除package-lock.json文件</li>\n<li>清除cache: npm cache clean –force</li>\n<li>不要用淘宝镜像：npm set registry <a href=\"https://registry.npmjs.org/\">https://registry.npmjs.org/</a></li>\n</ul>\n<h5 id=\"8-3-发布更新博客\"><a href=\"#8-3-发布更新博客\" class=\"headerlink\" title=\"8.3 发布更新博客\"></a>8.3 发布更新博客</h5><p>更新博客内容后提交到github,执行以下操作进行提交及其部署.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commint -m <span class=\"string\">&quot;注释&quot;</span></span><br><span class=\"line\">$ git push</span><br><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p><em>注：每次操作时，最好先git pull 一下。</em></p>\n<h4 id=\"9-设置图床\"><a href=\"#9-设置图床\" class=\"headerlink\" title=\"9 设置图床\"></a>9 设置图床</h4><p>为了解决图片的存储问题，使用第三方静态资源库，即图床，获取图片Url，目前可供选择的图床很多，小众一些的容易挂，大厂存储服务又需要花钱，因此，这里使用Github + jsDelivr + PicGo + Imagine打造自己的图床。</p>\n<h5 id=\"9-1-配置Github\"><a href=\"#9-1-配置Github\" class=\"headerlink\" title=\"9.1 配置Github\"></a>9.1 配置Github</h5><ul>\n<li><p>创建仓库</p>\n</li>\n<li><ul>\n<li>输入项目名称</li>\n<li>选择权限为公开</li>\n<li>初始化一个READMEmd文件</li>\n<li>创建项目</li>\n</ul>\n</li>\n<li><p>生成一个Token</p>\n<ul>\n<li>点击用户头像-&gt;选择”Settings“-&gt;点击”Developer settings“-&gt;点击”Personal access tokens“-&gt;点击”Generate new token“</li>\n<li>在“Node”栏键入token的备注</li>\n<li>在“Select scopes”中勾选“repo”</li>\n<li>点击“Generate token”按钮</li>\n</ul>\n</li>\n<li><p>获取Token秘钥：<u>该秘钥只会显示一次，注意自己保存一下，方便后续使用</u>。</p>\n</li>\n</ul>\n<h5 id=\"9-2-配置PicGo，并使用jsdelivr作为CDN加速\"><a href=\"#9-2-配置PicGo，并使用jsdelivr作为CDN加速\" class=\"headerlink\" title=\"9.2 配置PicGo，并使用jsdelivr作为CDN加速\"></a>9.2 配置PicGo，并使用jsdelivr作为CDN加速</h5><ul>\n<li><p>下载PicGo</p>\n</li>\n<li><ul>\n<li><a href=\"https://github.com/Molunerfinn/PicGo\">下载地址</a></li>\n<li>Linux系统下载<code>AppImage</code>文件，更改其权限为可执行，双击即可显示应用图标。</li>\n</ul>\n</li>\n<li><p>右键点击图标选择“打开详细窗口”-&gt;点击“图床设置”-&gt;选择“GitHub图床”，进行GitHub设置</p>\n<ul>\n<li><p>设定仓库名：Jovry-Lee/cdn</p>\n</li>\n<li><p>设定分支名：master</p>\n</li>\n<li><p>设定Token：&lt;Github配置时生成的那个秘钥&gt;</p>\n</li>\n<li><p>指定存储路径：img/   <em>(注: 指定存储路径，将会在仓库下创建设置名称的文件夹（eg：img），上传的图片将保存在里面。)</em></p>\n</li>\n<li><p>设定自定义域名： eg：<code>https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn</code>  <em>(注: 自定义域名的作用是，在图片上传后，PicGo会按照自定义域名+上传图片名的方式生成访问链接，放到粘贴板上。因为我们要使用 jsDelivr 加速访问，所以可以设置为<a href=\"https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D%E3%80%82\">https://cdn.jsdelivr.net/gh/用户名/图床仓库名。</a>)</em></p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"9-3-图片压缩工具\"><a href=\"#9-3-图片压缩工具\" class=\"headerlink\" title=\"9.3 图片压缩工具\"></a>9.3 图片压缩工具</h5><p>通常情况下，图片大小都是超过200KB的，网页加载会比较慢，所以需要对图片进行压缩。</p>\n<ul>\n<li><p>在线网站压缩</p>\n<p><a href=\"https://tinypng.com/\">网站地址</a></p>\n</li>\n<li><p>Imagine工具压缩</p>\n<p><a href=\"https://github.com/meowtec/Imagine\">下载地址</a></p>\n</li>\n</ul>\n<h5 id=\"9-4-图片上传-获取\"><a href=\"#9-4-图片上传-获取\" class=\"headerlink\" title=\"9.4 图片上传/获取\"></a>9.4 图片上传/获取</h5><ul>\n<li>上传: 上传区进行图片上传，PicGo工具支持多个图床,需要选择上传的图床,选择<code>GitHub图床</code>。</li>\n</ul>\n<ul>\n<li>获取: PicGo应用点击<code>相册</code>，选择图床，即可显示该图床下的所有图片。</li>\n</ul>\n<p>生成的图片的链接示例：<code>https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E7%9F%A9%E5%BD%A2@3x.png</code></p>\n<h4 id=\"Markdown编辑器安装\"><a href=\"#Markdown编辑器安装\" class=\"headerlink\" title=\"Markdown编辑器安装\"></a>Markdown编辑器安装</h4><p>GitHub page支持Markdown语法,推荐使用Markdown进行编辑.</p>\n<h5 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h5><p><a href=\"https://typora.io/\">Typora官网</a></p>\n<p>安装方法：</p>\n<ul>\n<li>命令行安装</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># or run:</span></span><br><span class=\"line\"><span class=\"comment\"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span></span><br><span class=\"line\">$ wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># add Typora&#x27;s repository</span></span><br><span class=\"line\">$ sudo add-apt-repository <span class=\"string\">&#x27;deb https://typora.io/linux ./&#x27;</span></span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># install typora</span></span><br><span class=\"line\">$ sudo apt-get install typora</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>源文件安装<ul>\n<li>官网下载二进制文件</li>\n<li>解压到指定目录</li>\n<li>配置环境变量</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://typora.io/linux/Typora-linux-x64.tar.gz</span><br><span class=\"line\">$ sudo tar zxvf Typora-linux-x64.tar.gz -d /usr/<span class=\"built_in\">local</span></span><br><span class=\"line\">$ sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>填入以下信息:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#set typora</span><br><span class=\"line\">export TYPORA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Typora-linux-x64</span><br><span class=\"line\">export PAHT&#x3D;$TYPORA_HOME:$PATH</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://ryanluoxu.github.io/2017/11/24/%E7%94%A8-Hexo-%E5%92%8C-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\">用 Hexo 和 GitHub Pages 搭建博客</a></p>\n<p><a href=\"https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/\">Ubuntu 16.04下Github配置</a> </p>\n<p><a href=\"http://theme-next.iissnan.com/getting-started.html\">Next使用文档</a></p>\n<p><a href=\"https://theme-next.js.org/docs/getting-started/\">Getting Started</a></p>\n<p><a href=\"https://www.zhihu.com/question/43517242\">Hexo中如何给一篇文章加多个tags？</a></p>\n<p><a href=\"https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2\">创建分类页面</a></p>\n<p><a href=\"https://blog.csdn.net/u011240016/article/details/79422462\">hexo之next主题添加分类</a></p>\n<p><a href=\"https://cccshuang.github.io/2018/09/28/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%86%99Hexo%E5%8D%9A%E5%AE%A2/\">使用多台电脑写Hexo博客</a></p>\n<p><a href=\"https://www.vivatakethat.com/2016/07/07/%E5%9C%A8Windows%E4%B8%8B%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo/\">在WSL下快速搭建hexo</a></p>\n<p><a href=\"https://hexo.io/zh-cn/\">Hexo官网</a></p>\n<p>[Hexo Blog折腾笔记](<a href=\"https://ghamster0.github.io/2019/03/12/Hexo\">https://ghamster0.github.io/2019/03/12/Hexo</a> Blog折腾笔记/)</p>\n<p><a href=\"https://www.cnblogs.com/sitoi/p/11848816.html\">GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床 </a></p>\n<p><a href=\"https://ryanluoxu.github.io/2017/11/26/Hexo-%E7%9A%84-Next-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96\">Hexo 的 Next 主题优化</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/30836436\">Hexo+Next主题优化</a></p>"},{"title":"高性能MySQL-Schema与数据类型优化","date":"2020-09-04T06:44:08.000Z","_content":"\n\n\n### 1 选择优化的数据类型\n\n- ①、`更小的通常更好`：更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，且处理时需要的CPU周期也更少。选择不会超过范围的最小类型。\n\n  <!--more-->\n\n- ②、`简单就好`：简单数据类型的操作通常需要更少的CPU周期，例如：\n\n- - a、整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。\n  - b、应使用mysql内建的类型来存储时间和日期（date,time,datetime），而不是字符串来存储日期和时间。\n  - c、应使用整型存储IP地址。\n\n- ③、`避免使用null`：最好使用列作为not null，除非真的需要存储null值，原因如下：\n\n- - a、若查询中包含可为null的列，对MySQL来说很难优化，因为可为null的列使得索引、索引统计和值都更复杂。\n  - b、可为null的列可能会使用更多的存储空间，在MySQL里需要特殊处理。\n  - c、当可为null的列被索引时，每个索引记录需要一个额外的字节\n\n（例外：InnoDB使用单独位（bit）存储null值，对于叙述数据有很好的空间效率，但不适用与MyISAM。）\n\n\n\n**为列选择数据类型的步骤？**\n\n- ①、确定适合的大类型，例如：数字、字符串、时间等。\n- ②、选择具体的类型。（注：很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不同、允许的精度不同，需要的物理空间（内存和磁盘）不同）。\n\n例如：datetime和timestamp列都可以存储相同类型的数据，时间和日期，精确到秒。但timestamp只使用datetime一半的存储空间，并且会根据时区变化，具有特殊自动更新能力。另一方面，timestamp允许的时间范围要小很多，有时候它的特殊能力会成为障碍。\n\n\n\n关于别名：Mysql支持很多别名，例如INTEGER,BOOL,以及NUMERIC。若建表使用的数据类型的别名，使用`show create table`检查时，会发现mysql报告的是基本类型，而不是别名。\n\n\n\n#### 1.1 整数类型\n\nMySQL支持两种类型的数字：`整数`和`实数`。\n\n\n\n其中,MySql整数类型有`TINYINT`，`SMALLINT`，`MEDEIUMINT`，`INT`，`BIGINT`。分别使用`8，16，24，32，64`位存储空间，其存储值得范围从-2^(N-1)到2^(N-1)-1，其中N是存储空间的位数。\n\n关于`UNSIGNED`属性，<u>表示不允许为负值，加上此属性，可以使正数的上限提高一倍。</u>\n\n（*注：有符号和无符号类型使用相同的存储空间，并且具有相同的性能。*）\n\n\n\n<u>Mysql可以为整数类型指定宽度。但它不会限制值的合法范围，只是规定Mysql的一些交互工具用来显示字符的个数</u>。例如，对于存储和运算INT(1)和INT(20)是相同的。\n\n\n\n#### 1.2 实数类型\n\n`实数是带有小数部分的数字`。它不仅可以存储小数，还可以使用DECIMAL存储比BIGINT还大的整数类型。\n\nMysql既支持`精确类型（指的decimal`），也支持`不精确类型（float及double类型）`。\t\n\n- `FLOAT`和`DOUBLE`类型支持使用标准的浮点运算进行近似计算，其计算与所使用的平台浮点数计算有关。\n\n- `DECIMAL`类型用于存储精确的小数（但仅限于MySQL5.0及更高版本，其实现是由MYSQL服务器自身实现的。），MYSQL4.1之前的版本中，DECEIMAL只是一个“存储类型”。\n\n\n\n浮点和decimal类型都可以指定精度。对于decimal列，可以指定小数点前后所允许的最大位数。\n\n（Mysql5.0和更高的版本将数字打包保存到一个二进制字符串中，每4个字节存9个数字，实现参考 https://zhidao.baidu.com/question/565903719525546284.html \n\n​     32位的2进制能表示最大的十进制数字是4294967295，一共有10位；除了最高的十亿位，其他九个位都能够表示0-9；也就是说MySQL的decimal类型在保存大数时并不是将单个十进制数字映射成二进制数保存。\n\n）\n\n`浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间`。float使用4个字节存储，double使用8个字节。`MySQL使用double作为内部浮点计算的类型。`\n\n（因为decimal需要额外的开销，所以应该尽量只在对小数进行精确计算时才使用decimal，例如财务数据。在数据量比较大的时候，可以考虑使用bigint代替decimal，然后将需要存储的货币单位根据小数的尾数乘以相应的倍数。）\n\n\n\n#### 1.3 字符串类型\n\nMySQL支持多种字符串类型，`varchar和char类型是最主要字符串类型`。其存储方式与存储引擎的具体实现有关。与varchar和char类似的类型还有`binary和varbinary，他们存储的是二进制字符串`。\n\n\n\n##### 1.3.1 varchar\n\n`varchar`类型用于`存储可变长字符串`，是最常见的字符串数据类型。（它比定长类型更节省空间，因为它仅使用必要的空间。例外的情况，若MySQL表使用`ROW_FORMAT=FIXED`创建，则每一行都会使用定长存储。）\n\n`varchar需要使用1或2个额外的字节记录字符串的长度`：若列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。\n\n\n\n**使用varchar(5)和varchar(200)存储‘hello‘的空间开销是一样的，那么使用短的列有什么优势吗？**\n\nMySQL通常会分配固定大小的内存块来保存内部值，因此更长的列会消耗更多的内存。尤其是使用内存临时表进行排序或操作时会特别糟糕，在利用磁盘临时表进行排序也同样糟糕。因此最好的策略是只分配真正需要的空间。\n\n\n\n**varchar类型的优缺点？**\n\n`优点`：节省存储空间，对性能有所帮助。\n\n`缺点`：由于行时变长的，在update时可能使行变得比原来更长，这就需要做额外的工作。例如，若行占用的空间增长，在页内没有更多的空间可以存储，MyISAM会拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。\n\n\n\n**那些场景下使用varchar类型是合适的？**\n\n- ①、字符串列的最大长度比平均长度大很多。\n- ②、列的更新很少，所以碎片不是问题。\n\n\n\n##### 1.3.2 char\n\n`char`类型是`定长的`，MySQL总是根据定义字符串长度分配足够的空间。\n\n\n\n**那些场景下使用char类型是合适的？**\n\n- ①、char适合存储很短的字符串；（例如：用char（1）来存储只有Y和N的值，采用单字节字符集只需要一个字节，但是varchar却需要两个字节，因为还需要另一个用于记录长度的额外的字节）\n- ②、存储所有值都接近同一个长度的字符串；（例如，存储密码的MD5值，因为这是一个定长的值。）\n- ③、存储经常变更的数据。\n\n\n\n##### 1.3.3 BLOB和TEXT类型\n\n`BLOB`和`TEXT`都是为存储很大的数据而设计的字符串数据类型，`分别采用二进制和字符方式存储`。\n\n- `BLOB类型采用二进制方式存储`，没有排序规则或者字符集，其家族包含：TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。\n- `TEXT类型采用字符串方式存储`，有字符集合排序规则，其家族包含：TINYTEXT、SMALLTEXT、TEXT、MEDIEMTEXT、LONGTEXT。\n\n\n\n**相对于MySQL的其他类型，BLOB和TEXT有什么不同点？**\n\n- ①、BLOB和TEXT只对每个列的最前`max_sort_length`字节而不是整个字符串做排序，若只排序前面一小部分字符，可以减小`max_sort_length`的配置，或者使用ORDER BY SUSTRING(column,length)。\n- ②、不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。\n\n\n\n##### 1.3.4 使用枚举（ENUM）代替字符串类型\n\n有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列值的数量压缩到一个或者两个字节中。\n\nMySQL在内部会将每个值在列表中的位置保存为整数，并且在表的`.frm文件`中保存“数字-字符串”映射关系的“查找表”。\n\n\n\n示例:\n\n```mysql\n# 建表\ncreate table enum_test (\n    e enum('fish', 'apple', 'dog') not null\n);\n\n# 写数据\ninsert into enum_test(e) values ('fish'),('dog'),('apple');\n\n# 枚举值实际存储的是整数,而不是字符串.\nmysql> select e+0 from enum_test;\n+-----+\n| e+0 |\n+-----+\n|   1 |\n|   3 |\n|   2 |\n+-----+\n3 rows in set (0.03 sec)\n\n# 枚举字段排序时按照内部存储的整数,而不是定义的字符串进行排序的.\nmysql> select e from enum_test order by e;\n+-------+\n| e     |\n+-------+\n| fish  |\n| apple |\n| dog   |\n+-------+\n3 rows in set (0.07 sec)\n```\n\n\n\n注:\n\n- a. 应该避免使用数字作为enum枚举常量.\n\n- b. `枚举字段排序时按照内部存储的整数,而不是定义的字符串进行排序的`.\n\n\n\n**枚举类型的缺点?**\n\n- `字符串列表是固定的,添加或删除字符串必须使用alter table`.因此,对于一系列未来可能会改变的字符串,枚举并不是一个好主意.\n\n- 每个枚举值保存为整数,并且必须进行查找才能转换为字符串,所以枚举列有一些开销.\n\n\n\n**枚举类型的优点？**\n\n- 转换后让表的大小及主键大小缩小了。\n\n\n\n#### 1.4 日期和时间类型\n\nMySQL可以使用许多类型来保存日期和时间值，例如，YEAR和DATE。`MySQL能存储的是最小时间粒度为秒`。\n\nMySQL提供两种相似的日期类型：`DATETIME`和`TIMESTAMP`。\n\n\n\n##### 1.4.1 DATETIME\n\n`DATETIME`将日期和时间封装到格式为`YYYYMMDDHHMMSS`的整数中，与时区无关。使用`8个字节`的存储空间。默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值，例如：“2018-01-16 22:37:08”。\n\n\n\n##### 1.4.2 TIMESTAMP（推荐）\n\n`TIMESTAMP`类型保存了1970年1月1日以来的秒数，它与Unix时间戳相同。使用`4个字节`的存储空间。只能表示从1970到2038年。\n\nMySQL提供了以下两个函数，对时间戳和日期进行转化。\n\n- `FROM_UNIXTIME()`：把Unix时间戳转换为日期。\n- `UNIX_TIMESTAMP()`：把日期转换为Unix时间戳。\n\nTIMESTAMP显示的值依赖于时区，MySQL服务器、客户端连接都有时区设置。\n\n\n\n**MySQL存储的时间都是以秒为粒度，若需要存储以秒为更小粒度的日期和时间值应该怎么处理？**\n\n- ①、可以使用`BIGINT类型`存储微秒级别的时间戳。\n\n- ②、可以使用`DOUBLE`存储秒之后的小数部分。\n\n- ③、可以使用MariaDB替代MySQL。\n\n\n\n#### 1.5 位数据类型\n\nMySQL有少数几种存储类型使用紧凑的位存储数据，`所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型`。\n\n##### 1.5.1 BIT\n\n可以使用Bit列在一列中存储一个或多个true/false值，BIT列最大长度为64个位。例如，BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位。\n\n<u>注：MySQL将BIT当做字符串类型，而不是数字类型。</u>当检索BIT(1)的值，结果是一个包含二进制0或1的字符串，而不是ASCII码的“0”或者“1”。在和数字上下文的场景中检索时，结果将是位字符串转换成的数字。\n\n例如：若存储一个值b‘00111001’到BIT(8)的列并检索它，得到的内容是字符码57的字符串（即ASCII码的字符“9”），在数字上下文场景中，得到的是数字57.\n\n```mysql\n# 创建测试表。\ncreate table bittest(a bit(8));\n# 写入数据。\ninsert bittest values (b'00111001');\n# 查询字符串场景和数字场景的结果。\nmysql> select a, a + 0 from bittest;\n+------+-------+\n| a    | a + 0 |\n+------+-------+\n| 9    |    57 |\n+------+-------+\n1 row in set (0.03 sec)\n\n```\n\n*注：应该避免使用BIT类型，若需要一个bit的存储空间存储一个true/false的值，可以创建一个可以为空的char(0)的列，该列可以保存空值（null）或者长度为0的字符串（空字符串）。*\n\n\n\n##### 1.5.2 SET\n\n若需要保存很多true/false的值，可以考虑合并这些列的到一个SET数据类型，它在MySql内部是以一系列打包的位的集合来表示的。MySQL提供了`FIND_IN_SET()`和`FIELD()`函数，方便地查询。\n\n**缺点**：<u>改变列的定义代价较高，需要alter table，这对大表来说是非常昂贵的操作。并且，也无法在SET列上通过索引查询</u>。\n\n\n\n**SET的改变操作代价较高，有什么替代的解决方案吗？**\n\n一种替代SET的方式是`使用一个整数包装一系列的位`。\n\n\n\n例如：可以把8个位包装到一个`TINYINT`中，并且按位操作来使用。可以在应用中为每个位定义名称常量来简化这个操作。\n\n示例：实现保存权限的访问控制列表（ACL）,每个没或者SET元素代表一个值，列入`CAN_READ`、`CAN_WRITE`或`CAN_DELETE`。\n\n- ①、使用SET列来存储。\n\n```mysql\n# 建表\ncreate table acl (\n  perms set('CAN_READ','CAN_WRITE','CAN_DELETE') not null  \n);\n# 写数据\ninsert into acl(perms) values ('CAN_READ,CAN_DELETE');\n# 查询\nmysql> select perms from acl where find_in_set('CAN_READ',perms);\n+---------------------+\n| perms               |\n+---------------------+\n| CAN_READ,CAN_DELETE |\n+---------------------+\n1 rows in set (0.00 sec)\n```\n\n- ②、使用整数列来存储。\n\n```mysql\n# 定义字段值。\nset @CAN_READ := 1<<0,\n    @CAN_WRITE := 1<<1,\n    @CAN_DELETE := 1<<2;\n# 建表\ncreate table acl_int (\n    perms tinyint unsigned not null default 0\n);\n# 写数据\ninsert into acl_int(perms) values (@CAN_READ + @CAN_DELETE);\n# 查询\nmysql> select perms from acl_int where perms & @CAN_READ;\n+-------+\n| perms |\n+-------+\n|     5 |\n+-------+\n1 row in set (0.07 sec)\n```\n\n\n\n#### 1.6 选择标识符（identifier）\n\n选择标识符的小技巧：\n\n- ①、`整数类型`：整数通常是标识列最好的选择，因为他们很快并且可以使用`auto_increment`.\n\n- ②、`尽量不要选择enum和set类型`：enum和set列适合存储固定信息，例如有序的状态、产品类型、人的性别。\n\n- ③、`尽量避免使用字符串类型作为标识符`：因为字符串类型很消耗空间，并且通常比数字类型慢。（*对于MyISAM*\n\n*默认对字符串使用压缩索引，会使查询变得更慢。*）\n\n\n\n### 2 范式和反范式\n\n#### 2.1 范式\n\n`MySQL的三大范式`：\n\n- 第一范式：确保数据表中`每列（字段）的原子性`，没有冗余属性；\n- 第二范式：在第一范式的基础上，目标是`确保表中的每列和主键相关`。\n- 第三范式：在第二范式的基础上，确保表中和`列和主键直接相关，而不是间接相关`。\n\n\n\n示例：下表为“雇员、部门、部门领导”的示例。\n\n```\nEMPLOYEE DEPARTMENT HEAD \nJones Accounting Jones \nSmith Engineering Smith \nBrown Accounting Jones \nGreen Engineering Smith \n```\n\n缺点：`若此时Say Brown接管Accounting部门的领导，需要修改多行来反应这个变化。`\n\n\n\n`范式化`方式为拆分雇员和部门项，以两张表存储。\n\n```\n# 雇员表\nEMPLOYEE_NAME DEPARTMENT\nJones Accounting \nSmith Engineering \nBrown Accounting \nGreen Engineering \n\n# 部门表\nDEPARTMENT HEAD \nAccounting Jones \nEngineering Smith \nAccounting Jones \nEngineering Smith \n```\n\n\n\n##### 2.1.1 范式的优缺点\n\n优点：\n\n- 范式化的更新操作通常比反范式化要快；\n- 当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。\n- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。\n- 很少有多余的数据，意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句。\n\n\n\n缺点：\n\n- 通常需要关联。稍微复杂一些的查询语句在符合范式的shcema上都可能需要至少一次关联，或者更多。（该问题可以通过在业务上实现关联）\n\n\n\n#### 2.2 反范式\n\n反范式化指的是`通过增加冗余或重复的数据来提高数据库的读性能`。\n\n##### 2.2.1 反范式的优缺点\n\n优点：\n\n- 反范式化的schema因为所有数据都在一张表中，可以更好的避免关联。\n- 若不需要关联，则对于大部分查询最差的情况（全表扫描），可以避免随机I/O，会比关联的情况快很多。\n- 一张表可以更有效的使用索引策略。\n\n缺点：\n\n​\t修改一个数据，可能需要修改多行来反映。\n\n\n\n### 3 加快alter table操作的速度\n\nMySQL执行大部分修改表结构的操作的方法是`用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表`。在数据量大的情况下，很耗时。\n\n大部分alter table操作将`导致MySQL服务中断`。\n\n\n\n对于常见的场景，技巧有：\n\n- ① 先在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换。\n\n- ② “影子拷贝”，影子拷贝用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张。或这是用工具完成拷贝工作。\n\n其余内容见参考资料1，懒得写了。\n\n\n\n### 参考资料\n\n1. 高性能MySQL_第三版\n\n2. [MySQL三大范式和反范式](https://www.cnblogs.com/moxiaotao/p/10120672.html)","source":"_posts/高性能MySQL-Schema与数据类型优化.md","raw":"---\ntitle: 高性能MySQL-Schema与数据类型优化\ndate: 2020-09-04 14:44:08\ntags: [\"MySQL\",\"Note\"]\ncategories: [\"MySQL\", \"Note\", \"高性能MySQL\"]\n---\n\n\n\n### 1 选择优化的数据类型\n\n- ①、`更小的通常更好`：更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，且处理时需要的CPU周期也更少。选择不会超过范围的最小类型。\n\n  <!--more-->\n\n- ②、`简单就好`：简单数据类型的操作通常需要更少的CPU周期，例如：\n\n- - a、整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。\n  - b、应使用mysql内建的类型来存储时间和日期（date,time,datetime），而不是字符串来存储日期和时间。\n  - c、应使用整型存储IP地址。\n\n- ③、`避免使用null`：最好使用列作为not null，除非真的需要存储null值，原因如下：\n\n- - a、若查询中包含可为null的列，对MySQL来说很难优化，因为可为null的列使得索引、索引统计和值都更复杂。\n  - b、可为null的列可能会使用更多的存储空间，在MySQL里需要特殊处理。\n  - c、当可为null的列被索引时，每个索引记录需要一个额外的字节\n\n（例外：InnoDB使用单独位（bit）存储null值，对于叙述数据有很好的空间效率，但不适用与MyISAM。）\n\n\n\n**为列选择数据类型的步骤？**\n\n- ①、确定适合的大类型，例如：数字、字符串、时间等。\n- ②、选择具体的类型。（注：很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不同、允许的精度不同，需要的物理空间（内存和磁盘）不同）。\n\n例如：datetime和timestamp列都可以存储相同类型的数据，时间和日期，精确到秒。但timestamp只使用datetime一半的存储空间，并且会根据时区变化，具有特殊自动更新能力。另一方面，timestamp允许的时间范围要小很多，有时候它的特殊能力会成为障碍。\n\n\n\n关于别名：Mysql支持很多别名，例如INTEGER,BOOL,以及NUMERIC。若建表使用的数据类型的别名，使用`show create table`检查时，会发现mysql报告的是基本类型，而不是别名。\n\n\n\n#### 1.1 整数类型\n\nMySQL支持两种类型的数字：`整数`和`实数`。\n\n\n\n其中,MySql整数类型有`TINYINT`，`SMALLINT`，`MEDEIUMINT`，`INT`，`BIGINT`。分别使用`8，16，24，32，64`位存储空间，其存储值得范围从-2^(N-1)到2^(N-1)-1，其中N是存储空间的位数。\n\n关于`UNSIGNED`属性，<u>表示不允许为负值，加上此属性，可以使正数的上限提高一倍。</u>\n\n（*注：有符号和无符号类型使用相同的存储空间，并且具有相同的性能。*）\n\n\n\n<u>Mysql可以为整数类型指定宽度。但它不会限制值的合法范围，只是规定Mysql的一些交互工具用来显示字符的个数</u>。例如，对于存储和运算INT(1)和INT(20)是相同的。\n\n\n\n#### 1.2 实数类型\n\n`实数是带有小数部分的数字`。它不仅可以存储小数，还可以使用DECIMAL存储比BIGINT还大的整数类型。\n\nMysql既支持`精确类型（指的decimal`），也支持`不精确类型（float及double类型）`。\t\n\n- `FLOAT`和`DOUBLE`类型支持使用标准的浮点运算进行近似计算，其计算与所使用的平台浮点数计算有关。\n\n- `DECIMAL`类型用于存储精确的小数（但仅限于MySQL5.0及更高版本，其实现是由MYSQL服务器自身实现的。），MYSQL4.1之前的版本中，DECEIMAL只是一个“存储类型”。\n\n\n\n浮点和decimal类型都可以指定精度。对于decimal列，可以指定小数点前后所允许的最大位数。\n\n（Mysql5.0和更高的版本将数字打包保存到一个二进制字符串中，每4个字节存9个数字，实现参考 https://zhidao.baidu.com/question/565903719525546284.html \n\n​     32位的2进制能表示最大的十进制数字是4294967295，一共有10位；除了最高的十亿位，其他九个位都能够表示0-9；也就是说MySQL的decimal类型在保存大数时并不是将单个十进制数字映射成二进制数保存。\n\n）\n\n`浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间`。float使用4个字节存储，double使用8个字节。`MySQL使用double作为内部浮点计算的类型。`\n\n（因为decimal需要额外的开销，所以应该尽量只在对小数进行精确计算时才使用decimal，例如财务数据。在数据量比较大的时候，可以考虑使用bigint代替decimal，然后将需要存储的货币单位根据小数的尾数乘以相应的倍数。）\n\n\n\n#### 1.3 字符串类型\n\nMySQL支持多种字符串类型，`varchar和char类型是最主要字符串类型`。其存储方式与存储引擎的具体实现有关。与varchar和char类似的类型还有`binary和varbinary，他们存储的是二进制字符串`。\n\n\n\n##### 1.3.1 varchar\n\n`varchar`类型用于`存储可变长字符串`，是最常见的字符串数据类型。（它比定长类型更节省空间，因为它仅使用必要的空间。例外的情况，若MySQL表使用`ROW_FORMAT=FIXED`创建，则每一行都会使用定长存储。）\n\n`varchar需要使用1或2个额外的字节记录字符串的长度`：若列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。\n\n\n\n**使用varchar(5)和varchar(200)存储‘hello‘的空间开销是一样的，那么使用短的列有什么优势吗？**\n\nMySQL通常会分配固定大小的内存块来保存内部值，因此更长的列会消耗更多的内存。尤其是使用内存临时表进行排序或操作时会特别糟糕，在利用磁盘临时表进行排序也同样糟糕。因此最好的策略是只分配真正需要的空间。\n\n\n\n**varchar类型的优缺点？**\n\n`优点`：节省存储空间，对性能有所帮助。\n\n`缺点`：由于行时变长的，在update时可能使行变得比原来更长，这就需要做额外的工作。例如，若行占用的空间增长，在页内没有更多的空间可以存储，MyISAM会拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。\n\n\n\n**那些场景下使用varchar类型是合适的？**\n\n- ①、字符串列的最大长度比平均长度大很多。\n- ②、列的更新很少，所以碎片不是问题。\n\n\n\n##### 1.3.2 char\n\n`char`类型是`定长的`，MySQL总是根据定义字符串长度分配足够的空间。\n\n\n\n**那些场景下使用char类型是合适的？**\n\n- ①、char适合存储很短的字符串；（例如：用char（1）来存储只有Y和N的值，采用单字节字符集只需要一个字节，但是varchar却需要两个字节，因为还需要另一个用于记录长度的额外的字节）\n- ②、存储所有值都接近同一个长度的字符串；（例如，存储密码的MD5值，因为这是一个定长的值。）\n- ③、存储经常变更的数据。\n\n\n\n##### 1.3.3 BLOB和TEXT类型\n\n`BLOB`和`TEXT`都是为存储很大的数据而设计的字符串数据类型，`分别采用二进制和字符方式存储`。\n\n- `BLOB类型采用二进制方式存储`，没有排序规则或者字符集，其家族包含：TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。\n- `TEXT类型采用字符串方式存储`，有字符集合排序规则，其家族包含：TINYTEXT、SMALLTEXT、TEXT、MEDIEMTEXT、LONGTEXT。\n\n\n\n**相对于MySQL的其他类型，BLOB和TEXT有什么不同点？**\n\n- ①、BLOB和TEXT只对每个列的最前`max_sort_length`字节而不是整个字符串做排序，若只排序前面一小部分字符，可以减小`max_sort_length`的配置，或者使用ORDER BY SUSTRING(column,length)。\n- ②、不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。\n\n\n\n##### 1.3.4 使用枚举（ENUM）代替字符串类型\n\n有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列值的数量压缩到一个或者两个字节中。\n\nMySQL在内部会将每个值在列表中的位置保存为整数，并且在表的`.frm文件`中保存“数字-字符串”映射关系的“查找表”。\n\n\n\n示例:\n\n```mysql\n# 建表\ncreate table enum_test (\n    e enum('fish', 'apple', 'dog') not null\n);\n\n# 写数据\ninsert into enum_test(e) values ('fish'),('dog'),('apple');\n\n# 枚举值实际存储的是整数,而不是字符串.\nmysql> select e+0 from enum_test;\n+-----+\n| e+0 |\n+-----+\n|   1 |\n|   3 |\n|   2 |\n+-----+\n3 rows in set (0.03 sec)\n\n# 枚举字段排序时按照内部存储的整数,而不是定义的字符串进行排序的.\nmysql> select e from enum_test order by e;\n+-------+\n| e     |\n+-------+\n| fish  |\n| apple |\n| dog   |\n+-------+\n3 rows in set (0.07 sec)\n```\n\n\n\n注:\n\n- a. 应该避免使用数字作为enum枚举常量.\n\n- b. `枚举字段排序时按照内部存储的整数,而不是定义的字符串进行排序的`.\n\n\n\n**枚举类型的缺点?**\n\n- `字符串列表是固定的,添加或删除字符串必须使用alter table`.因此,对于一系列未来可能会改变的字符串,枚举并不是一个好主意.\n\n- 每个枚举值保存为整数,并且必须进行查找才能转换为字符串,所以枚举列有一些开销.\n\n\n\n**枚举类型的优点？**\n\n- 转换后让表的大小及主键大小缩小了。\n\n\n\n#### 1.4 日期和时间类型\n\nMySQL可以使用许多类型来保存日期和时间值，例如，YEAR和DATE。`MySQL能存储的是最小时间粒度为秒`。\n\nMySQL提供两种相似的日期类型：`DATETIME`和`TIMESTAMP`。\n\n\n\n##### 1.4.1 DATETIME\n\n`DATETIME`将日期和时间封装到格式为`YYYYMMDDHHMMSS`的整数中，与时区无关。使用`8个字节`的存储空间。默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值，例如：“2018-01-16 22:37:08”。\n\n\n\n##### 1.4.2 TIMESTAMP（推荐）\n\n`TIMESTAMP`类型保存了1970年1月1日以来的秒数，它与Unix时间戳相同。使用`4个字节`的存储空间。只能表示从1970到2038年。\n\nMySQL提供了以下两个函数，对时间戳和日期进行转化。\n\n- `FROM_UNIXTIME()`：把Unix时间戳转换为日期。\n- `UNIX_TIMESTAMP()`：把日期转换为Unix时间戳。\n\nTIMESTAMP显示的值依赖于时区，MySQL服务器、客户端连接都有时区设置。\n\n\n\n**MySQL存储的时间都是以秒为粒度，若需要存储以秒为更小粒度的日期和时间值应该怎么处理？**\n\n- ①、可以使用`BIGINT类型`存储微秒级别的时间戳。\n\n- ②、可以使用`DOUBLE`存储秒之后的小数部分。\n\n- ③、可以使用MariaDB替代MySQL。\n\n\n\n#### 1.5 位数据类型\n\nMySQL有少数几种存储类型使用紧凑的位存储数据，`所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型`。\n\n##### 1.5.1 BIT\n\n可以使用Bit列在一列中存储一个或多个true/false值，BIT列最大长度为64个位。例如，BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位。\n\n<u>注：MySQL将BIT当做字符串类型，而不是数字类型。</u>当检索BIT(1)的值，结果是一个包含二进制0或1的字符串，而不是ASCII码的“0”或者“1”。在和数字上下文的场景中检索时，结果将是位字符串转换成的数字。\n\n例如：若存储一个值b‘00111001’到BIT(8)的列并检索它，得到的内容是字符码57的字符串（即ASCII码的字符“9”），在数字上下文场景中，得到的是数字57.\n\n```mysql\n# 创建测试表。\ncreate table bittest(a bit(8));\n# 写入数据。\ninsert bittest values (b'00111001');\n# 查询字符串场景和数字场景的结果。\nmysql> select a, a + 0 from bittest;\n+------+-------+\n| a    | a + 0 |\n+------+-------+\n| 9    |    57 |\n+------+-------+\n1 row in set (0.03 sec)\n\n```\n\n*注：应该避免使用BIT类型，若需要一个bit的存储空间存储一个true/false的值，可以创建一个可以为空的char(0)的列，该列可以保存空值（null）或者长度为0的字符串（空字符串）。*\n\n\n\n##### 1.5.2 SET\n\n若需要保存很多true/false的值，可以考虑合并这些列的到一个SET数据类型，它在MySql内部是以一系列打包的位的集合来表示的。MySQL提供了`FIND_IN_SET()`和`FIELD()`函数，方便地查询。\n\n**缺点**：<u>改变列的定义代价较高，需要alter table，这对大表来说是非常昂贵的操作。并且，也无法在SET列上通过索引查询</u>。\n\n\n\n**SET的改变操作代价较高，有什么替代的解决方案吗？**\n\n一种替代SET的方式是`使用一个整数包装一系列的位`。\n\n\n\n例如：可以把8个位包装到一个`TINYINT`中，并且按位操作来使用。可以在应用中为每个位定义名称常量来简化这个操作。\n\n示例：实现保存权限的访问控制列表（ACL）,每个没或者SET元素代表一个值，列入`CAN_READ`、`CAN_WRITE`或`CAN_DELETE`。\n\n- ①、使用SET列来存储。\n\n```mysql\n# 建表\ncreate table acl (\n  perms set('CAN_READ','CAN_WRITE','CAN_DELETE') not null  \n);\n# 写数据\ninsert into acl(perms) values ('CAN_READ,CAN_DELETE');\n# 查询\nmysql> select perms from acl where find_in_set('CAN_READ',perms);\n+---------------------+\n| perms               |\n+---------------------+\n| CAN_READ,CAN_DELETE |\n+---------------------+\n1 rows in set (0.00 sec)\n```\n\n- ②、使用整数列来存储。\n\n```mysql\n# 定义字段值。\nset @CAN_READ := 1<<0,\n    @CAN_WRITE := 1<<1,\n    @CAN_DELETE := 1<<2;\n# 建表\ncreate table acl_int (\n    perms tinyint unsigned not null default 0\n);\n# 写数据\ninsert into acl_int(perms) values (@CAN_READ + @CAN_DELETE);\n# 查询\nmysql> select perms from acl_int where perms & @CAN_READ;\n+-------+\n| perms |\n+-------+\n|     5 |\n+-------+\n1 row in set (0.07 sec)\n```\n\n\n\n#### 1.6 选择标识符（identifier）\n\n选择标识符的小技巧：\n\n- ①、`整数类型`：整数通常是标识列最好的选择，因为他们很快并且可以使用`auto_increment`.\n\n- ②、`尽量不要选择enum和set类型`：enum和set列适合存储固定信息，例如有序的状态、产品类型、人的性别。\n\n- ③、`尽量避免使用字符串类型作为标识符`：因为字符串类型很消耗空间，并且通常比数字类型慢。（*对于MyISAM*\n\n*默认对字符串使用压缩索引，会使查询变得更慢。*）\n\n\n\n### 2 范式和反范式\n\n#### 2.1 范式\n\n`MySQL的三大范式`：\n\n- 第一范式：确保数据表中`每列（字段）的原子性`，没有冗余属性；\n- 第二范式：在第一范式的基础上，目标是`确保表中的每列和主键相关`。\n- 第三范式：在第二范式的基础上，确保表中和`列和主键直接相关，而不是间接相关`。\n\n\n\n示例：下表为“雇员、部门、部门领导”的示例。\n\n```\nEMPLOYEE DEPARTMENT HEAD \nJones Accounting Jones \nSmith Engineering Smith \nBrown Accounting Jones \nGreen Engineering Smith \n```\n\n缺点：`若此时Say Brown接管Accounting部门的领导，需要修改多行来反应这个变化。`\n\n\n\n`范式化`方式为拆分雇员和部门项，以两张表存储。\n\n```\n# 雇员表\nEMPLOYEE_NAME DEPARTMENT\nJones Accounting \nSmith Engineering \nBrown Accounting \nGreen Engineering \n\n# 部门表\nDEPARTMENT HEAD \nAccounting Jones \nEngineering Smith \nAccounting Jones \nEngineering Smith \n```\n\n\n\n##### 2.1.1 范式的优缺点\n\n优点：\n\n- 范式化的更新操作通常比反范式化要快；\n- 当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。\n- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。\n- 很少有多余的数据，意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句。\n\n\n\n缺点：\n\n- 通常需要关联。稍微复杂一些的查询语句在符合范式的shcema上都可能需要至少一次关联，或者更多。（该问题可以通过在业务上实现关联）\n\n\n\n#### 2.2 反范式\n\n反范式化指的是`通过增加冗余或重复的数据来提高数据库的读性能`。\n\n##### 2.2.1 反范式的优缺点\n\n优点：\n\n- 反范式化的schema因为所有数据都在一张表中，可以更好的避免关联。\n- 若不需要关联，则对于大部分查询最差的情况（全表扫描），可以避免随机I/O，会比关联的情况快很多。\n- 一张表可以更有效的使用索引策略。\n\n缺点：\n\n​\t修改一个数据，可能需要修改多行来反映。\n\n\n\n### 3 加快alter table操作的速度\n\nMySQL执行大部分修改表结构的操作的方法是`用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表`。在数据量大的情况下，很耗时。\n\n大部分alter table操作将`导致MySQL服务中断`。\n\n\n\n对于常见的场景，技巧有：\n\n- ① 先在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换。\n\n- ② “影子拷贝”，影子拷贝用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张。或这是用工具完成拷贝工作。\n\n其余内容见参考资料1，懒得写了。\n\n\n\n### 参考资料\n\n1. 高性能MySQL_第三版\n\n2. [MySQL三大范式和反范式](https://www.cnblogs.com/moxiaotao/p/10120672.html)","slug":"高性能MySQL-Schema与数据类型优化","published":1,"updated":"2020-09-21T02:25:01.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabo5006n45g3delg7512","content":"<h3 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1 选择优化的数据类型\"></a>1 选择优化的数据类型</h3><ul>\n<li><p>①、<code>更小的通常更好</code>：更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，且处理时需要的CPU周期也更少。选择不会超过范围的最小类型。</p>\n<a id=\"more\"></a>\n</li>\n<li><p>②、<code>简单就好</code>：简单数据类型的操作通常需要更少的CPU周期，例如：</p>\n</li>\n<li><ul>\n<li>a、整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。</li>\n<li>b、应使用mysql内建的类型来存储时间和日期（date,time,datetime），而不是字符串来存储日期和时间。</li>\n<li>c、应使用整型存储IP地址。</li>\n</ul>\n</li>\n<li><p>③、<code>避免使用null</code>：最好使用列作为not null，除非真的需要存储null值，原因如下：</p>\n</li>\n<li><ul>\n<li>a、若查询中包含可为null的列，对MySQL来说很难优化，因为可为null的列使得索引、索引统计和值都更复杂。</li>\n<li>b、可为null的列可能会使用更多的存储空间，在MySQL里需要特殊处理。</li>\n<li>c、当可为null的列被索引时，每个索引记录需要一个额外的字节</li>\n</ul>\n</li>\n</ul>\n<p>（例外：InnoDB使用单独位（bit）存储null值，对于叙述数据有很好的空间效率，但不适用与MyISAM。）</p>\n<p><strong>为列选择数据类型的步骤？</strong></p>\n<ul>\n<li>①、确定适合的大类型，例如：数字、字符串、时间等。</li>\n<li>②、选择具体的类型。（注：很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不同、允许的精度不同，需要的物理空间（内存和磁盘）不同）。</li>\n</ul>\n<p>例如：datetime和timestamp列都可以存储相同类型的数据，时间和日期，精确到秒。但timestamp只使用datetime一半的存储空间，并且会根据时区变化，具有特殊自动更新能力。另一方面，timestamp允许的时间范围要小很多，有时候它的特殊能力会成为障碍。</p>\n<p>关于别名：Mysql支持很多别名，例如INTEGER,BOOL,以及NUMERIC。若建表使用的数据类型的别名，使用<code>show create table</code>检查时，会发现mysql报告的是基本类型，而不是别名。</p>\n<h4 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h4><p>MySQL支持两种类型的数字：<code>整数</code>和<code>实数</code>。</p>\n<p>其中,MySql整数类型有<code>TINYINT</code>，<code>SMALLINT</code>，<code>MEDEIUMINT</code>，<code>INT</code>，<code>BIGINT</code>。分别使用<code>8，16，24，32，64</code>位存储空间，其存储值得范围从-2^(N-1)到2^(N-1)-1，其中N是存储空间的位数。</p>\n<p>关于<code>UNSIGNED</code>属性，<u>表示不允许为负值，加上此属性，可以使正数的上限提高一倍。</u></p>\n<p>（<em>注：有符号和无符号类型使用相同的存储空间，并且具有相同的性能。</em>）</p>\n<p><u>Mysql可以为整数类型指定宽度。但它不会限制值的合法范围，只是规定Mysql的一些交互工具用来显示字符的个数</u>。例如，对于存储和运算INT(1)和INT(20)是相同的。</p>\n<h4 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h4><p><code>实数是带有小数部分的数字</code>。它不仅可以存储小数，还可以使用DECIMAL存储比BIGINT还大的整数类型。</p>\n<p>Mysql既支持<code>精确类型（指的decimal</code>），也支持<code>不精确类型（float及double类型）</code>。    </p>\n<ul>\n<li><p><code>FLOAT</code>和<code>DOUBLE</code>类型支持使用标准的浮点运算进行近似计算，其计算与所使用的平台浮点数计算有关。</p>\n</li>\n<li><p><code>DECIMAL</code>类型用于存储精确的小数（但仅限于MySQL5.0及更高版本，其实现是由MYSQL服务器自身实现的。），MYSQL4.1之前的版本中，DECEIMAL只是一个“存储类型”。</p>\n</li>\n</ul>\n<p>浮点和decimal类型都可以指定精度。对于decimal列，可以指定小数点前后所允许的最大位数。</p>\n<p>（Mysql5.0和更高的版本将数字打包保存到一个二进制字符串中，每4个字节存9个数字，实现参考 <a href=\"https://zhidao.baidu.com/question/565903719525546284.html\">https://zhidao.baidu.com/question/565903719525546284.html</a> </p>\n<p>​     32位的2进制能表示最大的十进制数字是4294967295，一共有10位；除了最高的十亿位，其他九个位都能够表示0-9；也就是说MySQL的decimal类型在保存大数时并不是将单个十进制数字映射成二进制数保存。</p>\n<p>）</p>\n<p><code>浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间</code>。float使用4个字节存储，double使用8个字节。<code>MySQL使用double作为内部浮点计算的类型。</code></p>\n<p>（因为decimal需要额外的开销，所以应该尽量只在对小数进行精确计算时才使用decimal，例如财务数据。在数据量比较大的时候，可以考虑使用bigint代替decimal，然后将需要存储的货币单位根据小数的尾数乘以相应的倍数。）</p>\n<h4 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h4><p>MySQL支持多种字符串类型，<code>varchar和char类型是最主要字符串类型</code>。其存储方式与存储引擎的具体实现有关。与varchar和char类似的类型还有<code>binary和varbinary，他们存储的是二进制字符串</code>。</p>\n<h5 id=\"1-3-1-varchar\"><a href=\"#1-3-1-varchar\" class=\"headerlink\" title=\"1.3.1 varchar\"></a>1.3.1 varchar</h5><p><code>varchar</code>类型用于<code>存储可变长字符串</code>，是最常见的字符串数据类型。（它比定长类型更节省空间，因为它仅使用必要的空间。例外的情况，若MySQL表使用<code>ROW_FORMAT=FIXED</code>创建，则每一行都会使用定长存储。）</p>\n<p><code>varchar需要使用1或2个额外的字节记录字符串的长度</code>：若列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。</p>\n<p><strong>使用varchar(5)和varchar(200)存储‘hello‘的空间开销是一样的，那么使用短的列有什么优势吗？</strong></p>\n<p>MySQL通常会分配固定大小的内存块来保存内部值，因此更长的列会消耗更多的内存。尤其是使用内存临时表进行排序或操作时会特别糟糕，在利用磁盘临时表进行排序也同样糟糕。因此最好的策略是只分配真正需要的空间。</p>\n<p><strong>varchar类型的优缺点？</strong></p>\n<p><code>优点</code>：节省存储空间，对性能有所帮助。</p>\n<p><code>缺点</code>：由于行时变长的，在update时可能使行变得比原来更长，这就需要做额外的工作。例如，若行占用的空间增长，在页内没有更多的空间可以存储，MyISAM会拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。</p>\n<p><strong>那些场景下使用varchar类型是合适的？</strong></p>\n<ul>\n<li>①、字符串列的最大长度比平均长度大很多。</li>\n<li>②、列的更新很少，所以碎片不是问题。</li>\n</ul>\n<h5 id=\"1-3-2-char\"><a href=\"#1-3-2-char\" class=\"headerlink\" title=\"1.3.2 char\"></a>1.3.2 char</h5><p><code>char</code>类型是<code>定长的</code>，MySQL总是根据定义字符串长度分配足够的空间。</p>\n<p><strong>那些场景下使用char类型是合适的？</strong></p>\n<ul>\n<li>①、char适合存储很短的字符串；（例如：用char（1）来存储只有Y和N的值，采用单字节字符集只需要一个字节，但是varchar却需要两个字节，因为还需要另一个用于记录长度的额外的字节）</li>\n<li>②、存储所有值都接近同一个长度的字符串；（例如，存储密码的MD5值，因为这是一个定长的值。）</li>\n<li>③、存储经常变更的数据。</li>\n</ul>\n<h5 id=\"1-3-3-BLOB和TEXT类型\"><a href=\"#1-3-3-BLOB和TEXT类型\" class=\"headerlink\" title=\"1.3.3 BLOB和TEXT类型\"></a>1.3.3 BLOB和TEXT类型</h5><p><code>BLOB</code>和<code>TEXT</code>都是为存储很大的数据而设计的字符串数据类型，<code>分别采用二进制和字符方式存储</code>。</p>\n<ul>\n<li><code>BLOB类型采用二进制方式存储</code>，没有排序规则或者字符集，其家族包含：TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。</li>\n<li><code>TEXT类型采用字符串方式存储</code>，有字符集合排序规则，其家族包含：TINYTEXT、SMALLTEXT、TEXT、MEDIEMTEXT、LONGTEXT。</li>\n</ul>\n<p><strong>相对于MySQL的其他类型，BLOB和TEXT有什么不同点？</strong></p>\n<ul>\n<li>①、BLOB和TEXT只对每个列的最前<code>max_sort_length</code>字节而不是整个字符串做排序，若只排序前面一小部分字符，可以减小<code>max_sort_length</code>的配置，或者使用ORDER BY SUSTRING(column,length)。</li>\n<li>②、不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。</li>\n</ul>\n<h5 id=\"1-3-4-使用枚举（ENUM）代替字符串类型\"><a href=\"#1-3-4-使用枚举（ENUM）代替字符串类型\" class=\"headerlink\" title=\"1.3.4 使用枚举（ENUM）代替字符串类型\"></a>1.3.4 使用枚举（ENUM）代替字符串类型</h5><p>有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列值的数量压缩到一个或者两个字节中。</p>\n<p>MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的<code>.frm文件</code>中保存“数字-字符串”映射关系的“查找表”。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建表</span><br><span class=\"line\">create table enum_test (</span><br><span class=\"line\">    e enum(&#39;fish&#39;, &#39;apple&#39;, &#39;dog&#39;) not null</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"># 写数据</span><br><span class=\"line\">insert into enum_test(e) values (&#39;fish&#39;),(&#39;dog&#39;),(&#39;apple&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"># 枚举值实际存储的是整数,而不是字符串.</span><br><span class=\"line\">mysql&gt; select e+0 from enum_test;</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">| e+0 |</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">|   1 |</span><br><span class=\"line\">|   3 |</span><br><span class=\"line\">|   2 |</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">3 rows in set (0.03 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"># 枚举字段排序时按照内部存储的整数,而不是定义的字符串进行排序的.</span><br><span class=\"line\">mysql&gt; select e from enum_test order by e;</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">| e     |</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">| fish  |</span><br><span class=\"line\">| apple |</span><br><span class=\"line\">| dog   |</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">3 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注:</p>\n<ul>\n<li><p>a. 应该避免使用数字作为enum枚举常量.</p>\n</li>\n<li><p>b. <code>枚举字段排序时按照内部存储的整数,而不是定义的字符串进行排序的</code>.</p>\n</li>\n</ul>\n<p><strong>枚举类型的缺点?</strong></p>\n<ul>\n<li><p><code>字符串列表是固定的,添加或删除字符串必须使用alter table</code>.因此,对于一系列未来可能会改变的字符串,枚举并不是一个好主意.</p>\n</li>\n<li><p>每个枚举值保存为整数,并且必须进行查找才能转换为字符串,所以枚举列有一些开销.</p>\n</li>\n</ul>\n<p><strong>枚举类型的优点？</strong></p>\n<ul>\n<li>转换后让表的大小及主键大小缩小了。</li>\n</ul>\n<h4 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h4><p>MySQL可以使用许多类型来保存日期和时间值，例如，YEAR和DATE。<code>MySQL能存储的是最小时间粒度为秒</code>。</p>\n<p>MySQL提供两种相似的日期类型：<code>DATETIME</code>和<code>TIMESTAMP</code>。</p>\n<h5 id=\"1-4-1-DATETIME\"><a href=\"#1-4-1-DATETIME\" class=\"headerlink\" title=\"1.4.1 DATETIME\"></a>1.4.1 DATETIME</h5><p><code>DATETIME</code>将日期和时间封装到格式为<code>YYYYMMDDHHMMSS</code>的整数中，与时区无关。使用<code>8个字节</code>的存储空间。默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值，例如：“2018-01-16 22:37:08”。</p>\n<h5 id=\"1-4-2-TIMESTAMP（推荐）\"><a href=\"#1-4-2-TIMESTAMP（推荐）\" class=\"headerlink\" title=\"1.4.2 TIMESTAMP（推荐）\"></a>1.4.2 TIMESTAMP（推荐）</h5><p><code>TIMESTAMP</code>类型保存了1970年1月1日以来的秒数，它与Unix时间戳相同。使用<code>4个字节</code>的存储空间。只能表示从1970到2038年。</p>\n<p>MySQL提供了以下两个函数，对时间戳和日期进行转化。</p>\n<ul>\n<li><code>FROM_UNIXTIME()</code>：把Unix时间戳转换为日期。</li>\n<li><code>UNIX_TIMESTAMP()</code>：把日期转换为Unix时间戳。</li>\n</ul>\n<p>TIMESTAMP显示的值依赖于时区，MySQL服务器、客户端连接都有时区设置。</p>\n<p><strong>MySQL存储的时间都是以秒为粒度，若需要存储以秒为更小粒度的日期和时间值应该怎么处理？</strong></p>\n<ul>\n<li><p>①、可以使用<code>BIGINT类型</code>存储微秒级别的时间戳。</p>\n</li>\n<li><p>②、可以使用<code>DOUBLE</code>存储秒之后的小数部分。</p>\n</li>\n<li><p>③、可以使用MariaDB替代MySQL。</p>\n</li>\n</ul>\n<h4 id=\"1-5-位数据类型\"><a href=\"#1-5-位数据类型\" class=\"headerlink\" title=\"1.5 位数据类型\"></a>1.5 位数据类型</h4><p>MySQL有少数几种存储类型使用紧凑的位存储数据，<code>所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型</code>。</p>\n<h5 id=\"1-5-1-BIT\"><a href=\"#1-5-1-BIT\" class=\"headerlink\" title=\"1.5.1 BIT\"></a>1.5.1 BIT</h5><p>可以使用Bit列在一列中存储一个或多个true/false值，BIT列最大长度为64个位。例如，BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位。</p>\n<p><u>注：MySQL将BIT当做字符串类型，而不是数字类型。</u>当检索BIT(1)的值，结果是一个包含二进制0或1的字符串，而不是ASCII码的“0”或者“1”。在和数字上下文的场景中检索时，结果将是位字符串转换成的数字。</p>\n<p>例如：若存储一个值b‘00111001’到BIT(8)的列并检索它，得到的内容是字符码57的字符串（即ASCII码的字符“9”），在数字上下文场景中，得到的是数字57.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建测试表。</span><br><span class=\"line\">create table bittest(a bit(8));</span><br><span class=\"line\"># 写入数据。</span><br><span class=\"line\">insert bittest values (b&#39;00111001&#39;);</span><br><span class=\"line\"># 查询字符串场景和数字场景的结果。</span><br><span class=\"line\">mysql&gt; select a, a + 0 from bittest;</span><br><span class=\"line\">+------+-------+</span><br><span class=\"line\">| a    | a + 0 |</span><br><span class=\"line\">+------+-------+</span><br><span class=\"line\">| 9    |    57 |</span><br><span class=\"line\">+------+-------+</span><br><span class=\"line\">1 row in set (0.03 sec)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><em>注：应该避免使用BIT类型，若需要一个bit的存储空间存储一个true/false的值，可以创建一个可以为空的char(0)的列，该列可以保存空值（null）或者长度为0的字符串（空字符串）。</em></p>\n<h5 id=\"1-5-2-SET\"><a href=\"#1-5-2-SET\" class=\"headerlink\" title=\"1.5.2 SET\"></a>1.5.2 SET</h5><p>若需要保存很多true/false的值，可以考虑合并这些列的到一个SET数据类型，它在MySql内部是以一系列打包的位的集合来表示的。MySQL提供了<code>FIND_IN_SET()</code>和<code>FIELD()</code>函数，方便地查询。</p>\n<p><strong>缺点</strong>：<u>改变列的定义代价较高，需要alter table，这对大表来说是非常昂贵的操作。并且，也无法在SET列上通过索引查询</u>。</p>\n<p><strong>SET的改变操作代价较高，有什么替代的解决方案吗？</strong></p>\n<p>一种替代SET的方式是<code>使用一个整数包装一系列的位</code>。</p>\n<p>例如：可以把8个位包装到一个<code>TINYINT</code>中，并且按位操作来使用。可以在应用中为每个位定义名称常量来简化这个操作。</p>\n<p>示例：实现保存权限的访问控制列表（ACL）,每个没或者SET元素代表一个值，列入<code>CAN_READ</code>、<code>CAN_WRITE</code>或<code>CAN_DELETE</code>。</p>\n<ul>\n<li>①、使用SET列来存储。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建表</span><br><span class=\"line\">create table acl (</span><br><span class=\"line\">  perms set(&#39;CAN_READ&#39;,&#39;CAN_WRITE&#39;,&#39;CAN_DELETE&#39;) not null  </span><br><span class=\"line\">);</span><br><span class=\"line\"># 写数据</span><br><span class=\"line\">insert into acl(perms) values (&#39;CAN_READ,CAN_DELETE&#39;);</span><br><span class=\"line\"># 查询</span><br><span class=\"line\">mysql&gt; select perms from acl where find_in_set(&#39;CAN_READ&#39;,perms);</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">| perms               |</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">| CAN_READ,CAN_DELETE |</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">1 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、使用整数列来存储。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 定义字段值。</span><br><span class=\"line\">set @CAN_READ :&#x3D; 1&lt;&lt;0,</span><br><span class=\"line\">    @CAN_WRITE :&#x3D; 1&lt;&lt;1,</span><br><span class=\"line\">    @CAN_DELETE :&#x3D; 1&lt;&lt;2;</span><br><span class=\"line\"># 建表</span><br><span class=\"line\">create table acl_int (</span><br><span class=\"line\">    perms tinyint unsigned not null default 0</span><br><span class=\"line\">);</span><br><span class=\"line\"># 写数据</span><br><span class=\"line\">insert into acl_int(perms) values (@CAN_READ + @CAN_DELETE);</span><br><span class=\"line\"># 查询</span><br><span class=\"line\">mysql&gt; select perms from acl_int where perms &amp; @CAN_READ;</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">| perms |</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">|     5 |</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">1 row in set (0.07 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-6-选择标识符（identifier）\"><a href=\"#1-6-选择标识符（identifier）\" class=\"headerlink\" title=\"1.6 选择标识符（identifier）\"></a>1.6 选择标识符（identifier）</h4><p>选择标识符的小技巧：</p>\n<ul>\n<li><p>①、<code>整数类型</code>：整数通常是标识列最好的选择，因为他们很快并且可以使用<code>auto_increment</code>.</p>\n</li>\n<li><p>②、<code>尽量不要选择enum和set类型</code>：enum和set列适合存储固定信息，例如有序的状态、产品类型、人的性别。</p>\n</li>\n<li><p>③、<code>尽量避免使用字符串类型作为标识符</code>：因为字符串类型很消耗空间，并且通常比数字类型慢。（<em>对于MyISAM</em></p>\n</li>\n</ul>\n<p><em>默认对字符串使用压缩索引，会使查询变得更慢。</em>）</p>\n<h3 id=\"2-范式和反范式\"><a href=\"#2-范式和反范式\" class=\"headerlink\" title=\"2 范式和反范式\"></a>2 范式和反范式</h3><h4 id=\"2-1-范式\"><a href=\"#2-1-范式\" class=\"headerlink\" title=\"2.1 范式\"></a>2.1 范式</h4><p><code>MySQL的三大范式</code>：</p>\n<ul>\n<li>第一范式：确保数据表中<code>每列（字段）的原子性</code>，没有冗余属性；</li>\n<li>第二范式：在第一范式的基础上，目标是<code>确保表中的每列和主键相关</code>。</li>\n<li>第三范式：在第二范式的基础上，确保表中和<code>列和主键直接相关，而不是间接相关</code>。</li>\n</ul>\n<p>示例：下表为“雇员、部门、部门领导”的示例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EMPLOYEE DEPARTMENT HEAD </span><br><span class=\"line\">Jones Accounting Jones </span><br><span class=\"line\">Smith Engineering Smith </span><br><span class=\"line\">Brown Accounting Jones </span><br><span class=\"line\">Green Engineering Smith </span><br></pre></td></tr></table></figure>\n\n<p>缺点：<code>若此时Say Brown接管Accounting部门的领导，需要修改多行来反应这个变化。</code></p>\n<p><code>范式化</code>方式为拆分雇员和部门项，以两张表存储。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 雇员表</span><br><span class=\"line\">EMPLOYEE_NAME DEPARTMENT</span><br><span class=\"line\">Jones Accounting </span><br><span class=\"line\">Smith Engineering </span><br><span class=\"line\">Brown Accounting </span><br><span class=\"line\">Green Engineering </span><br><span class=\"line\"></span><br><span class=\"line\"># 部门表</span><br><span class=\"line\">DEPARTMENT HEAD </span><br><span class=\"line\">Accounting Jones </span><br><span class=\"line\">Engineering Smith </span><br><span class=\"line\">Accounting Jones </span><br><span class=\"line\">Engineering Smith </span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-1-1-范式的优缺点\"><a href=\"#2-1-1-范式的优缺点\" class=\"headerlink\" title=\"2.1.1 范式的优缺点\"></a>2.1.1 范式的优缺点</h5><p>优点：</p>\n<ul>\n<li>范式化的更新操作通常比反范式化要快；</li>\n<li>当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。</li>\n<li>范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。</li>\n<li>很少有多余的数据，意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>通常需要关联。稍微复杂一些的查询语句在符合范式的shcema上都可能需要至少一次关联，或者更多。（该问题可以通过在业务上实现关联）</li>\n</ul>\n<h4 id=\"2-2-反范式\"><a href=\"#2-2-反范式\" class=\"headerlink\" title=\"2.2 反范式\"></a>2.2 反范式</h4><p>反范式化指的是<code>通过增加冗余或重复的数据来提高数据库的读性能</code>。</p>\n<h5 id=\"2-2-1-反范式的优缺点\"><a href=\"#2-2-1-反范式的优缺点\" class=\"headerlink\" title=\"2.2.1 反范式的优缺点\"></a>2.2.1 反范式的优缺点</h5><p>优点：</p>\n<ul>\n<li>反范式化的schema因为所有数据都在一张表中，可以更好的避免关联。</li>\n<li>若不需要关联，则对于大部分查询最差的情况（全表扫描），可以避免随机I/O，会比关联的情况快很多。</li>\n<li>一张表可以更有效的使用索引策略。</li>\n</ul>\n<p>缺点：</p>\n<p>​    修改一个数据，可能需要修改多行来反映。</p>\n<h3 id=\"3-加快alter-table操作的速度\"><a href=\"#3-加快alter-table操作的速度\" class=\"headerlink\" title=\"3 加快alter table操作的速度\"></a>3 加快alter table操作的速度</h3><p>MySQL执行大部分修改表结构的操作的方法是<code>用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表</code>。在数据量大的情况下，很耗时。</p>\n<p>大部分alter table操作将<code>导致MySQL服务中断</code>。</p>\n<p>对于常见的场景，技巧有：</p>\n<ul>\n<li><p>① 先在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换。</p>\n</li>\n<li><p>② “影子拷贝”，影子拷贝用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张。或这是用工具完成拷贝工作。</p>\n</li>\n</ul>\n<p>其余内容见参考资料1，懒得写了。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><p>高性能MySQL_第三版</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/moxiaotao/p/10120672.html\">MySQL三大范式和反范式</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1 选择优化的数据类型\"></a>1 选择优化的数据类型</h3><ul>\n<li><p>①、<code>更小的通常更好</code>：更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，且处理时需要的CPU周期也更少。选择不会超过范围的最小类型。</p>","more":"</li>\n<li><p>②、<code>简单就好</code>：简单数据类型的操作通常需要更少的CPU周期，例如：</p>\n</li>\n<li><ul>\n<li>a、整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。</li>\n<li>b、应使用mysql内建的类型来存储时间和日期（date,time,datetime），而不是字符串来存储日期和时间。</li>\n<li>c、应使用整型存储IP地址。</li>\n</ul>\n</li>\n<li><p>③、<code>避免使用null</code>：最好使用列作为not null，除非真的需要存储null值，原因如下：</p>\n</li>\n<li><ul>\n<li>a、若查询中包含可为null的列，对MySQL来说很难优化，因为可为null的列使得索引、索引统计和值都更复杂。</li>\n<li>b、可为null的列可能会使用更多的存储空间，在MySQL里需要特殊处理。</li>\n<li>c、当可为null的列被索引时，每个索引记录需要一个额外的字节</li>\n</ul>\n</li>\n</ul>\n<p>（例外：InnoDB使用单独位（bit）存储null值，对于叙述数据有很好的空间效率，但不适用与MyISAM。）</p>\n<p><strong>为列选择数据类型的步骤？</strong></p>\n<ul>\n<li>①、确定适合的大类型，例如：数字、字符串、时间等。</li>\n<li>②、选择具体的类型。（注：很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不同、允许的精度不同，需要的物理空间（内存和磁盘）不同）。</li>\n</ul>\n<p>例如：datetime和timestamp列都可以存储相同类型的数据，时间和日期，精确到秒。但timestamp只使用datetime一半的存储空间，并且会根据时区变化，具有特殊自动更新能力。另一方面，timestamp允许的时间范围要小很多，有时候它的特殊能力会成为障碍。</p>\n<p>关于别名：Mysql支持很多别名，例如INTEGER,BOOL,以及NUMERIC。若建表使用的数据类型的别名，使用<code>show create table</code>检查时，会发现mysql报告的是基本类型，而不是别名。</p>\n<h4 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h4><p>MySQL支持两种类型的数字：<code>整数</code>和<code>实数</code>。</p>\n<p>其中,MySql整数类型有<code>TINYINT</code>，<code>SMALLINT</code>，<code>MEDEIUMINT</code>，<code>INT</code>，<code>BIGINT</code>。分别使用<code>8，16，24，32，64</code>位存储空间，其存储值得范围从-2^(N-1)到2^(N-1)-1，其中N是存储空间的位数。</p>\n<p>关于<code>UNSIGNED</code>属性，<u>表示不允许为负值，加上此属性，可以使正数的上限提高一倍。</u></p>\n<p>（<em>注：有符号和无符号类型使用相同的存储空间，并且具有相同的性能。</em>）</p>\n<p><u>Mysql可以为整数类型指定宽度。但它不会限制值的合法范围，只是规定Mysql的一些交互工具用来显示字符的个数</u>。例如，对于存储和运算INT(1)和INT(20)是相同的。</p>\n<h4 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h4><p><code>实数是带有小数部分的数字</code>。它不仅可以存储小数，还可以使用DECIMAL存储比BIGINT还大的整数类型。</p>\n<p>Mysql既支持<code>精确类型（指的decimal</code>），也支持<code>不精确类型（float及double类型）</code>。    </p>\n<ul>\n<li><p><code>FLOAT</code>和<code>DOUBLE</code>类型支持使用标准的浮点运算进行近似计算，其计算与所使用的平台浮点数计算有关。</p>\n</li>\n<li><p><code>DECIMAL</code>类型用于存储精确的小数（但仅限于MySQL5.0及更高版本，其实现是由MYSQL服务器自身实现的。），MYSQL4.1之前的版本中，DECEIMAL只是一个“存储类型”。</p>\n</li>\n</ul>\n<p>浮点和decimal类型都可以指定精度。对于decimal列，可以指定小数点前后所允许的最大位数。</p>\n<p>（Mysql5.0和更高的版本将数字打包保存到一个二进制字符串中，每4个字节存9个数字，实现参考 <a href=\"https://zhidao.baidu.com/question/565903719525546284.html\">https://zhidao.baidu.com/question/565903719525546284.html</a> </p>\n<p>​     32位的2进制能表示最大的十进制数字是4294967295，一共有10位；除了最高的十亿位，其他九个位都能够表示0-9；也就是说MySQL的decimal类型在保存大数时并不是将单个十进制数字映射成二进制数保存。</p>\n<p>）</p>\n<p><code>浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间</code>。float使用4个字节存储，double使用8个字节。<code>MySQL使用double作为内部浮点计算的类型。</code></p>\n<p>（因为decimal需要额外的开销，所以应该尽量只在对小数进行精确计算时才使用decimal，例如财务数据。在数据量比较大的时候，可以考虑使用bigint代替decimal，然后将需要存储的货币单位根据小数的尾数乘以相应的倍数。）</p>\n<h4 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h4><p>MySQL支持多种字符串类型，<code>varchar和char类型是最主要字符串类型</code>。其存储方式与存储引擎的具体实现有关。与varchar和char类似的类型还有<code>binary和varbinary，他们存储的是二进制字符串</code>。</p>\n<h5 id=\"1-3-1-varchar\"><a href=\"#1-3-1-varchar\" class=\"headerlink\" title=\"1.3.1 varchar\"></a>1.3.1 varchar</h5><p><code>varchar</code>类型用于<code>存储可变长字符串</code>，是最常见的字符串数据类型。（它比定长类型更节省空间，因为它仅使用必要的空间。例外的情况，若MySQL表使用<code>ROW_FORMAT=FIXED</code>创建，则每一行都会使用定长存储。）</p>\n<p><code>varchar需要使用1或2个额外的字节记录字符串的长度</code>：若列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。</p>\n<p><strong>使用varchar(5)和varchar(200)存储‘hello‘的空间开销是一样的，那么使用短的列有什么优势吗？</strong></p>\n<p>MySQL通常会分配固定大小的内存块来保存内部值，因此更长的列会消耗更多的内存。尤其是使用内存临时表进行排序或操作时会特别糟糕，在利用磁盘临时表进行排序也同样糟糕。因此最好的策略是只分配真正需要的空间。</p>\n<p><strong>varchar类型的优缺点？</strong></p>\n<p><code>优点</code>：节省存储空间，对性能有所帮助。</p>\n<p><code>缺点</code>：由于行时变长的，在update时可能使行变得比原来更长，这就需要做额外的工作。例如，若行占用的空间增长，在页内没有更多的空间可以存储，MyISAM会拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。</p>\n<p><strong>那些场景下使用varchar类型是合适的？</strong></p>\n<ul>\n<li>①、字符串列的最大长度比平均长度大很多。</li>\n<li>②、列的更新很少，所以碎片不是问题。</li>\n</ul>\n<h5 id=\"1-3-2-char\"><a href=\"#1-3-2-char\" class=\"headerlink\" title=\"1.3.2 char\"></a>1.3.2 char</h5><p><code>char</code>类型是<code>定长的</code>，MySQL总是根据定义字符串长度分配足够的空间。</p>\n<p><strong>那些场景下使用char类型是合适的？</strong></p>\n<ul>\n<li>①、char适合存储很短的字符串；（例如：用char（1）来存储只有Y和N的值，采用单字节字符集只需要一个字节，但是varchar却需要两个字节，因为还需要另一个用于记录长度的额外的字节）</li>\n<li>②、存储所有值都接近同一个长度的字符串；（例如，存储密码的MD5值，因为这是一个定长的值。）</li>\n<li>③、存储经常变更的数据。</li>\n</ul>\n<h5 id=\"1-3-3-BLOB和TEXT类型\"><a href=\"#1-3-3-BLOB和TEXT类型\" class=\"headerlink\" title=\"1.3.3 BLOB和TEXT类型\"></a>1.3.3 BLOB和TEXT类型</h5><p><code>BLOB</code>和<code>TEXT</code>都是为存储很大的数据而设计的字符串数据类型，<code>分别采用二进制和字符方式存储</code>。</p>\n<ul>\n<li><code>BLOB类型采用二进制方式存储</code>，没有排序规则或者字符集，其家族包含：TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。</li>\n<li><code>TEXT类型采用字符串方式存储</code>，有字符集合排序规则，其家族包含：TINYTEXT、SMALLTEXT、TEXT、MEDIEMTEXT、LONGTEXT。</li>\n</ul>\n<p><strong>相对于MySQL的其他类型，BLOB和TEXT有什么不同点？</strong></p>\n<ul>\n<li>①、BLOB和TEXT只对每个列的最前<code>max_sort_length</code>字节而不是整个字符串做排序，若只排序前面一小部分字符，可以减小<code>max_sort_length</code>的配置，或者使用ORDER BY SUSTRING(column,length)。</li>\n<li>②、不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。</li>\n</ul>\n<h5 id=\"1-3-4-使用枚举（ENUM）代替字符串类型\"><a href=\"#1-3-4-使用枚举（ENUM）代替字符串类型\" class=\"headerlink\" title=\"1.3.4 使用枚举（ENUM）代替字符串类型\"></a>1.3.4 使用枚举（ENUM）代替字符串类型</h5><p>有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列值的数量压缩到一个或者两个字节中。</p>\n<p>MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的<code>.frm文件</code>中保存“数字-字符串”映射关系的“查找表”。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建表</span><br><span class=\"line\">create table enum_test (</span><br><span class=\"line\">    e enum(&#39;fish&#39;, &#39;apple&#39;, &#39;dog&#39;) not null</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"># 写数据</span><br><span class=\"line\">insert into enum_test(e) values (&#39;fish&#39;),(&#39;dog&#39;),(&#39;apple&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"># 枚举值实际存储的是整数,而不是字符串.</span><br><span class=\"line\">mysql&gt; select e+0 from enum_test;</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">| e+0 |</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">|   1 |</span><br><span class=\"line\">|   3 |</span><br><span class=\"line\">|   2 |</span><br><span class=\"line\">+-----+</span><br><span class=\"line\">3 rows in set (0.03 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"># 枚举字段排序时按照内部存储的整数,而不是定义的字符串进行排序的.</span><br><span class=\"line\">mysql&gt; select e from enum_test order by e;</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">| e     |</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">| fish  |</span><br><span class=\"line\">| apple |</span><br><span class=\"line\">| dog   |</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">3 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>注:</p>\n<ul>\n<li><p>a. 应该避免使用数字作为enum枚举常量.</p>\n</li>\n<li><p>b. <code>枚举字段排序时按照内部存储的整数,而不是定义的字符串进行排序的</code>.</p>\n</li>\n</ul>\n<p><strong>枚举类型的缺点?</strong></p>\n<ul>\n<li><p><code>字符串列表是固定的,添加或删除字符串必须使用alter table</code>.因此,对于一系列未来可能会改变的字符串,枚举并不是一个好主意.</p>\n</li>\n<li><p>每个枚举值保存为整数,并且必须进行查找才能转换为字符串,所以枚举列有一些开销.</p>\n</li>\n</ul>\n<p><strong>枚举类型的优点？</strong></p>\n<ul>\n<li>转换后让表的大小及主键大小缩小了。</li>\n</ul>\n<h4 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h4><p>MySQL可以使用许多类型来保存日期和时间值，例如，YEAR和DATE。<code>MySQL能存储的是最小时间粒度为秒</code>。</p>\n<p>MySQL提供两种相似的日期类型：<code>DATETIME</code>和<code>TIMESTAMP</code>。</p>\n<h5 id=\"1-4-1-DATETIME\"><a href=\"#1-4-1-DATETIME\" class=\"headerlink\" title=\"1.4.1 DATETIME\"></a>1.4.1 DATETIME</h5><p><code>DATETIME</code>将日期和时间封装到格式为<code>YYYYMMDDHHMMSS</code>的整数中，与时区无关。使用<code>8个字节</code>的存储空间。默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值，例如：“2018-01-16 22:37:08”。</p>\n<h5 id=\"1-4-2-TIMESTAMP（推荐）\"><a href=\"#1-4-2-TIMESTAMP（推荐）\" class=\"headerlink\" title=\"1.4.2 TIMESTAMP（推荐）\"></a>1.4.2 TIMESTAMP（推荐）</h5><p><code>TIMESTAMP</code>类型保存了1970年1月1日以来的秒数，它与Unix时间戳相同。使用<code>4个字节</code>的存储空间。只能表示从1970到2038年。</p>\n<p>MySQL提供了以下两个函数，对时间戳和日期进行转化。</p>\n<ul>\n<li><code>FROM_UNIXTIME()</code>：把Unix时间戳转换为日期。</li>\n<li><code>UNIX_TIMESTAMP()</code>：把日期转换为Unix时间戳。</li>\n</ul>\n<p>TIMESTAMP显示的值依赖于时区，MySQL服务器、客户端连接都有时区设置。</p>\n<p><strong>MySQL存储的时间都是以秒为粒度，若需要存储以秒为更小粒度的日期和时间值应该怎么处理？</strong></p>\n<ul>\n<li><p>①、可以使用<code>BIGINT类型</code>存储微秒级别的时间戳。</p>\n</li>\n<li><p>②、可以使用<code>DOUBLE</code>存储秒之后的小数部分。</p>\n</li>\n<li><p>③、可以使用MariaDB替代MySQL。</p>\n</li>\n</ul>\n<h4 id=\"1-5-位数据类型\"><a href=\"#1-5-位数据类型\" class=\"headerlink\" title=\"1.5 位数据类型\"></a>1.5 位数据类型</h4><p>MySQL有少数几种存储类型使用紧凑的位存储数据，<code>所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型</code>。</p>\n<h5 id=\"1-5-1-BIT\"><a href=\"#1-5-1-BIT\" class=\"headerlink\" title=\"1.5.1 BIT\"></a>1.5.1 BIT</h5><p>可以使用Bit列在一列中存储一个或多个true/false值，BIT列最大长度为64个位。例如，BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位。</p>\n<p><u>注：MySQL将BIT当做字符串类型，而不是数字类型。</u>当检索BIT(1)的值，结果是一个包含二进制0或1的字符串，而不是ASCII码的“0”或者“1”。在和数字上下文的场景中检索时，结果将是位字符串转换成的数字。</p>\n<p>例如：若存储一个值b‘00111001’到BIT(8)的列并检索它，得到的内容是字符码57的字符串（即ASCII码的字符“9”），在数字上下文场景中，得到的是数字57.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建测试表。</span><br><span class=\"line\">create table bittest(a bit(8));</span><br><span class=\"line\"># 写入数据。</span><br><span class=\"line\">insert bittest values (b&#39;00111001&#39;);</span><br><span class=\"line\"># 查询字符串场景和数字场景的结果。</span><br><span class=\"line\">mysql&gt; select a, a + 0 from bittest;</span><br><span class=\"line\">+------+-------+</span><br><span class=\"line\">| a    | a + 0 |</span><br><span class=\"line\">+------+-------+</span><br><span class=\"line\">| 9    |    57 |</span><br><span class=\"line\">+------+-------+</span><br><span class=\"line\">1 row in set (0.03 sec)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><em>注：应该避免使用BIT类型，若需要一个bit的存储空间存储一个true/false的值，可以创建一个可以为空的char(0)的列，该列可以保存空值（null）或者长度为0的字符串（空字符串）。</em></p>\n<h5 id=\"1-5-2-SET\"><a href=\"#1-5-2-SET\" class=\"headerlink\" title=\"1.5.2 SET\"></a>1.5.2 SET</h5><p>若需要保存很多true/false的值，可以考虑合并这些列的到一个SET数据类型，它在MySql内部是以一系列打包的位的集合来表示的。MySQL提供了<code>FIND_IN_SET()</code>和<code>FIELD()</code>函数，方便地查询。</p>\n<p><strong>缺点</strong>：<u>改变列的定义代价较高，需要alter table，这对大表来说是非常昂贵的操作。并且，也无法在SET列上通过索引查询</u>。</p>\n<p><strong>SET的改变操作代价较高，有什么替代的解决方案吗？</strong></p>\n<p>一种替代SET的方式是<code>使用一个整数包装一系列的位</code>。</p>\n<p>例如：可以把8个位包装到一个<code>TINYINT</code>中，并且按位操作来使用。可以在应用中为每个位定义名称常量来简化这个操作。</p>\n<p>示例：实现保存权限的访问控制列表（ACL）,每个没或者SET元素代表一个值，列入<code>CAN_READ</code>、<code>CAN_WRITE</code>或<code>CAN_DELETE</code>。</p>\n<ul>\n<li>①、使用SET列来存储。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建表</span><br><span class=\"line\">create table acl (</span><br><span class=\"line\">  perms set(&#39;CAN_READ&#39;,&#39;CAN_WRITE&#39;,&#39;CAN_DELETE&#39;) not null  </span><br><span class=\"line\">);</span><br><span class=\"line\"># 写数据</span><br><span class=\"line\">insert into acl(perms) values (&#39;CAN_READ,CAN_DELETE&#39;);</span><br><span class=\"line\"># 查询</span><br><span class=\"line\">mysql&gt; select perms from acl where find_in_set(&#39;CAN_READ&#39;,perms);</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">| perms               |</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">| CAN_READ,CAN_DELETE |</span><br><span class=\"line\">+---------------------+</span><br><span class=\"line\">1 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>②、使用整数列来存储。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 定义字段值。</span><br><span class=\"line\">set @CAN_READ :&#x3D; 1&lt;&lt;0,</span><br><span class=\"line\">    @CAN_WRITE :&#x3D; 1&lt;&lt;1,</span><br><span class=\"line\">    @CAN_DELETE :&#x3D; 1&lt;&lt;2;</span><br><span class=\"line\"># 建表</span><br><span class=\"line\">create table acl_int (</span><br><span class=\"line\">    perms tinyint unsigned not null default 0</span><br><span class=\"line\">);</span><br><span class=\"line\"># 写数据</span><br><span class=\"line\">insert into acl_int(perms) values (@CAN_READ + @CAN_DELETE);</span><br><span class=\"line\"># 查询</span><br><span class=\"line\">mysql&gt; select perms from acl_int where perms &amp; @CAN_READ;</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">| perms |</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">|     5 |</span><br><span class=\"line\">+-------+</span><br><span class=\"line\">1 row in set (0.07 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"1-6-选择标识符（identifier）\"><a href=\"#1-6-选择标识符（identifier）\" class=\"headerlink\" title=\"1.6 选择标识符（identifier）\"></a>1.6 选择标识符（identifier）</h4><p>选择标识符的小技巧：</p>\n<ul>\n<li><p>①、<code>整数类型</code>：整数通常是标识列最好的选择，因为他们很快并且可以使用<code>auto_increment</code>.</p>\n</li>\n<li><p>②、<code>尽量不要选择enum和set类型</code>：enum和set列适合存储固定信息，例如有序的状态、产品类型、人的性别。</p>\n</li>\n<li><p>③、<code>尽量避免使用字符串类型作为标识符</code>：因为字符串类型很消耗空间，并且通常比数字类型慢。（<em>对于MyISAM</em></p>\n</li>\n</ul>\n<p><em>默认对字符串使用压缩索引，会使查询变得更慢。</em>）</p>\n<h3 id=\"2-范式和反范式\"><a href=\"#2-范式和反范式\" class=\"headerlink\" title=\"2 范式和反范式\"></a>2 范式和反范式</h3><h4 id=\"2-1-范式\"><a href=\"#2-1-范式\" class=\"headerlink\" title=\"2.1 范式\"></a>2.1 范式</h4><p><code>MySQL的三大范式</code>：</p>\n<ul>\n<li>第一范式：确保数据表中<code>每列（字段）的原子性</code>，没有冗余属性；</li>\n<li>第二范式：在第一范式的基础上，目标是<code>确保表中的每列和主键相关</code>。</li>\n<li>第三范式：在第二范式的基础上，确保表中和<code>列和主键直接相关，而不是间接相关</code>。</li>\n</ul>\n<p>示例：下表为“雇员、部门、部门领导”的示例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EMPLOYEE DEPARTMENT HEAD </span><br><span class=\"line\">Jones Accounting Jones </span><br><span class=\"line\">Smith Engineering Smith </span><br><span class=\"line\">Brown Accounting Jones </span><br><span class=\"line\">Green Engineering Smith </span><br></pre></td></tr></table></figure>\n\n<p>缺点：<code>若此时Say Brown接管Accounting部门的领导，需要修改多行来反应这个变化。</code></p>\n<p><code>范式化</code>方式为拆分雇员和部门项，以两张表存储。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 雇员表</span><br><span class=\"line\">EMPLOYEE_NAME DEPARTMENT</span><br><span class=\"line\">Jones Accounting </span><br><span class=\"line\">Smith Engineering </span><br><span class=\"line\">Brown Accounting </span><br><span class=\"line\">Green Engineering </span><br><span class=\"line\"></span><br><span class=\"line\"># 部门表</span><br><span class=\"line\">DEPARTMENT HEAD </span><br><span class=\"line\">Accounting Jones </span><br><span class=\"line\">Engineering Smith </span><br><span class=\"line\">Accounting Jones </span><br><span class=\"line\">Engineering Smith </span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-1-1-范式的优缺点\"><a href=\"#2-1-1-范式的优缺点\" class=\"headerlink\" title=\"2.1.1 范式的优缺点\"></a>2.1.1 范式的优缺点</h5><p>优点：</p>\n<ul>\n<li>范式化的更新操作通常比反范式化要快；</li>\n<li>当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。</li>\n<li>范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。</li>\n<li>很少有多余的数据，意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>通常需要关联。稍微复杂一些的查询语句在符合范式的shcema上都可能需要至少一次关联，或者更多。（该问题可以通过在业务上实现关联）</li>\n</ul>\n<h4 id=\"2-2-反范式\"><a href=\"#2-2-反范式\" class=\"headerlink\" title=\"2.2 反范式\"></a>2.2 反范式</h4><p>反范式化指的是<code>通过增加冗余或重复的数据来提高数据库的读性能</code>。</p>\n<h5 id=\"2-2-1-反范式的优缺点\"><a href=\"#2-2-1-反范式的优缺点\" class=\"headerlink\" title=\"2.2.1 反范式的优缺点\"></a>2.2.1 反范式的优缺点</h5><p>优点：</p>\n<ul>\n<li>反范式化的schema因为所有数据都在一张表中，可以更好的避免关联。</li>\n<li>若不需要关联，则对于大部分查询最差的情况（全表扫描），可以避免随机I/O，会比关联的情况快很多。</li>\n<li>一张表可以更有效的使用索引策略。</li>\n</ul>\n<p>缺点：</p>\n<p>​    修改一个数据，可能需要修改多行来反映。</p>\n<h3 id=\"3-加快alter-table操作的速度\"><a href=\"#3-加快alter-table操作的速度\" class=\"headerlink\" title=\"3 加快alter table操作的速度\"></a>3 加快alter table操作的速度</h3><p>MySQL执行大部分修改表结构的操作的方法是<code>用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表</code>。在数据量大的情况下，很耗时。</p>\n<p>大部分alter table操作将<code>导致MySQL服务中断</code>。</p>\n<p>对于常见的场景，技巧有：</p>\n<ul>\n<li><p>① 先在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换。</p>\n</li>\n<li><p>② “影子拷贝”，影子拷贝用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张。或这是用工具完成拷贝工作。</p>\n</li>\n</ul>\n<p>其余内容见参考资料1，懒得写了。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><p>高性能MySQL_第三版</p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/moxiaotao/p/10120672.html\">MySQL三大范式和反范式</a></p>\n</li>\n</ol>"},{"title":"高性能MySQL-事务基础","date":"2020-09-09T07:05:02.000Z","_content":"\n#### 1、简介\n事务是一组原子性的SQL查询，或者说一个独立的工作单元。事务将数据库从一种一致状态转换为另一种一致状态,事务内的语句，要么全部执行成功，要么全部执行失败。\n\n<!--more-->\n\n#### 2、事务的ACID概念\n- `A： 原子性（automicity）`\n一个事务必须被视为一个不可分割的最小单元，整个事务中所有的操作要么全部提交成功，要么全部失败回滚。\n```\n问题: \n    对于单核单进程单个指令操作需要考虑事务的原子性吗?\n\n理解:\n    首先我们知道,在计算机中的大概分层如下,其次数据库的数据实际是存储在磁盘上,因此,针对单条指令,如insert,插入一条数\n据到数据库,实际上是由应用层/CPU(针对不同的编程语言可能会不同,如C语言可编译为二进制形式直接在CPU上运行,而PHP等\n语言需要通过OS)执行代码将需要的数据存储到磁盘中,此时若出现操作系统崩溃或者异常掉电的情况,则可能出现数据不一致的情况.\n\n结论:即使单核单进程单条指令操作也是需要考虑事务的原子性.\n\n 应用层\n-------\n  OS层\n-------\n  CPU\n-------\n  内存\n-------\n  磁盘\n-------\n\n```\n- `C： 一致性（consistency）`\n数据库总是从一个一致性的状态转换到另一个一致性的状态。保证数据库的完整性约束没有被破坏.\n```\n例如:\n    在表t中有一个字段id,为唯一约束,即在表中id不能重复.假设当前表t中有一条id=1的记录,此时事务A对id=1的记录进行了删\n除但尚未提交,事务B又创建了一个id=1的记录并提交,事务A回滚,若没有一致性约束,此时表t中存在两条id=1的记录,违反了id为唯一约束.\n\nTrans A              Trans B\n\nStart T\ndelete id =1\n \n                      Start T\n                      insert id=1\n                      Commit T\nRollback T\n```\n\n- `I： 隔离性（isolation）`\n    通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。（*与隔离级别有关*)\n\n    <u>通常通过锁来实现</u>,当前数据库系统中都提供了一种粒度锁(granular lock)的策略,允许事务仅锁住一个实体对象的子集,以此来提高事务之间的并发度.\n    \n- `D： 持久性（durability）`\n一旦事务提交，则其所作的修改就会永久保存到数据库中。\n\n#### 3、隔离级别\n在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间是可见的，哪些是不可见的。  \n*（不同事物的隔离级别，实际上是一致性与并发性的一个权衡与折中。）*\n\n\n\n##### 3.1 READ UNCOMMITTED（未提交读）（不推荐）\n\n事务中的修改，即使没有提交，对其他事务也是可见的。\n- 优点：性能上比另外三种级别好很多（并发性高）。\n- 缺点：读取到未提交的数据，出现**脏读**。且缺乏其他级别的好处（`一致性最差`）。\n\n###### 3.1.1 InnoDB的实现方式\nInnoDB在此种事务隔离级别下，select语句不加锁（官方文档原文：SELECT statements are performed in a nonlocking fashion.）。\n\n\n\n##### 3.2 READ COMMITTED（提交读）（别名：不可重复读）\n\n事务开始直到提交之前，所做的任何修改对其他事务都是不可见的。\n- 缺点：不可重复读，当两次执行同样的查询，可能会得到不一样的结果。  \n\n###### 3.2.1 InnoDB的实现方式\n- 普通读是快照读；\n- 加锁的select，update，delete等语句，除了在外面约束检查以及重复键检查时会封锁区间，其他时刻都只使用记录锁；此时其他事务的插入依旧可以执行，就可能导致幻读。\n\n\n\n##### 3.3 REPEATABLE READ（可重复读）——Mysql的默认事务隔离级别\n\n该级别解决了`脏读`的问题，且保证同一个事务中多次读取同样的记录结果是一致的。\n- 缺点：可能会出现幻读，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围插入了新的记录，就会产生幻行。\n- 解决： InnoDB和XtraDB通过`多版本并发控制（MVCC, Multiversion Concurrency Control）`解决了上述缺点。\n\n###### 3.3.1 InnoDB的实现方式\nRR隔离级别为InnoDB的默认隔离级别。\n\n①、普通的select使用快照读（snapshot read），这是一种不加锁的一致性读（Consistent Nonlocking Read），底层使用MVCC来实现。\n\n②、加锁的select（select ... in share mode/select ... fro update）,update，delete等语句，他们的锁，依赖于他们<u>是否在唯一索引上使用了唯一的查询条件，或者范围查询条件</u>：\n- 在唯一索引上使用唯一的查询条件，会使用`记录锁（record lock）`，而不会封锁记录之间的间隔，即不会使用间隙锁（gap lock）和临键锁（next-key lock）。\n- 范围查询条件，会使用`间隙锁与临键锁`，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻行记录，及避免不可重读的读。\n\n\n\n##### 3.4 SERIALIZABLE（可串行化）\n\n强制事务串行执行，避免可重复读的幻读问题。\n- 有点：一致性最好\n- 缺点：该级别会在读取的每一行数据加锁，可能导致大量的超时和锁争用问题（**并发性最差**）。\n\n###### 3.4.1 InnoDB的实现方式\n这种事务的隔离级别下，所有的select语句都会被隐式的转化为select ... in share mode.  \n\n这可能导致，如果有未提交的事务正在修改某些行，所有读取这些行的select都会被阻塞（官方文档原文：To force a plain SELECT to block if other transactions have modified the selected rows.）。\n\n---\n\n\n关于“脏读”，“不可重复读”，“幻读”示例：\n\n```\n假设有InnoDB表：\nt(id PK, name);\n \n表中有三条记录：\n1, shenjian\n2, zhangsan\n3, lisi\n```\n\n- 脏读\n  \n  脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据．\n  \n```\n    事务A，先执行，处于未提交的状态：\n    insert into t values(4, wangwu);\n \n    事务B，后执行，也未提交：\n    select * from t;\n   \n    如果事务B能够读取到(4, wangwu)这条记录，事务A就对事务B产生了影响，这个影响叫做“读脏”，读到了未提交事务操作的记录。\n```\n\n- 不可重复读\n  \n    不可重复读是指在一个事务中多次读取同一数据集合，在这个事务还没结束时，另一个事务也访问了该数据集合，并做了DML操作．导致第一个事务多次读取到的数据不一样．\n    \n```\n    事务A，先执行：\n    select * from t where id=1;\n \n    结果集为：\n    1, shenjian\n     \n事务B，后执行，并且提交：\n    update t set name=xxoo where id=1;\n    commit;\n \n    事务A，再次执行相同的查询：\n    select * from t where id=1;\n \n    结果集为：\n    1, xxoo\n     \n    这次是已提交事务B对事务A产生的影响，这个影响叫做“不可重复读”，一个事务内相同的查询，得到了不同的结果。\n```\n\n- 幻读\n    ```\n    事务A，先执行：\n    select * from t where id>3;\n \n    结果集为：\n    NULL\n        \n    事务B，后执行，并且提交：\n    insert into t values(4, wangwu);\n    commit;\n \n    事务A，首次查询了id>3的结果为NULL，于是想插入一条为4的记录：\n    insert into t values(4, xxoo);\n \n    结果集为：\n    Error : duplicate key!\n \n    事务A的内心OS是：你TM在逗我，查了id>3为空集，insert id=4告诉我PK冲突？\n \n    这次是已提交事务B对事务A产生的影响，这个影响叫做“幻读”。\n    ```\n    \n\n---\n\n\n#### 4、死锁\n死锁是指`两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。`\n\n解决方式：\n- ①、数据库系统实现了各种死锁检测和死锁超时机制。\n（`InnoDB处理方式：将持有最少行级排它锁的事务进行回滚`）\n- ②、当查询的时间达到锁等待超时的设定后当其锁请求。\n\n\n\n示例：\n\n```mysql\n事务A：\n    start transaction;\n    update stockprice set close = 45.50 where stock_id =4 and date ='2020-05-01';\n    update stockprice set close = 19.80 where stock_id =3 and date = '2020-05-02';\n    commit;\n\n事务B：\n    start transaction；\n    update stockprice set close = 20.12 where stock_id = 3 and date = '2020-05-02';\n    update stockprice set close = 47.20 where stock_id = 4 and date = '2020-05-01';\n    commit;\n```\n\n\n\n#### 5、MySQL中的事务\n\nMysql提供了两种事务型存储引擎：`InnoDB`和`NDB Cluster`。\n\n- 设置自动提交模式\n\n  `Mysql默认采用自动提交模式`，即如果不是显式地开始一个事务，每个查询都被当做一个事务执行提交操作。更改自动提交的命令如下：\n```\nSET AUTOCOMMIT = 1;(0：启用，1：禁用)\n```\n- `设置隔离级别`\nMysql能识别所有的4个ANSI隔离级别，InnoDB也支持所有隔离级别。\n命令示例：\n```\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED\n```\n- Mysql中的事务是<u>由下层的存储引擎实现的，同一个事务中使用多种存储引擎是不可靠的</u>。\n\n\n\n#### 6、多版本并发控制（MVCC）\n\nMVCC可以被认为是行级锁的一个变种，但他在很多情况下避免了加锁操作，因此开销更低。\n\nMVCC的实现：**通过保存数据在某个时间点的快照来实现的。**\n\n典型的存储引擎的MVCC实现：\n\n- 乐观并发控制（optimistic）\n- 悲观并发控制（pessimistic）\n\n\n\n##### 6.1 InnoDB的MVCC的实现\n\nInnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列一个保存了行的创建时间（系统版本号），一个保存行的过期时间（删除时间）（系统版本号）。每开始一个新的事务，系统版本号都会自动递增。事务开始时的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号进行比较。\n\n\n\nREPEATABLE READ隔离级别下，MVCC具体操作：\n\n- `SELECT`  \nInnoDB会根据以下两个条件检索：\n    - a、InnoDB查找行的系统版本号小于/等于事务的系统版本号，确保事务读取的行，要么在事务开始前已经存在，要么是事务自身插入或修改过的。\n    - b、行的删除版本要么未定义，要么大于当前事务版本号，确保事务读取到的行，在事务开始前未被删除。\n\n- `INSERT`  \nInnoDB为新插入的每一行保存当前系统版本号作为行版本号。\n- `DELETE`  \nInnoDB为删除的每一行保存当前系统版本号作为行删除标识。\n- `UPDATE`  \nInnoDB为新插入的每一行保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。\n\n注：<u>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作</u>。（READ UNCOMMITTED总是读取最新的数据行，而SERIALIZABLE则会对所有读取的行都加锁）\n\n\n\n#### 7、Mysql终端模拟并发事务\n\n##### 7.1 几个关键的配置\n要测试InnoDB的锁互斥，以及死锁，有几个配置需要提前确认：\n- ①、区间锁（间隙锁，临键锁）是否关闭\n- ②、事务自动提交（auto commit）是否关闭\n- ③、事务的隔离级别\n\n\n###### 7.1.1 区间锁是否关闭\n区间锁（间隙锁，临键锁）是InnoDB特有施加在索引记录区间的锁，Mysql5.6可以手动关闭区间锁。  \n\n控制参数：\n\n```\ninnodb_locks_unsafe_for_binlog\n```\n该参数支持两个值：\n- ON: 表示关闭区间锁，此时一致性会被破坏（所以是unsafe）\n- OFF：表示开启区间锁（默认）\n\n查询该参数的方法：\n\n```\nmysql> show variables like 'innodb_locks%';\n+--------------------------------+-------+\n| Variable_name                  | Value |\n+--------------------------------+-------+\n| innodb_locks_unsafe_for_binlog | OFF   |\n+--------------------------------+-------+\n1 row in set (0.03 sec)\n```\n\n修改方法：修改配置文件（/etc/mysql/mysql.conf.d/mysqld.cnf）文件，添加更改选项并重新启动服务：\n\n```\ninnodb_locks_unsafe_for_binlog = 1\n```\n\n```\nsudo service mysql restart\n```\n\n\n\n###### 7.1.2 事务自动提交\n\nMysql默认把每一个单独的SQL语句作为一个事务，自动提交。\n\n控制参数：\n```\nautocommit\n```\n\nMySQL5.7默认开启\n```\nmysql> show variables like 'autocommit';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| autocommit    | ON    |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n设置（关闭）方式：\n\n```\nset session autocommit=0;\n```\n\n\n\n###### 7.1.3 事务的隔离级别\n\n不同事务的隔离级别，InnoDB的锁实现是不一样的。默认为repeatable read。\n\n控制参数：\n```\ntx_isolation\n```\n查询事务的隔离级别的方法：\n\n```\nmysql> show global variables like 'tx_isolation';\n+---------------+-----------------+\n| Variable_name | Value           |\n+---------------+-----------------+\n| tx_isolation  | REPEATABLE-READ |\n+---------------+-----------------+\n1 row in set (0.00 sec)\n```\n\n设置事务的隔离级别的方式：\n\n```\nset session transaction isolation level <X>';\n```\n其中X可取值为：\n- read uncommitted\n- read committed\n- repeatable read\n- serializable\n\n\n\n##### 7.2 模拟并发事务前准备工作\n\n- ①、配置准备\n  要模拟并发事务，需要修改事务自动提交这个选项，每个session要改为手动提交。\n\n```\nmysql> set session autocommit=0;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> show variables like 'autocommit';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| autocommit    | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n\n\n- ②、数据准备  \n  InnoDB的行锁都是实现在索引上，实验时可以使用主键，建表时设定为innodb引擎：\n\n  - 建表\n\n    ```\n    mysql> create table t_id_pk( id int(10) primary key) engine=innodb;\n    ```\n\n  - 准备初始数据\n\n    ```\n     mysql> insert into t_id_pk(id) values (1),(3),(10);\n    ```\n\n\n\n##### 7.3 实验\n\n###### 7.3.1 间隙锁互斥实验\n开启区间锁，RR的隔离级别下，上例会有以下四个区间：\n- （-infinity， 1）\n- （1， 3）\n- （3， 10）\n- （10， infinity）\n\n事务A删除某个某个区间不存在的记录，获取到**共享间隙锁**，会阻止其他事务B在相应的区间插入数据，因为插入需要获取**排他间隙锁**。  \nsessionA：\n\n```mysql\nmysql> set autocommit=0;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delete from t_id_pk where id = 5;\nQuery OK, 0 rows affected (0.05 sec)\n```\n\nsessionB：\n\n```mysql\nmysql> set autocommit=0;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(0);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(2);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(12);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(7);\n\n```\n事务B插入的值：0，2，12都不在（3， 10）区间内，能够插入，而7在（3， 10）这个区间，会阻塞。`若事务A一直不提交，事务B就会一直等待，直到超时`，超时后会有如下提示：\n\n```\nERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n```\n\n\n---\n可以`使用以下命令查看锁的情况`：\n\n```\nshow engine innodb status;\n```\n当前实验锁部分情况如下：\n\n```\nTRANSACTIONS\n------------\nTrx id counter 66634\nPurge done for trx's n:o < 66634 undo n:o < 0 state: running but idle\nHistory list length 20\nLIST OF TRANSACTIONS FOR EACH SESSION:\n---TRANSACTION 66629, ACTIVE 52 sec inserting\nmysql tables in use 1, locked 1\nLOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 3\nMySQL thread id 20, OS thread handle 140324098004736, query id 196 localhost root update\ninsert into t_id_pk(id)values(7)\n------- TRX HAS BEEN WAITING 38 SEC FOR THIS LOCK TO BE GRANTED:\nRECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table `seven`.`t_id_pk` trx id 66629 lock_mode X locks gap before rec insert intention waiting\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0\n 0: len 4; hex 8000000a; asc     ;;\n 1: len 6; hex 00000001043f; asc      ?;;\n 2: len 7; hex af00000123012a; asc     # *;;\n\n------------------\n```\n可知insert into t_id_pk(id)values(7)正在等待事务A提交或回滚，这样事务B就能获得相应的锁，以继续执行。\n\n---\n\n\n\n###### 7.3.2 共享排它锁的死锁实验\n\n该实验需要三个并发的session。\n\nsessionA：\n```\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id) values(7);\nQuery OK, 1 row affected (0.00 sec)\n```\n\nsessionB:\n```\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id) values(7);\n```\n\nsessionC:\n```\nmysql> set autocommit=0;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id) values(7);\n```\n此时三个事务都试图往表中插入一条为7的记录：\n- A先执行，插入成功，并获取id=7的`排它锁`；\n- B后执行，需要进行PK校验，故需要先获取id=7的`共享锁`，阻塞；\n- C后执行，也需要进行PK校验，也要先获取id=7的`共享锁`，阻塞；\n\n此时若sessionA执行：\n```\nmysql> rollback;\nQuery OK, 0 rows affected (0.11 sec)\n```\nid=7的排它锁释放，则B，C会继续进行主键校验：\n- ①、B会获取到id=7共享锁，主键未互斥；\n- ②、C也会获取到id=7共享锁，主键未互斥；  \nB和C要想插入成功，必须获得id=7的排他锁，但由于双方都已经获取到id=7的共享锁，它们都无法获取到彼此的排他锁，死锁就出现了。\n\n\n\nInnoDB有死锁检测机制，B和C中的一个事务会插入成功，另一个会自动放弃：\nsessionB：\n\n```\nmysql> insert into t_id_pk(id) values(7);\nERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\n```\nsessionC:\n```\nmysql> insert into t_id_pk(id) values(7);\nQuery OK, 1 row affected (7.40 sec)\n```\n\n\n\n###### 7.3.3 并发间隙锁的死锁\n\n共享排它锁，在并发量插入相同记录的情况下，相应的案例比较容易分析，而并发的间隙锁死锁，是比较难定位的。\n```mysql\nA：set session autocommit=0;\nA：start transaction;\nA：delete from t where id=6;\n         B：set session autocommit=0;\n         B：start transaction;\n         B：delete from t where id=7;\nA：insert into t values(5);\n         B：insert into t values(8);\n```\n\nsessionA:\n```mysql\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delete from t_id_pk  where id=6;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(5);\nQuery OK, 1 row affected (8.73 sec)\n```\n\nsessionB:\n```mysql\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delete from t_id_pk where id=7;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(8);\nERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\n```\n\n- A执行delete后，会获得(3, 10)的共享间隙锁。\n- B执行delete后，也会获得(3, 10)的共享间隙锁。\n- A执行insert后，希望获得(3, 10)的排他间隙锁，于是会阻塞。\n- B执行insert后，也希望获得(3, 10)的排他间隙锁，于是死锁出现。\n\n\n\n使用show engine innodb status查看死锁的情况：\n\n```\n2019-05-14 15:05:35 0x7f9fc003d700\n*** (1) TRANSACTION:\nTRANSACTION 66641, ACTIVE 58 sec inserting\nmysql tables in use 1, locked 1\nLOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)\nMySQL thread id 18, OS thread handle 140323966887680, query id 226 localhost root update\ninsert into t_id_pk(id)values(5)\n*** (1) WAITING FOR THIS LOCK TO BE GRANTED:\nRECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table `seven`.`t_id_pk` trx id 66641 lock_mode X locks gap before rec insert intention waiting\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0\n 0: len 4; hex 8000000a; asc     ;;\n 1: len 6; hex 00000001043f; asc      ?;;\n 2: len 7; hex af00000123012a; asc     # *;;\n\n*** (2) TRANSACTION:\nTRANSACTION 66642, ACTIVE 33 sec inserting\nmysql tables in use 1, locked 1\n3 lock struct(s), heap size 1136, 2 row lock(s)\nMySQL thread id 20, OS thread handle 140324098004736, query id 227 localhost root update\ninsert into t_id_pk(id)values(8)\n*** (2) HOLDS THE LOCK(S):\nRECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table `seven`.`t_id_pk` trx id 66642 lock_mode X locks gap before rec\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0\n 0: len 4; hex 8000000a; asc     ;;\n 1: len 6; hex 00000001043f; asc      ?;;\n 2: len 7; hex af00000123012a; asc     # *;;\n\n*** (2) WAITING FOR THIS LOCK TO BE GRANTED:\nRECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table `seven`.`t_id_pk` trx id 66642 lock_mode X locks gap before rec insert intention waiting\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0\n 0: len 4; hex 8000000a; asc     ;;\n 1: len 6; hex 00000001043f; asc      ?;;\n 2: len 7; hex af00000123012a; asc     # *;;\n\n*** WE ROLL BACK TRANSACTION (2)\n```\n\n从事务锁的情况可以看出，当检测到死锁后，事务2自动回滚了。\n\n\n\n总结：\n\n- ①、并发事务，间隙锁可能互斥；\n    - a. A删除不存在的记录，获取共享间隙锁；\n    - b. B插入，必须获得排他间隙锁，故互斥；\n- ②、并发插入相同的记录，可能死锁（某一个回滚）；\n- ③、并发插入，可能出现间隙锁死锁（难排查）。\n\n\n\n\n---\n#### 参考资料\n- 1. MySQL第三版\n- 2. [4种事务的隔离级别，InnoDB如何巧妙实现](https://mp.weixin.qq.com/s/x_7E2R2i27Ci5O7kLQF0UA)\n- 3. [超赞，InnoDB调试死锁的方法！](https://mp.weixin.qq.com/s/_36Sy0FldFRNvLRpHxfucQ)\n\n","source":"_posts/高性能MySQL-事务基础.md","raw":"---\ntitle: 高性能MySQL-事务基础\ndate: 2020-09-09 15:05:02\ntags: [\"MySQL\",\"Note\"]\ncategories: [\"MySQL\", \"Note\", \"高性能MySQL\"]\n---\n\n#### 1、简介\n事务是一组原子性的SQL查询，或者说一个独立的工作单元。事务将数据库从一种一致状态转换为另一种一致状态,事务内的语句，要么全部执行成功，要么全部执行失败。\n\n<!--more-->\n\n#### 2、事务的ACID概念\n- `A： 原子性（automicity）`\n一个事务必须被视为一个不可分割的最小单元，整个事务中所有的操作要么全部提交成功，要么全部失败回滚。\n```\n问题: \n    对于单核单进程单个指令操作需要考虑事务的原子性吗?\n\n理解:\n    首先我们知道,在计算机中的大概分层如下,其次数据库的数据实际是存储在磁盘上,因此,针对单条指令,如insert,插入一条数\n据到数据库,实际上是由应用层/CPU(针对不同的编程语言可能会不同,如C语言可编译为二进制形式直接在CPU上运行,而PHP等\n语言需要通过OS)执行代码将需要的数据存储到磁盘中,此时若出现操作系统崩溃或者异常掉电的情况,则可能出现数据不一致的情况.\n\n结论:即使单核单进程单条指令操作也是需要考虑事务的原子性.\n\n 应用层\n-------\n  OS层\n-------\n  CPU\n-------\n  内存\n-------\n  磁盘\n-------\n\n```\n- `C： 一致性（consistency）`\n数据库总是从一个一致性的状态转换到另一个一致性的状态。保证数据库的完整性约束没有被破坏.\n```\n例如:\n    在表t中有一个字段id,为唯一约束,即在表中id不能重复.假设当前表t中有一条id=1的记录,此时事务A对id=1的记录进行了删\n除但尚未提交,事务B又创建了一个id=1的记录并提交,事务A回滚,若没有一致性约束,此时表t中存在两条id=1的记录,违反了id为唯一约束.\n\nTrans A              Trans B\n\nStart T\ndelete id =1\n \n                      Start T\n                      insert id=1\n                      Commit T\nRollback T\n```\n\n- `I： 隔离性（isolation）`\n    通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。（*与隔离级别有关*)\n\n    <u>通常通过锁来实现</u>,当前数据库系统中都提供了一种粒度锁(granular lock)的策略,允许事务仅锁住一个实体对象的子集,以此来提高事务之间的并发度.\n    \n- `D： 持久性（durability）`\n一旦事务提交，则其所作的修改就会永久保存到数据库中。\n\n#### 3、隔离级别\n在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间是可见的，哪些是不可见的。  \n*（不同事物的隔离级别，实际上是一致性与并发性的一个权衡与折中。）*\n\n\n\n##### 3.1 READ UNCOMMITTED（未提交读）（不推荐）\n\n事务中的修改，即使没有提交，对其他事务也是可见的。\n- 优点：性能上比另外三种级别好很多（并发性高）。\n- 缺点：读取到未提交的数据，出现**脏读**。且缺乏其他级别的好处（`一致性最差`）。\n\n###### 3.1.1 InnoDB的实现方式\nInnoDB在此种事务隔离级别下，select语句不加锁（官方文档原文：SELECT statements are performed in a nonlocking fashion.）。\n\n\n\n##### 3.2 READ COMMITTED（提交读）（别名：不可重复读）\n\n事务开始直到提交之前，所做的任何修改对其他事务都是不可见的。\n- 缺点：不可重复读，当两次执行同样的查询，可能会得到不一样的结果。  \n\n###### 3.2.1 InnoDB的实现方式\n- 普通读是快照读；\n- 加锁的select，update，delete等语句，除了在外面约束检查以及重复键检查时会封锁区间，其他时刻都只使用记录锁；此时其他事务的插入依旧可以执行，就可能导致幻读。\n\n\n\n##### 3.3 REPEATABLE READ（可重复读）——Mysql的默认事务隔离级别\n\n该级别解决了`脏读`的问题，且保证同一个事务中多次读取同样的记录结果是一致的。\n- 缺点：可能会出现幻读，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围插入了新的记录，就会产生幻行。\n- 解决： InnoDB和XtraDB通过`多版本并发控制（MVCC, Multiversion Concurrency Control）`解决了上述缺点。\n\n###### 3.3.1 InnoDB的实现方式\nRR隔离级别为InnoDB的默认隔离级别。\n\n①、普通的select使用快照读（snapshot read），这是一种不加锁的一致性读（Consistent Nonlocking Read），底层使用MVCC来实现。\n\n②、加锁的select（select ... in share mode/select ... fro update）,update，delete等语句，他们的锁，依赖于他们<u>是否在唯一索引上使用了唯一的查询条件，或者范围查询条件</u>：\n- 在唯一索引上使用唯一的查询条件，会使用`记录锁（record lock）`，而不会封锁记录之间的间隔，即不会使用间隙锁（gap lock）和临键锁（next-key lock）。\n- 范围查询条件，会使用`间隙锁与临键锁`，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻行记录，及避免不可重读的读。\n\n\n\n##### 3.4 SERIALIZABLE（可串行化）\n\n强制事务串行执行，避免可重复读的幻读问题。\n- 有点：一致性最好\n- 缺点：该级别会在读取的每一行数据加锁，可能导致大量的超时和锁争用问题（**并发性最差**）。\n\n###### 3.4.1 InnoDB的实现方式\n这种事务的隔离级别下，所有的select语句都会被隐式的转化为select ... in share mode.  \n\n这可能导致，如果有未提交的事务正在修改某些行，所有读取这些行的select都会被阻塞（官方文档原文：To force a plain SELECT to block if other transactions have modified the selected rows.）。\n\n---\n\n\n关于“脏读”，“不可重复读”，“幻读”示例：\n\n```\n假设有InnoDB表：\nt(id PK, name);\n \n表中有三条记录：\n1, shenjian\n2, zhangsan\n3, lisi\n```\n\n- 脏读\n  \n  脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据．\n  \n```\n    事务A，先执行，处于未提交的状态：\n    insert into t values(4, wangwu);\n \n    事务B，后执行，也未提交：\n    select * from t;\n   \n    如果事务B能够读取到(4, wangwu)这条记录，事务A就对事务B产生了影响，这个影响叫做“读脏”，读到了未提交事务操作的记录。\n```\n\n- 不可重复读\n  \n    不可重复读是指在一个事务中多次读取同一数据集合，在这个事务还没结束时，另一个事务也访问了该数据集合，并做了DML操作．导致第一个事务多次读取到的数据不一样．\n    \n```\n    事务A，先执行：\n    select * from t where id=1;\n \n    结果集为：\n    1, shenjian\n     \n事务B，后执行，并且提交：\n    update t set name=xxoo where id=1;\n    commit;\n \n    事务A，再次执行相同的查询：\n    select * from t where id=1;\n \n    结果集为：\n    1, xxoo\n     \n    这次是已提交事务B对事务A产生的影响，这个影响叫做“不可重复读”，一个事务内相同的查询，得到了不同的结果。\n```\n\n- 幻读\n    ```\n    事务A，先执行：\n    select * from t where id>3;\n \n    结果集为：\n    NULL\n        \n    事务B，后执行，并且提交：\n    insert into t values(4, wangwu);\n    commit;\n \n    事务A，首次查询了id>3的结果为NULL，于是想插入一条为4的记录：\n    insert into t values(4, xxoo);\n \n    结果集为：\n    Error : duplicate key!\n \n    事务A的内心OS是：你TM在逗我，查了id>3为空集，insert id=4告诉我PK冲突？\n \n    这次是已提交事务B对事务A产生的影响，这个影响叫做“幻读”。\n    ```\n    \n\n---\n\n\n#### 4、死锁\n死锁是指`两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。`\n\n解决方式：\n- ①、数据库系统实现了各种死锁检测和死锁超时机制。\n（`InnoDB处理方式：将持有最少行级排它锁的事务进行回滚`）\n- ②、当查询的时间达到锁等待超时的设定后当其锁请求。\n\n\n\n示例：\n\n```mysql\n事务A：\n    start transaction;\n    update stockprice set close = 45.50 where stock_id =4 and date ='2020-05-01';\n    update stockprice set close = 19.80 where stock_id =3 and date = '2020-05-02';\n    commit;\n\n事务B：\n    start transaction；\n    update stockprice set close = 20.12 where stock_id = 3 and date = '2020-05-02';\n    update stockprice set close = 47.20 where stock_id = 4 and date = '2020-05-01';\n    commit;\n```\n\n\n\n#### 5、MySQL中的事务\n\nMysql提供了两种事务型存储引擎：`InnoDB`和`NDB Cluster`。\n\n- 设置自动提交模式\n\n  `Mysql默认采用自动提交模式`，即如果不是显式地开始一个事务，每个查询都被当做一个事务执行提交操作。更改自动提交的命令如下：\n```\nSET AUTOCOMMIT = 1;(0：启用，1：禁用)\n```\n- `设置隔离级别`\nMysql能识别所有的4个ANSI隔离级别，InnoDB也支持所有隔离级别。\n命令示例：\n```\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED\n```\n- Mysql中的事务是<u>由下层的存储引擎实现的，同一个事务中使用多种存储引擎是不可靠的</u>。\n\n\n\n#### 6、多版本并发控制（MVCC）\n\nMVCC可以被认为是行级锁的一个变种，但他在很多情况下避免了加锁操作，因此开销更低。\n\nMVCC的实现：**通过保存数据在某个时间点的快照来实现的。**\n\n典型的存储引擎的MVCC实现：\n\n- 乐观并发控制（optimistic）\n- 悲观并发控制（pessimistic）\n\n\n\n##### 6.1 InnoDB的MVCC的实现\n\nInnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列一个保存了行的创建时间（系统版本号），一个保存行的过期时间（删除时间）（系统版本号）。每开始一个新的事务，系统版本号都会自动递增。事务开始时的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号进行比较。\n\n\n\nREPEATABLE READ隔离级别下，MVCC具体操作：\n\n- `SELECT`  \nInnoDB会根据以下两个条件检索：\n    - a、InnoDB查找行的系统版本号小于/等于事务的系统版本号，确保事务读取的行，要么在事务开始前已经存在，要么是事务自身插入或修改过的。\n    - b、行的删除版本要么未定义，要么大于当前事务版本号，确保事务读取到的行，在事务开始前未被删除。\n\n- `INSERT`  \nInnoDB为新插入的每一行保存当前系统版本号作为行版本号。\n- `DELETE`  \nInnoDB为删除的每一行保存当前系统版本号作为行删除标识。\n- `UPDATE`  \nInnoDB为新插入的每一行保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。\n\n注：<u>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作</u>。（READ UNCOMMITTED总是读取最新的数据行，而SERIALIZABLE则会对所有读取的行都加锁）\n\n\n\n#### 7、Mysql终端模拟并发事务\n\n##### 7.1 几个关键的配置\n要测试InnoDB的锁互斥，以及死锁，有几个配置需要提前确认：\n- ①、区间锁（间隙锁，临键锁）是否关闭\n- ②、事务自动提交（auto commit）是否关闭\n- ③、事务的隔离级别\n\n\n###### 7.1.1 区间锁是否关闭\n区间锁（间隙锁，临键锁）是InnoDB特有施加在索引记录区间的锁，Mysql5.6可以手动关闭区间锁。  \n\n控制参数：\n\n```\ninnodb_locks_unsafe_for_binlog\n```\n该参数支持两个值：\n- ON: 表示关闭区间锁，此时一致性会被破坏（所以是unsafe）\n- OFF：表示开启区间锁（默认）\n\n查询该参数的方法：\n\n```\nmysql> show variables like 'innodb_locks%';\n+--------------------------------+-------+\n| Variable_name                  | Value |\n+--------------------------------+-------+\n| innodb_locks_unsafe_for_binlog | OFF   |\n+--------------------------------+-------+\n1 row in set (0.03 sec)\n```\n\n修改方法：修改配置文件（/etc/mysql/mysql.conf.d/mysqld.cnf）文件，添加更改选项并重新启动服务：\n\n```\ninnodb_locks_unsafe_for_binlog = 1\n```\n\n```\nsudo service mysql restart\n```\n\n\n\n###### 7.1.2 事务自动提交\n\nMysql默认把每一个单独的SQL语句作为一个事务，自动提交。\n\n控制参数：\n```\nautocommit\n```\n\nMySQL5.7默认开启\n```\nmysql> show variables like 'autocommit';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| autocommit    | ON    |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n设置（关闭）方式：\n\n```\nset session autocommit=0;\n```\n\n\n\n###### 7.1.3 事务的隔离级别\n\n不同事务的隔离级别，InnoDB的锁实现是不一样的。默认为repeatable read。\n\n控制参数：\n```\ntx_isolation\n```\n查询事务的隔离级别的方法：\n\n```\nmysql> show global variables like 'tx_isolation';\n+---------------+-----------------+\n| Variable_name | Value           |\n+---------------+-----------------+\n| tx_isolation  | REPEATABLE-READ |\n+---------------+-----------------+\n1 row in set (0.00 sec)\n```\n\n设置事务的隔离级别的方式：\n\n```\nset session transaction isolation level <X>';\n```\n其中X可取值为：\n- read uncommitted\n- read committed\n- repeatable read\n- serializable\n\n\n\n##### 7.2 模拟并发事务前准备工作\n\n- ①、配置准备\n  要模拟并发事务，需要修改事务自动提交这个选项，每个session要改为手动提交。\n\n```\nmysql> set session autocommit=0;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> show variables like 'autocommit';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| autocommit    | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n\n\n- ②、数据准备  \n  InnoDB的行锁都是实现在索引上，实验时可以使用主键，建表时设定为innodb引擎：\n\n  - 建表\n\n    ```\n    mysql> create table t_id_pk( id int(10) primary key) engine=innodb;\n    ```\n\n  - 准备初始数据\n\n    ```\n     mysql> insert into t_id_pk(id) values (1),(3),(10);\n    ```\n\n\n\n##### 7.3 实验\n\n###### 7.3.1 间隙锁互斥实验\n开启区间锁，RR的隔离级别下，上例会有以下四个区间：\n- （-infinity， 1）\n- （1， 3）\n- （3， 10）\n- （10， infinity）\n\n事务A删除某个某个区间不存在的记录，获取到**共享间隙锁**，会阻止其他事务B在相应的区间插入数据，因为插入需要获取**排他间隙锁**。  \nsessionA：\n\n```mysql\nmysql> set autocommit=0;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delete from t_id_pk where id = 5;\nQuery OK, 0 rows affected (0.05 sec)\n```\n\nsessionB：\n\n```mysql\nmysql> set autocommit=0;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(0);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(2);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(12);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(7);\n\n```\n事务B插入的值：0，2，12都不在（3， 10）区间内，能够插入，而7在（3， 10）这个区间，会阻塞。`若事务A一直不提交，事务B就会一直等待，直到超时`，超时后会有如下提示：\n\n```\nERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n```\n\n\n---\n可以`使用以下命令查看锁的情况`：\n\n```\nshow engine innodb status;\n```\n当前实验锁部分情况如下：\n\n```\nTRANSACTIONS\n------------\nTrx id counter 66634\nPurge done for trx's n:o < 66634 undo n:o < 0 state: running but idle\nHistory list length 20\nLIST OF TRANSACTIONS FOR EACH SESSION:\n---TRANSACTION 66629, ACTIVE 52 sec inserting\nmysql tables in use 1, locked 1\nLOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 3\nMySQL thread id 20, OS thread handle 140324098004736, query id 196 localhost root update\ninsert into t_id_pk(id)values(7)\n------- TRX HAS BEEN WAITING 38 SEC FOR THIS LOCK TO BE GRANTED:\nRECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table `seven`.`t_id_pk` trx id 66629 lock_mode X locks gap before rec insert intention waiting\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0\n 0: len 4; hex 8000000a; asc     ;;\n 1: len 6; hex 00000001043f; asc      ?;;\n 2: len 7; hex af00000123012a; asc     # *;;\n\n------------------\n```\n可知insert into t_id_pk(id)values(7)正在等待事务A提交或回滚，这样事务B就能获得相应的锁，以继续执行。\n\n---\n\n\n\n###### 7.3.2 共享排它锁的死锁实验\n\n该实验需要三个并发的session。\n\nsessionA：\n```\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id) values(7);\nQuery OK, 1 row affected (0.00 sec)\n```\n\nsessionB:\n```\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id) values(7);\n```\n\nsessionC:\n```\nmysql> set autocommit=0;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id) values(7);\n```\n此时三个事务都试图往表中插入一条为7的记录：\n- A先执行，插入成功，并获取id=7的`排它锁`；\n- B后执行，需要进行PK校验，故需要先获取id=7的`共享锁`，阻塞；\n- C后执行，也需要进行PK校验，也要先获取id=7的`共享锁`，阻塞；\n\n此时若sessionA执行：\n```\nmysql> rollback;\nQuery OK, 0 rows affected (0.11 sec)\n```\nid=7的排它锁释放，则B，C会继续进行主键校验：\n- ①、B会获取到id=7共享锁，主键未互斥；\n- ②、C也会获取到id=7共享锁，主键未互斥；  \nB和C要想插入成功，必须获得id=7的排他锁，但由于双方都已经获取到id=7的共享锁，它们都无法获取到彼此的排他锁，死锁就出现了。\n\n\n\nInnoDB有死锁检测机制，B和C中的一个事务会插入成功，另一个会自动放弃：\nsessionB：\n\n```\nmysql> insert into t_id_pk(id) values(7);\nERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\n```\nsessionC:\n```\nmysql> insert into t_id_pk(id) values(7);\nQuery OK, 1 row affected (7.40 sec)\n```\n\n\n\n###### 7.3.3 并发间隙锁的死锁\n\n共享排它锁，在并发量插入相同记录的情况下，相应的案例比较容易分析，而并发的间隙锁死锁，是比较难定位的。\n```mysql\nA：set session autocommit=0;\nA：start transaction;\nA：delete from t where id=6;\n         B：set session autocommit=0;\n         B：start transaction;\n         B：delete from t where id=7;\nA：insert into t values(5);\n         B：insert into t values(8);\n```\n\nsessionA:\n```mysql\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delete from t_id_pk  where id=6;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(5);\nQuery OK, 1 row affected (8.73 sec)\n```\n\nsessionB:\n```mysql\nmysql> start transaction;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delete from t_id_pk where id=7;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> insert into t_id_pk(id)values(8);\nERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction\n```\n\n- A执行delete后，会获得(3, 10)的共享间隙锁。\n- B执行delete后，也会获得(3, 10)的共享间隙锁。\n- A执行insert后，希望获得(3, 10)的排他间隙锁，于是会阻塞。\n- B执行insert后，也希望获得(3, 10)的排他间隙锁，于是死锁出现。\n\n\n\n使用show engine innodb status查看死锁的情况：\n\n```\n2019-05-14 15:05:35 0x7f9fc003d700\n*** (1) TRANSACTION:\nTRANSACTION 66641, ACTIVE 58 sec inserting\nmysql tables in use 1, locked 1\nLOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)\nMySQL thread id 18, OS thread handle 140323966887680, query id 226 localhost root update\ninsert into t_id_pk(id)values(5)\n*** (1) WAITING FOR THIS LOCK TO BE GRANTED:\nRECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table `seven`.`t_id_pk` trx id 66641 lock_mode X locks gap before rec insert intention waiting\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0\n 0: len 4; hex 8000000a; asc     ;;\n 1: len 6; hex 00000001043f; asc      ?;;\n 2: len 7; hex af00000123012a; asc     # *;;\n\n*** (2) TRANSACTION:\nTRANSACTION 66642, ACTIVE 33 sec inserting\nmysql tables in use 1, locked 1\n3 lock struct(s), heap size 1136, 2 row lock(s)\nMySQL thread id 20, OS thread handle 140324098004736, query id 227 localhost root update\ninsert into t_id_pk(id)values(8)\n*** (2) HOLDS THE LOCK(S):\nRECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table `seven`.`t_id_pk` trx id 66642 lock_mode X locks gap before rec\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0\n 0: len 4; hex 8000000a; asc     ;;\n 1: len 6; hex 00000001043f; asc      ?;;\n 2: len 7; hex af00000123012a; asc     # *;;\n\n*** (2) WAITING FOR THIS LOCK TO BE GRANTED:\nRECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table `seven`.`t_id_pk` trx id 66642 lock_mode X locks gap before rec insert intention waiting\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0\n 0: len 4; hex 8000000a; asc     ;;\n 1: len 6; hex 00000001043f; asc      ?;;\n 2: len 7; hex af00000123012a; asc     # *;;\n\n*** WE ROLL BACK TRANSACTION (2)\n```\n\n从事务锁的情况可以看出，当检测到死锁后，事务2自动回滚了。\n\n\n\n总结：\n\n- ①、并发事务，间隙锁可能互斥；\n    - a. A删除不存在的记录，获取共享间隙锁；\n    - b. B插入，必须获得排他间隙锁，故互斥；\n- ②、并发插入相同的记录，可能死锁（某一个回滚）；\n- ③、并发插入，可能出现间隙锁死锁（难排查）。\n\n\n\n\n---\n#### 参考资料\n- 1. MySQL第三版\n- 2. [4种事务的隔离级别，InnoDB如何巧妙实现](https://mp.weixin.qq.com/s/x_7E2R2i27Ci5O7kLQF0UA)\n- 3. [超赞，InnoDB调试死锁的方法！](https://mp.weixin.qq.com/s/_36Sy0FldFRNvLRpHxfucQ)\n\n","slug":"高性能MySQL-事务基础","published":1,"updated":"2020-09-17T02:14:39.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabo8006r45g33etl6yq5","content":"<h4 id=\"1、简介\"><a href=\"#1、简介\" class=\"headerlink\" title=\"1、简介\"></a>1、简介</h4><p>事务是一组原子性的SQL查询，或者说一个独立的工作单元。事务将数据库从一种一致状态转换为另一种一致状态,事务内的语句，要么全部执行成功，要么全部执行失败。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"2、事务的ACID概念\"><a href=\"#2、事务的ACID概念\" class=\"headerlink\" title=\"2、事务的ACID概念\"></a>2、事务的ACID概念</h4><ul>\n<li><p><code>A： 原子性（automicity）</code><br>一个事务必须被视为一个不可分割的最小单元，整个事务中所有的操作要么全部提交成功，要么全部失败回滚。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题: </span><br><span class=\"line\">    对于单核单进程单个指令操作需要考虑事务的原子性吗?</span><br><span class=\"line\"></span><br><span class=\"line\">理解:</span><br><span class=\"line\">    首先我们知道,在计算机中的大概分层如下,其次数据库的数据实际是存储在磁盘上,因此,针对单条指令,如insert,插入一条数</span><br><span class=\"line\">据到数据库,实际上是由应用层&#x2F;CPU(针对不同的编程语言可能会不同,如C语言可编译为二进制形式直接在CPU上运行,而PHP等</span><br><span class=\"line\">语言需要通过OS)执行代码将需要的数据存储到磁盘中,此时若出现操作系统崩溃或者异常掉电的情况,则可能出现数据不一致的情况.</span><br><span class=\"line\"></span><br><span class=\"line\">结论:即使单核单进程单条指令操作也是需要考虑事务的原子性.</span><br><span class=\"line\"></span><br><span class=\"line\"> 应用层</span><br><span class=\"line\">-------</span><br><span class=\"line\">  OS层</span><br><span class=\"line\">-------</span><br><span class=\"line\">  CPU</span><br><span class=\"line\">-------</span><br><span class=\"line\">  内存</span><br><span class=\"line\">-------</span><br><span class=\"line\">  磁盘</span><br><span class=\"line\">-------</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p><code>C： 一致性（consistency）</code><br>数据库总是从一个一致性的状态转换到另一个一致性的状态。保证数据库的完整性约束没有被破坏.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如:</span><br><span class=\"line\">    在表t中有一个字段id,为唯一约束,即在表中id不能重复.假设当前表t中有一条id&#x3D;1的记录,此时事务A对id&#x3D;1的记录进行了删</span><br><span class=\"line\">除但尚未提交,事务B又创建了一个id&#x3D;1的记录并提交,事务A回滚,若没有一致性约束,此时表t中存在两条id&#x3D;1的记录,违反了id为唯一约束.</span><br><span class=\"line\"></span><br><span class=\"line\">Trans A              Trans B</span><br><span class=\"line\"></span><br><span class=\"line\">Start T</span><br><span class=\"line\">delete id &#x3D;1</span><br><span class=\"line\"> </span><br><span class=\"line\">                      Start T</span><br><span class=\"line\">                      insert id&#x3D;1</span><br><span class=\"line\">                      Commit T</span><br><span class=\"line\">Rollback T</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>I： 隔离性（isolation）</code><br>  通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。（<em>与隔离级别有关</em>)</p>\n<p>  <u>通常通过锁来实现</u>,当前数据库系统中都提供了一种粒度锁(granular lock)的策略,允许事务仅锁住一个实体对象的子集,以此来提高事务之间的并发度.</p>\n</li>\n<li><p><code>D： 持久性（durability）</code><br>一旦事务提交，则其所作的修改就会永久保存到数据库中。</p>\n</li>\n</ul>\n<h4 id=\"3、隔离级别\"><a href=\"#3、隔离级别\" class=\"headerlink\" title=\"3、隔离级别\"></a>3、隔离级别</h4><p>在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间是可见的，哪些是不可见的。<br><em>（不同事物的隔离级别，实际上是一致性与并发性的一个权衡与折中。）</em></p>\n<h5 id=\"3-1-READ-UNCOMMITTED（未提交读）（不推荐）\"><a href=\"#3-1-READ-UNCOMMITTED（未提交读）（不推荐）\" class=\"headerlink\" title=\"3.1 READ UNCOMMITTED（未提交读）（不推荐）\"></a>3.1 READ UNCOMMITTED（未提交读）（不推荐）</h5><p>事务中的修改，即使没有提交，对其他事务也是可见的。</p>\n<ul>\n<li>优点：性能上比另外三种级别好很多（并发性高）。</li>\n<li>缺点：读取到未提交的数据，出现<strong>脏读</strong>。且缺乏其他级别的好处（<code>一致性最差</code>）。</li>\n</ul>\n<h6 id=\"3-1-1-InnoDB的实现方式\"><a href=\"#3-1-1-InnoDB的实现方式\" class=\"headerlink\" title=\"3.1.1 InnoDB的实现方式\"></a>3.1.1 InnoDB的实现方式</h6><p>InnoDB在此种事务隔离级别下，select语句不加锁（官方文档原文：SELECT statements are performed in a nonlocking fashion.）。</p>\n<h5 id=\"3-2-READ-COMMITTED（提交读）（别名：不可重复读）\"><a href=\"#3-2-READ-COMMITTED（提交读）（别名：不可重复读）\" class=\"headerlink\" title=\"3.2 READ COMMITTED（提交读）（别名：不可重复读）\"></a>3.2 READ COMMITTED（提交读）（别名：不可重复读）</h5><p>事务开始直到提交之前，所做的任何修改对其他事务都是不可见的。</p>\n<ul>\n<li>缺点：不可重复读，当两次执行同样的查询，可能会得到不一样的结果。  </li>\n</ul>\n<h6 id=\"3-2-1-InnoDB的实现方式\"><a href=\"#3-2-1-InnoDB的实现方式\" class=\"headerlink\" title=\"3.2.1 InnoDB的实现方式\"></a>3.2.1 InnoDB的实现方式</h6><ul>\n<li>普通读是快照读；</li>\n<li>加锁的select，update，delete等语句，除了在外面约束检查以及重复键检查时会封锁区间，其他时刻都只使用记录锁；此时其他事务的插入依旧可以执行，就可能导致幻读。</li>\n</ul>\n<h5 id=\"3-3-REPEATABLE-READ（可重复读）——Mysql的默认事务隔离级别\"><a href=\"#3-3-REPEATABLE-READ（可重复读）——Mysql的默认事务隔离级别\" class=\"headerlink\" title=\"3.3 REPEATABLE READ（可重复读）——Mysql的默认事务隔离级别\"></a>3.3 REPEATABLE READ（可重复读）——Mysql的默认事务隔离级别</h5><p>该级别解决了<code>脏读</code>的问题，且保证同一个事务中多次读取同样的记录结果是一致的。</p>\n<ul>\n<li>缺点：可能会出现幻读，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围插入了新的记录，就会产生幻行。</li>\n<li>解决： InnoDB和XtraDB通过<code>多版本并发控制（MVCC, Multiversion Concurrency Control）</code>解决了上述缺点。</li>\n</ul>\n<h6 id=\"3-3-1-InnoDB的实现方式\"><a href=\"#3-3-1-InnoDB的实现方式\" class=\"headerlink\" title=\"3.3.1 InnoDB的实现方式\"></a>3.3.1 InnoDB的实现方式</h6><p>RR隔离级别为InnoDB的默认隔离级别。</p>\n<p>①、普通的select使用快照读（snapshot read），这是一种不加锁的一致性读（Consistent Nonlocking Read），底层使用MVCC来实现。</p>\n<p>②、加锁的select（select … in share mode/select … fro update）,update，delete等语句，他们的锁，依赖于他们<u>是否在唯一索引上使用了唯一的查询条件，或者范围查询条件</u>：</p>\n<ul>\n<li>在唯一索引上使用唯一的查询条件，会使用<code>记录锁（record lock）</code>，而不会封锁记录之间的间隔，即不会使用间隙锁（gap lock）和临键锁（next-key lock）。</li>\n<li>范围查询条件，会使用<code>间隙锁与临键锁</code>，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻行记录，及避免不可重读的读。</li>\n</ul>\n<h5 id=\"3-4-SERIALIZABLE（可串行化）\"><a href=\"#3-4-SERIALIZABLE（可串行化）\" class=\"headerlink\" title=\"3.4 SERIALIZABLE（可串行化）\"></a>3.4 SERIALIZABLE（可串行化）</h5><p>强制事务串行执行，避免可重复读的幻读问题。</p>\n<ul>\n<li>有点：一致性最好</li>\n<li>缺点：该级别会在读取的每一行数据加锁，可能导致大量的超时和锁争用问题（<strong>并发性最差</strong>）。</li>\n</ul>\n<h6 id=\"3-4-1-InnoDB的实现方式\"><a href=\"#3-4-1-InnoDB的实现方式\" class=\"headerlink\" title=\"3.4.1 InnoDB的实现方式\"></a>3.4.1 InnoDB的实现方式</h6><p>这种事务的隔离级别下，所有的select语句都会被隐式的转化为select … in share mode.  </p>\n<p>这可能导致，如果有未提交的事务正在修改某些行，所有读取这些行的select都会被阻塞（官方文档原文：To force a plain SELECT to block if other transactions have modified the selected rows.）。</p>\n<hr>\n<p>关于“脏读”，“不可重复读”，“幻读”示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设有InnoDB表：</span><br><span class=\"line\">t(id PK, name);</span><br><span class=\"line\"> </span><br><span class=\"line\">表中有三条记录：</span><br><span class=\"line\">1, shenjian</span><br><span class=\"line\">2, zhangsan</span><br><span class=\"line\">3, lisi</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>脏读</p>\n<p>脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据．</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A，先执行，处于未提交的状态：</span><br><span class=\"line\">insert into t values(4, wangwu);</span><br><span class=\"line\"> </span><br><span class=\"line\">事务B，后执行，也未提交：</span><br><span class=\"line\">select * from t;</span><br><span class=\"line\">   </span><br><span class=\"line\">如果事务B能够读取到(4, wangwu)这条记录，事务A就对事务B产生了影响，这个影响叫做“读脏”，读到了未提交事务操作的记录。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>不可重复读</p>\n<p>  不可重复读是指在一个事务中多次读取同一数据集合，在这个事务还没结束时，另一个事务也访问了该数据集合，并做了DML操作．导致第一个事务多次读取到的数据不一样．</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    事务A，先执行：</span><br><span class=\"line\">    select * from t where id&#x3D;1;</span><br><span class=\"line\"> </span><br><span class=\"line\">    结果集为：</span><br><span class=\"line\">    1, shenjian</span><br><span class=\"line\">     </span><br><span class=\"line\">事务B，后执行，并且提交：</span><br><span class=\"line\">    update t set name&#x3D;xxoo where id&#x3D;1;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\"> </span><br><span class=\"line\">    事务A，再次执行相同的查询：</span><br><span class=\"line\">    select * from t where id&#x3D;1;</span><br><span class=\"line\"> </span><br><span class=\"line\">    结果集为：</span><br><span class=\"line\">    1, xxoo</span><br><span class=\"line\">     </span><br><span class=\"line\">    这次是已提交事务B对事务A产生的影响，这个影响叫做“不可重复读”，一个事务内相同的查询，得到了不同的结果。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>幻读  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A，先执行：</span><br><span class=\"line\">select * from t where id&gt;3;</span><br><span class=\"line\"> </span><br><span class=\"line\">结果集为：</span><br><span class=\"line\">NULL</span><br><span class=\"line\">    </span><br><span class=\"line\">事务B，后执行，并且提交：</span><br><span class=\"line\">insert into t values(4, wangwu);</span><br><span class=\"line\">commit;</span><br><span class=\"line\"> </span><br><span class=\"line\">事务A，首次查询了id&gt;3的结果为NULL，于是想插入一条为4的记录：</span><br><span class=\"line\">insert into t values(4, xxoo);</span><br><span class=\"line\"> </span><br><span class=\"line\">结果集为：</span><br><span class=\"line\">Error : duplicate key!</span><br><span class=\"line\"> </span><br><span class=\"line\">事务A的内心OS是：你TM在逗我，查了id&gt;3为空集，insert id&#x3D;4告诉我PK冲突？</span><br><span class=\"line\"> </span><br><span class=\"line\">这次是已提交事务B对事务A产生的影响，这个影响叫做“幻读”。</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<hr>\n<h4 id=\"4、死锁\"><a href=\"#4、死锁\" class=\"headerlink\" title=\"4、死锁\"></a>4、死锁</h4><p>死锁是指<code>两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</code></p>\n<p>解决方式：</p>\n<ul>\n<li>①、数据库系统实现了各种死锁检测和死锁超时机制。<br>（<code>InnoDB处理方式：将持有最少行级排它锁的事务进行回滚</code>）</li>\n<li>②、当查询的时间达到锁等待超时的设定后当其锁请求。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A：</span><br><span class=\"line\">    start transaction;</span><br><span class=\"line\">    update stockprice set close &#x3D; 45.50 where stock_id &#x3D;4 and date &#x3D;&#39;2020-05-01&#39;;</span><br><span class=\"line\">    update stockprice set close &#x3D; 19.80 where stock_id &#x3D;3 and date &#x3D; &#39;2020-05-02&#39;;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\"></span><br><span class=\"line\">事务B：</span><br><span class=\"line\">    start transaction；</span><br><span class=\"line\">    update stockprice set close &#x3D; 20.12 where stock_id &#x3D; 3 and date &#x3D; &#39;2020-05-02&#39;;</span><br><span class=\"line\">    update stockprice set close &#x3D; 47.20 where stock_id &#x3D; 4 and date &#x3D; &#39;2020-05-01&#39;;</span><br><span class=\"line\">    commit;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5、MySQL中的事务\"><a href=\"#5、MySQL中的事务\" class=\"headerlink\" title=\"5、MySQL中的事务\"></a>5、MySQL中的事务</h4><p>Mysql提供了两种事务型存储引擎：<code>InnoDB</code>和<code>NDB Cluster</code>。</p>\n<ul>\n<li><p>设置自动提交模式</p>\n<p><code>Mysql默认采用自动提交模式</code>，即如果不是显式地开始一个事务，每个查询都被当做一个事务执行提交操作。更改自动提交的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET AUTOCOMMIT &#x3D; 1;(0：启用，1：禁用)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>设置隔离级别</code><br>Mysql能识别所有的4个ANSI隔离级别，InnoDB也支持所有隔离级别。<br>命令示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br></pre></td></tr></table></figure></li>\n<li><p>Mysql中的事务是<u>由下层的存储引擎实现的，同一个事务中使用多种存储引擎是不可靠的</u>。</p>\n</li>\n</ul>\n<h4 id=\"6、多版本并发控制（MVCC）\"><a href=\"#6、多版本并发控制（MVCC）\" class=\"headerlink\" title=\"6、多版本并发控制（MVCC）\"></a>6、多版本并发控制（MVCC）</h4><p>MVCC可以被认为是行级锁的一个变种，但他在很多情况下避免了加锁操作，因此开销更低。</p>\n<p>MVCC的实现：<strong>通过保存数据在某个时间点的快照来实现的。</strong></p>\n<p>典型的存储引擎的MVCC实现：</p>\n<ul>\n<li>乐观并发控制（optimistic）</li>\n<li>悲观并发控制（pessimistic）</li>\n</ul>\n<h5 id=\"6-1-InnoDB的MVCC的实现\"><a href=\"#6-1-InnoDB的MVCC的实现\" class=\"headerlink\" title=\"6.1 InnoDB的MVCC的实现\"></a>6.1 InnoDB的MVCC的实现</h5><p>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列一个保存了行的创建时间（系统版本号），一个保存行的过期时间（删除时间）（系统版本号）。每开始一个新的事务，系统版本号都会自动递增。事务开始时的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>\n<p>REPEATABLE READ隔离级别下，MVCC具体操作：</p>\n<ul>\n<li><p><code>SELECT</code><br>InnoDB会根据以下两个条件检索：</p>\n<ul>\n<li>a、InnoDB查找行的系统版本号小于/等于事务的系统版本号，确保事务读取的行，要么在事务开始前已经存在，要么是事务自身插入或修改过的。</li>\n<li>b、行的删除版本要么未定义，要么大于当前事务版本号，确保事务读取到的行，在事务开始前未被删除。</li>\n</ul>\n</li>\n<li><p><code>INSERT</code><br>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>\n</li>\n<li><p><code>DELETE</code><br>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>\n</li>\n<li><p><code>UPDATE</code><br>InnoDB为新插入的每一行保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。</p>\n</li>\n</ul>\n<p>注：<u>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作</u>。（READ UNCOMMITTED总是读取最新的数据行，而SERIALIZABLE则会对所有读取的行都加锁）</p>\n<h4 id=\"7、Mysql终端模拟并发事务\"><a href=\"#7、Mysql终端模拟并发事务\" class=\"headerlink\" title=\"7、Mysql终端模拟并发事务\"></a>7、Mysql终端模拟并发事务</h4><h5 id=\"7-1-几个关键的配置\"><a href=\"#7-1-几个关键的配置\" class=\"headerlink\" title=\"7.1 几个关键的配置\"></a>7.1 几个关键的配置</h5><p>要测试InnoDB的锁互斥，以及死锁，有几个配置需要提前确认：</p>\n<ul>\n<li>①、区间锁（间隙锁，临键锁）是否关闭</li>\n<li>②、事务自动提交（auto commit）是否关闭</li>\n<li>③、事务的隔离级别</li>\n</ul>\n<h6 id=\"7-1-1-区间锁是否关闭\"><a href=\"#7-1-1-区间锁是否关闭\" class=\"headerlink\" title=\"7.1.1 区间锁是否关闭\"></a>7.1.1 区间锁是否关闭</h6><p>区间锁（间隙锁，临键锁）是InnoDB特有施加在索引记录区间的锁，Mysql5.6可以手动关闭区间锁。  </p>\n<p>控制参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_locks_unsafe_for_binlog</span><br></pre></td></tr></table></figure>\n<p>该参数支持两个值：</p>\n<ul>\n<li>ON: 表示关闭区间锁，此时一致性会被破坏（所以是unsafe）</li>\n<li>OFF：表示开启区间锁（默认）</li>\n</ul>\n<p>查询该参数的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;innodb_locks%&#39;;</span><br><span class=\"line\">+--------------------------------+-------+</span><br><span class=\"line\">| Variable_name                  | Value |</span><br><span class=\"line\">+--------------------------------+-------+</span><br><span class=\"line\">| innodb_locks_unsafe_for_binlog | OFF   |</span><br><span class=\"line\">+--------------------------------+-------+</span><br><span class=\"line\">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure>\n\n<p>修改方法：修改配置文件（/etc/mysql/mysql.conf.d/mysqld.cnf）文件，添加更改选项并重新启动服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_locks_unsafe_for_binlog &#x3D; 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service mysql restart</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-1-2-事务自动提交\"><a href=\"#7-1-2-事务自动提交\" class=\"headerlink\" title=\"7.1.2 事务自动提交\"></a>7.1.2 事务自动提交</h6><p>Mysql默认把每一个单独的SQL语句作为一个事务，自动提交。</p>\n<p>控制参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">autocommit</span><br></pre></td></tr></table></figure>\n\n<p>MySQL5.7默认开启</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;autocommit&#39;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| autocommit    | ON    |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>设置（关闭）方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set session autocommit&#x3D;0;</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-1-3-事务的隔离级别\"><a href=\"#7-1-3-事务的隔离级别\" class=\"headerlink\" title=\"7.1.3 事务的隔离级别\"></a>7.1.3 事务的隔离级别</h6><p>不同事务的隔离级别，InnoDB的锁实现是不一样的。默认为repeatable read。</p>\n<p>控制参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tx_isolation</span><br></pre></td></tr></table></figure>\n<p>查询事务的隔离级别的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show global variables like &#39;tx_isolation&#39;;</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">| Variable_name | Value           |</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">| tx_isolation  | REPEATABLE-READ |</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>设置事务的隔离级别的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set session transaction isolation level &lt;X&gt;&#39;;</span><br></pre></td></tr></table></figure>\n<p>其中X可取值为：</p>\n<ul>\n<li>read uncommitted</li>\n<li>read committed</li>\n<li>repeatable read</li>\n<li>serializable</li>\n</ul>\n<h5 id=\"7-2-模拟并发事务前准备工作\"><a href=\"#7-2-模拟并发事务前准备工作\" class=\"headerlink\" title=\"7.2 模拟并发事务前准备工作\"></a>7.2 模拟并发事务前准备工作</h5><ul>\n<li>①、配置准备<br>要模拟并发事务，需要修改事务自动提交这个选项，每个session要改为手动提交。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set session autocommit&#x3D;0;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show variables like &#39;autocommit&#39;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| autocommit    | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>②、数据准备<br>InnoDB的行锁都是实现在索引上，实验时可以使用主键，建表时设定为innodb引擎：</p>\n<ul>\n<li><p>建表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table t_id_pk( id int(10) primary key) engine&#x3D;innodb;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>准备初始数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; insert into t_id_pk(id) values (1),(3),(10);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"7-3-实验\"><a href=\"#7-3-实验\" class=\"headerlink\" title=\"7.3 实验\"></a>7.3 实验</h5><h6 id=\"7-3-1-间隙锁互斥实验\"><a href=\"#7-3-1-间隙锁互斥实验\" class=\"headerlink\" title=\"7.3.1 间隙锁互斥实验\"></a>7.3.1 间隙锁互斥实验</h6><p>开启区间锁，RR的隔离级别下，上例会有以下四个区间：</p>\n<ul>\n<li>（-infinity， 1）</li>\n<li>（1， 3）</li>\n<li>（3， 10）</li>\n<li>（10， infinity）</li>\n</ul>\n<p>事务A删除某个某个区间不存在的记录，获取到<strong>共享间隙锁</strong>，会阻止其他事务B在相应的区间插入数据，因为插入需要获取<strong>排他间隙锁</strong>。<br>sessionA：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set autocommit&#x3D;0;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delete from t_id_pk where id &#x3D; 5;</span><br><span class=\"line\">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure>\n\n<p>sessionB：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set autocommit&#x3D;0;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(0);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(2);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(12);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(7);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>事务B插入的值：0，2，12都不在（3， 10）区间内，能够插入，而7在（3， 10）这个区间，会阻塞。<code>若事务A一直不提交，事务B就会一直等待，直到超时</code>，超时后会有如下提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<p>可以<code>使用以下命令查看锁的情况</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show engine innodb status;</span><br></pre></td></tr></table></figure>\n<p>当前实验锁部分情况如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TRANSACTIONS</span><br><span class=\"line\">------------</span><br><span class=\"line\">Trx id counter 66634</span><br><span class=\"line\">Purge done for trx&#39;s n:o &lt; 66634 undo n:o &lt; 0 state: running but idle</span><br><span class=\"line\">History list length 20</span><br><span class=\"line\">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class=\"line\">---TRANSACTION 66629, ACTIVE 52 sec inserting</span><br><span class=\"line\">mysql tables in use 1, locked 1</span><br><span class=\"line\">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 3</span><br><span class=\"line\">MySQL thread id 20, OS thread handle 140324098004736, query id 196 localhost root update</span><br><span class=\"line\">insert into t_id_pk(id)values(7)</span><br><span class=\"line\">------- TRX HAS BEEN WAITING 38 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class=\"line\">RECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table &#96;seven&#96;.&#96;t_id_pk&#96; trx id 66629 lock_mode X locks gap before rec insert intention waiting</span><br><span class=\"line\">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class=\"line\"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class=\"line\"> 1: len 6; hex 00000001043f; asc      ?;;</span><br><span class=\"line\"> 2: len 7; hex af00000123012a; asc     # *;;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------</span><br></pre></td></tr></table></figure>\n<p>可知insert into t_id_pk(id)values(7)正在等待事务A提交或回滚，这样事务B就能获得相应的锁，以继续执行。</p>\n<hr>\n<h6 id=\"7-3-2-共享排它锁的死锁实验\"><a href=\"#7-3-2-共享排它锁的死锁实验\" class=\"headerlink\" title=\"7.3.2 共享排它锁的死锁实验\"></a>7.3.2 共享排它锁的死锁实验</h6><p>该实验需要三个并发的session。</p>\n<p>sessionA：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>sessionB:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br></pre></td></tr></table></figure>\n\n<p>sessionC:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set autocommit&#x3D;0;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br></pre></td></tr></table></figure>\n<p>此时三个事务都试图往表中插入一条为7的记录：</p>\n<ul>\n<li>A先执行，插入成功，并获取id=7的<code>排它锁</code>；</li>\n<li>B后执行，需要进行PK校验，故需要先获取id=7的<code>共享锁</code>，阻塞；</li>\n<li>C后执行，也需要进行PK校验，也要先获取id=7的<code>共享锁</code>，阻塞；</li>\n</ul>\n<p>此时若sessionA执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; rollback;</span><br><span class=\"line\">Query OK, 0 rows affected (0.11 sec)</span><br></pre></td></tr></table></figure>\n<p>id=7的排它锁释放，则B，C会继续进行主键校验：</p>\n<ul>\n<li>①、B会获取到id=7共享锁，主键未互斥；</li>\n<li>②、C也会获取到id=7共享锁，主键未互斥；<br>B和C要想插入成功，必须获得id=7的排他锁，但由于双方都已经获取到id=7的共享锁，它们都无法获取到彼此的排他锁，死锁就出现了。</li>\n</ul>\n<p>InnoDB有死锁检测机制，B和C中的一个事务会插入成功，另一个会自动放弃：<br>sessionB：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br><span class=\"line\">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>\n<p>sessionC:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br><span class=\"line\">Query OK, 1 row affected (7.40 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-3-3-并发间隙锁的死锁\"><a href=\"#7-3-3-并发间隙锁的死锁\" class=\"headerlink\" title=\"7.3.3 并发间隙锁的死锁\"></a>7.3.3 并发间隙锁的死锁</h6><p>共享排它锁，在并发量插入相同记录的情况下，相应的案例比较容易分析，而并发的间隙锁死锁，是比较难定位的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A：set session autocommit&#x3D;0;</span><br><span class=\"line\">A：start transaction;</span><br><span class=\"line\">A：delete from t where id&#x3D;6;</span><br><span class=\"line\">         B：set session autocommit&#x3D;0;</span><br><span class=\"line\">         B：start transaction;</span><br><span class=\"line\">         B：delete from t where id&#x3D;7;</span><br><span class=\"line\">A：insert into t values(5);</span><br><span class=\"line\">         B：insert into t values(8);</span><br></pre></td></tr></table></figure>\n\n<p>sessionA:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delete from t_id_pk  where id&#x3D;6;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(5);</span><br><span class=\"line\">Query OK, 1 row affected (8.73 sec)</span><br></pre></td></tr></table></figure>\n\n<p>sessionB:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delete from t_id_pk where id&#x3D;7;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(8);</span><br><span class=\"line\">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>A执行delete后，会获得(3, 10)的共享间隙锁。</li>\n<li>B执行delete后，也会获得(3, 10)的共享间隙锁。</li>\n<li>A执行insert后，希望获得(3, 10)的排他间隙锁，于是会阻塞。</li>\n<li>B执行insert后，也希望获得(3, 10)的排他间隙锁，于是死锁出现。</li>\n</ul>\n<p>使用show engine innodb status查看死锁的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-05-14 15:05:35 0x7f9fc003d700</span><br><span class=\"line\">*** (1) TRANSACTION:</span><br><span class=\"line\">TRANSACTION 66641, ACTIVE 58 sec inserting</span><br><span class=\"line\">mysql tables in use 1, locked 1</span><br><span class=\"line\">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class=\"line\">MySQL thread id 18, OS thread handle 140323966887680, query id 226 localhost root update</span><br><span class=\"line\">insert into t_id_pk(id)values(5)</span><br><span class=\"line\">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class=\"line\">RECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table &#96;seven&#96;.&#96;t_id_pk&#96; trx id 66641 lock_mode X locks gap before rec insert intention waiting</span><br><span class=\"line\">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class=\"line\"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class=\"line\"> 1: len 6; hex 00000001043f; asc      ?;;</span><br><span class=\"line\"> 2: len 7; hex af00000123012a; asc     # *;;</span><br><span class=\"line\"></span><br><span class=\"line\">*** (2) TRANSACTION:</span><br><span class=\"line\">TRANSACTION 66642, ACTIVE 33 sec inserting</span><br><span class=\"line\">mysql tables in use 1, locked 1</span><br><span class=\"line\">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class=\"line\">MySQL thread id 20, OS thread handle 140324098004736, query id 227 localhost root update</span><br><span class=\"line\">insert into t_id_pk(id)values(8)</span><br><span class=\"line\">*** (2) HOLDS THE LOCK(S):</span><br><span class=\"line\">RECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table &#96;seven&#96;.&#96;t_id_pk&#96; trx id 66642 lock_mode X locks gap before rec</span><br><span class=\"line\">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class=\"line\"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class=\"line\"> 1: len 6; hex 00000001043f; asc      ?;;</span><br><span class=\"line\"> 2: len 7; hex af00000123012a; asc     # *;;</span><br><span class=\"line\"></span><br><span class=\"line\">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class=\"line\">RECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table &#96;seven&#96;.&#96;t_id_pk&#96; trx id 66642 lock_mode X locks gap before rec insert intention waiting</span><br><span class=\"line\">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class=\"line\"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class=\"line\"> 1: len 6; hex 00000001043f; asc      ?;;</span><br><span class=\"line\"> 2: len 7; hex af00000123012a; asc     # *;;</span><br><span class=\"line\"></span><br><span class=\"line\">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure>\n\n<p>从事务锁的情况可以看出，当检测到死锁后，事务2自动回滚了。</p>\n<p>总结：</p>\n<ul>\n<li>①、并发事务，间隙锁可能互斥；<ul>\n<li>a. A删除不存在的记录，获取共享间隙锁；</li>\n<li>b. B插入，必须获得排他间隙锁，故互斥；</li>\n</ul>\n</li>\n<li>②、并发插入相同的记录，可能死锁（某一个回滚）；</li>\n<li>③、并发插入，可能出现间隙锁死锁（难排查）。</li>\n</ul>\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ul>\n<li><ol>\n<li>MySQL第三版</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><a href=\"https://mp.weixin.qq.com/s/x_7E2R2i27Ci5O7kLQF0UA\">4种事务的隔离级别，InnoDB如何巧妙实现</a></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><a href=\"https://mp.weixin.qq.com/s/_36Sy0FldFRNvLRpHxfucQ\">超赞，InnoDB调试死锁的方法！</a></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"1、简介\"><a href=\"#1、简介\" class=\"headerlink\" title=\"1、简介\"></a>1、简介</h4><p>事务是一组原子性的SQL查询，或者说一个独立的工作单元。事务将数据库从一种一致状态转换为另一种一致状态,事务内的语句，要么全部执行成功，要么全部执行失败。</p>","more":"<h4 id=\"2、事务的ACID概念\"><a href=\"#2、事务的ACID概念\" class=\"headerlink\" title=\"2、事务的ACID概念\"></a>2、事务的ACID概念</h4><ul>\n<li><p><code>A： 原子性（automicity）</code><br>一个事务必须被视为一个不可分割的最小单元，整个事务中所有的操作要么全部提交成功，要么全部失败回滚。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题: </span><br><span class=\"line\">    对于单核单进程单个指令操作需要考虑事务的原子性吗?</span><br><span class=\"line\"></span><br><span class=\"line\">理解:</span><br><span class=\"line\">    首先我们知道,在计算机中的大概分层如下,其次数据库的数据实际是存储在磁盘上,因此,针对单条指令,如insert,插入一条数</span><br><span class=\"line\">据到数据库,实际上是由应用层&#x2F;CPU(针对不同的编程语言可能会不同,如C语言可编译为二进制形式直接在CPU上运行,而PHP等</span><br><span class=\"line\">语言需要通过OS)执行代码将需要的数据存储到磁盘中,此时若出现操作系统崩溃或者异常掉电的情况,则可能出现数据不一致的情况.</span><br><span class=\"line\"></span><br><span class=\"line\">结论:即使单核单进程单条指令操作也是需要考虑事务的原子性.</span><br><span class=\"line\"></span><br><span class=\"line\"> 应用层</span><br><span class=\"line\">-------</span><br><span class=\"line\">  OS层</span><br><span class=\"line\">-------</span><br><span class=\"line\">  CPU</span><br><span class=\"line\">-------</span><br><span class=\"line\">  内存</span><br><span class=\"line\">-------</span><br><span class=\"line\">  磁盘</span><br><span class=\"line\">-------</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p><code>C： 一致性（consistency）</code><br>数据库总是从一个一致性的状态转换到另一个一致性的状态。保证数据库的完整性约束没有被破坏.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如:</span><br><span class=\"line\">    在表t中有一个字段id,为唯一约束,即在表中id不能重复.假设当前表t中有一条id&#x3D;1的记录,此时事务A对id&#x3D;1的记录进行了删</span><br><span class=\"line\">除但尚未提交,事务B又创建了一个id&#x3D;1的记录并提交,事务A回滚,若没有一致性约束,此时表t中存在两条id&#x3D;1的记录,违反了id为唯一约束.</span><br><span class=\"line\"></span><br><span class=\"line\">Trans A              Trans B</span><br><span class=\"line\"></span><br><span class=\"line\">Start T</span><br><span class=\"line\">delete id &#x3D;1</span><br><span class=\"line\"> </span><br><span class=\"line\">                      Start T</span><br><span class=\"line\">                      insert id&#x3D;1</span><br><span class=\"line\">                      Commit T</span><br><span class=\"line\">Rollback T</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>I： 隔离性（isolation）</code><br>  通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的。（<em>与隔离级别有关</em>)</p>\n<p>  <u>通常通过锁来实现</u>,当前数据库系统中都提供了一种粒度锁(granular lock)的策略,允许事务仅锁住一个实体对象的子集,以此来提高事务之间的并发度.</p>\n</li>\n<li><p><code>D： 持久性（durability）</code><br>一旦事务提交，则其所作的修改就会永久保存到数据库中。</p>\n</li>\n</ul>\n<h4 id=\"3、隔离级别\"><a href=\"#3、隔离级别\" class=\"headerlink\" title=\"3、隔离级别\"></a>3、隔离级别</h4><p>在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间是可见的，哪些是不可见的。<br><em>（不同事物的隔离级别，实际上是一致性与并发性的一个权衡与折中。）</em></p>\n<h5 id=\"3-1-READ-UNCOMMITTED（未提交读）（不推荐）\"><a href=\"#3-1-READ-UNCOMMITTED（未提交读）（不推荐）\" class=\"headerlink\" title=\"3.1 READ UNCOMMITTED（未提交读）（不推荐）\"></a>3.1 READ UNCOMMITTED（未提交读）（不推荐）</h5><p>事务中的修改，即使没有提交，对其他事务也是可见的。</p>\n<ul>\n<li>优点：性能上比另外三种级别好很多（并发性高）。</li>\n<li>缺点：读取到未提交的数据，出现<strong>脏读</strong>。且缺乏其他级别的好处（<code>一致性最差</code>）。</li>\n</ul>\n<h6 id=\"3-1-1-InnoDB的实现方式\"><a href=\"#3-1-1-InnoDB的实现方式\" class=\"headerlink\" title=\"3.1.1 InnoDB的实现方式\"></a>3.1.1 InnoDB的实现方式</h6><p>InnoDB在此种事务隔离级别下，select语句不加锁（官方文档原文：SELECT statements are performed in a nonlocking fashion.）。</p>\n<h5 id=\"3-2-READ-COMMITTED（提交读）（别名：不可重复读）\"><a href=\"#3-2-READ-COMMITTED（提交读）（别名：不可重复读）\" class=\"headerlink\" title=\"3.2 READ COMMITTED（提交读）（别名：不可重复读）\"></a>3.2 READ COMMITTED（提交读）（别名：不可重复读）</h5><p>事务开始直到提交之前，所做的任何修改对其他事务都是不可见的。</p>\n<ul>\n<li>缺点：不可重复读，当两次执行同样的查询，可能会得到不一样的结果。  </li>\n</ul>\n<h6 id=\"3-2-1-InnoDB的实现方式\"><a href=\"#3-2-1-InnoDB的实现方式\" class=\"headerlink\" title=\"3.2.1 InnoDB的实现方式\"></a>3.2.1 InnoDB的实现方式</h6><ul>\n<li>普通读是快照读；</li>\n<li>加锁的select，update，delete等语句，除了在外面约束检查以及重复键检查时会封锁区间，其他时刻都只使用记录锁；此时其他事务的插入依旧可以执行，就可能导致幻读。</li>\n</ul>\n<h5 id=\"3-3-REPEATABLE-READ（可重复读）——Mysql的默认事务隔离级别\"><a href=\"#3-3-REPEATABLE-READ（可重复读）——Mysql的默认事务隔离级别\" class=\"headerlink\" title=\"3.3 REPEATABLE READ（可重复读）——Mysql的默认事务隔离级别\"></a>3.3 REPEATABLE READ（可重复读）——Mysql的默认事务隔离级别</h5><p>该级别解决了<code>脏读</code>的问题，且保证同一个事务中多次读取同样的记录结果是一致的。</p>\n<ul>\n<li>缺点：可能会出现幻读，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围插入了新的记录，就会产生幻行。</li>\n<li>解决： InnoDB和XtraDB通过<code>多版本并发控制（MVCC, Multiversion Concurrency Control）</code>解决了上述缺点。</li>\n</ul>\n<h6 id=\"3-3-1-InnoDB的实现方式\"><a href=\"#3-3-1-InnoDB的实现方式\" class=\"headerlink\" title=\"3.3.1 InnoDB的实现方式\"></a>3.3.1 InnoDB的实现方式</h6><p>RR隔离级别为InnoDB的默认隔离级别。</p>\n<p>①、普通的select使用快照读（snapshot read），这是一种不加锁的一致性读（Consistent Nonlocking Read），底层使用MVCC来实现。</p>\n<p>②、加锁的select（select … in share mode/select … fro update）,update，delete等语句，他们的锁，依赖于他们<u>是否在唯一索引上使用了唯一的查询条件，或者范围查询条件</u>：</p>\n<ul>\n<li>在唯一索引上使用唯一的查询条件，会使用<code>记录锁（record lock）</code>，而不会封锁记录之间的间隔，即不会使用间隙锁（gap lock）和临键锁（next-key lock）。</li>\n<li>范围查询条件，会使用<code>间隙锁与临键锁</code>，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻行记录，及避免不可重读的读。</li>\n</ul>\n<h5 id=\"3-4-SERIALIZABLE（可串行化）\"><a href=\"#3-4-SERIALIZABLE（可串行化）\" class=\"headerlink\" title=\"3.4 SERIALIZABLE（可串行化）\"></a>3.4 SERIALIZABLE（可串行化）</h5><p>强制事务串行执行，避免可重复读的幻读问题。</p>\n<ul>\n<li>有点：一致性最好</li>\n<li>缺点：该级别会在读取的每一行数据加锁，可能导致大量的超时和锁争用问题（<strong>并发性最差</strong>）。</li>\n</ul>\n<h6 id=\"3-4-1-InnoDB的实现方式\"><a href=\"#3-4-1-InnoDB的实现方式\" class=\"headerlink\" title=\"3.4.1 InnoDB的实现方式\"></a>3.4.1 InnoDB的实现方式</h6><p>这种事务的隔离级别下，所有的select语句都会被隐式的转化为select … in share mode.  </p>\n<p>这可能导致，如果有未提交的事务正在修改某些行，所有读取这些行的select都会被阻塞（官方文档原文：To force a plain SELECT to block if other transactions have modified the selected rows.）。</p>\n<hr>\n<p>关于“脏读”，“不可重复读”，“幻读”示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设有InnoDB表：</span><br><span class=\"line\">t(id PK, name);</span><br><span class=\"line\"> </span><br><span class=\"line\">表中有三条记录：</span><br><span class=\"line\">1, shenjian</span><br><span class=\"line\">2, zhangsan</span><br><span class=\"line\">3, lisi</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>脏读</p>\n<p>脏读指的是在不同事务下，当前事务可以读到另外事务未提交的数据．</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A，先执行，处于未提交的状态：</span><br><span class=\"line\">insert into t values(4, wangwu);</span><br><span class=\"line\"> </span><br><span class=\"line\">事务B，后执行，也未提交：</span><br><span class=\"line\">select * from t;</span><br><span class=\"line\">   </span><br><span class=\"line\">如果事务B能够读取到(4, wangwu)这条记录，事务A就对事务B产生了影响，这个影响叫做“读脏”，读到了未提交事务操作的记录。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>不可重复读</p>\n<p>  不可重复读是指在一个事务中多次读取同一数据集合，在这个事务还没结束时，另一个事务也访问了该数据集合，并做了DML操作．导致第一个事务多次读取到的数据不一样．</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    事务A，先执行：</span><br><span class=\"line\">    select * from t where id&#x3D;1;</span><br><span class=\"line\"> </span><br><span class=\"line\">    结果集为：</span><br><span class=\"line\">    1, shenjian</span><br><span class=\"line\">     </span><br><span class=\"line\">事务B，后执行，并且提交：</span><br><span class=\"line\">    update t set name&#x3D;xxoo where id&#x3D;1;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\"> </span><br><span class=\"line\">    事务A，再次执行相同的查询：</span><br><span class=\"line\">    select * from t where id&#x3D;1;</span><br><span class=\"line\"> </span><br><span class=\"line\">    结果集为：</span><br><span class=\"line\">    1, xxoo</span><br><span class=\"line\">     </span><br><span class=\"line\">    这次是已提交事务B对事务A产生的影响，这个影响叫做“不可重复读”，一个事务内相同的查询，得到了不同的结果。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>幻读  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A，先执行：</span><br><span class=\"line\">select * from t where id&gt;3;</span><br><span class=\"line\"> </span><br><span class=\"line\">结果集为：</span><br><span class=\"line\">NULL</span><br><span class=\"line\">    </span><br><span class=\"line\">事务B，后执行，并且提交：</span><br><span class=\"line\">insert into t values(4, wangwu);</span><br><span class=\"line\">commit;</span><br><span class=\"line\"> </span><br><span class=\"line\">事务A，首次查询了id&gt;3的结果为NULL，于是想插入一条为4的记录：</span><br><span class=\"line\">insert into t values(4, xxoo);</span><br><span class=\"line\"> </span><br><span class=\"line\">结果集为：</span><br><span class=\"line\">Error : duplicate key!</span><br><span class=\"line\"> </span><br><span class=\"line\">事务A的内心OS是：你TM在逗我，查了id&gt;3为空集，insert id&#x3D;4告诉我PK冲突？</span><br><span class=\"line\"> </span><br><span class=\"line\">这次是已提交事务B对事务A产生的影响，这个影响叫做“幻读”。</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<hr>\n<h4 id=\"4、死锁\"><a href=\"#4、死锁\" class=\"headerlink\" title=\"4、死锁\"></a>4、死锁</h4><p>死锁是指<code>两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</code></p>\n<p>解决方式：</p>\n<ul>\n<li>①、数据库系统实现了各种死锁检测和死锁超时机制。<br>（<code>InnoDB处理方式：将持有最少行级排它锁的事务进行回滚</code>）</li>\n<li>②、当查询的时间达到锁等待超时的设定后当其锁请求。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A：</span><br><span class=\"line\">    start transaction;</span><br><span class=\"line\">    update stockprice set close &#x3D; 45.50 where stock_id &#x3D;4 and date &#x3D;&#39;2020-05-01&#39;;</span><br><span class=\"line\">    update stockprice set close &#x3D; 19.80 where stock_id &#x3D;3 and date &#x3D; &#39;2020-05-02&#39;;</span><br><span class=\"line\">    commit;</span><br><span class=\"line\"></span><br><span class=\"line\">事务B：</span><br><span class=\"line\">    start transaction；</span><br><span class=\"line\">    update stockprice set close &#x3D; 20.12 where stock_id &#x3D; 3 and date &#x3D; &#39;2020-05-02&#39;;</span><br><span class=\"line\">    update stockprice set close &#x3D; 47.20 where stock_id &#x3D; 4 and date &#x3D; &#39;2020-05-01&#39;;</span><br><span class=\"line\">    commit;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5、MySQL中的事务\"><a href=\"#5、MySQL中的事务\" class=\"headerlink\" title=\"5、MySQL中的事务\"></a>5、MySQL中的事务</h4><p>Mysql提供了两种事务型存储引擎：<code>InnoDB</code>和<code>NDB Cluster</code>。</p>\n<ul>\n<li><p>设置自动提交模式</p>\n<p><code>Mysql默认采用自动提交模式</code>，即如果不是显式地开始一个事务，每个查询都被当做一个事务执行提交操作。更改自动提交的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET AUTOCOMMIT &#x3D; 1;(0：启用，1：禁用)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>设置隔离级别</code><br>Mysql能识别所有的4个ANSI隔离级别，InnoDB也支持所有隔离级别。<br>命令示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br></pre></td></tr></table></figure></li>\n<li><p>Mysql中的事务是<u>由下层的存储引擎实现的，同一个事务中使用多种存储引擎是不可靠的</u>。</p>\n</li>\n</ul>\n<h4 id=\"6、多版本并发控制（MVCC）\"><a href=\"#6、多版本并发控制（MVCC）\" class=\"headerlink\" title=\"6、多版本并发控制（MVCC）\"></a>6、多版本并发控制（MVCC）</h4><p>MVCC可以被认为是行级锁的一个变种，但他在很多情况下避免了加锁操作，因此开销更低。</p>\n<p>MVCC的实现：<strong>通过保存数据在某个时间点的快照来实现的。</strong></p>\n<p>典型的存储引擎的MVCC实现：</p>\n<ul>\n<li>乐观并发控制（optimistic）</li>\n<li>悲观并发控制（pessimistic）</li>\n</ul>\n<h5 id=\"6-1-InnoDB的MVCC的实现\"><a href=\"#6-1-InnoDB的MVCC的实现\" class=\"headerlink\" title=\"6.1 InnoDB的MVCC的实现\"></a>6.1 InnoDB的MVCC的实现</h5><p>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列一个保存了行的创建时间（系统版本号），一个保存行的过期时间（删除时间）（系统版本号）。每开始一个新的事务，系统版本号都会自动递增。事务开始时的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>\n<p>REPEATABLE READ隔离级别下，MVCC具体操作：</p>\n<ul>\n<li><p><code>SELECT</code><br>InnoDB会根据以下两个条件检索：</p>\n<ul>\n<li>a、InnoDB查找行的系统版本号小于/等于事务的系统版本号，确保事务读取的行，要么在事务开始前已经存在，要么是事务自身插入或修改过的。</li>\n<li>b、行的删除版本要么未定义，要么大于当前事务版本号，确保事务读取到的行，在事务开始前未被删除。</li>\n</ul>\n</li>\n<li><p><code>INSERT</code><br>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>\n</li>\n<li><p><code>DELETE</code><br>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>\n</li>\n<li><p><code>UPDATE</code><br>InnoDB为新插入的每一行保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。</p>\n</li>\n</ul>\n<p>注：<u>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作</u>。（READ UNCOMMITTED总是读取最新的数据行，而SERIALIZABLE则会对所有读取的行都加锁）</p>\n<h4 id=\"7、Mysql终端模拟并发事务\"><a href=\"#7、Mysql终端模拟并发事务\" class=\"headerlink\" title=\"7、Mysql终端模拟并发事务\"></a>7、Mysql终端模拟并发事务</h4><h5 id=\"7-1-几个关键的配置\"><a href=\"#7-1-几个关键的配置\" class=\"headerlink\" title=\"7.1 几个关键的配置\"></a>7.1 几个关键的配置</h5><p>要测试InnoDB的锁互斥，以及死锁，有几个配置需要提前确认：</p>\n<ul>\n<li>①、区间锁（间隙锁，临键锁）是否关闭</li>\n<li>②、事务自动提交（auto commit）是否关闭</li>\n<li>③、事务的隔离级别</li>\n</ul>\n<h6 id=\"7-1-1-区间锁是否关闭\"><a href=\"#7-1-1-区间锁是否关闭\" class=\"headerlink\" title=\"7.1.1 区间锁是否关闭\"></a>7.1.1 区间锁是否关闭</h6><p>区间锁（间隙锁，临键锁）是InnoDB特有施加在索引记录区间的锁，Mysql5.6可以手动关闭区间锁。  </p>\n<p>控制参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_locks_unsafe_for_binlog</span><br></pre></td></tr></table></figure>\n<p>该参数支持两个值：</p>\n<ul>\n<li>ON: 表示关闭区间锁，此时一致性会被破坏（所以是unsafe）</li>\n<li>OFF：表示开启区间锁（默认）</li>\n</ul>\n<p>查询该参数的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;innodb_locks%&#39;;</span><br><span class=\"line\">+--------------------------------+-------+</span><br><span class=\"line\">| Variable_name                  | Value |</span><br><span class=\"line\">+--------------------------------+-------+</span><br><span class=\"line\">| innodb_locks_unsafe_for_binlog | OFF   |</span><br><span class=\"line\">+--------------------------------+-------+</span><br><span class=\"line\">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure>\n\n<p>修改方法：修改配置文件（/etc/mysql/mysql.conf.d/mysqld.cnf）文件，添加更改选项并重新启动服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">innodb_locks_unsafe_for_binlog &#x3D; 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service mysql restart</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-1-2-事务自动提交\"><a href=\"#7-1-2-事务自动提交\" class=\"headerlink\" title=\"7.1.2 事务自动提交\"></a>7.1.2 事务自动提交</h6><p>Mysql默认把每一个单独的SQL语句作为一个事务，自动提交。</p>\n<p>控制参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">autocommit</span><br></pre></td></tr></table></figure>\n\n<p>MySQL5.7默认开启</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;autocommit&#39;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| autocommit    | ON    |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>设置（关闭）方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set session autocommit&#x3D;0;</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-1-3-事务的隔离级别\"><a href=\"#7-1-3-事务的隔离级别\" class=\"headerlink\" title=\"7.1.3 事务的隔离级别\"></a>7.1.3 事务的隔离级别</h6><p>不同事务的隔离级别，InnoDB的锁实现是不一样的。默认为repeatable read。</p>\n<p>控制参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tx_isolation</span><br></pre></td></tr></table></figure>\n<p>查询事务的隔离级别的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show global variables like &#39;tx_isolation&#39;;</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">| Variable_name | Value           |</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">| tx_isolation  | REPEATABLE-READ |</span><br><span class=\"line\">+---------------+-----------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>设置事务的隔离级别的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set session transaction isolation level &lt;X&gt;&#39;;</span><br></pre></td></tr></table></figure>\n<p>其中X可取值为：</p>\n<ul>\n<li>read uncommitted</li>\n<li>read committed</li>\n<li>repeatable read</li>\n<li>serializable</li>\n</ul>\n<h5 id=\"7-2-模拟并发事务前准备工作\"><a href=\"#7-2-模拟并发事务前准备工作\" class=\"headerlink\" title=\"7.2 模拟并发事务前准备工作\"></a>7.2 模拟并发事务前准备工作</h5><ul>\n<li>①、配置准备<br>要模拟并发事务，需要修改事务自动提交这个选项，每个session要改为手动提交。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set session autocommit&#x3D;0;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show variables like &#39;autocommit&#39;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| autocommit    | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>②、数据准备<br>InnoDB的行锁都是实现在索引上，实验时可以使用主键，建表时设定为innodb引擎：</p>\n<ul>\n<li><p>建表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create table t_id_pk( id int(10) primary key) engine&#x3D;innodb;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>准备初始数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; insert into t_id_pk(id) values (1),(3),(10);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"7-3-实验\"><a href=\"#7-3-实验\" class=\"headerlink\" title=\"7.3 实验\"></a>7.3 实验</h5><h6 id=\"7-3-1-间隙锁互斥实验\"><a href=\"#7-3-1-间隙锁互斥实验\" class=\"headerlink\" title=\"7.3.1 间隙锁互斥实验\"></a>7.3.1 间隙锁互斥实验</h6><p>开启区间锁，RR的隔离级别下，上例会有以下四个区间：</p>\n<ul>\n<li>（-infinity， 1）</li>\n<li>（1， 3）</li>\n<li>（3， 10）</li>\n<li>（10， infinity）</li>\n</ul>\n<p>事务A删除某个某个区间不存在的记录，获取到<strong>共享间隙锁</strong>，会阻止其他事务B在相应的区间插入数据，因为插入需要获取<strong>排他间隙锁</strong>。<br>sessionA：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set autocommit&#x3D;0;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delete from t_id_pk where id &#x3D; 5;</span><br><span class=\"line\">Query OK, 0 rows affected (0.05 sec)</span><br></pre></td></tr></table></figure>\n\n<p>sessionB：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set autocommit&#x3D;0;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(0);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(2);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(12);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(7);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>事务B插入的值：0，2，12都不在（3， 10）区间内，能够插入，而7在（3， 10）这个区间，会阻塞。<code>若事务A一直不提交，事务B就会一直等待，直到超时</code>，超时后会有如下提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<p>可以<code>使用以下命令查看锁的情况</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show engine innodb status;</span><br></pre></td></tr></table></figure>\n<p>当前实验锁部分情况如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TRANSACTIONS</span><br><span class=\"line\">------------</span><br><span class=\"line\">Trx id counter 66634</span><br><span class=\"line\">Purge done for trx&#39;s n:o &lt; 66634 undo n:o &lt; 0 state: running but idle</span><br><span class=\"line\">History list length 20</span><br><span class=\"line\">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class=\"line\">---TRANSACTION 66629, ACTIVE 52 sec inserting</span><br><span class=\"line\">mysql tables in use 1, locked 1</span><br><span class=\"line\">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 3</span><br><span class=\"line\">MySQL thread id 20, OS thread handle 140324098004736, query id 196 localhost root update</span><br><span class=\"line\">insert into t_id_pk(id)values(7)</span><br><span class=\"line\">------- TRX HAS BEEN WAITING 38 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class=\"line\">RECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table &#96;seven&#96;.&#96;t_id_pk&#96; trx id 66629 lock_mode X locks gap before rec insert intention waiting</span><br><span class=\"line\">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class=\"line\"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class=\"line\"> 1: len 6; hex 00000001043f; asc      ?;;</span><br><span class=\"line\"> 2: len 7; hex af00000123012a; asc     # *;;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------</span><br></pre></td></tr></table></figure>\n<p>可知insert into t_id_pk(id)values(7)正在等待事务A提交或回滚，这样事务B就能获得相应的锁，以继续执行。</p>\n<hr>\n<h6 id=\"7-3-2-共享排它锁的死锁实验\"><a href=\"#7-3-2-共享排它锁的死锁实验\" class=\"headerlink\" title=\"7.3.2 共享排它锁的死锁实验\"></a>7.3.2 共享排它锁的死锁实验</h6><p>该实验需要三个并发的session。</p>\n<p>sessionA：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>sessionB:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br></pre></td></tr></table></figure>\n\n<p>sessionC:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set autocommit&#x3D;0;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br></pre></td></tr></table></figure>\n<p>此时三个事务都试图往表中插入一条为7的记录：</p>\n<ul>\n<li>A先执行，插入成功，并获取id=7的<code>排它锁</code>；</li>\n<li>B后执行，需要进行PK校验，故需要先获取id=7的<code>共享锁</code>，阻塞；</li>\n<li>C后执行，也需要进行PK校验，也要先获取id=7的<code>共享锁</code>，阻塞；</li>\n</ul>\n<p>此时若sessionA执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; rollback;</span><br><span class=\"line\">Query OK, 0 rows affected (0.11 sec)</span><br></pre></td></tr></table></figure>\n<p>id=7的排它锁释放，则B，C会继续进行主键校验：</p>\n<ul>\n<li>①、B会获取到id=7共享锁，主键未互斥；</li>\n<li>②、C也会获取到id=7共享锁，主键未互斥；<br>B和C要想插入成功，必须获得id=7的排他锁，但由于双方都已经获取到id=7的共享锁，它们都无法获取到彼此的排他锁，死锁就出现了。</li>\n</ul>\n<p>InnoDB有死锁检测机制，B和C中的一个事务会插入成功，另一个会自动放弃：<br>sessionB：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br><span class=\"line\">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>\n<p>sessionC:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; insert into t_id_pk(id) values(7);</span><br><span class=\"line\">Query OK, 1 row affected (7.40 sec)</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"7-3-3-并发间隙锁的死锁\"><a href=\"#7-3-3-并发间隙锁的死锁\" class=\"headerlink\" title=\"7.3.3 并发间隙锁的死锁\"></a>7.3.3 并发间隙锁的死锁</h6><p>共享排它锁，在并发量插入相同记录的情况下，相应的案例比较容易分析，而并发的间隙锁死锁，是比较难定位的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A：set session autocommit&#x3D;0;</span><br><span class=\"line\">A：start transaction;</span><br><span class=\"line\">A：delete from t where id&#x3D;6;</span><br><span class=\"line\">         B：set session autocommit&#x3D;0;</span><br><span class=\"line\">         B：start transaction;</span><br><span class=\"line\">         B：delete from t where id&#x3D;7;</span><br><span class=\"line\">A：insert into t values(5);</span><br><span class=\"line\">         B：insert into t values(8);</span><br></pre></td></tr></table></figure>\n\n<p>sessionA:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delete from t_id_pk  where id&#x3D;6;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(5);</span><br><span class=\"line\">Query OK, 1 row affected (8.73 sec)</span><br></pre></td></tr></table></figure>\n\n<p>sessionB:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; start transaction;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delete from t_id_pk where id&#x3D;7;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; insert into t_id_pk(id)values(8);</span><br><span class=\"line\">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>A执行delete后，会获得(3, 10)的共享间隙锁。</li>\n<li>B执行delete后，也会获得(3, 10)的共享间隙锁。</li>\n<li>A执行insert后，希望获得(3, 10)的排他间隙锁，于是会阻塞。</li>\n<li>B执行insert后，也希望获得(3, 10)的排他间隙锁，于是死锁出现。</li>\n</ul>\n<p>使用show engine innodb status查看死锁的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-05-14 15:05:35 0x7f9fc003d700</span><br><span class=\"line\">*** (1) TRANSACTION:</span><br><span class=\"line\">TRANSACTION 66641, ACTIVE 58 sec inserting</span><br><span class=\"line\">mysql tables in use 1, locked 1</span><br><span class=\"line\">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class=\"line\">MySQL thread id 18, OS thread handle 140323966887680, query id 226 localhost root update</span><br><span class=\"line\">insert into t_id_pk(id)values(5)</span><br><span class=\"line\">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class=\"line\">RECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table &#96;seven&#96;.&#96;t_id_pk&#96; trx id 66641 lock_mode X locks gap before rec insert intention waiting</span><br><span class=\"line\">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class=\"line\"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class=\"line\"> 1: len 6; hex 00000001043f; asc      ?;;</span><br><span class=\"line\"> 2: len 7; hex af00000123012a; asc     # *;;</span><br><span class=\"line\"></span><br><span class=\"line\">*** (2) TRANSACTION:</span><br><span class=\"line\">TRANSACTION 66642, ACTIVE 33 sec inserting</span><br><span class=\"line\">mysql tables in use 1, locked 1</span><br><span class=\"line\">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class=\"line\">MySQL thread id 20, OS thread handle 140324098004736, query id 227 localhost root update</span><br><span class=\"line\">insert into t_id_pk(id)values(8)</span><br><span class=\"line\">*** (2) HOLDS THE LOCK(S):</span><br><span class=\"line\">RECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table &#96;seven&#96;.&#96;t_id_pk&#96; trx id 66642 lock_mode X locks gap before rec</span><br><span class=\"line\">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class=\"line\"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class=\"line\"> 1: len 6; hex 00000001043f; asc      ?;;</span><br><span class=\"line\"> 2: len 7; hex af00000123012a; asc     # *;;</span><br><span class=\"line\"></span><br><span class=\"line\">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class=\"line\">RECORD LOCKS space id 445 page no 3 n bits 80 index PRIMARY of table &#96;seven&#96;.&#96;t_id_pk&#96; trx id 66642 lock_mode X locks gap before rec insert intention waiting</span><br><span class=\"line\">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class=\"line\"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class=\"line\"> 1: len 6; hex 00000001043f; asc      ?;;</span><br><span class=\"line\"> 2: len 7; hex af00000123012a; asc     # *;;</span><br><span class=\"line\"></span><br><span class=\"line\">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure>\n\n<p>从事务锁的情况可以看出，当检测到死锁后，事务2自动回滚了。</p>\n<p>总结：</p>\n<ul>\n<li>①、并发事务，间隙锁可能互斥；<ul>\n<li>a. A删除不存在的记录，获取共享间隙锁；</li>\n<li>b. B插入，必须获得排他间隙锁，故互斥；</li>\n</ul>\n</li>\n<li>②、并发插入相同的记录，可能死锁（某一个回滚）；</li>\n<li>③、并发插入，可能出现间隙锁死锁（难排查）。</li>\n</ul>\n<hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ul>\n<li><ol>\n<li>MySQL第三版</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><a href=\"https://mp.weixin.qq.com/s/x_7E2R2i27Ci5O7kLQF0UA\">4种事务的隔离级别，InnoDB如何巧妙实现</a></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><a href=\"https://mp.weixin.qq.com/s/_36Sy0FldFRNvLRpHxfucQ\">超赞，InnoDB调试死锁的方法！</a></li>\n</ol>\n</li>\n</ul>"},{"title":"高性能MySQL-创建高性能索引","date":"2020-09-06T11:46:30.000Z","_content":"\n索引是存储引擎中用于快速找到记录的一种数据结构。索引优化应该是对查询性能优化最有效的手段。\n\n<!--more-->\n\n### 1 索引基础\n\n索引可以包含一个或多个列（联合索引）的值。如果索引包含多个列，其列的顺序非常重要，因为MySql只能高效地使用索引的最左前缀列。\n\n#### 1.1 索引的类型\n\n`Mysql中的索引实现是在存储引擎层中实现的，而不是服务层`，因此没有统一的索引标准（不同的存储引擎的工作方式不一样）\n\n##### 1.1.1 B-Tree索引\n\n此处的B-Tree是泛指，例如InnoDB实际使用的B+Tree；NDB实际使用的T-Tree。 大多数MySql引擎都使用这种索引。\n\nB-Tree索引的其特征如下：\n\n- 所有的值都是按顺序存储的。\n- 每个叶子页到根的距离相同。\n\n\n\n下图为B-Tree索引的抽象表示：\n\n![B-Tree索引的抽象表示](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/高性能MySQL_第三版-创建高性能索引/B-Tree索引的抽象表示.png)\n\n其中，每个节点表示一个页，对于InnoDB存储引擎的逻辑页大小为16k。\n\n\n\n示例：假设有一个联合索引的表，如下：\n\n```mysql\ncreate table People (\n    `id` int unsigned not null auto_increment comment '主键id',\n    `last_name` varchar(50) not null default '' comment '姓氏',\n    `first_name` varchar(50) not null default '' comment '名称',\n    `dob` date not null comment '生日',\n    `gender` enum('m','f') not null comment '性别',\n    primary key (`id`),\n    key `idx_name_dob`(`last_name`, `first_name`, `dob`)\n) engine=InnoDB default charset=utf8mb4 comment='用户信息表'\n```\n\n对于表中的普通联合索引，其组织数据的存储结构如下：\n\n![普通联合索引-其组织数据的存储结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/高性能MySQL_第三版-创建高性能索引/普通联合索引-其组织数据的存储结构.png)\n\n注：\n\n- ①、索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。\n\n- ②、图中最后两个条目的人名都一样，其排序是使用出生日期进行排序的。\n\n\n\n\n**B-Tree适应哪些查询类型？**\n\n- 全键值查询\n- 键值范围查询\n- 键前缀查询（*只适用于最左前缀查询*）\n\n\n\n**联合索引能适用于哪些查询类型呢？**\n\n- `全值匹配`：和索引中的所有列进行匹配；\n- `匹配最左前缀`：例如，使用索引中的第一列，或者第一及第二列；\n- `匹配列前缀`：匹配某一列的值的开头部分，如查找示例所有姓为J开头的人；\n- `匹配范围值`：如查找示例中姓氏在Allen和Barrymore之间的人；\n- `精确匹配某一列并范围匹配另一列`：例如示例中，查询所有姓氏为Allen，并且名字是字母K开头的人，即第一列全值匹配，第二列范围匹配；\n- `只访问索引的查询`：B-Tree通常可以支持只访问索引，而无需访问数据行。\n\n*注：由于B-Tree索引树中的节点是有序的，因此该索引还可以用于查询ORDER BY操作（排序）。*\n\n\n\n**B-Tree索引有哪些限制（缺点）？**\n\n- ①、如果不是按照索引的最左列开始查找，则无法使用索引。\n- ②、不能跳过索引中的列。\n- ③、如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找（即全表扫描）。\n\n\n\n**为什么MySQL数据库大部分索引结构要使用B+Tree？**\n\n\n\n##### 1.1.2 哈希索引\n\n`哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。`对于每一行数据，存储引擎都会对所有的索引列计算出一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。 \n\nMysql中只有Memory引擎显式支持且默认支持哈希索引。\n\n\n\n示例：\n\n```mysql\n# 建表\ncreate table `testhash` (\n    `fname` varchar(50) not null,\n    `lname` varchar(50) not null,\n    key using hash(fname)\n)engine=memory;\n\n# 添加数据\ninsert into `testhash` (`fname`,`lname`) \nvalues \n    ('Arjen','Lentz'),\n    ('Baron', 'Schwartz'),\n    ('Peter', 'Zartsev'),\n    ('Vadim', 'Tkachenko');\n```\n\n**哈希索引的优点**：\n\n- ①、索引自身只需存储对应的哈希值，因此索引结构紧凑。\n- ②、查找速度非常快。\n\n\n\n**哈希索引的限制(缺点)：**\n\n- ①、不能使用索引中的值来直接读取行（哈希索引只包含哈希值和行指针，而不存储字段值）\n- ②、哈希索引数据不是按照索引值顺序存储的，因此无法用于排序。\n- ③、哈希索引不支持部分索引匹配查找。（哈希索引使用是使用索引列的全部内容计算哈希值的）\n- ④、哈希索引只支持等值比较查询（=，IN(), <=>），也不支持任何的范围查询。\n- ⑤、当有很多哈希冲突时，会导致访问速度变慢，且维护成本代价也会很高。\n\n\n\n**哈希索引比树型索引更快，为什么MySQL的索引结构要设计成B-Tree结构？**\n\n- 对于哈希索引，其增删改查的平均时间复杂度为O(1)；\n\n\n- 而Tree型索引，其增删改查的平均时间复杂度为O(lg(n))；\n\n\n- 对于单行数据的读写，哈希索引均比Tree型索引块，但是对于某些特殊的查询SQL，例如分组、排序、比较等情况，哈希索引的时间复杂度会退化为O(n)，而Tree索引因为其有序的特性，能依旧保持O(lg(n))的高效率。\n\n\n*注：InnoDB存储引擎不支持哈希索引。*\n\n\n\n**哈希索引的适用场景举例？**\n\n在数据仓库的应用中有一种经典的“星型”schema，需要关联很多查找表，哈希索引就非常适合查找表的需求。\n\n\n\n###### 1.1.2.1 InnoDB的自适应哈希索引\n\nInnoDB会将某些使用非常频繁的索引在内存中基于B-Tree索引之上再创建一个哈希索引。这是一个完全自动、内部的行为，用于无法控制或配置，如有必要，可关闭该功能。\n\n###### 1.1.2.2 创建自定义哈希索引\n\n**思路**：`在B-Tree基础上创建一个伪哈希索引`。需要做的就是在查询的WHERE字句中手动指定使用的哈希函数。（*实例见高性能MySQL P156*），为避免冲突问题，必须在WHERE条件中带入哈希值和对应的列值。\n\n\n\n示例：需要存储大量的URL，并根据URL进行搜索查找，若使用B-Tree来存储URL，存储的内容就会很大，因为URL本身很长。因此可以新增一个被索引的url_crc列，使用crc32做哈希，然后查询时使用以下方式查询：\n\n```mysql\nselect id from url where url=\"http://www/mysql.com\" and url_crc=crc32(\"http://www/mysql.com\");\n```\n\n这样做的优点是性能非常高，但是需要维护哈希值（维护方式可以手动维护，即程序控制，还可以通过触发器维护（*触发器示例看参考资料1P149*））。\n\n\n\n##### 1.1.3 空间数据索引（R-Tree）\n\n`MyISAM引擎支持空间索引，可以样做地理数据存储`。该索引可以从所有维度来查询数据。必须使用MySQL的GIS相关函数来维护数据。MySQL对GIS支持不完善，不推荐使用此特性。\n\n开源关系数据库系统对GIS的解决方案做的比较好的是：PostgreSQL的PostGIS\n\n\n\n##### 1.1.4 全文索引\n\n全文索引是一种特殊类型的索引，`它查找的是文本中的关键词，而不是直接比较索引中的值。`\n\n\n\n### 2 索引的优点\n\n索引可以让服务器快速定位指定位置，根据创建索引的数据结构不同，索引还有一些其他的附加作用。例如B-Tree索引，按照顺序存储数据，索引可以用于ORDER BY 和GROUP BY操作。\n\n**应用索引有哪些优点？**\n\n- 减少服务器需要扫描的数据量\n- 帮助服务器避免排序和临时表\n- 将随机I/O变为顺序I/O\n\n\n\n### 3 高性能的索引策略\n\n#### 3.1 独立的列\n\n`独立的列指索引列不能是表达式的一部分，也不能是函数的参数。`\n\n示例：\n\n```mysql\n# 下面的这个查询无法使用actor_id列的索引。\nselect actor_id from sakila.actor where actor_id + 1 = 5;\n\n# 优化后的查询\nselect actor_id from sakila.actor where actor_id = 4;\n```\n\n\n\n#### 3.2 前缀索引和索引选择性\n\n当索引很长字符列时，会让索引变得大且慢，解决方法：\n\n- ①、模拟哈希索引\n- ②、前缀索引+索引的选择\n\n\n\n`前缀索引`：索引开始的部分字符，节约索引空间，提高索引效率。前缀索引会降低索引的选择性。\n\n`索引的选择性`：<u>指不重复的索引值和数据表的记录总数的比值。索引的选择性索高则查询的效率越高</u>。\n\n\n\n示例：创建前缀索引\n\n```mysql\nalter table sakila.city_demo add key (city(7))\n```\n\n\n\n**前缀索引的优缺点分别是什么？**\n\n- 优点：使索引能更小、更快。\n- 缺点：Mysql无法使用前缀索引做ORDERY BY 和GROUP BY，也无法使用前缀索引做覆盖扫描。\n\n`前缀索引常见的应用场景`：<u>针对很长的十六进制唯一ID使用前缀索引。</u>\n\n\n\n**既然有前缀索引，那么有没有后缀索引呢？**\n\n其实是有后缀索引的，但MySQL原生不支持反向索引，但可以把字符串反转后存储，并基于此建立前缀索引。\n\n\n\n#### 3.3 多列索引\n\n#### 3.4 选择合适的索引顺序\n\n正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。\n\n在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等字句的查询。\n\n`通常来说，当不需要考虑排序或分组时，将选择性高的列放到索引最前列是很好的。`\n\n\n\n#### 3.5 聚簇索引\n\n`聚簇索引并不是一种单独的索引类型，而是一种数据存储方式`。具体的实现细节依赖于其实现方式，但<u>InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</u>\n\n`聚簇索引的数据行实际存放在索引的叶子页（leaf page）`，术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。（一个表只会有一个聚簇索引）\n\n\n\n聚簇索引中的记录存放示例：\n\n![聚簇索引中的记录存放示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/高性能MySQL_第三版-创建高性能索引/聚簇索引中的记录存放示例.png)\n\n*对于InnoDB，通过主键聚集数据，若没有主键，InnoDB会选择一个唯一的非空索引代替，若没有唯一非空索引，InnoDB会隐式定义一个主键来作为聚簇索引。*\n\n\n\n**聚簇索引的优点**？\n\n- 可以将数据保存在一起。例如试下电子邮箱时，可以根据用户ID来聚集数据，这样只需要从此磁盘读取少数的数据页就能获取某个用户的全部邮件，若没有使用聚簇索引，则每封邮件都可能导致一次磁盘I/O。\n- 数据访问更快；\n- 使用覆盖索引扫描的查询可以直接使用页结点中的主键值。\n\n\n\n**聚簇索引的缺点？**\n\n- 聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有什么优势了。\n- 插入的速度严重依赖于插入的顺序。\n- 更新聚簇索引列的代价很高，因为会强制InnoDB将每个更新的行移动到新的位置。\n- 基于聚簇索引的表再插入新行，或者主键被更新告知需要移动行的时候，可能面临“页分裂”的问题。\n- 可能导致全表扫描变慢，尤其是行比较稀疏或者由于页分裂告知数据存储不连续的时候。\n- 二级索引可能比想象的要更大，因为二级索引的叶子节点包含了引用行的主键列。\n- 二级索引访问需要两次索引查询，而不是一次。\n\n\n\n**InnoDB和MyISAM保存数据和索引的区别？**\n\n![InnoDB和MyiSAM保存数据和索引的区别](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/高性能MySQL_第三版-创建高性能索引/InnoDB和MyiSAM保存数据和索引的区别.png)\n\n\n\n*在InnoDB表时应该尽可能地按主键顺序插入数据，并且尽可能使用单调增加的聚簇键的值来插入新行。*\n\n\n\n**那么顺序的主键有不适用的时候吗？是什么时候呢？**\n\n对于高并发负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”，因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是auto_increment锁机制。\n\n\n\n#### 3.6 覆盖索引\n\n定义：`如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称为覆盖索引。`\n\n优点：\n\n- ①、索引条目远小于数据行大小，此时Mysql会极大的减少数据访问量。\n- ②、索引按照列值顺序存储（至少单页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行的数据的I/O要少得多。\n- ③、一些存储索引（如：MyISAM）在内存中值缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要系统调用。这可能会导致严重的性能问题，尤其是那桐调用占了数据访问中最大开销的场景。\n- ④、InnoDB是聚簇索引，覆盖索引对InnoDB表特别有用，使用覆盖索引可以避免对主键索引的二次查询。\n\n（注：不是所有类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引）\n\n\n\n**如何知道一个查询被索引覆盖？**\n\n在EXPLAIN的EXtra列可以看到`“Using index”`的信息。\n\n\n\n#### 3.7 使用索引扫描来做排序\n\n**MySQL生成有序结果的方式有哪些？**\n\n- ①、排序操作。\n- ②、索引顺序扫描。\n\n\n\n**为什么按索引顺序读取数据的速度通常要比顺序地全表扫描慢？**\n\n扫描索引本身是很快的，但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就得回表查询一次对应的行，这基本上都是随机I/O，因此会比顺序地全表扫描慢，尤其是在I/O密集型工作负载时。\n\n\n\nMySQL可以使用同一个索引既满足排序，又用于查找行，因此，设计索引时应该尽可能的同事满足索引和排序这两种任务。只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才能使用索引来对接过做排序。\n\n（<u>注：若多表关联查询，只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。</u>）\n\n特殊情况：有一种情况ORDER BY子句不满足索引的最左前缀的要求，就是前导列为常量的时候，如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。\n\n\n\n#### 3.8 压缩（前缀压缩）索引\n\n`MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能，`默认只压缩字符串，但通过参数设置也可以对整数做压缩。`\n\n\n\n**MyISAM压缩每个索引块的方法是怎么样的？**\n\n先完全保存索引块中的第一个值，然后将其他值和第一个值比较，得到相同前缀的字节数和剩余不同后缀部分，把这部分存储起来即可。\n\n\n\n`示例`：索引块中第一个值是“perform”，第二个值为“performance”，那么第二个指的前缀压缩后存储的值类似于“7，ance”这样的形式。\n\n*注：MyISAM对行指针也采用前缀索引方式。*\n\n\n\n**压缩（前缀压缩）索引的优缺点？**\n\n- 优点：使用更少的空间；\n- 缺点：某些操作可能更慢，比如，每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而是只能从头开始扫描。倒序扫描也支持得不是很好。\n\n在CREATE TABLE语句中使用`PACK_KEYS参数`来控制索引压缩的方式。\n\n\n\n#### 3.9 冗余和重复索引\n\nMySQL允许在相同列上创建多个索引，无论有意还是无意。\n\n`重复索引`：指在相同的列上按照相同的顺序创建相同类型的索引。应该避免这样创建重复索引！\n\n`冗余索引`：冗余索引与重复索引有些许不同，比如，已有联合索引（A，B），若在创建索引A，则算是冗余索引。\n\n\n\n#### 3.10 未使用的索引\n\n**怎样检查那些索引未使用到？**\n\n- ①、在Percona Server或者MariaDB中先打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS就能查到每个索引的使用频率。\n- ②、使用Percona Toolkit中pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告。\n\n\n\n#### 3.11 索引和锁\n\n索引可以让查询锁定更少的行。InnoDB只有在访问行的时候才会对其加锁，而索引能够减少innoDB访问的行数，从而减少锁的数量。（仅在InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。）\n\n`InnoDB在二级索引上使用共享锁，但访问主键索引需要排他锁`。\n\n\n\n### 4 索引案例\n\n案例描述：\n\n假设要涉及一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色等等。网站必须支持上面这些特征的各种组合来搜索用户，还必须允许更具用户的最后在线时间、其他会员对用户的评分等对用户进行排序并对结果进行限制。\n\n`第一件要考虑的事情是：需要使用索引来排序，还是先检索数据再排序。`\n\n\n\n#### 4.1 支持多种过滤条件\n\n分析哪些列拥有很多不同的取值，哪些列在WHERE子句中出现的最频繁。`通常在有更多不同的值的创建索引的选择性会更好`。\n\n根据实际业务场景，country列的选择性通常不高，sex列的选择性肯定很低，但是他们在很多查询中都会用到。因此建议在创建不同组合索引的时候，将（sex, country）列作为前缀，其原因如下：\n\n①、几乎所有查询都会用到sex列（若对sex列没有限制，可以通过一些技巧绕过最左前缀限制）。\n\n技巧：<u>若某个查询不限制性别，那么可以通过在查询条件中新增AND SEX IN('m','f')来让MySQL选择该索引。</u>\n\n\n\n②、考虑常见的where条件的组合，了解哪些组合在没有合适的索引情况下会很慢。(sex,country,age)上建立索引。\n\n`对于生僻的搜索条件，及时他们选择性高，使用不频繁，可以忽略他们。`\n\n\n\n#### 4.2 避免多个范围查询\n\n`对于范围查询，MySQL无法使用联合查询后面的索引。`\n\n\n\n假设有一个last_online列，并希望通过以下的查询显示在过去几周上线过的用户：\n\n```mysql\nwhere eye_color in ('brown','blue','hazel')\n    and hair_color in ('black', 'red', 'blonde', 'brown')\n    and sex in ('M','F')\n    and last_online > DATE_SUB(NOW(), INTERVAL 7 DAY)\n    and age between 18 and 25\n```\n\n这个查询中，他有两个范围查询条件，last_online和age列，MySQL可以使用last_online列索引或者age列索引，但无法同时使用他们。\n\n\n\n#### 4.3 优化排序\n\n使用文件排序对小数据集是很快的，但如果一个查询匹配的结果有上白万行会怎样？\n\n\n\n示例：高效地利用(sex,rating)索引进行排序和分页？\n\n`利用延迟关联策略，通过覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行。`\n\n```mysql\nselect <cols> from profiles inner join (\n    select <primary key cols> from profiles\n    where x.sex='M' order by rating limt 1000000, 10\n) as x using(<primary key cols>);\n```\n\n\n\n### 5 维护索引和表\n\n维护表的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。\n\n\n\n#### 5.1 找到并修复损坏的表\n\n通过以下命令可以`检查表是否发生了损坏`：\n\n```\ncheck table\n```\n\n通过以下命令可以`修复损坏的表`：\n\n```\nrepair table\n```\n\n*注：以上两个命令并不是所有存储引擎都支持。*\n\n<u>若存储引擎不支持，可以通过一个不做任何操作的alter操作来重建表</u>，如下示例所示：\n\n```\nalter table innodb_tb1 engine=innodb;\n```\n\n通常来说InnoDB引擎的表不容易损坏，若发生损坏，一般要么是数据库的硬件问题，例如内存或磁盘问题，要么是由于数据库管理员的错误，例如，在MySQL外部操作了数据文件（有可能）或者InnoDB本身的缺陷（不太可能）。\n\n\n\n#### 5.2 更新索引的统计信息\n\nMySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息：\n\n- `record_in_range()`：通过向存储引擎传入两个边界值获取这个范围大概有多少条记录。\n- `info()`：返回各种类型的数据，包括索引的基数（每个键值有多少条记录）\n\n若存储引擎向优化器提供的扫描行数信息不准确或者执行计划本身太复杂，以至于无法准确地获取各个阶段匹配的行数，那么优化器会使用索引统计信息来估算扫描行数。\n\n`MySQL优化器使用的是基于成本的模型，而衡量成本的主要指标就是一个查询需要扫描多少行。`\n\n通过以下命令来生成统计信息解决表没有统计信息或者统计信息不准确的情况。\n\n```\nanalyze table\n```\n\n通过以下命令查看索引的基数：\n\n```\nshow index from <table_name>\n```\n\n\n\n#### 5.3 减少索引和数据的碎片\n\n见参考资料1 P191\n\n\n\n### 6 总结\n\n针对B-Tree索引，在选择索引和编写利用这些索引的查询时，需要记住以下三个原则：\n\n- ①、单行访问是很慢的。特别是在机械硬盘存储中。最好读取的块中能尽可能多的包含所需的行。\n- ②、按顺序访问范围数据是很快的，其原因是：第一，顺序I/O比随机I/O快很多。第二，服务器按顺序读取数据就不需要额外的排序操作。\n- ③、覆盖索引是很快。覆盖索引避免了回表操作。\n\n\n\n如何判断一个系统创建的索引时合理的呢？\n\n- ①、按响应时间来对查询进行分析。找出那些消耗最长时间的查询或者那些给服务器最大压力的查询。\n- ②、检查这些查询的schema、SQL和索引结构，判断是否有查询扫描了太多的行，是否做了很多额外的排序或者使用了临时表，是否使用了随机I/O访问数据，或者有太多徽标查询那些不在索引中的列的操作。\n\n------\n\n### 参考资料：\n\n1  高性能MySQL_第3版 P177","source":"_posts/高性能MySQL-创建高性能索引.md","raw":"---\ntitle: 高性能MySQL-创建高性能索引\ndate: 2020-09-06 19:46:30\ntags: [\"MySQL\",\"Note\"]\ncategories: [\"MySQL\", \"Note\", \"高性能MySQL\"]\n---\n\n索引是存储引擎中用于快速找到记录的一种数据结构。索引优化应该是对查询性能优化最有效的手段。\n\n<!--more-->\n\n### 1 索引基础\n\n索引可以包含一个或多个列（联合索引）的值。如果索引包含多个列，其列的顺序非常重要，因为MySql只能高效地使用索引的最左前缀列。\n\n#### 1.1 索引的类型\n\n`Mysql中的索引实现是在存储引擎层中实现的，而不是服务层`，因此没有统一的索引标准（不同的存储引擎的工作方式不一样）\n\n##### 1.1.1 B-Tree索引\n\n此处的B-Tree是泛指，例如InnoDB实际使用的B+Tree；NDB实际使用的T-Tree。 大多数MySql引擎都使用这种索引。\n\nB-Tree索引的其特征如下：\n\n- 所有的值都是按顺序存储的。\n- 每个叶子页到根的距离相同。\n\n\n\n下图为B-Tree索引的抽象表示：\n\n![B-Tree索引的抽象表示](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/高性能MySQL_第三版-创建高性能索引/B-Tree索引的抽象表示.png)\n\n其中，每个节点表示一个页，对于InnoDB存储引擎的逻辑页大小为16k。\n\n\n\n示例：假设有一个联合索引的表，如下：\n\n```mysql\ncreate table People (\n    `id` int unsigned not null auto_increment comment '主键id',\n    `last_name` varchar(50) not null default '' comment '姓氏',\n    `first_name` varchar(50) not null default '' comment '名称',\n    `dob` date not null comment '生日',\n    `gender` enum('m','f') not null comment '性别',\n    primary key (`id`),\n    key `idx_name_dob`(`last_name`, `first_name`, `dob`)\n) engine=InnoDB default charset=utf8mb4 comment='用户信息表'\n```\n\n对于表中的普通联合索引，其组织数据的存储结构如下：\n\n![普通联合索引-其组织数据的存储结构](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/高性能MySQL_第三版-创建高性能索引/普通联合索引-其组织数据的存储结构.png)\n\n注：\n\n- ①、索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。\n\n- ②、图中最后两个条目的人名都一样，其排序是使用出生日期进行排序的。\n\n\n\n\n**B-Tree适应哪些查询类型？**\n\n- 全键值查询\n- 键值范围查询\n- 键前缀查询（*只适用于最左前缀查询*）\n\n\n\n**联合索引能适用于哪些查询类型呢？**\n\n- `全值匹配`：和索引中的所有列进行匹配；\n- `匹配最左前缀`：例如，使用索引中的第一列，或者第一及第二列；\n- `匹配列前缀`：匹配某一列的值的开头部分，如查找示例所有姓为J开头的人；\n- `匹配范围值`：如查找示例中姓氏在Allen和Barrymore之间的人；\n- `精确匹配某一列并范围匹配另一列`：例如示例中，查询所有姓氏为Allen，并且名字是字母K开头的人，即第一列全值匹配，第二列范围匹配；\n- `只访问索引的查询`：B-Tree通常可以支持只访问索引，而无需访问数据行。\n\n*注：由于B-Tree索引树中的节点是有序的，因此该索引还可以用于查询ORDER BY操作（排序）。*\n\n\n\n**B-Tree索引有哪些限制（缺点）？**\n\n- ①、如果不是按照索引的最左列开始查找，则无法使用索引。\n- ②、不能跳过索引中的列。\n- ③、如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找（即全表扫描）。\n\n\n\n**为什么MySQL数据库大部分索引结构要使用B+Tree？**\n\n\n\n##### 1.1.2 哈希索引\n\n`哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。`对于每一行数据，存储引擎都会对所有的索引列计算出一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。 \n\nMysql中只有Memory引擎显式支持且默认支持哈希索引。\n\n\n\n示例：\n\n```mysql\n# 建表\ncreate table `testhash` (\n    `fname` varchar(50) not null,\n    `lname` varchar(50) not null,\n    key using hash(fname)\n)engine=memory;\n\n# 添加数据\ninsert into `testhash` (`fname`,`lname`) \nvalues \n    ('Arjen','Lentz'),\n    ('Baron', 'Schwartz'),\n    ('Peter', 'Zartsev'),\n    ('Vadim', 'Tkachenko');\n```\n\n**哈希索引的优点**：\n\n- ①、索引自身只需存储对应的哈希值，因此索引结构紧凑。\n- ②、查找速度非常快。\n\n\n\n**哈希索引的限制(缺点)：**\n\n- ①、不能使用索引中的值来直接读取行（哈希索引只包含哈希值和行指针，而不存储字段值）\n- ②、哈希索引数据不是按照索引值顺序存储的，因此无法用于排序。\n- ③、哈希索引不支持部分索引匹配查找。（哈希索引使用是使用索引列的全部内容计算哈希值的）\n- ④、哈希索引只支持等值比较查询（=，IN(), <=>），也不支持任何的范围查询。\n- ⑤、当有很多哈希冲突时，会导致访问速度变慢，且维护成本代价也会很高。\n\n\n\n**哈希索引比树型索引更快，为什么MySQL的索引结构要设计成B-Tree结构？**\n\n- 对于哈希索引，其增删改查的平均时间复杂度为O(1)；\n\n\n- 而Tree型索引，其增删改查的平均时间复杂度为O(lg(n))；\n\n\n- 对于单行数据的读写，哈希索引均比Tree型索引块，但是对于某些特殊的查询SQL，例如分组、排序、比较等情况，哈希索引的时间复杂度会退化为O(n)，而Tree索引因为其有序的特性，能依旧保持O(lg(n))的高效率。\n\n\n*注：InnoDB存储引擎不支持哈希索引。*\n\n\n\n**哈希索引的适用场景举例？**\n\n在数据仓库的应用中有一种经典的“星型”schema，需要关联很多查找表，哈希索引就非常适合查找表的需求。\n\n\n\n###### 1.1.2.1 InnoDB的自适应哈希索引\n\nInnoDB会将某些使用非常频繁的索引在内存中基于B-Tree索引之上再创建一个哈希索引。这是一个完全自动、内部的行为，用于无法控制或配置，如有必要，可关闭该功能。\n\n###### 1.1.2.2 创建自定义哈希索引\n\n**思路**：`在B-Tree基础上创建一个伪哈希索引`。需要做的就是在查询的WHERE字句中手动指定使用的哈希函数。（*实例见高性能MySQL P156*），为避免冲突问题，必须在WHERE条件中带入哈希值和对应的列值。\n\n\n\n示例：需要存储大量的URL，并根据URL进行搜索查找，若使用B-Tree来存储URL，存储的内容就会很大，因为URL本身很长。因此可以新增一个被索引的url_crc列，使用crc32做哈希，然后查询时使用以下方式查询：\n\n```mysql\nselect id from url where url=\"http://www/mysql.com\" and url_crc=crc32(\"http://www/mysql.com\");\n```\n\n这样做的优点是性能非常高，但是需要维护哈希值（维护方式可以手动维护，即程序控制，还可以通过触发器维护（*触发器示例看参考资料1P149*））。\n\n\n\n##### 1.1.3 空间数据索引（R-Tree）\n\n`MyISAM引擎支持空间索引，可以样做地理数据存储`。该索引可以从所有维度来查询数据。必须使用MySQL的GIS相关函数来维护数据。MySQL对GIS支持不完善，不推荐使用此特性。\n\n开源关系数据库系统对GIS的解决方案做的比较好的是：PostgreSQL的PostGIS\n\n\n\n##### 1.1.4 全文索引\n\n全文索引是一种特殊类型的索引，`它查找的是文本中的关键词，而不是直接比较索引中的值。`\n\n\n\n### 2 索引的优点\n\n索引可以让服务器快速定位指定位置，根据创建索引的数据结构不同，索引还有一些其他的附加作用。例如B-Tree索引，按照顺序存储数据，索引可以用于ORDER BY 和GROUP BY操作。\n\n**应用索引有哪些优点？**\n\n- 减少服务器需要扫描的数据量\n- 帮助服务器避免排序和临时表\n- 将随机I/O变为顺序I/O\n\n\n\n### 3 高性能的索引策略\n\n#### 3.1 独立的列\n\n`独立的列指索引列不能是表达式的一部分，也不能是函数的参数。`\n\n示例：\n\n```mysql\n# 下面的这个查询无法使用actor_id列的索引。\nselect actor_id from sakila.actor where actor_id + 1 = 5;\n\n# 优化后的查询\nselect actor_id from sakila.actor where actor_id = 4;\n```\n\n\n\n#### 3.2 前缀索引和索引选择性\n\n当索引很长字符列时，会让索引变得大且慢，解决方法：\n\n- ①、模拟哈希索引\n- ②、前缀索引+索引的选择\n\n\n\n`前缀索引`：索引开始的部分字符，节约索引空间，提高索引效率。前缀索引会降低索引的选择性。\n\n`索引的选择性`：<u>指不重复的索引值和数据表的记录总数的比值。索引的选择性索高则查询的效率越高</u>。\n\n\n\n示例：创建前缀索引\n\n```mysql\nalter table sakila.city_demo add key (city(7))\n```\n\n\n\n**前缀索引的优缺点分别是什么？**\n\n- 优点：使索引能更小、更快。\n- 缺点：Mysql无法使用前缀索引做ORDERY BY 和GROUP BY，也无法使用前缀索引做覆盖扫描。\n\n`前缀索引常见的应用场景`：<u>针对很长的十六进制唯一ID使用前缀索引。</u>\n\n\n\n**既然有前缀索引，那么有没有后缀索引呢？**\n\n其实是有后缀索引的，但MySQL原生不支持反向索引，但可以把字符串反转后存储，并基于此建立前缀索引。\n\n\n\n#### 3.3 多列索引\n\n#### 3.4 选择合适的索引顺序\n\n正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。\n\n在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等字句的查询。\n\n`通常来说，当不需要考虑排序或分组时，将选择性高的列放到索引最前列是很好的。`\n\n\n\n#### 3.5 聚簇索引\n\n`聚簇索引并不是一种单独的索引类型，而是一种数据存储方式`。具体的实现细节依赖于其实现方式，但<u>InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</u>\n\n`聚簇索引的数据行实际存放在索引的叶子页（leaf page）`，术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。（一个表只会有一个聚簇索引）\n\n\n\n聚簇索引中的记录存放示例：\n\n![聚簇索引中的记录存放示例](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/高性能MySQL_第三版-创建高性能索引/聚簇索引中的记录存放示例.png)\n\n*对于InnoDB，通过主键聚集数据，若没有主键，InnoDB会选择一个唯一的非空索引代替，若没有唯一非空索引，InnoDB会隐式定义一个主键来作为聚簇索引。*\n\n\n\n**聚簇索引的优点**？\n\n- 可以将数据保存在一起。例如试下电子邮箱时，可以根据用户ID来聚集数据，这样只需要从此磁盘读取少数的数据页就能获取某个用户的全部邮件，若没有使用聚簇索引，则每封邮件都可能导致一次磁盘I/O。\n- 数据访问更快；\n- 使用覆盖索引扫描的查询可以直接使用页结点中的主键值。\n\n\n\n**聚簇索引的缺点？**\n\n- 聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有什么优势了。\n- 插入的速度严重依赖于插入的顺序。\n- 更新聚簇索引列的代价很高，因为会强制InnoDB将每个更新的行移动到新的位置。\n- 基于聚簇索引的表再插入新行，或者主键被更新告知需要移动行的时候，可能面临“页分裂”的问题。\n- 可能导致全表扫描变慢，尤其是行比较稀疏或者由于页分裂告知数据存储不连续的时候。\n- 二级索引可能比想象的要更大，因为二级索引的叶子节点包含了引用行的主键列。\n- 二级索引访问需要两次索引查询，而不是一次。\n\n\n\n**InnoDB和MyISAM保存数据和索引的区别？**\n\n![InnoDB和MyiSAM保存数据和索引的区别](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/高性能MySQL_第三版-创建高性能索引/InnoDB和MyiSAM保存数据和索引的区别.png)\n\n\n\n*在InnoDB表时应该尽可能地按主键顺序插入数据，并且尽可能使用单调增加的聚簇键的值来插入新行。*\n\n\n\n**那么顺序的主键有不适用的时候吗？是什么时候呢？**\n\n对于高并发负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”，因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是auto_increment锁机制。\n\n\n\n#### 3.6 覆盖索引\n\n定义：`如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称为覆盖索引。`\n\n优点：\n\n- ①、索引条目远小于数据行大小，此时Mysql会极大的减少数据访问量。\n- ②、索引按照列值顺序存储（至少单页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行的数据的I/O要少得多。\n- ③、一些存储索引（如：MyISAM）在内存中值缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要系统调用。这可能会导致严重的性能问题，尤其是那桐调用占了数据访问中最大开销的场景。\n- ④、InnoDB是聚簇索引，覆盖索引对InnoDB表特别有用，使用覆盖索引可以避免对主键索引的二次查询。\n\n（注：不是所有类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引）\n\n\n\n**如何知道一个查询被索引覆盖？**\n\n在EXPLAIN的EXtra列可以看到`“Using index”`的信息。\n\n\n\n#### 3.7 使用索引扫描来做排序\n\n**MySQL生成有序结果的方式有哪些？**\n\n- ①、排序操作。\n- ②、索引顺序扫描。\n\n\n\n**为什么按索引顺序读取数据的速度通常要比顺序地全表扫描慢？**\n\n扫描索引本身是很快的，但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就得回表查询一次对应的行，这基本上都是随机I/O，因此会比顺序地全表扫描慢，尤其是在I/O密集型工作负载时。\n\n\n\nMySQL可以使用同一个索引既满足排序，又用于查找行，因此，设计索引时应该尽可能的同事满足索引和排序这两种任务。只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才能使用索引来对接过做排序。\n\n（<u>注：若多表关联查询，只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。</u>）\n\n特殊情况：有一种情况ORDER BY子句不满足索引的最左前缀的要求，就是前导列为常量的时候，如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。\n\n\n\n#### 3.8 压缩（前缀压缩）索引\n\n`MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能，`默认只压缩字符串，但通过参数设置也可以对整数做压缩。`\n\n\n\n**MyISAM压缩每个索引块的方法是怎么样的？**\n\n先完全保存索引块中的第一个值，然后将其他值和第一个值比较，得到相同前缀的字节数和剩余不同后缀部分，把这部分存储起来即可。\n\n\n\n`示例`：索引块中第一个值是“perform”，第二个值为“performance”，那么第二个指的前缀压缩后存储的值类似于“7，ance”这样的形式。\n\n*注：MyISAM对行指针也采用前缀索引方式。*\n\n\n\n**压缩（前缀压缩）索引的优缺点？**\n\n- 优点：使用更少的空间；\n- 缺点：某些操作可能更慢，比如，每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而是只能从头开始扫描。倒序扫描也支持得不是很好。\n\n在CREATE TABLE语句中使用`PACK_KEYS参数`来控制索引压缩的方式。\n\n\n\n#### 3.9 冗余和重复索引\n\nMySQL允许在相同列上创建多个索引，无论有意还是无意。\n\n`重复索引`：指在相同的列上按照相同的顺序创建相同类型的索引。应该避免这样创建重复索引！\n\n`冗余索引`：冗余索引与重复索引有些许不同，比如，已有联合索引（A，B），若在创建索引A，则算是冗余索引。\n\n\n\n#### 3.10 未使用的索引\n\n**怎样检查那些索引未使用到？**\n\n- ①、在Percona Server或者MariaDB中先打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS就能查到每个索引的使用频率。\n- ②、使用Percona Toolkit中pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告。\n\n\n\n#### 3.11 索引和锁\n\n索引可以让查询锁定更少的行。InnoDB只有在访问行的时候才会对其加锁，而索引能够减少innoDB访问的行数，从而减少锁的数量。（仅在InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。）\n\n`InnoDB在二级索引上使用共享锁，但访问主键索引需要排他锁`。\n\n\n\n### 4 索引案例\n\n案例描述：\n\n假设要涉及一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色等等。网站必须支持上面这些特征的各种组合来搜索用户，还必须允许更具用户的最后在线时间、其他会员对用户的评分等对用户进行排序并对结果进行限制。\n\n`第一件要考虑的事情是：需要使用索引来排序，还是先检索数据再排序。`\n\n\n\n#### 4.1 支持多种过滤条件\n\n分析哪些列拥有很多不同的取值，哪些列在WHERE子句中出现的最频繁。`通常在有更多不同的值的创建索引的选择性会更好`。\n\n根据实际业务场景，country列的选择性通常不高，sex列的选择性肯定很低，但是他们在很多查询中都会用到。因此建议在创建不同组合索引的时候，将（sex, country）列作为前缀，其原因如下：\n\n①、几乎所有查询都会用到sex列（若对sex列没有限制，可以通过一些技巧绕过最左前缀限制）。\n\n技巧：<u>若某个查询不限制性别，那么可以通过在查询条件中新增AND SEX IN('m','f')来让MySQL选择该索引。</u>\n\n\n\n②、考虑常见的where条件的组合，了解哪些组合在没有合适的索引情况下会很慢。(sex,country,age)上建立索引。\n\n`对于生僻的搜索条件，及时他们选择性高，使用不频繁，可以忽略他们。`\n\n\n\n#### 4.2 避免多个范围查询\n\n`对于范围查询，MySQL无法使用联合查询后面的索引。`\n\n\n\n假设有一个last_online列，并希望通过以下的查询显示在过去几周上线过的用户：\n\n```mysql\nwhere eye_color in ('brown','blue','hazel')\n    and hair_color in ('black', 'red', 'blonde', 'brown')\n    and sex in ('M','F')\n    and last_online > DATE_SUB(NOW(), INTERVAL 7 DAY)\n    and age between 18 and 25\n```\n\n这个查询中，他有两个范围查询条件，last_online和age列，MySQL可以使用last_online列索引或者age列索引，但无法同时使用他们。\n\n\n\n#### 4.3 优化排序\n\n使用文件排序对小数据集是很快的，但如果一个查询匹配的结果有上白万行会怎样？\n\n\n\n示例：高效地利用(sex,rating)索引进行排序和分页？\n\n`利用延迟关联策略，通过覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行。`\n\n```mysql\nselect <cols> from profiles inner join (\n    select <primary key cols> from profiles\n    where x.sex='M' order by rating limt 1000000, 10\n) as x using(<primary key cols>);\n```\n\n\n\n### 5 维护索引和表\n\n维护表的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。\n\n\n\n#### 5.1 找到并修复损坏的表\n\n通过以下命令可以`检查表是否发生了损坏`：\n\n```\ncheck table\n```\n\n通过以下命令可以`修复损坏的表`：\n\n```\nrepair table\n```\n\n*注：以上两个命令并不是所有存储引擎都支持。*\n\n<u>若存储引擎不支持，可以通过一个不做任何操作的alter操作来重建表</u>，如下示例所示：\n\n```\nalter table innodb_tb1 engine=innodb;\n```\n\n通常来说InnoDB引擎的表不容易损坏，若发生损坏，一般要么是数据库的硬件问题，例如内存或磁盘问题，要么是由于数据库管理员的错误，例如，在MySQL外部操作了数据文件（有可能）或者InnoDB本身的缺陷（不太可能）。\n\n\n\n#### 5.2 更新索引的统计信息\n\nMySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息：\n\n- `record_in_range()`：通过向存储引擎传入两个边界值获取这个范围大概有多少条记录。\n- `info()`：返回各种类型的数据，包括索引的基数（每个键值有多少条记录）\n\n若存储引擎向优化器提供的扫描行数信息不准确或者执行计划本身太复杂，以至于无法准确地获取各个阶段匹配的行数，那么优化器会使用索引统计信息来估算扫描行数。\n\n`MySQL优化器使用的是基于成本的模型，而衡量成本的主要指标就是一个查询需要扫描多少行。`\n\n通过以下命令来生成统计信息解决表没有统计信息或者统计信息不准确的情况。\n\n```\nanalyze table\n```\n\n通过以下命令查看索引的基数：\n\n```\nshow index from <table_name>\n```\n\n\n\n#### 5.3 减少索引和数据的碎片\n\n见参考资料1 P191\n\n\n\n### 6 总结\n\n针对B-Tree索引，在选择索引和编写利用这些索引的查询时，需要记住以下三个原则：\n\n- ①、单行访问是很慢的。特别是在机械硬盘存储中。最好读取的块中能尽可能多的包含所需的行。\n- ②、按顺序访问范围数据是很快的，其原因是：第一，顺序I/O比随机I/O快很多。第二，服务器按顺序读取数据就不需要额外的排序操作。\n- ③、覆盖索引是很快。覆盖索引避免了回表操作。\n\n\n\n如何判断一个系统创建的索引时合理的呢？\n\n- ①、按响应时间来对查询进行分析。找出那些消耗最长时间的查询或者那些给服务器最大压力的查询。\n- ②、检查这些查询的schema、SQL和索引结构，判断是否有查询扫描了太多的行，是否做了很多额外的排序或者使用了临时表，是否使用了随机I/O访问数据，或者有太多徽标查询那些不在索引中的列的操作。\n\n------\n\n### 参考资料：\n\n1  高性能MySQL_第3版 P177","slug":"高性能MySQL-创建高性能索引","published":1,"updated":"2020-09-08T08:53:36.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfgoabo9006u45g33ofy81py","content":"<p>索引是存储引擎中用于快速找到记录的一种数据结构。索引优化应该是对查询性能优化最有效的手段。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-索引基础\"><a href=\"#1-索引基础\" class=\"headerlink\" title=\"1 索引基础\"></a>1 索引基础</h3><p>索引可以包含一个或多个列（联合索引）的值。如果索引包含多个列，其列的顺序非常重要，因为MySql只能高效地使用索引的最左前缀列。</p>\n<h4 id=\"1-1-索引的类型\"><a href=\"#1-1-索引的类型\" class=\"headerlink\" title=\"1.1 索引的类型\"></a>1.1 索引的类型</h4><p><code>Mysql中的索引实现是在存储引擎层中实现的，而不是服务层</code>，因此没有统一的索引标准（不同的存储引擎的工作方式不一样）</p>\n<h5 id=\"1-1-1-B-Tree索引\"><a href=\"#1-1-1-B-Tree索引\" class=\"headerlink\" title=\"1.1.1 B-Tree索引\"></a>1.1.1 B-Tree索引</h5><p>此处的B-Tree是泛指，例如InnoDB实际使用的B+Tree；NDB实际使用的T-Tree。 大多数MySql引擎都使用这种索引。</p>\n<p>B-Tree索引的其特征如下：</p>\n<ul>\n<li>所有的值都是按顺序存储的。</li>\n<li>每个叶子页到根的距离相同。</li>\n</ul>\n<p>下图为B-Tree索引的抽象表示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E9%AB%98%E6%80%A7%E8%83%BDMySQL_%E7%AC%AC%E4%B8%89%E7%89%88-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/B-Tree%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%A4%BA.png\" alt=\"B-Tree索引的抽象表示\"></p>\n<p>其中，每个节点表示一个页，对于InnoDB存储引擎的逻辑页大小为16k。</p>\n<p>示例：假设有一个联合索引的表，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table People (</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;last_name&#96; varchar(50) not null default &#39;&#39; comment &#39;姓氏&#39;,</span><br><span class=\"line\">    &#96;first_name&#96; varchar(50) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;dob&#96; date not null comment &#39;生日&#39;,</span><br><span class=\"line\">    &#96;gender&#96; enum(&#39;m&#39;,&#39;f&#39;) not null comment &#39;性别&#39;,</span><br><span class=\"line\">    primary key (&#96;id&#96;),</span><br><span class=\"line\">    key &#96;idx_name_dob&#96;(&#96;last_name&#96;, &#96;first_name&#96;, &#96;dob&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;用户信息表&#39;</span><br></pre></td></tr></table></figure>\n\n<p>对于表中的普通联合索引，其组织数据的存储结构如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E9%AB%98%E6%80%A7%E8%83%BDMySQL_%E7%AC%AC%E4%B8%89%E7%89%88-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/%E6%99%AE%E9%80%9A%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-%E5%85%B6%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png\" alt=\"普通联合索引-其组织数据的存储结构\"></p>\n<p>注：</p>\n<ul>\n<li><p>①、索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</p>\n</li>\n<li><p>②、图中最后两个条目的人名都一样，其排序是使用出生日期进行排序的。</p>\n</li>\n</ul>\n<p><strong>B-Tree适应哪些查询类型？</strong></p>\n<ul>\n<li>全键值查询</li>\n<li>键值范围查询</li>\n<li>键前缀查询（<em>只适用于最左前缀查询</em>）</li>\n</ul>\n<p><strong>联合索引能适用于哪些查询类型呢？</strong></p>\n<ul>\n<li><code>全值匹配</code>：和索引中的所有列进行匹配；</li>\n<li><code>匹配最左前缀</code>：例如，使用索引中的第一列，或者第一及第二列；</li>\n<li><code>匹配列前缀</code>：匹配某一列的值的开头部分，如查找示例所有姓为J开头的人；</li>\n<li><code>匹配范围值</code>：如查找示例中姓氏在Allen和Barrymore之间的人；</li>\n<li><code>精确匹配某一列并范围匹配另一列</code>：例如示例中，查询所有姓氏为Allen，并且名字是字母K开头的人，即第一列全值匹配，第二列范围匹配；</li>\n<li><code>只访问索引的查询</code>：B-Tree通常可以支持只访问索引，而无需访问数据行。</li>\n</ul>\n<p><em>注：由于B-Tree索引树中的节点是有序的，因此该索引还可以用于查询ORDER BY操作（排序）。</em></p>\n<p><strong>B-Tree索引有哪些限制（缺点）？</strong></p>\n<ul>\n<li>①、如果不是按照索引的最左列开始查找，则无法使用索引。</li>\n<li>②、不能跳过索引中的列。</li>\n<li>③、如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找（即全表扫描）。</li>\n</ul>\n<p><strong>为什么MySQL数据库大部分索引结构要使用B+Tree？</strong></p>\n<h5 id=\"1-1-2-哈希索引\"><a href=\"#1-1-2-哈希索引\" class=\"headerlink\" title=\"1.1.2 哈希索引\"></a>1.1.2 哈希索引</h5><p><code>哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。</code>对于每一行数据，存储引擎都会对所有的索引列计算出一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。 </p>\n<p>Mysql中只有Memory引擎显式支持且默认支持哈希索引。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建表</span><br><span class=\"line\">create table &#96;testhash&#96; (</span><br><span class=\"line\">    &#96;fname&#96; varchar(50) not null,</span><br><span class=\"line\">    &#96;lname&#96; varchar(50) not null,</span><br><span class=\"line\">    key using hash(fname)</span><br><span class=\"line\">)engine&#x3D;memory;</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加数据</span><br><span class=\"line\">insert into &#96;testhash&#96; (&#96;fname&#96;,&#96;lname&#96;) </span><br><span class=\"line\">values </span><br><span class=\"line\">    (&#39;Arjen&#39;,&#39;Lentz&#39;),</span><br><span class=\"line\">    (&#39;Baron&#39;, &#39;Schwartz&#39;),</span><br><span class=\"line\">    (&#39;Peter&#39;, &#39;Zartsev&#39;),</span><br><span class=\"line\">    (&#39;Vadim&#39;, &#39;Tkachenko&#39;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>哈希索引的优点</strong>：</p>\n<ul>\n<li>①、索引自身只需存储对应的哈希值，因此索引结构紧凑。</li>\n<li>②、查找速度非常快。</li>\n</ul>\n<p><strong>哈希索引的限制(缺点)：</strong></p>\n<ul>\n<li>①、不能使用索引中的值来直接读取行（哈希索引只包含哈希值和行指针，而不存储字段值）</li>\n<li>②、哈希索引数据不是按照索引值顺序存储的，因此无法用于排序。</li>\n<li>③、哈希索引不支持部分索引匹配查找。（哈希索引使用是使用索引列的全部内容计算哈希值的）</li>\n<li>④、哈希索引只支持等值比较查询（=，IN(), &lt;=&gt;），也不支持任何的范围查询。</li>\n<li>⑤、当有很多哈希冲突时，会导致访问速度变慢，且维护成本代价也会很高。</li>\n</ul>\n<p><strong>哈希索引比树型索引更快，为什么MySQL的索引结构要设计成B-Tree结构？</strong></p>\n<ul>\n<li>对于哈希索引，其增删改查的平均时间复杂度为O(1)；</li>\n</ul>\n<ul>\n<li>而Tree型索引，其增删改查的平均时间复杂度为O(lg(n))；</li>\n</ul>\n<ul>\n<li>对于单行数据的读写，哈希索引均比Tree型索引块，但是对于某些特殊的查询SQL，例如分组、排序、比较等情况，哈希索引的时间复杂度会退化为O(n)，而Tree索引因为其有序的特性，能依旧保持O(lg(n))的高效率。</li>\n</ul>\n<p><em>注：InnoDB存储引擎不支持哈希索引。</em></p>\n<p><strong>哈希索引的适用场景举例？</strong></p>\n<p>在数据仓库的应用中有一种经典的“星型”schema，需要关联很多查找表，哈希索引就非常适合查找表的需求。</p>\n<h6 id=\"1-1-2-1-InnoDB的自适应哈希索引\"><a href=\"#1-1-2-1-InnoDB的自适应哈希索引\" class=\"headerlink\" title=\"1.1.2.1 InnoDB的自适应哈希索引\"></a>1.1.2.1 InnoDB的自适应哈希索引</h6><p>InnoDB会将某些使用非常频繁的索引在内存中基于B-Tree索引之上再创建一个哈希索引。这是一个完全自动、内部的行为，用于无法控制或配置，如有必要，可关闭该功能。</p>\n<h6 id=\"1-1-2-2-创建自定义哈希索引\"><a href=\"#1-1-2-2-创建自定义哈希索引\" class=\"headerlink\" title=\"1.1.2.2 创建自定义哈希索引\"></a>1.1.2.2 创建自定义哈希索引</h6><p><strong>思路</strong>：<code>在B-Tree基础上创建一个伪哈希索引</code>。需要做的就是在查询的WHERE字句中手动指定使用的哈希函数。（<em>实例见高性能MySQL P156</em>），为避免冲突问题，必须在WHERE条件中带入哈希值和对应的列值。</p>\n<p>示例：需要存储大量的URL，并根据URL进行搜索查找，若使用B-Tree来存储URL，存储的内容就会很大，因为URL本身很长。因此可以新增一个被索引的url_crc列，使用crc32做哈希，然后查询时使用以下方式查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id from url where url&#x3D;&quot;http:&#x2F;&#x2F;www&#x2F;mysql.com&quot; and url_crc&#x3D;crc32(&quot;http:&#x2F;&#x2F;www&#x2F;mysql.com&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>这样做的优点是性能非常高，但是需要维护哈希值（维护方式可以手动维护，即程序控制，还可以通过触发器维护（<em>触发器示例看参考资料1P149</em>））。</p>\n<h5 id=\"1-1-3-空间数据索引（R-Tree）\"><a href=\"#1-1-3-空间数据索引（R-Tree）\" class=\"headerlink\" title=\"1.1.3 空间数据索引（R-Tree）\"></a>1.1.3 空间数据索引（R-Tree）</h5><p><code>MyISAM引擎支持空间索引，可以样做地理数据存储</code>。该索引可以从所有维度来查询数据。必须使用MySQL的GIS相关函数来维护数据。MySQL对GIS支持不完善，不推荐使用此特性。</p>\n<p>开源关系数据库系统对GIS的解决方案做的比较好的是：PostgreSQL的PostGIS</p>\n<h5 id=\"1-1-4-全文索引\"><a href=\"#1-1-4-全文索引\" class=\"headerlink\" title=\"1.1.4 全文索引\"></a>1.1.4 全文索引</h5><p>全文索引是一种特殊类型的索引，<code>它查找的是文本中的关键词，而不是直接比较索引中的值。</code></p>\n<h3 id=\"2-索引的优点\"><a href=\"#2-索引的优点\" class=\"headerlink\" title=\"2 索引的优点\"></a>2 索引的优点</h3><p>索引可以让服务器快速定位指定位置，根据创建索引的数据结构不同，索引还有一些其他的附加作用。例如B-Tree索引，按照顺序存储数据，索引可以用于ORDER BY 和GROUP BY操作。</p>\n<p><strong>应用索引有哪些优点？</strong></p>\n<ul>\n<li>减少服务器需要扫描的数据量</li>\n<li>帮助服务器避免排序和临时表</li>\n<li>将随机I/O变为顺序I/O</li>\n</ul>\n<h3 id=\"3-高性能的索引策略\"><a href=\"#3-高性能的索引策略\" class=\"headerlink\" title=\"3 高性能的索引策略\"></a>3 高性能的索引策略</h3><h4 id=\"3-1-独立的列\"><a href=\"#3-1-独立的列\" class=\"headerlink\" title=\"3.1 独立的列\"></a>3.1 独立的列</h4><p><code>独立的列指索引列不能是表达式的一部分，也不能是函数的参数。</code></p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下面的这个查询无法使用actor_id列的索引。</span><br><span class=\"line\">select actor_id from sakila.actor where actor_id + 1 &#x3D; 5;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优化后的查询</span><br><span class=\"line\">select actor_id from sakila.actor where actor_id &#x3D; 4;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-前缀索引和索引选择性\"><a href=\"#3-2-前缀索引和索引选择性\" class=\"headerlink\" title=\"3.2 前缀索引和索引选择性\"></a>3.2 前缀索引和索引选择性</h4><p>当索引很长字符列时，会让索引变得大且慢，解决方法：</p>\n<ul>\n<li>①、模拟哈希索引</li>\n<li>②、前缀索引+索引的选择</li>\n</ul>\n<p><code>前缀索引</code>：索引开始的部分字符，节约索引空间，提高索引效率。前缀索引会降低索引的选择性。</p>\n<p><code>索引的选择性</code>：<u>指不重复的索引值和数据表的记录总数的比值。索引的选择性索高则查询的效率越高</u>。</p>\n<p>示例：创建前缀索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table sakila.city_demo add key (city(7))</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>前缀索引的优缺点分别是什么？</strong></p>\n<ul>\n<li>优点：使索引能更小、更快。</li>\n<li>缺点：Mysql无法使用前缀索引做ORDERY BY 和GROUP BY，也无法使用前缀索引做覆盖扫描。</li>\n</ul>\n<p><code>前缀索引常见的应用场景</code>：<u>针对很长的十六进制唯一ID使用前缀索引。</u></p>\n<p><strong>既然有前缀索引，那么有没有后缀索引呢？</strong></p>\n<p>其实是有后缀索引的，但MySQL原生不支持反向索引，但可以把字符串反转后存储，并基于此建立前缀索引。</p>\n<h4 id=\"3-3-多列索引\"><a href=\"#3-3-多列索引\" class=\"headerlink\" title=\"3.3 多列索引\"></a>3.3 多列索引</h4><h4 id=\"3-4-选择合适的索引顺序\"><a href=\"#3-4-选择合适的索引顺序\" class=\"headerlink\" title=\"3.4 选择合适的索引顺序\"></a>3.4 选择合适的索引顺序</h4><p>正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。</p>\n<p>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等字句的查询。</p>\n<p><code>通常来说，当不需要考虑排序或分组时，将选择性高的列放到索引最前列是很好的。</code></p>\n<h4 id=\"3-5-聚簇索引\"><a href=\"#3-5-聚簇索引\" class=\"headerlink\" title=\"3.5 聚簇索引\"></a>3.5 聚簇索引</h4><p><code>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式</code>。具体的实现细节依赖于其实现方式，但<u>InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</u></p>\n<p><code>聚簇索引的数据行实际存放在索引的叶子页（leaf page）</code>，术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。（一个表只会有一个聚簇索引）</p>\n<p>聚簇索引中的记录存放示例：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E9%AB%98%E6%80%A7%E8%83%BDMySQL_%E7%AC%AC%E4%B8%89%E7%89%88-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E8%AE%B0%E5%BD%95%E5%AD%98%E6%94%BE%E7%A4%BA%E4%BE%8B.png\" alt=\"聚簇索引中的记录存放示例\"></p>\n<p><em>对于InnoDB，通过主键聚集数据，若没有主键，InnoDB会选择一个唯一的非空索引代替，若没有唯一非空索引，InnoDB会隐式定义一个主键来作为聚簇索引。</em></p>\n<p><strong>聚簇索引的优点</strong>？</p>\n<ul>\n<li>可以将数据保存在一起。例如试下电子邮箱时，可以根据用户ID来聚集数据，这样只需要从此磁盘读取少数的数据页就能获取某个用户的全部邮件，若没有使用聚簇索引，则每封邮件都可能导致一次磁盘I/O。</li>\n<li>数据访问更快；</li>\n<li>使用覆盖索引扫描的查询可以直接使用页结点中的主键值。</li>\n</ul>\n<p><strong>聚簇索引的缺点？</strong></p>\n<ul>\n<li>聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有什么优势了。</li>\n<li>插入的速度严重依赖于插入的顺序。</li>\n<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个更新的行移动到新的位置。</li>\n<li>基于聚簇索引的表再插入新行，或者主键被更新告知需要移动行的时候，可能面临“页分裂”的问题。</li>\n<li>可能导致全表扫描变慢，尤其是行比较稀疏或者由于页分裂告知数据存储不连续的时候。</li>\n<li>二级索引可能比想象的要更大，因为二级索引的叶子节点包含了引用行的主键列。</li>\n<li>二级索引访问需要两次索引查询，而不是一次。</li>\n</ul>\n<p><strong>InnoDB和MyISAM保存数据和索引的区别？</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E9%AB%98%E6%80%A7%E8%83%BDMySQL_%E7%AC%AC%E4%B8%89%E7%89%88-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/InnoDB%E5%92%8CMyiSAM%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB.png\" alt=\"InnoDB和MyiSAM保存数据和索引的区别\"></p>\n<p><em>在InnoDB表时应该尽可能地按主键顺序插入数据，并且尽可能使用单调增加的聚簇键的值来插入新行。</em></p>\n<p><strong>那么顺序的主键有不适用的时候吗？是什么时候呢？</strong></p>\n<p>对于高并发负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”，因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是auto_increment锁机制。</p>\n<h4 id=\"3-6-覆盖索引\"><a href=\"#3-6-覆盖索引\" class=\"headerlink\" title=\"3.6 覆盖索引\"></a>3.6 覆盖索引</h4><p>定义：<code>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称为覆盖索引。</code></p>\n<p>优点：</p>\n<ul>\n<li>①、索引条目远小于数据行大小，此时Mysql会极大的减少数据访问量。</li>\n<li>②、索引按照列值顺序存储（至少单页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行的数据的I/O要少得多。</li>\n<li>③、一些存储索引（如：MyISAM）在内存中值缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要系统调用。这可能会导致严重的性能问题，尤其是那桐调用占了数据访问中最大开销的场景。</li>\n<li>④、InnoDB是聚簇索引，覆盖索引对InnoDB表特别有用，使用覆盖索引可以避免对主键索引的二次查询。</li>\n</ul>\n<p>（注：不是所有类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引）</p>\n<p><strong>如何知道一个查询被索引覆盖？</strong></p>\n<p>在EXPLAIN的EXtra列可以看到<code>“Using index”</code>的信息。</p>\n<h4 id=\"3-7-使用索引扫描来做排序\"><a href=\"#3-7-使用索引扫描来做排序\" class=\"headerlink\" title=\"3.7 使用索引扫描来做排序\"></a>3.7 使用索引扫描来做排序</h4><p><strong>MySQL生成有序结果的方式有哪些？</strong></p>\n<ul>\n<li>①、排序操作。</li>\n<li>②、索引顺序扫描。</li>\n</ul>\n<p><strong>为什么按索引顺序读取数据的速度通常要比顺序地全表扫描慢？</strong></p>\n<p>扫描索引本身是很快的，但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就得回表查询一次对应的行，这基本上都是随机I/O，因此会比顺序地全表扫描慢，尤其是在I/O密集型工作负载时。</p>\n<p>MySQL可以使用同一个索引既满足排序，又用于查找行，因此，设计索引时应该尽可能的同事满足索引和排序这两种任务。只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才能使用索引来对接过做排序。</p>\n<p>（<u>注：若多表关联查询，只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。</u>）</p>\n<p>特殊情况：有一种情况ORDER BY子句不满足索引的最左前缀的要求，就是前导列为常量的时候，如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。</p>\n<h4 id=\"3-8-压缩（前缀压缩）索引\"><a href=\"#3-8-压缩（前缀压缩）索引\" class=\"headerlink\" title=\"3.8 压缩（前缀压缩）索引\"></a>3.8 压缩（前缀压缩）索引</h4><p><code>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能，</code>默认只压缩字符串，但通过参数设置也可以对整数做压缩。`</p>\n<p><strong>MyISAM压缩每个索引块的方法是怎么样的？</strong></p>\n<p>先完全保存索引块中的第一个值，然后将其他值和第一个值比较，得到相同前缀的字节数和剩余不同后缀部分，把这部分存储起来即可。</p>\n<p><code>示例</code>：索引块中第一个值是“perform”，第二个值为“performance”，那么第二个指的前缀压缩后存储的值类似于“7，ance”这样的形式。</p>\n<p><em>注：MyISAM对行指针也采用前缀索引方式。</em></p>\n<p><strong>压缩（前缀压缩）索引的优缺点？</strong></p>\n<ul>\n<li>优点：使用更少的空间；</li>\n<li>缺点：某些操作可能更慢，比如，每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而是只能从头开始扫描。倒序扫描也支持得不是很好。</li>\n</ul>\n<p>在CREATE TABLE语句中使用<code>PACK_KEYS参数</code>来控制索引压缩的方式。</p>\n<h4 id=\"3-9-冗余和重复索引\"><a href=\"#3-9-冗余和重复索引\" class=\"headerlink\" title=\"3.9 冗余和重复索引\"></a>3.9 冗余和重复索引</h4><p>MySQL允许在相同列上创建多个索引，无论有意还是无意。</p>\n<p><code>重复索引</code>：指在相同的列上按照相同的顺序创建相同类型的索引。应该避免这样创建重复索引！</p>\n<p><code>冗余索引</code>：冗余索引与重复索引有些许不同，比如，已有联合索引（A，B），若在创建索引A，则算是冗余索引。</p>\n<h4 id=\"3-10-未使用的索引\"><a href=\"#3-10-未使用的索引\" class=\"headerlink\" title=\"3.10 未使用的索引\"></a>3.10 未使用的索引</h4><p><strong>怎样检查那些索引未使用到？</strong></p>\n<ul>\n<li>①、在Percona Server或者MariaDB中先打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS就能查到每个索引的使用频率。</li>\n<li>②、使用Percona Toolkit中pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告。</li>\n</ul>\n<h4 id=\"3-11-索引和锁\"><a href=\"#3-11-索引和锁\" class=\"headerlink\" title=\"3.11 索引和锁\"></a>3.11 索引和锁</h4><p>索引可以让查询锁定更少的行。InnoDB只有在访问行的时候才会对其加锁，而索引能够减少innoDB访问的行数，从而减少锁的数量。（仅在InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。）</p>\n<p><code>InnoDB在二级索引上使用共享锁，但访问主键索引需要排他锁</code>。</p>\n<h3 id=\"4-索引案例\"><a href=\"#4-索引案例\" class=\"headerlink\" title=\"4 索引案例\"></a>4 索引案例</h3><p>案例描述：</p>\n<p>假设要涉及一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色等等。网站必须支持上面这些特征的各种组合来搜索用户，还必须允许更具用户的最后在线时间、其他会员对用户的评分等对用户进行排序并对结果进行限制。</p>\n<p><code>第一件要考虑的事情是：需要使用索引来排序，还是先检索数据再排序。</code></p>\n<h4 id=\"4-1-支持多种过滤条件\"><a href=\"#4-1-支持多种过滤条件\" class=\"headerlink\" title=\"4.1 支持多种过滤条件\"></a>4.1 支持多种过滤条件</h4><p>分析哪些列拥有很多不同的取值，哪些列在WHERE子句中出现的最频繁。<code>通常在有更多不同的值的创建索引的选择性会更好</code>。</p>\n<p>根据实际业务场景，country列的选择性通常不高，sex列的选择性肯定很低，但是他们在很多查询中都会用到。因此建议在创建不同组合索引的时候，将（sex, country）列作为前缀，其原因如下：</p>\n<p>①、几乎所有查询都会用到sex列（若对sex列没有限制，可以通过一些技巧绕过最左前缀限制）。</p>\n<p>技巧：<u>若某个查询不限制性别，那么可以通过在查询条件中新增AND SEX IN(‘m’,’f’)来让MySQL选择该索引。</u></p>\n<p>②、考虑常见的where条件的组合，了解哪些组合在没有合适的索引情况下会很慢。(sex,country,age)上建立索引。</p>\n<p><code>对于生僻的搜索条件，及时他们选择性高，使用不频繁，可以忽略他们。</code></p>\n<h4 id=\"4-2-避免多个范围查询\"><a href=\"#4-2-避免多个范围查询\" class=\"headerlink\" title=\"4.2 避免多个范围查询\"></a>4.2 避免多个范围查询</h4><p><code>对于范围查询，MySQL无法使用联合查询后面的索引。</code></p>\n<p>假设有一个last_online列，并希望通过以下的查询显示在过去几周上线过的用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">where eye_color in (&#39;brown&#39;,&#39;blue&#39;,&#39;hazel&#39;)</span><br><span class=\"line\">    and hair_color in (&#39;black&#39;, &#39;red&#39;, &#39;blonde&#39;, &#39;brown&#39;)</span><br><span class=\"line\">    and sex in (&#39;M&#39;,&#39;F&#39;)</span><br><span class=\"line\">    and last_online &gt; DATE_SUB(NOW(), INTERVAL 7 DAY)</span><br><span class=\"line\">    and age between 18 and 25</span><br></pre></td></tr></table></figure>\n\n<p>这个查询中，他有两个范围查询条件，last_online和age列，MySQL可以使用last_online列索引或者age列索引，但无法同时使用他们。</p>\n<h4 id=\"4-3-优化排序\"><a href=\"#4-3-优化排序\" class=\"headerlink\" title=\"4.3 优化排序\"></a>4.3 优化排序</h4><p>使用文件排序对小数据集是很快的，但如果一个查询匹配的结果有上白万行会怎样？</p>\n<p>示例：高效地利用(sex,rating)索引进行排序和分页？</p>\n<p><code>利用延迟关联策略，通过覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行。</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &lt;cols&gt; from profiles inner join (</span><br><span class=\"line\">    select &lt;primary key cols&gt; from profiles</span><br><span class=\"line\">    where x.sex&#x3D;&#39;M&#39; order by rating limt 1000000, 10</span><br><span class=\"line\">) as x using(&lt;primary key cols&gt;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-维护索引和表\"><a href=\"#5-维护索引和表\" class=\"headerlink\" title=\"5 维护索引和表\"></a>5 维护索引和表</h3><p>维护表的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。</p>\n<h4 id=\"5-1-找到并修复损坏的表\"><a href=\"#5-1-找到并修复损坏的表\" class=\"headerlink\" title=\"5.1 找到并修复损坏的表\"></a>5.1 找到并修复损坏的表</h4><p>通过以下命令可以<code>检查表是否发生了损坏</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">check table</span><br></pre></td></tr></table></figure>\n\n<p>通过以下命令可以<code>修复损坏的表</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repair table</span><br></pre></td></tr></table></figure>\n\n<p><em>注：以上两个命令并不是所有存储引擎都支持。</em></p>\n<p><u>若存储引擎不支持，可以通过一个不做任何操作的alter操作来重建表</u>，如下示例所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table innodb_tb1 engine&#x3D;innodb;</span><br></pre></td></tr></table></figure>\n\n<p>通常来说InnoDB引擎的表不容易损坏，若发生损坏，一般要么是数据库的硬件问题，例如内存或磁盘问题，要么是由于数据库管理员的错误，例如，在MySQL外部操作了数据文件（有可能）或者InnoDB本身的缺陷（不太可能）。</p>\n<h4 id=\"5-2-更新索引的统计信息\"><a href=\"#5-2-更新索引的统计信息\" class=\"headerlink\" title=\"5.2 更新索引的统计信息\"></a>5.2 更新索引的统计信息</h4><p>MySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息：</p>\n<ul>\n<li><code>record_in_range()</code>：通过向存储引擎传入两个边界值获取这个范围大概有多少条记录。</li>\n<li><code>info()</code>：返回各种类型的数据，包括索引的基数（每个键值有多少条记录）</li>\n</ul>\n<p>若存储引擎向优化器提供的扫描行数信息不准确或者执行计划本身太复杂，以至于无法准确地获取各个阶段匹配的行数，那么优化器会使用索引统计信息来估算扫描行数。</p>\n<p><code>MySQL优化器使用的是基于成本的模型，而衡量成本的主要指标就是一个查询需要扫描多少行。</code></p>\n<p>通过以下命令来生成统计信息解决表没有统计信息或者统计信息不准确的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">analyze table</span><br></pre></td></tr></table></figure>\n\n<p>通过以下命令查看索引的基数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show index from &lt;table_name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-减少索引和数据的碎片\"><a href=\"#5-3-减少索引和数据的碎片\" class=\"headerlink\" title=\"5.3 减少索引和数据的碎片\"></a>5.3 减少索引和数据的碎片</h4><p>见参考资料1 P191</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h3><p>针对B-Tree索引，在选择索引和编写利用这些索引的查询时，需要记住以下三个原则：</p>\n<ul>\n<li>①、单行访问是很慢的。特别是在机械硬盘存储中。最好读取的块中能尽可能多的包含所需的行。</li>\n<li>②、按顺序访问范围数据是很快的，其原因是：第一，顺序I/O比随机I/O快很多。第二，服务器按顺序读取数据就不需要额外的排序操作。</li>\n<li>③、覆盖索引是很快。覆盖索引避免了回表操作。</li>\n</ul>\n<p>如何判断一个系统创建的索引时合理的呢？</p>\n<ul>\n<li>①、按响应时间来对查询进行分析。找出那些消耗最长时间的查询或者那些给服务器最大压力的查询。</li>\n<li>②、检查这些查询的schema、SQL和索引结构，判断是否有查询扫描了太多的行，是否做了很多额外的排序或者使用了临时表，是否使用了随机I/O访问数据，或者有太多徽标查询那些不在索引中的列的操作。</li>\n</ul>\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>1  高性能MySQL_第3版 P177</p>\n","site":{"data":{}},"excerpt":"<p>索引是存储引擎中用于快速找到记录的一种数据结构。索引优化应该是对查询性能优化最有效的手段。</p>","more":"<h3 id=\"1-索引基础\"><a href=\"#1-索引基础\" class=\"headerlink\" title=\"1 索引基础\"></a>1 索引基础</h3><p>索引可以包含一个或多个列（联合索引）的值。如果索引包含多个列，其列的顺序非常重要，因为MySql只能高效地使用索引的最左前缀列。</p>\n<h4 id=\"1-1-索引的类型\"><a href=\"#1-1-索引的类型\" class=\"headerlink\" title=\"1.1 索引的类型\"></a>1.1 索引的类型</h4><p><code>Mysql中的索引实现是在存储引擎层中实现的，而不是服务层</code>，因此没有统一的索引标准（不同的存储引擎的工作方式不一样）</p>\n<h5 id=\"1-1-1-B-Tree索引\"><a href=\"#1-1-1-B-Tree索引\" class=\"headerlink\" title=\"1.1.1 B-Tree索引\"></a>1.1.1 B-Tree索引</h5><p>此处的B-Tree是泛指，例如InnoDB实际使用的B+Tree；NDB实际使用的T-Tree。 大多数MySql引擎都使用这种索引。</p>\n<p>B-Tree索引的其特征如下：</p>\n<ul>\n<li>所有的值都是按顺序存储的。</li>\n<li>每个叶子页到根的距离相同。</li>\n</ul>\n<p>下图为B-Tree索引的抽象表示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E9%AB%98%E6%80%A7%E8%83%BDMySQL_%E7%AC%AC%E4%B8%89%E7%89%88-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/B-Tree%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%A4%BA.png\" alt=\"B-Tree索引的抽象表示\"></p>\n<p>其中，每个节点表示一个页，对于InnoDB存储引擎的逻辑页大小为16k。</p>\n<p>示例：假设有一个联合索引的表，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table People (</span><br><span class=\"line\">    &#96;id&#96; int unsigned not null auto_increment comment &#39;主键id&#39;,</span><br><span class=\"line\">    &#96;last_name&#96; varchar(50) not null default &#39;&#39; comment &#39;姓氏&#39;,</span><br><span class=\"line\">    &#96;first_name&#96; varchar(50) not null default &#39;&#39; comment &#39;名称&#39;,</span><br><span class=\"line\">    &#96;dob&#96; date not null comment &#39;生日&#39;,</span><br><span class=\"line\">    &#96;gender&#96; enum(&#39;m&#39;,&#39;f&#39;) not null comment &#39;性别&#39;,</span><br><span class=\"line\">    primary key (&#96;id&#96;),</span><br><span class=\"line\">    key &#96;idx_name_dob&#96;(&#96;last_name&#96;, &#96;first_name&#96;, &#96;dob&#96;)</span><br><span class=\"line\">) engine&#x3D;InnoDB default charset&#x3D;utf8mb4 comment&#x3D;&#39;用户信息表&#39;</span><br></pre></td></tr></table></figure>\n\n<p>对于表中的普通联合索引，其组织数据的存储结构如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E9%AB%98%E6%80%A7%E8%83%BDMySQL_%E7%AC%AC%E4%B8%89%E7%89%88-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/%E6%99%AE%E9%80%9A%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-%E5%85%B6%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png\" alt=\"普通联合索引-其组织数据的存储结构\"></p>\n<p>注：</p>\n<ul>\n<li><p>①、索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</p>\n</li>\n<li><p>②、图中最后两个条目的人名都一样，其排序是使用出生日期进行排序的。</p>\n</li>\n</ul>\n<p><strong>B-Tree适应哪些查询类型？</strong></p>\n<ul>\n<li>全键值查询</li>\n<li>键值范围查询</li>\n<li>键前缀查询（<em>只适用于最左前缀查询</em>）</li>\n</ul>\n<p><strong>联合索引能适用于哪些查询类型呢？</strong></p>\n<ul>\n<li><code>全值匹配</code>：和索引中的所有列进行匹配；</li>\n<li><code>匹配最左前缀</code>：例如，使用索引中的第一列，或者第一及第二列；</li>\n<li><code>匹配列前缀</code>：匹配某一列的值的开头部分，如查找示例所有姓为J开头的人；</li>\n<li><code>匹配范围值</code>：如查找示例中姓氏在Allen和Barrymore之间的人；</li>\n<li><code>精确匹配某一列并范围匹配另一列</code>：例如示例中，查询所有姓氏为Allen，并且名字是字母K开头的人，即第一列全值匹配，第二列范围匹配；</li>\n<li><code>只访问索引的查询</code>：B-Tree通常可以支持只访问索引，而无需访问数据行。</li>\n</ul>\n<p><em>注：由于B-Tree索引树中的节点是有序的，因此该索引还可以用于查询ORDER BY操作（排序）。</em></p>\n<p><strong>B-Tree索引有哪些限制（缺点）？</strong></p>\n<ul>\n<li>①、如果不是按照索引的最左列开始查找，则无法使用索引。</li>\n<li>②、不能跳过索引中的列。</li>\n<li>③、如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找（即全表扫描）。</li>\n</ul>\n<p><strong>为什么MySQL数据库大部分索引结构要使用B+Tree？</strong></p>\n<h5 id=\"1-1-2-哈希索引\"><a href=\"#1-1-2-哈希索引\" class=\"headerlink\" title=\"1.1.2 哈希索引\"></a>1.1.2 哈希索引</h5><p><code>哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。</code>对于每一行数据，存储引擎都会对所有的索引列计算出一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。 </p>\n<p>Mysql中只有Memory引擎显式支持且默认支持哈希索引。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 建表</span><br><span class=\"line\">create table &#96;testhash&#96; (</span><br><span class=\"line\">    &#96;fname&#96; varchar(50) not null,</span><br><span class=\"line\">    &#96;lname&#96; varchar(50) not null,</span><br><span class=\"line\">    key using hash(fname)</span><br><span class=\"line\">)engine&#x3D;memory;</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加数据</span><br><span class=\"line\">insert into &#96;testhash&#96; (&#96;fname&#96;,&#96;lname&#96;) </span><br><span class=\"line\">values </span><br><span class=\"line\">    (&#39;Arjen&#39;,&#39;Lentz&#39;),</span><br><span class=\"line\">    (&#39;Baron&#39;, &#39;Schwartz&#39;),</span><br><span class=\"line\">    (&#39;Peter&#39;, &#39;Zartsev&#39;),</span><br><span class=\"line\">    (&#39;Vadim&#39;, &#39;Tkachenko&#39;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>哈希索引的优点</strong>：</p>\n<ul>\n<li>①、索引自身只需存储对应的哈希值，因此索引结构紧凑。</li>\n<li>②、查找速度非常快。</li>\n</ul>\n<p><strong>哈希索引的限制(缺点)：</strong></p>\n<ul>\n<li>①、不能使用索引中的值来直接读取行（哈希索引只包含哈希值和行指针，而不存储字段值）</li>\n<li>②、哈希索引数据不是按照索引值顺序存储的，因此无法用于排序。</li>\n<li>③、哈希索引不支持部分索引匹配查找。（哈希索引使用是使用索引列的全部内容计算哈希值的）</li>\n<li>④、哈希索引只支持等值比较查询（=，IN(), &lt;=&gt;），也不支持任何的范围查询。</li>\n<li>⑤、当有很多哈希冲突时，会导致访问速度变慢，且维护成本代价也会很高。</li>\n</ul>\n<p><strong>哈希索引比树型索引更快，为什么MySQL的索引结构要设计成B-Tree结构？</strong></p>\n<ul>\n<li>对于哈希索引，其增删改查的平均时间复杂度为O(1)；</li>\n</ul>\n<ul>\n<li>而Tree型索引，其增删改查的平均时间复杂度为O(lg(n))；</li>\n</ul>\n<ul>\n<li>对于单行数据的读写，哈希索引均比Tree型索引块，但是对于某些特殊的查询SQL，例如分组、排序、比较等情况，哈希索引的时间复杂度会退化为O(n)，而Tree索引因为其有序的特性，能依旧保持O(lg(n))的高效率。</li>\n</ul>\n<p><em>注：InnoDB存储引擎不支持哈希索引。</em></p>\n<p><strong>哈希索引的适用场景举例？</strong></p>\n<p>在数据仓库的应用中有一种经典的“星型”schema，需要关联很多查找表，哈希索引就非常适合查找表的需求。</p>\n<h6 id=\"1-1-2-1-InnoDB的自适应哈希索引\"><a href=\"#1-1-2-1-InnoDB的自适应哈希索引\" class=\"headerlink\" title=\"1.1.2.1 InnoDB的自适应哈希索引\"></a>1.1.2.1 InnoDB的自适应哈希索引</h6><p>InnoDB会将某些使用非常频繁的索引在内存中基于B-Tree索引之上再创建一个哈希索引。这是一个完全自动、内部的行为，用于无法控制或配置，如有必要，可关闭该功能。</p>\n<h6 id=\"1-1-2-2-创建自定义哈希索引\"><a href=\"#1-1-2-2-创建自定义哈希索引\" class=\"headerlink\" title=\"1.1.2.2 创建自定义哈希索引\"></a>1.1.2.2 创建自定义哈希索引</h6><p><strong>思路</strong>：<code>在B-Tree基础上创建一个伪哈希索引</code>。需要做的就是在查询的WHERE字句中手动指定使用的哈希函数。（<em>实例见高性能MySQL P156</em>），为避免冲突问题，必须在WHERE条件中带入哈希值和对应的列值。</p>\n<p>示例：需要存储大量的URL，并根据URL进行搜索查找，若使用B-Tree来存储URL，存储的内容就会很大，因为URL本身很长。因此可以新增一个被索引的url_crc列，使用crc32做哈希，然后查询时使用以下方式查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id from url where url&#x3D;&quot;http:&#x2F;&#x2F;www&#x2F;mysql.com&quot; and url_crc&#x3D;crc32(&quot;http:&#x2F;&#x2F;www&#x2F;mysql.com&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>这样做的优点是性能非常高，但是需要维护哈希值（维护方式可以手动维护，即程序控制，还可以通过触发器维护（<em>触发器示例看参考资料1P149</em>））。</p>\n<h5 id=\"1-1-3-空间数据索引（R-Tree）\"><a href=\"#1-1-3-空间数据索引（R-Tree）\" class=\"headerlink\" title=\"1.1.3 空间数据索引（R-Tree）\"></a>1.1.3 空间数据索引（R-Tree）</h5><p><code>MyISAM引擎支持空间索引，可以样做地理数据存储</code>。该索引可以从所有维度来查询数据。必须使用MySQL的GIS相关函数来维护数据。MySQL对GIS支持不完善，不推荐使用此特性。</p>\n<p>开源关系数据库系统对GIS的解决方案做的比较好的是：PostgreSQL的PostGIS</p>\n<h5 id=\"1-1-4-全文索引\"><a href=\"#1-1-4-全文索引\" class=\"headerlink\" title=\"1.1.4 全文索引\"></a>1.1.4 全文索引</h5><p>全文索引是一种特殊类型的索引，<code>它查找的是文本中的关键词，而不是直接比较索引中的值。</code></p>\n<h3 id=\"2-索引的优点\"><a href=\"#2-索引的优点\" class=\"headerlink\" title=\"2 索引的优点\"></a>2 索引的优点</h3><p>索引可以让服务器快速定位指定位置，根据创建索引的数据结构不同，索引还有一些其他的附加作用。例如B-Tree索引，按照顺序存储数据，索引可以用于ORDER BY 和GROUP BY操作。</p>\n<p><strong>应用索引有哪些优点？</strong></p>\n<ul>\n<li>减少服务器需要扫描的数据量</li>\n<li>帮助服务器避免排序和临时表</li>\n<li>将随机I/O变为顺序I/O</li>\n</ul>\n<h3 id=\"3-高性能的索引策略\"><a href=\"#3-高性能的索引策略\" class=\"headerlink\" title=\"3 高性能的索引策略\"></a>3 高性能的索引策略</h3><h4 id=\"3-1-独立的列\"><a href=\"#3-1-独立的列\" class=\"headerlink\" title=\"3.1 独立的列\"></a>3.1 独立的列</h4><p><code>独立的列指索引列不能是表达式的一部分，也不能是函数的参数。</code></p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下面的这个查询无法使用actor_id列的索引。</span><br><span class=\"line\">select actor_id from sakila.actor where actor_id + 1 &#x3D; 5;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优化后的查询</span><br><span class=\"line\">select actor_id from sakila.actor where actor_id &#x3D; 4;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-2-前缀索引和索引选择性\"><a href=\"#3-2-前缀索引和索引选择性\" class=\"headerlink\" title=\"3.2 前缀索引和索引选择性\"></a>3.2 前缀索引和索引选择性</h4><p>当索引很长字符列时，会让索引变得大且慢，解决方法：</p>\n<ul>\n<li>①、模拟哈希索引</li>\n<li>②、前缀索引+索引的选择</li>\n</ul>\n<p><code>前缀索引</code>：索引开始的部分字符，节约索引空间，提高索引效率。前缀索引会降低索引的选择性。</p>\n<p><code>索引的选择性</code>：<u>指不重复的索引值和数据表的记录总数的比值。索引的选择性索高则查询的效率越高</u>。</p>\n<p>示例：创建前缀索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table sakila.city_demo add key (city(7))</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>前缀索引的优缺点分别是什么？</strong></p>\n<ul>\n<li>优点：使索引能更小、更快。</li>\n<li>缺点：Mysql无法使用前缀索引做ORDERY BY 和GROUP BY，也无法使用前缀索引做覆盖扫描。</li>\n</ul>\n<p><code>前缀索引常见的应用场景</code>：<u>针对很长的十六进制唯一ID使用前缀索引。</u></p>\n<p><strong>既然有前缀索引，那么有没有后缀索引呢？</strong></p>\n<p>其实是有后缀索引的，但MySQL原生不支持反向索引，但可以把字符串反转后存储，并基于此建立前缀索引。</p>\n<h4 id=\"3-3-多列索引\"><a href=\"#3-3-多列索引\" class=\"headerlink\" title=\"3.3 多列索引\"></a>3.3 多列索引</h4><h4 id=\"3-4-选择合适的索引顺序\"><a href=\"#3-4-选择合适的索引顺序\" class=\"headerlink\" title=\"3.4 选择合适的索引顺序\"></a>3.4 选择合适的索引顺序</h4><p>正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。</p>\n<p>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等字句的查询。</p>\n<p><code>通常来说，当不需要考虑排序或分组时，将选择性高的列放到索引最前列是很好的。</code></p>\n<h4 id=\"3-5-聚簇索引\"><a href=\"#3-5-聚簇索引\" class=\"headerlink\" title=\"3.5 聚簇索引\"></a>3.5 聚簇索引</h4><p><code>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式</code>。具体的实现细节依赖于其实现方式，但<u>InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</u></p>\n<p><code>聚簇索引的数据行实际存放在索引的叶子页（leaf page）</code>，术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。（一个表只会有一个聚簇索引）</p>\n<p>聚簇索引中的记录存放示例：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E9%AB%98%E6%80%A7%E8%83%BDMySQL_%E7%AC%AC%E4%B8%89%E7%89%88-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E8%AE%B0%E5%BD%95%E5%AD%98%E6%94%BE%E7%A4%BA%E4%BE%8B.png\" alt=\"聚簇索引中的记录存放示例\"></p>\n<p><em>对于InnoDB，通过主键聚集数据，若没有主键，InnoDB会选择一个唯一的非空索引代替，若没有唯一非空索引，InnoDB会隐式定义一个主键来作为聚簇索引。</em></p>\n<p><strong>聚簇索引的优点</strong>？</p>\n<ul>\n<li>可以将数据保存在一起。例如试下电子邮箱时，可以根据用户ID来聚集数据，这样只需要从此磁盘读取少数的数据页就能获取某个用户的全部邮件，若没有使用聚簇索引，则每封邮件都可能导致一次磁盘I/O。</li>\n<li>数据访问更快；</li>\n<li>使用覆盖索引扫描的查询可以直接使用页结点中的主键值。</li>\n</ul>\n<p><strong>聚簇索引的缺点？</strong></p>\n<ul>\n<li>聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有什么优势了。</li>\n<li>插入的速度严重依赖于插入的顺序。</li>\n<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个更新的行移动到新的位置。</li>\n<li>基于聚簇索引的表再插入新行，或者主键被更新告知需要移动行的时候，可能面临“页分裂”的问题。</li>\n<li>可能导致全表扫描变慢，尤其是行比较稀疏或者由于页分裂告知数据存储不连续的时候。</li>\n<li>二级索引可能比想象的要更大，因为二级索引的叶子节点包含了引用行的主键列。</li>\n<li>二级索引访问需要两次索引查询，而不是一次。</li>\n</ul>\n<p><strong>InnoDB和MyISAM保存数据和索引的区别？</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/%E9%AB%98%E6%80%A7%E8%83%BDMySQL_%E7%AC%AC%E4%B8%89%E7%89%88-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/InnoDB%E5%92%8CMyiSAM%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB.png\" alt=\"InnoDB和MyiSAM保存数据和索引的区别\"></p>\n<p><em>在InnoDB表时应该尽可能地按主键顺序插入数据，并且尽可能使用单调增加的聚簇键的值来插入新行。</em></p>\n<p><strong>那么顺序的主键有不适用的时候吗？是什么时候呢？</strong></p>\n<p>对于高并发负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”，因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是auto_increment锁机制。</p>\n<h4 id=\"3-6-覆盖索引\"><a href=\"#3-6-覆盖索引\" class=\"headerlink\" title=\"3.6 覆盖索引\"></a>3.6 覆盖索引</h4><p>定义：<code>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称为覆盖索引。</code></p>\n<p>优点：</p>\n<ul>\n<li>①、索引条目远小于数据行大小，此时Mysql会极大的减少数据访问量。</li>\n<li>②、索引按照列值顺序存储（至少单页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行的数据的I/O要少得多。</li>\n<li>③、一些存储索引（如：MyISAM）在内存中值缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要系统调用。这可能会导致严重的性能问题，尤其是那桐调用占了数据访问中最大开销的场景。</li>\n<li>④、InnoDB是聚簇索引，覆盖索引对InnoDB表特别有用，使用覆盖索引可以避免对主键索引的二次查询。</li>\n</ul>\n<p>（注：不是所有类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引）</p>\n<p><strong>如何知道一个查询被索引覆盖？</strong></p>\n<p>在EXPLAIN的EXtra列可以看到<code>“Using index”</code>的信息。</p>\n<h4 id=\"3-7-使用索引扫描来做排序\"><a href=\"#3-7-使用索引扫描来做排序\" class=\"headerlink\" title=\"3.7 使用索引扫描来做排序\"></a>3.7 使用索引扫描来做排序</h4><p><strong>MySQL生成有序结果的方式有哪些？</strong></p>\n<ul>\n<li>①、排序操作。</li>\n<li>②、索引顺序扫描。</li>\n</ul>\n<p><strong>为什么按索引顺序读取数据的速度通常要比顺序地全表扫描慢？</strong></p>\n<p>扫描索引本身是很快的，但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就得回表查询一次对应的行，这基本上都是随机I/O，因此会比顺序地全表扫描慢，尤其是在I/O密集型工作负载时。</p>\n<p>MySQL可以使用同一个索引既满足排序，又用于查找行，因此，设计索引时应该尽可能的同事满足索引和排序这两种任务。只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才能使用索引来对接过做排序。</p>\n<p>（<u>注：若多表关联查询，只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。</u>）</p>\n<p>特殊情况：有一种情况ORDER BY子句不满足索引的最左前缀的要求，就是前导列为常量的时候，如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。</p>\n<h4 id=\"3-8-压缩（前缀压缩）索引\"><a href=\"#3-8-压缩（前缀压缩）索引\" class=\"headerlink\" title=\"3.8 压缩（前缀压缩）索引\"></a>3.8 压缩（前缀压缩）索引</h4><p><code>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能，</code>默认只压缩字符串，但通过参数设置也可以对整数做压缩。`</p>\n<p><strong>MyISAM压缩每个索引块的方法是怎么样的？</strong></p>\n<p>先完全保存索引块中的第一个值，然后将其他值和第一个值比较，得到相同前缀的字节数和剩余不同后缀部分，把这部分存储起来即可。</p>\n<p><code>示例</code>：索引块中第一个值是“perform”，第二个值为“performance”，那么第二个指的前缀压缩后存储的值类似于“7，ance”这样的形式。</p>\n<p><em>注：MyISAM对行指针也采用前缀索引方式。</em></p>\n<p><strong>压缩（前缀压缩）索引的优缺点？</strong></p>\n<ul>\n<li>优点：使用更少的空间；</li>\n<li>缺点：某些操作可能更慢，比如，每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而是只能从头开始扫描。倒序扫描也支持得不是很好。</li>\n</ul>\n<p>在CREATE TABLE语句中使用<code>PACK_KEYS参数</code>来控制索引压缩的方式。</p>\n<h4 id=\"3-9-冗余和重复索引\"><a href=\"#3-9-冗余和重复索引\" class=\"headerlink\" title=\"3.9 冗余和重复索引\"></a>3.9 冗余和重复索引</h4><p>MySQL允许在相同列上创建多个索引，无论有意还是无意。</p>\n<p><code>重复索引</code>：指在相同的列上按照相同的顺序创建相同类型的索引。应该避免这样创建重复索引！</p>\n<p><code>冗余索引</code>：冗余索引与重复索引有些许不同，比如，已有联合索引（A，B），若在创建索引A，则算是冗余索引。</p>\n<h4 id=\"3-10-未使用的索引\"><a href=\"#3-10-未使用的索引\" class=\"headerlink\" title=\"3.10 未使用的索引\"></a>3.10 未使用的索引</h4><p><strong>怎样检查那些索引未使用到？</strong></p>\n<ul>\n<li>①、在Percona Server或者MariaDB中先打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS就能查到每个索引的使用频率。</li>\n<li>②、使用Percona Toolkit中pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告。</li>\n</ul>\n<h4 id=\"3-11-索引和锁\"><a href=\"#3-11-索引和锁\" class=\"headerlink\" title=\"3.11 索引和锁\"></a>3.11 索引和锁</h4><p>索引可以让查询锁定更少的行。InnoDB只有在访问行的时候才会对其加锁，而索引能够减少innoDB访问的行数，从而减少锁的数量。（仅在InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。）</p>\n<p><code>InnoDB在二级索引上使用共享锁，但访问主键索引需要排他锁</code>。</p>\n<h3 id=\"4-索引案例\"><a href=\"#4-索引案例\" class=\"headerlink\" title=\"4 索引案例\"></a>4 索引案例</h3><p>案例描述：</p>\n<p>假设要涉及一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色等等。网站必须支持上面这些特征的各种组合来搜索用户，还必须允许更具用户的最后在线时间、其他会员对用户的评分等对用户进行排序并对结果进行限制。</p>\n<p><code>第一件要考虑的事情是：需要使用索引来排序，还是先检索数据再排序。</code></p>\n<h4 id=\"4-1-支持多种过滤条件\"><a href=\"#4-1-支持多种过滤条件\" class=\"headerlink\" title=\"4.1 支持多种过滤条件\"></a>4.1 支持多种过滤条件</h4><p>分析哪些列拥有很多不同的取值，哪些列在WHERE子句中出现的最频繁。<code>通常在有更多不同的值的创建索引的选择性会更好</code>。</p>\n<p>根据实际业务场景，country列的选择性通常不高，sex列的选择性肯定很低，但是他们在很多查询中都会用到。因此建议在创建不同组合索引的时候，将（sex, country）列作为前缀，其原因如下：</p>\n<p>①、几乎所有查询都会用到sex列（若对sex列没有限制，可以通过一些技巧绕过最左前缀限制）。</p>\n<p>技巧：<u>若某个查询不限制性别，那么可以通过在查询条件中新增AND SEX IN(‘m’,’f’)来让MySQL选择该索引。</u></p>\n<p>②、考虑常见的where条件的组合，了解哪些组合在没有合适的索引情况下会很慢。(sex,country,age)上建立索引。</p>\n<p><code>对于生僻的搜索条件，及时他们选择性高，使用不频繁，可以忽略他们。</code></p>\n<h4 id=\"4-2-避免多个范围查询\"><a href=\"#4-2-避免多个范围查询\" class=\"headerlink\" title=\"4.2 避免多个范围查询\"></a>4.2 避免多个范围查询</h4><p><code>对于范围查询，MySQL无法使用联合查询后面的索引。</code></p>\n<p>假设有一个last_online列，并希望通过以下的查询显示在过去几周上线过的用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">where eye_color in (&#39;brown&#39;,&#39;blue&#39;,&#39;hazel&#39;)</span><br><span class=\"line\">    and hair_color in (&#39;black&#39;, &#39;red&#39;, &#39;blonde&#39;, &#39;brown&#39;)</span><br><span class=\"line\">    and sex in (&#39;M&#39;,&#39;F&#39;)</span><br><span class=\"line\">    and last_online &gt; DATE_SUB(NOW(), INTERVAL 7 DAY)</span><br><span class=\"line\">    and age between 18 and 25</span><br></pre></td></tr></table></figure>\n\n<p>这个查询中，他有两个范围查询条件，last_online和age列，MySQL可以使用last_online列索引或者age列索引，但无法同时使用他们。</p>\n<h4 id=\"4-3-优化排序\"><a href=\"#4-3-优化排序\" class=\"headerlink\" title=\"4.3 优化排序\"></a>4.3 优化排序</h4><p>使用文件排序对小数据集是很快的，但如果一个查询匹配的结果有上白万行会怎样？</p>\n<p>示例：高效地利用(sex,rating)索引进行排序和分页？</p>\n<p><code>利用延迟关联策略，通过覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行。</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &lt;cols&gt; from profiles inner join (</span><br><span class=\"line\">    select &lt;primary key cols&gt; from profiles</span><br><span class=\"line\">    where x.sex&#x3D;&#39;M&#39; order by rating limt 1000000, 10</span><br><span class=\"line\">) as x using(&lt;primary key cols&gt;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"5-维护索引和表\"><a href=\"#5-维护索引和表\" class=\"headerlink\" title=\"5 维护索引和表\"></a>5 维护索引和表</h3><p>维护表的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。</p>\n<h4 id=\"5-1-找到并修复损坏的表\"><a href=\"#5-1-找到并修复损坏的表\" class=\"headerlink\" title=\"5.1 找到并修复损坏的表\"></a>5.1 找到并修复损坏的表</h4><p>通过以下命令可以<code>检查表是否发生了损坏</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">check table</span><br></pre></td></tr></table></figure>\n\n<p>通过以下命令可以<code>修复损坏的表</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repair table</span><br></pre></td></tr></table></figure>\n\n<p><em>注：以上两个命令并不是所有存储引擎都支持。</em></p>\n<p><u>若存储引擎不支持，可以通过一个不做任何操作的alter操作来重建表</u>，如下示例所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table innodb_tb1 engine&#x3D;innodb;</span><br></pre></td></tr></table></figure>\n\n<p>通常来说InnoDB引擎的表不容易损坏，若发生损坏，一般要么是数据库的硬件问题，例如内存或磁盘问题，要么是由于数据库管理员的错误，例如，在MySQL外部操作了数据文件（有可能）或者InnoDB本身的缺陷（不太可能）。</p>\n<h4 id=\"5-2-更新索引的统计信息\"><a href=\"#5-2-更新索引的统计信息\" class=\"headerlink\" title=\"5.2 更新索引的统计信息\"></a>5.2 更新索引的统计信息</h4><p>MySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息：</p>\n<ul>\n<li><code>record_in_range()</code>：通过向存储引擎传入两个边界值获取这个范围大概有多少条记录。</li>\n<li><code>info()</code>：返回各种类型的数据，包括索引的基数（每个键值有多少条记录）</li>\n</ul>\n<p>若存储引擎向优化器提供的扫描行数信息不准确或者执行计划本身太复杂，以至于无法准确地获取各个阶段匹配的行数，那么优化器会使用索引统计信息来估算扫描行数。</p>\n<p><code>MySQL优化器使用的是基于成本的模型，而衡量成本的主要指标就是一个查询需要扫描多少行。</code></p>\n<p>通过以下命令来生成统计信息解决表没有统计信息或者统计信息不准确的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">analyze table</span><br></pre></td></tr></table></figure>\n\n<p>通过以下命令查看索引的基数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show index from &lt;table_name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"5-3-减少索引和数据的碎片\"><a href=\"#5-3-减少索引和数据的碎片\" class=\"headerlink\" title=\"5.3 减少索引和数据的碎片\"></a>5.3 减少索引和数据的碎片</h4><p>见参考资料1 P191</p>\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6 总结\"></a>6 总结</h3><p>针对B-Tree索引，在选择索引和编写利用这些索引的查询时，需要记住以下三个原则：</p>\n<ul>\n<li>①、单行访问是很慢的。特别是在机械硬盘存储中。最好读取的块中能尽可能多的包含所需的行。</li>\n<li>②、按顺序访问范围数据是很快的，其原因是：第一，顺序I/O比随机I/O快很多。第二，服务器按顺序读取数据就不需要额外的排序操作。</li>\n<li>③、覆盖索引是很快。覆盖索引避免了回表操作。</li>\n</ul>\n<p>如何判断一个系统创建的索引时合理的呢？</p>\n<ul>\n<li>①、按响应时间来对查询进行分析。找出那些消耗最长时间的查询或者那些给服务器最大压力的查询。</li>\n<li>②、检查这些查询的schema、SQL和索引结构，判断是否有查询扫描了太多的行，是否做了很多额外的排序或者使用了临时表，是否使用了随机I/O访问数据，或者有太多徽标查询那些不在索引中的列的操作。</li>\n</ul>\n<hr>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>1  高性能MySQL_第3版 P177</p>"},{"title":"DesignPattern-Command(命令模式)","date":"2020-09-25T03:17:34.000Z","_content":"\n\n\n### 1 概述\n\n当我们使用遥控器时，每个按钮对应了不同的功能，对于使用者来说，只需要知道某个按键的功能，并不需要这些功能涉及了哪些硬件设备，具体怎样实现执行相应的功能．\n\n<!--more-->\n\n抽象来看，通过封装方法调用，将＂动作请求者＂从＂动作执行者＂对象中解偶，这就是`Command Pattern（命令模式）`．\n\n\n\n### 2 Command（命令模式）\n\n**命令模式**指将＂请求＂封装成对象，以便使用不同的请求，队列或日志来参数化其他对象．命令也支持可撤销的操作．\n\n一个命令对象通过在特定接收者上绑定一组动作来封装一个请求，并只暴露一个execute()方法，方此方法被调用时，接收者就会进行相应的动作．\n\n\n\n其类图如下：\n\n![Command_UML](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Command_UML.png)\n\n\n\nPHP示例：\n\n```php\n// 1. 实现一个命令接口，所有命令对象均需要实现该接口．\ninterface Command\n{\n    public function execute();\n}\n\n// 2. 当前有一个Light类用于底层控制电灯的开关．\nclass Light\n{\n    public function on()\n    {\n        echo \"Light is On\\n\"; // 实现开灯.\n    }\n\n    public function off()\n    {\n        echo \"Light is Off\\n\";// todo 实现关灯.\n    }\n}\n\n// 3. 实现一个打开电灯的命令．\nclass LightOnCommand implements Command\n{\n    public $light;\n\t// 构造器被传入了某个电灯，以便让这个命令控制，然后记录在实例变量中，一旦调用execute()．就由这个电灯对象成为接收者，负责接收请求．\n    public function __construct(Light $light)\n    {\n        $this->light = $light;\n    }\n\t// 通过execute()方法调用接收对象的on方法.\n    public function execute()\n    {\n        $this->light->on();\n    }\n}\n\n// 4.有一个简单的遥控器用于打开电灯．\nclass SimpleRemoteContorl\n{\n    // 命令槽, 持有某个命令.这个命令用于控制者某个装置．\n    protected $slot;\n\t// 设置插槽控制命令，若需要更改遥控器的按钮行为，可以多次设置．\n    public function setCommand(Command $command)\n    {\n        $this->slot = $command;\n    }\n\t// 当按下按钮时，这个方法就会被调用．使得当前命令衔接插槽，并调用它的execute()方法．\n    public function buttenWasPressed()\n    {\n        $this->slot->execute();\n    }\n}\n\n// 5. 测试． \n$simpleRemoteControl = new SimpleRemoteContorl();　// 实例化一个遥控器.\n$light = new Light();　// 实例化一个灯.\n$lightOnCommand = new LightOnCommand($light);　// 实例化一个开灯的行为.\n$simpleRemoteControl->setCommand($lightOnCommand);　// 遥控器设置开灯行为.\n$simpleRemoteControl->buttenWasPressed();　// 按下遥控器.\n```\n\n\n\n#### 2.1 命令模式的优缺点\n\n优点：\n\n- 使代码可扩展，添加新命令无需更改现有的代码。\n- 减少命令和调用者的接受者的耦合。\n\n\n\n缺点：\n\n- 每增加一个命令都要增加一个类。\n\n\n\n### 3 扩展应用\n\n队列或日志请求，并支持可撤销操作 意味着Command的Execute操作可以存储状态，以便在Command本身中反转其效果。Command可能具有添加的unExecute操作，该操作可以反转先前执行调用的影响。它还可以支持日志记录更改，以便在系统崩溃时可以重新应用它们。\n\n\n\n#### 3.1 队列请求\n\n假设当前有一个工作队列，在某一端添加命令，然后另一端是线程．线程从队列中取出一个命令，调用它的execute()方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令．\n\n\n\n#### 3.2 日志请求\n\n某些应用需要我们将所有的动作都记录在日志中，并能在系统司机后，重新调用这些动作恢复到之前的状态．使用命令模式将能支持这一点．\n\n当我们执行命令的时候，将历史记录存储在磁盘上，一旦系统死机，我们就可以将命令对象重新加载，并程批得依次调用这些对象的execute方法．\n\n\n\n### 4 总结\n\n- 命令模式将发出请求的对象和执行请求的对象解耦；\n- 在被解耦的两者之间是通过命令对象进行通信的．命令对象封装了接收者和一个或一组动作．\n- 调用者通过调用命令对象的execute()发出请求，使得接收者的动作被调用；\n- 调用者可以接收命令当作参数，甚至在运行时动态的进行；\n- 命令可以支持撤销，做法时实现一个undo()方法来回到execute()被执行前的状态．\n\n\n\n------\n\n### 参考资料\n\nFirst Head设计模式——封装调用：命令模式\n[Command Pattern](https://www.geeksforgeeks.org/command-pattern/)\n\n\n\n","source":"_posts/DesignPattern-Command.md","raw":"---\ntitle: DesignPattern-Command(命令模式)\ndate: 2020-09-25 11:17:34\ntags: [\"DesignPattern\",\"Command\"]\ncategories: [\"DesignPattern\"]\n---\n\n\n\n### 1 概述\n\n当我们使用遥控器时，每个按钮对应了不同的功能，对于使用者来说，只需要知道某个按键的功能，并不需要这些功能涉及了哪些硬件设备，具体怎样实现执行相应的功能．\n\n<!--more-->\n\n抽象来看，通过封装方法调用，将＂动作请求者＂从＂动作执行者＂对象中解偶，这就是`Command Pattern（命令模式）`．\n\n\n\n### 2 Command（命令模式）\n\n**命令模式**指将＂请求＂封装成对象，以便使用不同的请求，队列或日志来参数化其他对象．命令也支持可撤销的操作．\n\n一个命令对象通过在特定接收者上绑定一组动作来封装一个请求，并只暴露一个execute()方法，方此方法被调用时，接收者就会进行相应的动作．\n\n\n\n其类图如下：\n\n![Command_UML](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Command_UML.png)\n\n\n\nPHP示例：\n\n```php\n// 1. 实现一个命令接口，所有命令对象均需要实现该接口．\ninterface Command\n{\n    public function execute();\n}\n\n// 2. 当前有一个Light类用于底层控制电灯的开关．\nclass Light\n{\n    public function on()\n    {\n        echo \"Light is On\\n\"; // 实现开灯.\n    }\n\n    public function off()\n    {\n        echo \"Light is Off\\n\";// todo 实现关灯.\n    }\n}\n\n// 3. 实现一个打开电灯的命令．\nclass LightOnCommand implements Command\n{\n    public $light;\n\t// 构造器被传入了某个电灯，以便让这个命令控制，然后记录在实例变量中，一旦调用execute()．就由这个电灯对象成为接收者，负责接收请求．\n    public function __construct(Light $light)\n    {\n        $this->light = $light;\n    }\n\t// 通过execute()方法调用接收对象的on方法.\n    public function execute()\n    {\n        $this->light->on();\n    }\n}\n\n// 4.有一个简单的遥控器用于打开电灯．\nclass SimpleRemoteContorl\n{\n    // 命令槽, 持有某个命令.这个命令用于控制者某个装置．\n    protected $slot;\n\t// 设置插槽控制命令，若需要更改遥控器的按钮行为，可以多次设置．\n    public function setCommand(Command $command)\n    {\n        $this->slot = $command;\n    }\n\t// 当按下按钮时，这个方法就会被调用．使得当前命令衔接插槽，并调用它的execute()方法．\n    public function buttenWasPressed()\n    {\n        $this->slot->execute();\n    }\n}\n\n// 5. 测试． \n$simpleRemoteControl = new SimpleRemoteContorl();　// 实例化一个遥控器.\n$light = new Light();　// 实例化一个灯.\n$lightOnCommand = new LightOnCommand($light);　// 实例化一个开灯的行为.\n$simpleRemoteControl->setCommand($lightOnCommand);　// 遥控器设置开灯行为.\n$simpleRemoteControl->buttenWasPressed();　// 按下遥控器.\n```\n\n\n\n#### 2.1 命令模式的优缺点\n\n优点：\n\n- 使代码可扩展，添加新命令无需更改现有的代码。\n- 减少命令和调用者的接受者的耦合。\n\n\n\n缺点：\n\n- 每增加一个命令都要增加一个类。\n\n\n\n### 3 扩展应用\n\n队列或日志请求，并支持可撤销操作 意味着Command的Execute操作可以存储状态，以便在Command本身中反转其效果。Command可能具有添加的unExecute操作，该操作可以反转先前执行调用的影响。它还可以支持日志记录更改，以便在系统崩溃时可以重新应用它们。\n\n\n\n#### 3.1 队列请求\n\n假设当前有一个工作队列，在某一端添加命令，然后另一端是线程．线程从队列中取出一个命令，调用它的execute()方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令．\n\n\n\n#### 3.2 日志请求\n\n某些应用需要我们将所有的动作都记录在日志中，并能在系统司机后，重新调用这些动作恢复到之前的状态．使用命令模式将能支持这一点．\n\n当我们执行命令的时候，将历史记录存储在磁盘上，一旦系统死机，我们就可以将命令对象重新加载，并程批得依次调用这些对象的execute方法．\n\n\n\n### 4 总结\n\n- 命令模式将发出请求的对象和执行请求的对象解耦；\n- 在被解耦的两者之间是通过命令对象进行通信的．命令对象封装了接收者和一个或一组动作．\n- 调用者通过调用命令对象的execute()发出请求，使得接收者的动作被调用；\n- 调用者可以接收命令当作参数，甚至在运行时动态的进行；\n- 命令可以支持撤销，做法时实现一个undo()方法来回到execute()被执行前的状态．\n\n\n\n------\n\n### 参考资料\n\nFirst Head设计模式——封装调用：命令模式\n[Command Pattern](https://www.geeksforgeeks.org/command-pattern/)\n\n\n\n","slug":"DesignPattern-Command","published":1,"updated":"2020-09-25T09:37:08.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfi1xptk0000qbg3bou775yk","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>当我们使用遥控器时，每个按钮对应了不同的功能，对于使用者来说，只需要知道某个按键的功能，并不需要这些功能涉及了哪些硬件设备，具体怎样实现执行相应的功能．</p>\n<a id=\"more\"></a>\n\n<p>抽象来看，通过封装方法调用，将＂动作请求者＂从＂动作执行者＂对象中解偶，这就是<code>Command Pattern（命令模式）</code>．</p>\n<h3 id=\"2-Command（命令模式）\"><a href=\"#2-Command（命令模式）\" class=\"headerlink\" title=\"2 Command（命令模式）\"></a>2 Command（命令模式）</h3><p><strong>命令模式</strong>指将＂请求＂封装成对象，以便使用不同的请求，队列或日志来参数化其他对象．命令也支持可撤销的操作．</p>\n<p>一个命令对象通过在特定接收者上绑定一组动作来封装一个请求，并只暴露一个execute()方法，方此方法被调用时，接收者就会进行相应的动作．</p>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Command_UML.png\" alt=\"Command_UML\"></p>\n<p>PHP示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 实现一个命令接口，所有命令对象均需要实现该接口．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 当前有一个Light类用于底层控制电灯的开关．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Light</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">on</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Light is On\\n&quot;</span>; <span class=\"comment\">// 实现开灯.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">off</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Light is Off\\n&quot;</span>;<span class=\"comment\">// todo 实现关灯.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 实现一个打开电灯的命令．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LightOnCommand</span> <span class=\"keyword\">implements</span> <span class=\"title\">Command</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $light;</span><br><span class=\"line\">\t<span class=\"comment\">// 构造器被传入了某个电灯，以便让这个命令控制，然后记录在实例变量中，一旦调用execute()．就由这个电灯对象成为接收者，负责接收请求．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\">Light $light</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;light = $light;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 通过execute()方法调用接收对象的on方法.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;light-&gt;on();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4.有一个简单的遥控器用于打开电灯．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleRemoteContorl</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 命令槽, 持有某个命令.这个命令用于控制者某个装置．</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> $slot;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置插槽控制命令，若需要更改遥控器的按钮行为，可以多次设置．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setCommand</span>(<span class=\"params\">Command $command</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;slot = $command;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 当按下按钮时，这个方法就会被调用．使得当前命令衔接插槽，并调用它的execute()方法．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buttenWasPressed</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;slot-&gt;execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 测试． </span></span><br><span class=\"line\">$simpleRemoteControl = <span class=\"keyword\">new</span> SimpleRemoteContorl();　<span class=\"comment\">// 实例化一个遥控器.</span></span><br><span class=\"line\">$light = <span class=\"keyword\">new</span> Light();　<span class=\"comment\">// 实例化一个灯.</span></span><br><span class=\"line\">$lightOnCommand = <span class=\"keyword\">new</span> LightOnCommand($light);　<span class=\"comment\">// 实例化一个开灯的行为.</span></span><br><span class=\"line\">$simpleRemoteControl-&gt;setCommand($lightOnCommand);　<span class=\"comment\">// 遥控器设置开灯行为.</span></span><br><span class=\"line\">$simpleRemoteControl-&gt;buttenWasPressed();　<span class=\"comment\">// 按下遥控器.</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-命令模式的优缺点\"><a href=\"#2-1-命令模式的优缺点\" class=\"headerlink\" title=\"2.1 命令模式的优缺点\"></a>2.1 命令模式的优缺点</h4><p>优点：</p>\n<ul>\n<li>使代码可扩展，添加新命令无需更改现有的代码。</li>\n<li>减少命令和调用者的接受者的耦合。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>每增加一个命令都要增加一个类。</li>\n</ul>\n<h3 id=\"3-扩展应用\"><a href=\"#3-扩展应用\" class=\"headerlink\" title=\"3 扩展应用\"></a>3 扩展应用</h3><p>队列或日志请求，并支持可撤销操作 意味着Command的Execute操作可以存储状态，以便在Command本身中反转其效果。Command可能具有添加的unExecute操作，该操作可以反转先前执行调用的影响。它还可以支持日志记录更改，以便在系统崩溃时可以重新应用它们。</p>\n<h4 id=\"3-1-队列请求\"><a href=\"#3-1-队列请求\" class=\"headerlink\" title=\"3.1 队列请求\"></a>3.1 队列请求</h4><p>假设当前有一个工作队列，在某一端添加命令，然后另一端是线程．线程从队列中取出一个命令，调用它的execute()方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令．</p>\n<h4 id=\"3-2-日志请求\"><a href=\"#3-2-日志请求\" class=\"headerlink\" title=\"3.2 日志请求\"></a>3.2 日志请求</h4><p>某些应用需要我们将所有的动作都记录在日志中，并能在系统司机后，重新调用这些动作恢复到之前的状态．使用命令模式将能支持这一点．</p>\n<p>当我们执行命令的时候，将历史记录存储在磁盘上，一旦系统死机，我们就可以将命令对象重新加载，并程批得依次调用这些对象的execute方法．</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h3><ul>\n<li>命令模式将发出请求的对象和执行请求的对象解耦；</li>\n<li>在被解耦的两者之间是通过命令对象进行通信的．命令对象封装了接收者和一个或一组动作．</li>\n<li>调用者通过调用命令对象的execute()发出请求，使得接收者的动作被调用；</li>\n<li>调用者可以接收命令当作参数，甚至在运行时动态的进行；</li>\n<li>命令可以支持撤销，做法时实现一个undo()方法来回到execute()被执行前的状态．</li>\n</ul>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>First Head设计模式——封装调用：命令模式<br><a href=\"https://www.geeksforgeeks.org/command-pattern/\">Command Pattern</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>当我们使用遥控器时，每个按钮对应了不同的功能，对于使用者来说，只需要知道某个按键的功能，并不需要这些功能涉及了哪些硬件设备，具体怎样实现执行相应的功能．</p>","more":"<p>抽象来看，通过封装方法调用，将＂动作请求者＂从＂动作执行者＂对象中解偶，这就是<code>Command Pattern（命令模式）</code>．</p>\n<h3 id=\"2-Command（命令模式）\"><a href=\"#2-Command（命令模式）\" class=\"headerlink\" title=\"2 Command（命令模式）\"></a>2 Command（命令模式）</h3><p><strong>命令模式</strong>指将＂请求＂封装成对象，以便使用不同的请求，队列或日志来参数化其他对象．命令也支持可撤销的操作．</p>\n<p>一个命令对象通过在特定接收者上绑定一组动作来封装一个请求，并只暴露一个execute()方法，方此方法被调用时，接收者就会进行相应的动作．</p>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Command_UML.png\" alt=\"Command_UML\"></p>\n<p>PHP示例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 实现一个命令接口，所有命令对象均需要实现该接口．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 当前有一个Light类用于底层控制电灯的开关．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Light</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">on</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Light is On\\n&quot;</span>; <span class=\"comment\">// 实现开灯.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">off</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Light is Off\\n&quot;</span>;<span class=\"comment\">// todo 实现关灯.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 实现一个打开电灯的命令．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LightOnCommand</span> <span class=\"keyword\">implements</span> <span class=\"title\">Command</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $light;</span><br><span class=\"line\">\t<span class=\"comment\">// 构造器被传入了某个电灯，以便让这个命令控制，然后记录在实例变量中，一旦调用execute()．就由这个电灯对象成为接收者，负责接收请求．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\">Light $light</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;light = $light;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 通过execute()方法调用接收对象的on方法.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;light-&gt;on();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4.有一个简单的遥控器用于打开电灯．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleRemoteContorl</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 命令槽, 持有某个命令.这个命令用于控制者某个装置．</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> $slot;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置插槽控制命令，若需要更改遥控器的按钮行为，可以多次设置．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setCommand</span>(<span class=\"params\">Command $command</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;slot = $command;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 当按下按钮时，这个方法就会被调用．使得当前命令衔接插槽，并调用它的execute()方法．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buttenWasPressed</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;slot-&gt;execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 测试． </span></span><br><span class=\"line\">$simpleRemoteControl = <span class=\"keyword\">new</span> SimpleRemoteContorl();　<span class=\"comment\">// 实例化一个遥控器.</span></span><br><span class=\"line\">$light = <span class=\"keyword\">new</span> Light();　<span class=\"comment\">// 实例化一个灯.</span></span><br><span class=\"line\">$lightOnCommand = <span class=\"keyword\">new</span> LightOnCommand($light);　<span class=\"comment\">// 实例化一个开灯的行为.</span></span><br><span class=\"line\">$simpleRemoteControl-&gt;setCommand($lightOnCommand);　<span class=\"comment\">// 遥控器设置开灯行为.</span></span><br><span class=\"line\">$simpleRemoteControl-&gt;buttenWasPressed();　<span class=\"comment\">// 按下遥控器.</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-命令模式的优缺点\"><a href=\"#2-1-命令模式的优缺点\" class=\"headerlink\" title=\"2.1 命令模式的优缺点\"></a>2.1 命令模式的优缺点</h4><p>优点：</p>\n<ul>\n<li>使代码可扩展，添加新命令无需更改现有的代码。</li>\n<li>减少命令和调用者的接受者的耦合。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>每增加一个命令都要增加一个类。</li>\n</ul>\n<h3 id=\"3-扩展应用\"><a href=\"#3-扩展应用\" class=\"headerlink\" title=\"3 扩展应用\"></a>3 扩展应用</h3><p>队列或日志请求，并支持可撤销操作 意味着Command的Execute操作可以存储状态，以便在Command本身中反转其效果。Command可能具有添加的unExecute操作，该操作可以反转先前执行调用的影响。它还可以支持日志记录更改，以便在系统崩溃时可以重新应用它们。</p>\n<h4 id=\"3-1-队列请求\"><a href=\"#3-1-队列请求\" class=\"headerlink\" title=\"3.1 队列请求\"></a>3.1 队列请求</h4><p>假设当前有一个工作队列，在某一端添加命令，然后另一端是线程．线程从队列中取出一个命令，调用它的execute()方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令．</p>\n<h4 id=\"3-2-日志请求\"><a href=\"#3-2-日志请求\" class=\"headerlink\" title=\"3.2 日志请求\"></a>3.2 日志请求</h4><p>某些应用需要我们将所有的动作都记录在日志中，并能在系统司机后，重新调用这些动作恢复到之前的状态．使用命令模式将能支持这一点．</p>\n<p>当我们执行命令的时候，将历史记录存储在磁盘上，一旦系统死机，我们就可以将命令对象重新加载，并程批得依次调用这些对象的execute方法．</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4 总结\"></a>4 总结</h3><ul>\n<li>命令模式将发出请求的对象和执行请求的对象解耦；</li>\n<li>在被解耦的两者之间是通过命令对象进行通信的．命令对象封装了接收者和一个或一组动作．</li>\n<li>调用者通过调用命令对象的execute()发出请求，使得接收者的动作被调用；</li>\n<li>调用者可以接收命令当作参数，甚至在运行时动态的进行；</li>\n<li>命令可以支持撤销，做法时实现一个undo()方法来回到execute()被执行前的状态．</li>\n</ul>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>First Head设计模式——封装调用：命令模式<br><a href=\"https://www.geeksforgeeks.org/command-pattern/\">Command Pattern</a></p>"},{"title":"Concept-什么是ORM？","date":"2020-09-25T14:27:39.000Z","_content":"\n### 1 什么是ORM?\n\nORM（Object Relation Mapping，对象关系映射）是一种程序设计技术，通过面向对象编程语言的语法，完成关系型数据库的操作．\n\n<!--more-->\n\nORM把数据库映射成对象：\n\n```\n数据库的表（table）   --->  类（class）\n记录（record，行记录） --->  对象（object）\n字段（filed）        --->   对象的属性（attribute）\n```\n\n\n\n示例所示：通常对于数据库，采用SQL方式查询如下：\n\n```mysql\nselect * from users where uid = 123;\n```\n\n\n\nORM通过使用我们自行选择的语言而非SQL与数据库进行交互：\n\n```\nvar orm = require（'generic-orm-libarry'）;\nvar user = orm（“users”）．where（{uid：123}）;\n```\n\n\n\n### 2 ORM的优缺点\n\n优点：\n\n- 数据模型都在一个地方定义，更容易更新和维护，也利于代码重用；\n- ORM有现成的工具，许多高级功能可以自动完成，例如数据消毒、事务、连接池、迁移、流等其他功能的支持；\n- 当使用MVC架构时，ORM就是现成的Model，使最终代码更加清晰；\n- 基于ORM的业务代码更简单，代码量少，语义清晰，容易理解；\n- 它抽象了数据库系统，因此可以更为方便地切换数据库类型，如从MySQL切换到PostgreSQL；\n- 使许多查询的性能比自行编写SQL语句的性能更好；\n- 对于没有DBA的小型团队中，使用ORM将极大简化数据层的工作。\n\n\n\n缺点：\n\n- ORM库不是轻量级工具，将增加学习ORM的成本；\n- 对于复杂的查询，ORM可能无法表示，或性能不如原生的SQL;\n- ORM的初始配置可能较为复杂；\n- 作为开发人员，重要的是要了解其原理，而ORM抽象掉了数据层，可能导致开发者对底层原理理解不到位，也无法定制一些特殊的SQL;\n\n\n\n### 3 关系类型\n\n表与表之间的关系，分为三种：\n\n- `一对一`：一种对象与另一种对象是一一对应关系；比如一个顾客只能对应一张入场票；\n- `一对多`：一种对象可以属于另一个对象的多个实例，比如一张唱片包含多首歌；\n- `多对多`：两种对象彼此都是＂一对多＂关系，比如一张唱片包含多首歌，同时一首歌可以属于多张唱片．\n\n\n\n### 4 ORM的实现\n\nORM中有两种常用的实现模式：`Active Record`和`Data Mapper`\n\n\n\n#### 4.1 Active Record\n\nActive Record模式的ORM将对象映射到数据库行．\n\n\n\n如下示例所示：创建一个User对象，设置username，然后将该对象保存到数据库中．将User对象映射到users表中的一行．\n\n```php\n$user = new User;  \n$user->username = ‘philipbrown’;  \n$user->save();  \n```\n\n\n\nActive Record模式的优点：\n\n- 可以简单的调用`save()`方法来更新数据库．\n- 每个模型对象都继承自基础Active Record对象，因此可以访问所有与持久性有关的方法．\n- Active Record实现非常直观，容易上手．\n\n\n\n#### 4.2 Data Mapper\n\nActive Record和Data Mapper模式之间的最大区别是，Data Mapper模式将对象与持久层完全分开．\n\n\n\n如下示例所示：Data Mapper使用一个完全不同的服务，如`EntityManager`进行数据持久化到数据库．\n\n```php\n$user = new User;  \n$user->username = ‘philipbrown’;  \nEntityManager::persist($user);  \n```\n\n\n\nData Mapper模式的优点：\n\n- 对象不需要了解他们如何存储数据库，因此对象将更加轻便，因为它们不必继承完整的ORM．\n- 与数据库进行交互的过程更加严格，不能在代码中调用`save()`方法．\n\n\n\n### 5 常见ORM框架\n\n各种语言常见的ORM框架【*参考资料3*】\n\n- JAVA：ActiveJDBC、Hibernate、MyBatis等\n- PHP：Doctrine、Yii、Laravel等\n\n\n\n------\n\n### 参考资料\n\n1. [What is an ORM and Why You Should Use it](https://blog.bitsrc.io/what-is-an-orm-and-why-you-should-use-it-b2b6f75f5e2a)\n2. [对象关系映射](https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84)\n3. [List of object-relational mapping software](https://en.wikipedia.org/wiki/List_of_object-relational_mapping_software)\n4. [Active Record和Data Mapper有什么区别？](https://culttt.com/2014/06/18/whats-difference-active-record-data-mapper/)\n\n","source":"_posts/Concept-ORM是什么？.md","raw":"---\ntitle: Concept-什么是ORM？\ndate: 2020-09-25 22:27:39\ntags: [\"Concept\",\"ORM\"]\ncategories: [\"Concept\"]\n---\n\n### 1 什么是ORM?\n\nORM（Object Relation Mapping，对象关系映射）是一种程序设计技术，通过面向对象编程语言的语法，完成关系型数据库的操作．\n\n<!--more-->\n\nORM把数据库映射成对象：\n\n```\n数据库的表（table）   --->  类（class）\n记录（record，行记录） --->  对象（object）\n字段（filed）        --->   对象的属性（attribute）\n```\n\n\n\n示例所示：通常对于数据库，采用SQL方式查询如下：\n\n```mysql\nselect * from users where uid = 123;\n```\n\n\n\nORM通过使用我们自行选择的语言而非SQL与数据库进行交互：\n\n```\nvar orm = require（'generic-orm-libarry'）;\nvar user = orm（“users”）．where（{uid：123}）;\n```\n\n\n\n### 2 ORM的优缺点\n\n优点：\n\n- 数据模型都在一个地方定义，更容易更新和维护，也利于代码重用；\n- ORM有现成的工具，许多高级功能可以自动完成，例如数据消毒、事务、连接池、迁移、流等其他功能的支持；\n- 当使用MVC架构时，ORM就是现成的Model，使最终代码更加清晰；\n- 基于ORM的业务代码更简单，代码量少，语义清晰，容易理解；\n- 它抽象了数据库系统，因此可以更为方便地切换数据库类型，如从MySQL切换到PostgreSQL；\n- 使许多查询的性能比自行编写SQL语句的性能更好；\n- 对于没有DBA的小型团队中，使用ORM将极大简化数据层的工作。\n\n\n\n缺点：\n\n- ORM库不是轻量级工具，将增加学习ORM的成本；\n- 对于复杂的查询，ORM可能无法表示，或性能不如原生的SQL;\n- ORM的初始配置可能较为复杂；\n- 作为开发人员，重要的是要了解其原理，而ORM抽象掉了数据层，可能导致开发者对底层原理理解不到位，也无法定制一些特殊的SQL;\n\n\n\n### 3 关系类型\n\n表与表之间的关系，分为三种：\n\n- `一对一`：一种对象与另一种对象是一一对应关系；比如一个顾客只能对应一张入场票；\n- `一对多`：一种对象可以属于另一个对象的多个实例，比如一张唱片包含多首歌；\n- `多对多`：两种对象彼此都是＂一对多＂关系，比如一张唱片包含多首歌，同时一首歌可以属于多张唱片．\n\n\n\n### 4 ORM的实现\n\nORM中有两种常用的实现模式：`Active Record`和`Data Mapper`\n\n\n\n#### 4.1 Active Record\n\nActive Record模式的ORM将对象映射到数据库行．\n\n\n\n如下示例所示：创建一个User对象，设置username，然后将该对象保存到数据库中．将User对象映射到users表中的一行．\n\n```php\n$user = new User;  \n$user->username = ‘philipbrown’;  \n$user->save();  \n```\n\n\n\nActive Record模式的优点：\n\n- 可以简单的调用`save()`方法来更新数据库．\n- 每个模型对象都继承自基础Active Record对象，因此可以访问所有与持久性有关的方法．\n- Active Record实现非常直观，容易上手．\n\n\n\n#### 4.2 Data Mapper\n\nActive Record和Data Mapper模式之间的最大区别是，Data Mapper模式将对象与持久层完全分开．\n\n\n\n如下示例所示：Data Mapper使用一个完全不同的服务，如`EntityManager`进行数据持久化到数据库．\n\n```php\n$user = new User;  \n$user->username = ‘philipbrown’;  \nEntityManager::persist($user);  \n```\n\n\n\nData Mapper模式的优点：\n\n- 对象不需要了解他们如何存储数据库，因此对象将更加轻便，因为它们不必继承完整的ORM．\n- 与数据库进行交互的过程更加严格，不能在代码中调用`save()`方法．\n\n\n\n### 5 常见ORM框架\n\n各种语言常见的ORM框架【*参考资料3*】\n\n- JAVA：ActiveJDBC、Hibernate、MyBatis等\n- PHP：Doctrine、Yii、Laravel等\n\n\n\n------\n\n### 参考资料\n\n1. [What is an ORM and Why You Should Use it](https://blog.bitsrc.io/what-is-an-orm-and-why-you-should-use-it-b2b6f75f5e2a)\n2. [对象关系映射](https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84)\n3. [List of object-relational mapping software](https://en.wikipedia.org/wiki/List_of_object-relational_mapping_software)\n4. [Active Record和Data Mapper有什么区别？](https://culttt.com/2014/06/18/whats-difference-active-record-data-mapper/)\n\n","slug":"Concept-ORM是什么？","published":1,"updated":"2020-09-27T10:03:55.601Z","_id":"ckfjv880w00012svtgqukhd4w","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-什么是ORM\"><a href=\"#1-什么是ORM\" class=\"headerlink\" title=\"1 什么是ORM?\"></a>1 什么是ORM?</h3><p>ORM（Object Relation Mapping，对象关系映射）是一种程序设计技术，通过面向对象编程语言的语法，完成关系型数据库的操作．</p>\n<a id=\"more\"></a>\n\n<p>ORM把数据库映射成对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据库的表（table）   ---&gt;  类（class）</span><br><span class=\"line\">记录（record，行记录） ---&gt;  对象（object）</span><br><span class=\"line\">字段（filed）        ---&gt;   对象的属性（attribute）</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例所示：通常对于数据库，采用SQL方式查询如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from users where uid &#x3D; 123;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ORM通过使用我们自行选择的语言而非SQL与数据库进行交互：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var orm &#x3D; require（&#39;generic-orm-libarry&#39;）;</span><br><span class=\"line\">var user &#x3D; orm（“users”）．where（&#123;uid：123&#125;）;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-ORM的优缺点\"><a href=\"#2-ORM的优缺点\" class=\"headerlink\" title=\"2 ORM的优缺点\"></a>2 ORM的优缺点</h3><p>优点：</p>\n<ul>\n<li>数据模型都在一个地方定义，更容易更新和维护，也利于代码重用；</li>\n<li>ORM有现成的工具，许多高级功能可以自动完成，例如数据消毒、事务、连接池、迁移、流等其他功能的支持；</li>\n<li>当使用MVC架构时，ORM就是现成的Model，使最终代码更加清晰；</li>\n<li>基于ORM的业务代码更简单，代码量少，语义清晰，容易理解；</li>\n<li>它抽象了数据库系统，因此可以更为方便地切换数据库类型，如从MySQL切换到PostgreSQL；</li>\n<li>使许多查询的性能比自行编写SQL语句的性能更好；</li>\n<li>对于没有DBA的小型团队中，使用ORM将极大简化数据层的工作。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>ORM库不是轻量级工具，将增加学习ORM的成本；</li>\n<li>对于复杂的查询，ORM可能无法表示，或性能不如原生的SQL;</li>\n<li>ORM的初始配置可能较为复杂；</li>\n<li>作为开发人员，重要的是要了解其原理，而ORM抽象掉了数据层，可能导致开发者对底层原理理解不到位，也无法定制一些特殊的SQL;</li>\n</ul>\n<h3 id=\"3-关系类型\"><a href=\"#3-关系类型\" class=\"headerlink\" title=\"3 关系类型\"></a>3 关系类型</h3><p>表与表之间的关系，分为三种：</p>\n<ul>\n<li><code>一对一</code>：一种对象与另一种对象是一一对应关系；比如一个顾客只能对应一张入场票；</li>\n<li><code>一对多</code>：一种对象可以属于另一个对象的多个实例，比如一张唱片包含多首歌；</li>\n<li><code>多对多</code>：两种对象彼此都是＂一对多＂关系，比如一张唱片包含多首歌，同时一首歌可以属于多张唱片．</li>\n</ul>\n<h3 id=\"4-ORM的实现\"><a href=\"#4-ORM的实现\" class=\"headerlink\" title=\"4 ORM的实现\"></a>4 ORM的实现</h3><p>ORM中有两种常用的实现模式：<code>Active Record</code>和<code>Data Mapper</code></p>\n<h4 id=\"4-1-Active-Record\"><a href=\"#4-1-Active-Record\" class=\"headerlink\" title=\"4.1 Active Record\"></a>4.1 Active Record</h4><p>Active Record模式的ORM将对象映射到数据库行．</p>\n<p>如下示例所示：创建一个User对象，设置username，然后将该对象保存到数据库中．将User对象映射到users表中的一行．</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$user = <span class=\"keyword\">new</span> User;  </span><br><span class=\"line\">$user-&gt;username = ‘philipbrown’;  </span><br><span class=\"line\">$user-&gt;save();  </span><br></pre></td></tr></table></figure>\n\n\n\n<p>Active Record模式的优点：</p>\n<ul>\n<li>可以简单的调用<code>save()</code>方法来更新数据库．</li>\n<li>每个模型对象都继承自基础Active Record对象，因此可以访问所有与持久性有关的方法．</li>\n<li>Active Record实现非常直观，容易上手．</li>\n</ul>\n<h4 id=\"4-2-Data-Mapper\"><a href=\"#4-2-Data-Mapper\" class=\"headerlink\" title=\"4.2 Data Mapper\"></a>4.2 Data Mapper</h4><p>Active Record和Data Mapper模式之间的最大区别是，Data Mapper模式将对象与持久层完全分开．</p>\n<p>如下示例所示：Data Mapper使用一个完全不同的服务，如<code>EntityManager</code>进行数据持久化到数据库．</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$user = <span class=\"keyword\">new</span> User;  </span><br><span class=\"line\">$user-&gt;username = ‘philipbrown’;  </span><br><span class=\"line\">EntityManager::persist($user);  </span><br></pre></td></tr></table></figure>\n\n\n\n<p>Data Mapper模式的优点：</p>\n<ul>\n<li>对象不需要了解他们如何存储数据库，因此对象将更加轻便，因为它们不必继承完整的ORM．</li>\n<li>与数据库进行交互的过程更加严格，不能在代码中调用<code>save()</code>方法．</li>\n</ul>\n<h3 id=\"5-常见ORM框架\"><a href=\"#5-常见ORM框架\" class=\"headerlink\" title=\"5 常见ORM框架\"></a>5 常见ORM框架</h3><p>各种语言常见的ORM框架【<em>参考资料3</em>】</p>\n<ul>\n<li>JAVA：ActiveJDBC、Hibernate、MyBatis等</li>\n<li>PHP：Doctrine、Yii、Laravel等</li>\n</ul>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://blog.bitsrc.io/what-is-an-orm-and-why-you-should-use-it-b2b6f75f5e2a\">What is an ORM and Why You Should Use it</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84\">对象关系映射</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/List_of_object-relational_mapping_software\">List of object-relational mapping software</a></li>\n<li><a href=\"https://culttt.com/2014/06/18/whats-difference-active-record-data-mapper/\">Active Record和Data Mapper有什么区别？</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-什么是ORM\"><a href=\"#1-什么是ORM\" class=\"headerlink\" title=\"1 什么是ORM?\"></a>1 什么是ORM?</h3><p>ORM（Object Relation Mapping，对象关系映射）是一种程序设计技术，通过面向对象编程语言的语法，完成关系型数据库的操作．</p>","more":"<p>ORM把数据库映射成对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据库的表（table）   ---&gt;  类（class）</span><br><span class=\"line\">记录（record，行记录） ---&gt;  对象（object）</span><br><span class=\"line\">字段（filed）        ---&gt;   对象的属性（attribute）</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例所示：通常对于数据库，采用SQL方式查询如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from users where uid &#x3D; 123;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ORM通过使用我们自行选择的语言而非SQL与数据库进行交互：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var orm &#x3D; require（&#39;generic-orm-libarry&#39;）;</span><br><span class=\"line\">var user &#x3D; orm（“users”）．where（&#123;uid：123&#125;）;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-ORM的优缺点\"><a href=\"#2-ORM的优缺点\" class=\"headerlink\" title=\"2 ORM的优缺点\"></a>2 ORM的优缺点</h3><p>优点：</p>\n<ul>\n<li>数据模型都在一个地方定义，更容易更新和维护，也利于代码重用；</li>\n<li>ORM有现成的工具，许多高级功能可以自动完成，例如数据消毒、事务、连接池、迁移、流等其他功能的支持；</li>\n<li>当使用MVC架构时，ORM就是现成的Model，使最终代码更加清晰；</li>\n<li>基于ORM的业务代码更简单，代码量少，语义清晰，容易理解；</li>\n<li>它抽象了数据库系统，因此可以更为方便地切换数据库类型，如从MySQL切换到PostgreSQL；</li>\n<li>使许多查询的性能比自行编写SQL语句的性能更好；</li>\n<li>对于没有DBA的小型团队中，使用ORM将极大简化数据层的工作。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>ORM库不是轻量级工具，将增加学习ORM的成本；</li>\n<li>对于复杂的查询，ORM可能无法表示，或性能不如原生的SQL;</li>\n<li>ORM的初始配置可能较为复杂；</li>\n<li>作为开发人员，重要的是要了解其原理，而ORM抽象掉了数据层，可能导致开发者对底层原理理解不到位，也无法定制一些特殊的SQL;</li>\n</ul>\n<h3 id=\"3-关系类型\"><a href=\"#3-关系类型\" class=\"headerlink\" title=\"3 关系类型\"></a>3 关系类型</h3><p>表与表之间的关系，分为三种：</p>\n<ul>\n<li><code>一对一</code>：一种对象与另一种对象是一一对应关系；比如一个顾客只能对应一张入场票；</li>\n<li><code>一对多</code>：一种对象可以属于另一个对象的多个实例，比如一张唱片包含多首歌；</li>\n<li><code>多对多</code>：两种对象彼此都是＂一对多＂关系，比如一张唱片包含多首歌，同时一首歌可以属于多张唱片．</li>\n</ul>\n<h3 id=\"4-ORM的实现\"><a href=\"#4-ORM的实现\" class=\"headerlink\" title=\"4 ORM的实现\"></a>4 ORM的实现</h3><p>ORM中有两种常用的实现模式：<code>Active Record</code>和<code>Data Mapper</code></p>\n<h4 id=\"4-1-Active-Record\"><a href=\"#4-1-Active-Record\" class=\"headerlink\" title=\"4.1 Active Record\"></a>4.1 Active Record</h4><p>Active Record模式的ORM将对象映射到数据库行．</p>\n<p>如下示例所示：创建一个User对象，设置username，然后将该对象保存到数据库中．将User对象映射到users表中的一行．</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$user = <span class=\"keyword\">new</span> User;  </span><br><span class=\"line\">$user-&gt;username = ‘philipbrown’;  </span><br><span class=\"line\">$user-&gt;save();  </span><br></pre></td></tr></table></figure>\n\n\n\n<p>Active Record模式的优点：</p>\n<ul>\n<li>可以简单的调用<code>save()</code>方法来更新数据库．</li>\n<li>每个模型对象都继承自基础Active Record对象，因此可以访问所有与持久性有关的方法．</li>\n<li>Active Record实现非常直观，容易上手．</li>\n</ul>\n<h4 id=\"4-2-Data-Mapper\"><a href=\"#4-2-Data-Mapper\" class=\"headerlink\" title=\"4.2 Data Mapper\"></a>4.2 Data Mapper</h4><p>Active Record和Data Mapper模式之间的最大区别是，Data Mapper模式将对象与持久层完全分开．</p>\n<p>如下示例所示：Data Mapper使用一个完全不同的服务，如<code>EntityManager</code>进行数据持久化到数据库．</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$user = <span class=\"keyword\">new</span> User;  </span><br><span class=\"line\">$user-&gt;username = ‘philipbrown’;  </span><br><span class=\"line\">EntityManager::persist($user);  </span><br></pre></td></tr></table></figure>\n\n\n\n<p>Data Mapper模式的优点：</p>\n<ul>\n<li>对象不需要了解他们如何存储数据库，因此对象将更加轻便，因为它们不必继承完整的ORM．</li>\n<li>与数据库进行交互的过程更加严格，不能在代码中调用<code>save()</code>方法．</li>\n</ul>\n<h3 id=\"5-常见ORM框架\"><a href=\"#5-常见ORM框架\" class=\"headerlink\" title=\"5 常见ORM框架\"></a>5 常见ORM框架</h3><p>各种语言常见的ORM框架【<em>参考资料3</em>】</p>\n<ul>\n<li>JAVA：ActiveJDBC、Hibernate、MyBatis等</li>\n<li>PHP：Doctrine、Yii、Laravel等</li>\n</ul>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://blog.bitsrc.io/what-is-an-orm-and-why-you-should-use-it-b2b6f75f5e2a\">What is an ORM and Why You Should Use it</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84\">对象关系映射</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/List_of_object-relational_mapping_software\">List of object-relational mapping software</a></li>\n<li><a href=\"https://culttt.com/2014/06/18/whats-difference-active-record-data-mapper/\">Active Record和Data Mapper有什么区别？</a></li>\n</ol>"},{"title":"Differences-OOP和POP的区别？","date":"2020-09-26T15:51:36.000Z","_content":"\n### 1 概述\n\n面向过程编程（POP）和面向对象编程（OOP）都是编程方法，它们使用高级语言进行编程。\n\n<!--more-->\n\n\n\n示例：对于开车，加速，减速，刹车几个步骤．\n\n- 面向过程编程：首先需要有个车，然后这４件事需要分别写４个函数，分别是开车，加速，减速，刹车．如果要使用的话，则分别调用这四个函数．\n- 面向对象编程：需要关心的应该是车这个类，而不是开车，加速，减速和刹车这四个过程．这四个过程只是这个类的一部分，只是其中的一种行为，对于行为的顺序没有强制要求．\n\n\n\n### 2 面向过程编程（OOP）\n\nOOP是一种常规的编程方式．面向过程编程主要重点在于`按顺序`完成任务．通过流程图组织程序的控制流．若程序是扩展程序，则使用函数对一些小单元进行结构化，他们共享全局数据．\n\n(**面向过程时具体的，流程化的**)\n\n\n\nPOP特征：\n\n在设计程序时，POP遵循自上而下的编程方法；\n\n大多数功能允许共享全局数据；\n\n可将较大的程序切分为小的单元（Function）；\n\n数据通过功能从一种形式转换为另一种形式；\n\n重视功能的概念．\n\n\n\n#### 2.1 POP的优缺点\n\n优点：\n\n- 提供在不同地方重用相同代码的能力；\n- 有助于跟踪程序流程；\n- 能够构建模块．\n\n\n\n缺点：\n\n- 全局数据不安全，容易被篡改；\n- 部分代码相互依赖；\n- 很难定位数据位置；\n- 实际问题无法建模；\n\n\n\n### 3 面向对象编程（OOP）\n\nOOP是基于“对象”，“类”，“封装或抽象”，“继承”和“多态或重载”的基本概念开发的。在OOP中，可以通过对数据和功能进行分区，将程序划分为模块，如果需要，还可以将其用作创建模块新副本的模板。因此，这是一种通过构造用于数据和功能的分区存储区域来促进程序模块化的方法。\n\n（**面向对象是模型化的，抽象出一个类，是一个封闭的环境，这个环境中提供数据及方法，使用时无须了解其实现方式，直接使用就行**）\n\n\n\nOOP特征：\n\n- 对象：它被视为类型类的变量和类的实例。\n- 类：它是一组类似类型的对象。对象的完整数据和代码集通过使用类来创建用户定义的数据类型。\n- 数据抽象和封装：抽象是隐藏背景细节并表示基本特征的方法。封装是一种将数据和功能打包到单个单元中的方法。\n- 继承：继承是一种从一个类到另一个类对象获取对象特征的技术。换句话说，它有助于从现有的类别中派生新类别。\n- 多态性：多态性提供了一种使用单个函数名称创建函数多种形式的方法。\n- 动态绑定：它指定与特定过程关联的代码直到运行时调用时刻才知道。\n- 消息传递：此OOP概念通过发送和接收信息来实现不同类之间的交互。\n\n\n\n#### 3.1 OOP的优缺点\n\n优点：\n\n- Object有助于项目中的任务划分；\n- 通过继承可以减少冗余代码；\n- 代码可以使用可重用性进行扩展；\n- 数据抽象提高了可靠性；\n- 动态绑定是代码更加灵活；\n- 通过数据隐藏可以建立安全的程序；\n- 可以映射对象；\n- 支持将对象分为不同的类；\n- 面向对象的系统更容易更新；\n- 可以实现更大的模块化；\n- 通过使用信息隐藏将基本规范从其实现中解耦．\n\n\n\n缺点：\n\n- 它需要更多资源。\n- 对象的动态行为需要RAM存储。\n- 在执行消息传递时，在复杂的应用程序中检测和调试更加困难。\n- 继承使它们的类紧密耦合，从而影响对象的可重用性。\n\n​\t\n\n### 4 OOP和POP的区别\n\n- 1 POP是面向过程的编程，POP是面向对象的编程；\n- 2 POP的主要重点是自上而下，遵循流程图来完成功能．OOP的主要重点是保证数据安全性，因为它仅允许类的对象访问类的属性或功能；\n- 3 POP的函数是大程序或者小程序的小部分，执行这些程序即可完成主要功能．OOP的类的属性和功能则是在对象之间划分；\n- 4 POP中没有特定的访问模式限制可以访问的属性或功能．OOP中支持三种访问模式private，protected，public；\n- 5 POP不支持重载/多态的概念．OOP支持重载/多态，可以使用相同的功能名称来执行不同的功能；\n- 6 POP中没有继承的概念，而OOP支持继承，该继承允许通过继承使用其他类的属性和函数；\n- 7 在POP中，如果要在程序的所有功能之间共享某些数据，则会在所有功能之外全局声明该数据。在OOP中，可以通过类的成员函数访问类的数据成员；\n- 8 POP中没有抽象类的概念，而在OOP中，虚拟函数支持多态。\n\n\n\n### 5 OOP和POP的联系\n\nOOP中，Class中实现具体的功能还是需要流程化，具体化的去实现．即面向对象的底层还是现象过程，面向过程抽象成类，然后封装，方便使用就是面向对象．\n\n\n\n------\n\n参考资料\n[Difference Between OOP and POP](https://techdifferences.com/difference-between-oop-and-pop.html)\n[面向对象编程与面向过程编程的区别与联系](https://www.cnblogs.com/Mr--Yang/p/6886447.html)","source":"_posts/Differences-OOP和POP的区别？.md","raw":"---\ntitle: Differences-OOP和POP的区别？\ntags:\n  - Differences\n  - OOP\n  - POP\ncategories:\n  - Differences\ndate: 2020-09-26 23:51:36\n---\n\n### 1 概述\n\n面向过程编程（POP）和面向对象编程（OOP）都是编程方法，它们使用高级语言进行编程。\n\n<!--more-->\n\n\n\n示例：对于开车，加速，减速，刹车几个步骤．\n\n- 面向过程编程：首先需要有个车，然后这４件事需要分别写４个函数，分别是开车，加速，减速，刹车．如果要使用的话，则分别调用这四个函数．\n- 面向对象编程：需要关心的应该是车这个类，而不是开车，加速，减速和刹车这四个过程．这四个过程只是这个类的一部分，只是其中的一种行为，对于行为的顺序没有强制要求．\n\n\n\n### 2 面向过程编程（OOP）\n\nOOP是一种常规的编程方式．面向过程编程主要重点在于`按顺序`完成任务．通过流程图组织程序的控制流．若程序是扩展程序，则使用函数对一些小单元进行结构化，他们共享全局数据．\n\n(**面向过程时具体的，流程化的**)\n\n\n\nPOP特征：\n\n在设计程序时，POP遵循自上而下的编程方法；\n\n大多数功能允许共享全局数据；\n\n可将较大的程序切分为小的单元（Function）；\n\n数据通过功能从一种形式转换为另一种形式；\n\n重视功能的概念．\n\n\n\n#### 2.1 POP的优缺点\n\n优点：\n\n- 提供在不同地方重用相同代码的能力；\n- 有助于跟踪程序流程；\n- 能够构建模块．\n\n\n\n缺点：\n\n- 全局数据不安全，容易被篡改；\n- 部分代码相互依赖；\n- 很难定位数据位置；\n- 实际问题无法建模；\n\n\n\n### 3 面向对象编程（OOP）\n\nOOP是基于“对象”，“类”，“封装或抽象”，“继承”和“多态或重载”的基本概念开发的。在OOP中，可以通过对数据和功能进行分区，将程序划分为模块，如果需要，还可以将其用作创建模块新副本的模板。因此，这是一种通过构造用于数据和功能的分区存储区域来促进程序模块化的方法。\n\n（**面向对象是模型化的，抽象出一个类，是一个封闭的环境，这个环境中提供数据及方法，使用时无须了解其实现方式，直接使用就行**）\n\n\n\nOOP特征：\n\n- 对象：它被视为类型类的变量和类的实例。\n- 类：它是一组类似类型的对象。对象的完整数据和代码集通过使用类来创建用户定义的数据类型。\n- 数据抽象和封装：抽象是隐藏背景细节并表示基本特征的方法。封装是一种将数据和功能打包到单个单元中的方法。\n- 继承：继承是一种从一个类到另一个类对象获取对象特征的技术。换句话说，它有助于从现有的类别中派生新类别。\n- 多态性：多态性提供了一种使用单个函数名称创建函数多种形式的方法。\n- 动态绑定：它指定与特定过程关联的代码直到运行时调用时刻才知道。\n- 消息传递：此OOP概念通过发送和接收信息来实现不同类之间的交互。\n\n\n\n#### 3.1 OOP的优缺点\n\n优点：\n\n- Object有助于项目中的任务划分；\n- 通过继承可以减少冗余代码；\n- 代码可以使用可重用性进行扩展；\n- 数据抽象提高了可靠性；\n- 动态绑定是代码更加灵活；\n- 通过数据隐藏可以建立安全的程序；\n- 可以映射对象；\n- 支持将对象分为不同的类；\n- 面向对象的系统更容易更新；\n- 可以实现更大的模块化；\n- 通过使用信息隐藏将基本规范从其实现中解耦．\n\n\n\n缺点：\n\n- 它需要更多资源。\n- 对象的动态行为需要RAM存储。\n- 在执行消息传递时，在复杂的应用程序中检测和调试更加困难。\n- 继承使它们的类紧密耦合，从而影响对象的可重用性。\n\n​\t\n\n### 4 OOP和POP的区别\n\n- 1 POP是面向过程的编程，POP是面向对象的编程；\n- 2 POP的主要重点是自上而下，遵循流程图来完成功能．OOP的主要重点是保证数据安全性，因为它仅允许类的对象访问类的属性或功能；\n- 3 POP的函数是大程序或者小程序的小部分，执行这些程序即可完成主要功能．OOP的类的属性和功能则是在对象之间划分；\n- 4 POP中没有特定的访问模式限制可以访问的属性或功能．OOP中支持三种访问模式private，protected，public；\n- 5 POP不支持重载/多态的概念．OOP支持重载/多态，可以使用相同的功能名称来执行不同的功能；\n- 6 POP中没有继承的概念，而OOP支持继承，该继承允许通过继承使用其他类的属性和函数；\n- 7 在POP中，如果要在程序的所有功能之间共享某些数据，则会在所有功能之外全局声明该数据。在OOP中，可以通过类的成员函数访问类的数据成员；\n- 8 POP中没有抽象类的概念，而在OOP中，虚拟函数支持多态。\n\n\n\n### 5 OOP和POP的联系\n\nOOP中，Class中实现具体的功能还是需要流程化，具体化的去实现．即面向对象的底层还是现象过程，面向过程抽象成类，然后封装，方便使用就是面向对象．\n\n\n\n------\n\n参考资料\n[Difference Between OOP and POP](https://techdifferences.com/difference-between-oop-and-pop.html)\n[面向对象编程与面向过程编程的区别与联系](https://www.cnblogs.com/Mr--Yang/p/6886447.html)","slug":"Differences-OOP和POP的区别？","published":1,"updated":"2020-09-27T07:49:20.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfkxsgte0000peg33dbw1sa1","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>面向过程编程（POP）和面向对象编程（OOP）都是编程方法，它们使用高级语言进行编程。</p>\n<a id=\"more\"></a>\n\n\n\n<p>示例：对于开车，加速，减速，刹车几个步骤．</p>\n<ul>\n<li>面向过程编程：首先需要有个车，然后这４件事需要分别写４个函数，分别是开车，加速，减速，刹车．如果要使用的话，则分别调用这四个函数．</li>\n<li>面向对象编程：需要关心的应该是车这个类，而不是开车，加速，减速和刹车这四个过程．这四个过程只是这个类的一部分，只是其中的一种行为，对于行为的顺序没有强制要求．</li>\n</ul>\n<h3 id=\"2-面向过程编程（OOP）\"><a href=\"#2-面向过程编程（OOP）\" class=\"headerlink\" title=\"2 面向过程编程（OOP）\"></a>2 面向过程编程（OOP）</h3><p>OOP是一种常规的编程方式．面向过程编程主要重点在于<code>按顺序</code>完成任务．通过流程图组织程序的控制流．若程序是扩展程序，则使用函数对一些小单元进行结构化，他们共享全局数据．</p>\n<p>(<strong>面向过程时具体的，流程化的</strong>)</p>\n<p>POP特征：</p>\n<p>在设计程序时，POP遵循自上而下的编程方法；</p>\n<p>大多数功能允许共享全局数据；</p>\n<p>可将较大的程序切分为小的单元（Function）；</p>\n<p>数据通过功能从一种形式转换为另一种形式；</p>\n<p>重视功能的概念．</p>\n<h4 id=\"2-1-POP的优缺点\"><a href=\"#2-1-POP的优缺点\" class=\"headerlink\" title=\"2.1 POP的优缺点\"></a>2.1 POP的优缺点</h4><p>优点：</p>\n<ul>\n<li>提供在不同地方重用相同代码的能力；</li>\n<li>有助于跟踪程序流程；</li>\n<li>能够构建模块．</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>全局数据不安全，容易被篡改；</li>\n<li>部分代码相互依赖；</li>\n<li>很难定位数据位置；</li>\n<li>实际问题无法建模；</li>\n</ul>\n<h3 id=\"3-面向对象编程（OOP）\"><a href=\"#3-面向对象编程（OOP）\" class=\"headerlink\" title=\"3 面向对象编程（OOP）\"></a>3 面向对象编程（OOP）</h3><p>OOP是基于“对象”，“类”，“封装或抽象”，“继承”和“多态或重载”的基本概念开发的。在OOP中，可以通过对数据和功能进行分区，将程序划分为模块，如果需要，还可以将其用作创建模块新副本的模板。因此，这是一种通过构造用于数据和功能的分区存储区域来促进程序模块化的方法。</p>\n<p>（<strong>面向对象是模型化的，抽象出一个类，是一个封闭的环境，这个环境中提供数据及方法，使用时无须了解其实现方式，直接使用就行</strong>）</p>\n<p>OOP特征：</p>\n<ul>\n<li>对象：它被视为类型类的变量和类的实例。</li>\n<li>类：它是一组类似类型的对象。对象的完整数据和代码集通过使用类来创建用户定义的数据类型。</li>\n<li>数据抽象和封装：抽象是隐藏背景细节并表示基本特征的方法。封装是一种将数据和功能打包到单个单元中的方法。</li>\n<li>继承：继承是一种从一个类到另一个类对象获取对象特征的技术。换句话说，它有助于从现有的类别中派生新类别。</li>\n<li>多态性：多态性提供了一种使用单个函数名称创建函数多种形式的方法。</li>\n<li>动态绑定：它指定与特定过程关联的代码直到运行时调用时刻才知道。</li>\n<li>消息传递：此OOP概念通过发送和接收信息来实现不同类之间的交互。</li>\n</ul>\n<h4 id=\"3-1-OOP的优缺点\"><a href=\"#3-1-OOP的优缺点\" class=\"headerlink\" title=\"3.1 OOP的优缺点\"></a>3.1 OOP的优缺点</h4><p>优点：</p>\n<ul>\n<li>Object有助于项目中的任务划分；</li>\n<li>通过继承可以减少冗余代码；</li>\n<li>代码可以使用可重用性进行扩展；</li>\n<li>数据抽象提高了可靠性；</li>\n<li>动态绑定是代码更加灵活；</li>\n<li>通过数据隐藏可以建立安全的程序；</li>\n<li>可以映射对象；</li>\n<li>支持将对象分为不同的类；</li>\n<li>面向对象的系统更容易更新；</li>\n<li>可以实现更大的模块化；</li>\n<li>通过使用信息隐藏将基本规范从其实现中解耦．</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>它需要更多资源。</li>\n<li>对象的动态行为需要RAM存储。</li>\n<li>在执行消息传递时，在复杂的应用程序中检测和调试更加困难。</li>\n<li>继承使它们的类紧密耦合，从而影响对象的可重用性。</li>\n</ul>\n<p>​    </p>\n<h3 id=\"4-OOP和POP的区别\"><a href=\"#4-OOP和POP的区别\" class=\"headerlink\" title=\"4 OOP和POP的区别\"></a>4 OOP和POP的区别</h3><ul>\n<li>1 POP是面向过程的编程，POP是面向对象的编程；</li>\n<li>2 POP的主要重点是自上而下，遵循流程图来完成功能．OOP的主要重点是保证数据安全性，因为它仅允许类的对象访问类的属性或功能；</li>\n<li>3 POP的函数是大程序或者小程序的小部分，执行这些程序即可完成主要功能．OOP的类的属性和功能则是在对象之间划分；</li>\n<li>4 POP中没有特定的访问模式限制可以访问的属性或功能．OOP中支持三种访问模式private，protected，public；</li>\n<li>5 POP不支持重载/多态的概念．OOP支持重载/多态，可以使用相同的功能名称来执行不同的功能；</li>\n<li>6 POP中没有继承的概念，而OOP支持继承，该继承允许通过继承使用其他类的属性和函数；</li>\n<li>7 在POP中，如果要在程序的所有功能之间共享某些数据，则会在所有功能之外全局声明该数据。在OOP中，可以通过类的成员函数访问类的数据成员；</li>\n<li>8 POP中没有抽象类的概念，而在OOP中，虚拟函数支持多态。</li>\n</ul>\n<h3 id=\"5-OOP和POP的联系\"><a href=\"#5-OOP和POP的联系\" class=\"headerlink\" title=\"5 OOP和POP的联系\"></a>5 OOP和POP的联系</h3><p>OOP中，Class中实现具体的功能还是需要流程化，具体化的去实现．即面向对象的底层还是现象过程，面向过程抽象成类，然后封装，方便使用就是面向对象．</p>\n<hr>\n<p>参考资料<br><a href=\"https://techdifferences.com/difference-between-oop-and-pop.html\">Difference Between OOP and POP</a><br><a href=\"https://www.cnblogs.com/Mr--Yang/p/6886447.html\">面向对象编程与面向过程编程的区别与联系</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>面向过程编程（POP）和面向对象编程（OOP）都是编程方法，它们使用高级语言进行编程。</p>","more":"<p>示例：对于开车，加速，减速，刹车几个步骤．</p>\n<ul>\n<li>面向过程编程：首先需要有个车，然后这４件事需要分别写４个函数，分别是开车，加速，减速，刹车．如果要使用的话，则分别调用这四个函数．</li>\n<li>面向对象编程：需要关心的应该是车这个类，而不是开车，加速，减速和刹车这四个过程．这四个过程只是这个类的一部分，只是其中的一种行为，对于行为的顺序没有强制要求．</li>\n</ul>\n<h3 id=\"2-面向过程编程（OOP）\"><a href=\"#2-面向过程编程（OOP）\" class=\"headerlink\" title=\"2 面向过程编程（OOP）\"></a>2 面向过程编程（OOP）</h3><p>OOP是一种常规的编程方式．面向过程编程主要重点在于<code>按顺序</code>完成任务．通过流程图组织程序的控制流．若程序是扩展程序，则使用函数对一些小单元进行结构化，他们共享全局数据．</p>\n<p>(<strong>面向过程时具体的，流程化的</strong>)</p>\n<p>POP特征：</p>\n<p>在设计程序时，POP遵循自上而下的编程方法；</p>\n<p>大多数功能允许共享全局数据；</p>\n<p>可将较大的程序切分为小的单元（Function）；</p>\n<p>数据通过功能从一种形式转换为另一种形式；</p>\n<p>重视功能的概念．</p>\n<h4 id=\"2-1-POP的优缺点\"><a href=\"#2-1-POP的优缺点\" class=\"headerlink\" title=\"2.1 POP的优缺点\"></a>2.1 POP的优缺点</h4><p>优点：</p>\n<ul>\n<li>提供在不同地方重用相同代码的能力；</li>\n<li>有助于跟踪程序流程；</li>\n<li>能够构建模块．</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>全局数据不安全，容易被篡改；</li>\n<li>部分代码相互依赖；</li>\n<li>很难定位数据位置；</li>\n<li>实际问题无法建模；</li>\n</ul>\n<h3 id=\"3-面向对象编程（OOP）\"><a href=\"#3-面向对象编程（OOP）\" class=\"headerlink\" title=\"3 面向对象编程（OOP）\"></a>3 面向对象编程（OOP）</h3><p>OOP是基于“对象”，“类”，“封装或抽象”，“继承”和“多态或重载”的基本概念开发的。在OOP中，可以通过对数据和功能进行分区，将程序划分为模块，如果需要，还可以将其用作创建模块新副本的模板。因此，这是一种通过构造用于数据和功能的分区存储区域来促进程序模块化的方法。</p>\n<p>（<strong>面向对象是模型化的，抽象出一个类，是一个封闭的环境，这个环境中提供数据及方法，使用时无须了解其实现方式，直接使用就行</strong>）</p>\n<p>OOP特征：</p>\n<ul>\n<li>对象：它被视为类型类的变量和类的实例。</li>\n<li>类：它是一组类似类型的对象。对象的完整数据和代码集通过使用类来创建用户定义的数据类型。</li>\n<li>数据抽象和封装：抽象是隐藏背景细节并表示基本特征的方法。封装是一种将数据和功能打包到单个单元中的方法。</li>\n<li>继承：继承是一种从一个类到另一个类对象获取对象特征的技术。换句话说，它有助于从现有的类别中派生新类别。</li>\n<li>多态性：多态性提供了一种使用单个函数名称创建函数多种形式的方法。</li>\n<li>动态绑定：它指定与特定过程关联的代码直到运行时调用时刻才知道。</li>\n<li>消息传递：此OOP概念通过发送和接收信息来实现不同类之间的交互。</li>\n</ul>\n<h4 id=\"3-1-OOP的优缺点\"><a href=\"#3-1-OOP的优缺点\" class=\"headerlink\" title=\"3.1 OOP的优缺点\"></a>3.1 OOP的优缺点</h4><p>优点：</p>\n<ul>\n<li>Object有助于项目中的任务划分；</li>\n<li>通过继承可以减少冗余代码；</li>\n<li>代码可以使用可重用性进行扩展；</li>\n<li>数据抽象提高了可靠性；</li>\n<li>动态绑定是代码更加灵活；</li>\n<li>通过数据隐藏可以建立安全的程序；</li>\n<li>可以映射对象；</li>\n<li>支持将对象分为不同的类；</li>\n<li>面向对象的系统更容易更新；</li>\n<li>可以实现更大的模块化；</li>\n<li>通过使用信息隐藏将基本规范从其实现中解耦．</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>它需要更多资源。</li>\n<li>对象的动态行为需要RAM存储。</li>\n<li>在执行消息传递时，在复杂的应用程序中检测和调试更加困难。</li>\n<li>继承使它们的类紧密耦合，从而影响对象的可重用性。</li>\n</ul>\n<p>​    </p>\n<h3 id=\"4-OOP和POP的区别\"><a href=\"#4-OOP和POP的区别\" class=\"headerlink\" title=\"4 OOP和POP的区别\"></a>4 OOP和POP的区别</h3><ul>\n<li>1 POP是面向过程的编程，POP是面向对象的编程；</li>\n<li>2 POP的主要重点是自上而下，遵循流程图来完成功能．OOP的主要重点是保证数据安全性，因为它仅允许类的对象访问类的属性或功能；</li>\n<li>3 POP的函数是大程序或者小程序的小部分，执行这些程序即可完成主要功能．OOP的类的属性和功能则是在对象之间划分；</li>\n<li>4 POP中没有特定的访问模式限制可以访问的属性或功能．OOP中支持三种访问模式private，protected，public；</li>\n<li>5 POP不支持重载/多态的概念．OOP支持重载/多态，可以使用相同的功能名称来执行不同的功能；</li>\n<li>6 POP中没有继承的概念，而OOP支持继承，该继承允许通过继承使用其他类的属性和函数；</li>\n<li>7 在POP中，如果要在程序的所有功能之间共享某些数据，则会在所有功能之外全局声明该数据。在OOP中，可以通过类的成员函数访问类的数据成员；</li>\n<li>8 POP中没有抽象类的概念，而在OOP中，虚拟函数支持多态。</li>\n</ul>\n<h3 id=\"5-OOP和POP的联系\"><a href=\"#5-OOP和POP的联系\" class=\"headerlink\" title=\"5 OOP和POP的联系\"></a>5 OOP和POP的联系</h3><p>OOP中，Class中实现具体的功能还是需要流程化，具体化的去实现．即面向对象的底层还是现象过程，面向过程抽象成类，然后封装，方便使用就是面向对象．</p>\n<hr>\n<p>参考资料<br><a href=\"https://techdifferences.com/difference-between-oop-and-pop.html\">Difference Between OOP and POP</a><br><a href=\"https://www.cnblogs.com/Mr--Yang/p/6886447.html\">面向对象编程与面向过程编程的区别与联系</a></p>"},{"title":"DesignPattern-Decorator(装饰者模式)","date":"2020-09-28T02:08:45.000Z","_content":"\n\n\n### 1 概述\n\n我们知道OOP的＂继承＂功能非常强大，利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为，达到复用的目的．但实际上使用继承的方式却不总是最有弹性的，可能造成的问题有：类数量爆炸，设计死板，基类加入新功能并不适用与所有的子类．\n\n<!--more-->\n\n利用组合（composition）和委托（delegation）可以在运行时具有继承的效果．通过动态地组合对象，可以写新的代码添加新功能，而无须修改现有代码．既然没有改变现有代码，那么引进bug或产生意外副作用的机会将大大减少．\n\n\n\n这里有一个**重要的设计原则**：\n\n> 类应该对扩展开放，对修改关闭\n\n该设计原则的目标是：<u>允许类容易扩展，在不修改现有代码的情况下，可以搭配新的行为．使其具有弹性可以应对改变，可以接受新的功能来应对改变的需求．</u>\n\n装饰者模式就是完全遵守开放-关闭原则的一个好例子．\n\n\n\n### 2 装饰者模式\n\n**装饰者模式**动态地将责任附加到对象上．若要扩展功能，装饰者提供了比继承更有弹性的替代方案．\n\n\n\n其UML图如下：\n\n![Decorator_UML](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Decorator_UML.png)\n\n\n\n`特征`：\n\n- 装饰者(`Decorator`)和被装饰对象(`ConcreteComponent`)有相同的超类型（`Component`）；\n- 可以用一个或多个装饰者包装一个对象；\n- 装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，都可以用装饰过的对象代替它．\n- 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的．\n- 对象可以在任何时候被装饰，所以可以在运行时动态地，不限量的用装饰者来装饰对象．\n\n\n\n#### 2.1 装饰器模式中继承和组合的关系\n\n从装饰器模式的类图可见．`Decorator`继承了`Component`，这里用到继承．但是这里实际上是让装饰者和被装饰者拥有相同的超类．此处的继承是为了＂类型匹配＂，而不是＂继承行为＂；\n\n\n\n### 3 装饰器模式示例\n\n根据以下类图实现一个简单的饮料系统：\n\n![DecoratorExample](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/DecoratorExample.png)\n\n\n\n> 在Head First设计模式书的示例中，Beverage抽象类中包含一个getDescription和cost两个方法，其中cost方法是抽象方法；CondimentDecorator抽象类继承于Beverage类，并将getDescription这个非抽象方法重载为抽象方法．\n>\n> \n>\n> 对于PHP编码报出以下错误：PHP Fatal error:  Cannot make non abstract method Beverage::getDescription() abstract in class CondimentDecorator\n>\n> 即对于PHP语言，不能将一个已声明为非抽象的方法，重新声明为抽象方法．\n\n\n\n```php\n// Beverage是一个抽象类．\nabstract class Beverage\n{\n    public $description = \"Unknown Beverage\";\n    public function getDescription()\n    {\n        return $this->description;\n    }\n    // 子类必须实现此方法．\n    public abstract function cost();\n}\n\n/* \n// 由于PHP不支持将非抽象方法声明为抽象方法，因此测试时，先将该方法注释掉．\n// 装饰器类必须与被装饰类拥有相同的超类.\nabstract class CondimentDecorator extends Beverage\n{\n    // 所有的装饰者都必须重新实现getDescription方法.\n    public abstract function getDescription();\n}\n*/\n// 浓缩饮料．\nclass Espresso extends Beverage\n{\n    public function __construct()\n    {\n        $this->description = 'Espresso';\n    }\n\n    public function cost()\n    {\n        return 1.99;\n    }\n}\n\nclass HouseBlend extends Beverage\n{\n    public function __construct()\n    {\n        $this->description = 'House Blend Coffee';\n    }\n\n    public function cost()\n    {\n        return 0.89;\n    }\n}\n\n// Mocha是一个装饰者，所以让他继承CondimentDecorator\nclass Mocha extends Beverage\n{\n    /** @var Beverage $beverage 用于让Mocha引用一个Beverage*/\n    public $beverage;\n\n    // 将Beverage实例传给Mocha的实例变量中.\n    public function __construct(Beverage $beverage)\n    {\n        $this->beverage = $beverage;\n    }\n\n    // 添加Mocha的描述．\n    public function getDescription()\n    {\n        return $this->beverage->getDescription() . \", Mocha\";\n    }\n\n    // 添加摩卡的价格．\n    public function cost()\n    {\n        return 0.2 + $this->beverage->cost();\n    }\n}\n\n// 创建一个被浓缩咖啡．\n$beverage = new Espresso();\necho \"{$beverage->getDescription()} \\${$beverage->cost()}\\n\";　// Espresso $1.99\n// 做成一杯摩卡．\n$beverage = new Mocha($beverage);\necho \"{$beverage->getDescription()} \\${$beverage->cost()}\\n\"; // Espresso, Mocha $2.19\n\n$beverage１ = new HouseBlend();\necho \"{$beverage１->getDescription()} \\${$beverage１->cost()}\\n\"; // House Blend Coffee $0.89\n\n$beverage１ = new Mocha($beverage１);\necho \"{$beverage１->getDescription()} \\${$beverage１->cost()}\\n\"; // House Blend Coffee, Mocha $1.09\n```\n\n\n\n### 4 装饰器模式的应用\n\n在JAVA语言中，java.io包里面很多都应用了装饰器模式，例如`FileInputStream-->BufferedInputStream-->LineNumberInputStream`，其中：\n\n- FileInputStream是被装饰的组件，Java I/O程序库提供了几个组件，包括FileInputStream，StringBufferInputStream，ByteArrayInputStream等，这些都提供了最基本的字节读取功能；\n- BufferedInputStream是一个具体的装饰者，它加入来嗯中行为：利用缓冲输入来改进性能，用一个readline()方法来增强接口；\n- LineNumberInputStream也是一个具体的装饰者，他加上了计算行数的能力．\n\n\n\n如下图所示：\n\n![JavaIO-Decorator](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/JavaIO-Decorator.png)\n\n\n\n------\n\n### 参考资料\n\nHead First设计模式 装饰对象：装饰者模式（P79）","source":"_posts/DesignPattern-Decorator.md","raw":"---\ntitle: DesignPattern-Decorator(装饰者模式)\ndate: 2020-09-28 10:08:45\ntags: [\"DesignPattern\",\"Decorator\"]\ncategories: [\"DesignPattern\"]\n---\n\n\n\n### 1 概述\n\n我们知道OOP的＂继承＂功能非常强大，利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为，达到复用的目的．但实际上使用继承的方式却不总是最有弹性的，可能造成的问题有：类数量爆炸，设计死板，基类加入新功能并不适用与所有的子类．\n\n<!--more-->\n\n利用组合（composition）和委托（delegation）可以在运行时具有继承的效果．通过动态地组合对象，可以写新的代码添加新功能，而无须修改现有代码．既然没有改变现有代码，那么引进bug或产生意外副作用的机会将大大减少．\n\n\n\n这里有一个**重要的设计原则**：\n\n> 类应该对扩展开放，对修改关闭\n\n该设计原则的目标是：<u>允许类容易扩展，在不修改现有代码的情况下，可以搭配新的行为．使其具有弹性可以应对改变，可以接受新的功能来应对改变的需求．</u>\n\n装饰者模式就是完全遵守开放-关闭原则的一个好例子．\n\n\n\n### 2 装饰者模式\n\n**装饰者模式**动态地将责任附加到对象上．若要扩展功能，装饰者提供了比继承更有弹性的替代方案．\n\n\n\n其UML图如下：\n\n![Decorator_UML](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Decorator_UML.png)\n\n\n\n`特征`：\n\n- 装饰者(`Decorator`)和被装饰对象(`ConcreteComponent`)有相同的超类型（`Component`）；\n- 可以用一个或多个装饰者包装一个对象；\n- 装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，都可以用装饰过的对象代替它．\n- 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的．\n- 对象可以在任何时候被装饰，所以可以在运行时动态地，不限量的用装饰者来装饰对象．\n\n\n\n#### 2.1 装饰器模式中继承和组合的关系\n\n从装饰器模式的类图可见．`Decorator`继承了`Component`，这里用到继承．但是这里实际上是让装饰者和被装饰者拥有相同的超类．此处的继承是为了＂类型匹配＂，而不是＂继承行为＂；\n\n\n\n### 3 装饰器模式示例\n\n根据以下类图实现一个简单的饮料系统：\n\n![DecoratorExample](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/DecoratorExample.png)\n\n\n\n> 在Head First设计模式书的示例中，Beverage抽象类中包含一个getDescription和cost两个方法，其中cost方法是抽象方法；CondimentDecorator抽象类继承于Beverage类，并将getDescription这个非抽象方法重载为抽象方法．\n>\n> \n>\n> 对于PHP编码报出以下错误：PHP Fatal error:  Cannot make non abstract method Beverage::getDescription() abstract in class CondimentDecorator\n>\n> 即对于PHP语言，不能将一个已声明为非抽象的方法，重新声明为抽象方法．\n\n\n\n```php\n// Beverage是一个抽象类．\nabstract class Beverage\n{\n    public $description = \"Unknown Beverage\";\n    public function getDescription()\n    {\n        return $this->description;\n    }\n    // 子类必须实现此方法．\n    public abstract function cost();\n}\n\n/* \n// 由于PHP不支持将非抽象方法声明为抽象方法，因此测试时，先将该方法注释掉．\n// 装饰器类必须与被装饰类拥有相同的超类.\nabstract class CondimentDecorator extends Beverage\n{\n    // 所有的装饰者都必须重新实现getDescription方法.\n    public abstract function getDescription();\n}\n*/\n// 浓缩饮料．\nclass Espresso extends Beverage\n{\n    public function __construct()\n    {\n        $this->description = 'Espresso';\n    }\n\n    public function cost()\n    {\n        return 1.99;\n    }\n}\n\nclass HouseBlend extends Beverage\n{\n    public function __construct()\n    {\n        $this->description = 'House Blend Coffee';\n    }\n\n    public function cost()\n    {\n        return 0.89;\n    }\n}\n\n// Mocha是一个装饰者，所以让他继承CondimentDecorator\nclass Mocha extends Beverage\n{\n    /** @var Beverage $beverage 用于让Mocha引用一个Beverage*/\n    public $beverage;\n\n    // 将Beverage实例传给Mocha的实例变量中.\n    public function __construct(Beverage $beverage)\n    {\n        $this->beverage = $beverage;\n    }\n\n    // 添加Mocha的描述．\n    public function getDescription()\n    {\n        return $this->beverage->getDescription() . \", Mocha\";\n    }\n\n    // 添加摩卡的价格．\n    public function cost()\n    {\n        return 0.2 + $this->beverage->cost();\n    }\n}\n\n// 创建一个被浓缩咖啡．\n$beverage = new Espresso();\necho \"{$beverage->getDescription()} \\${$beverage->cost()}\\n\";　// Espresso $1.99\n// 做成一杯摩卡．\n$beverage = new Mocha($beverage);\necho \"{$beverage->getDescription()} \\${$beverage->cost()}\\n\"; // Espresso, Mocha $2.19\n\n$beverage１ = new HouseBlend();\necho \"{$beverage１->getDescription()} \\${$beverage１->cost()}\\n\"; // House Blend Coffee $0.89\n\n$beverage１ = new Mocha($beverage１);\necho \"{$beverage１->getDescription()} \\${$beverage１->cost()}\\n\"; // House Blend Coffee, Mocha $1.09\n```\n\n\n\n### 4 装饰器模式的应用\n\n在JAVA语言中，java.io包里面很多都应用了装饰器模式，例如`FileInputStream-->BufferedInputStream-->LineNumberInputStream`，其中：\n\n- FileInputStream是被装饰的组件，Java I/O程序库提供了几个组件，包括FileInputStream，StringBufferInputStream，ByteArrayInputStream等，这些都提供了最基本的字节读取功能；\n- BufferedInputStream是一个具体的装饰者，它加入来嗯中行为：利用缓冲输入来改进性能，用一个readline()方法来增强接口；\n- LineNumberInputStream也是一个具体的装饰者，他加上了计算行数的能力．\n\n\n\n如下图所示：\n\n![JavaIO-Decorator](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/JavaIO-Decorator.png)\n\n\n\n------\n\n### 参考资料\n\nHead First设计模式 装饰对象：装饰者模式（P79）","slug":"DesignPattern-Decorator","published":1,"updated":"2020-09-29T02:18:56.769Z","_id":"ckfme10yg00003rg30a1t84ra","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>我们知道OOP的＂继承＂功能非常强大，利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为，达到复用的目的．但实际上使用继承的方式却不总是最有弹性的，可能造成的问题有：类数量爆炸，设计死板，基类加入新功能并不适用与所有的子类．</p>\n<a id=\"more\"></a>\n\n<p>利用组合（composition）和委托（delegation）可以在运行时具有继承的效果．通过动态地组合对象，可以写新的代码添加新功能，而无须修改现有代码．既然没有改变现有代码，那么引进bug或产生意外副作用的机会将大大减少．</p>\n<p>这里有一个<strong>重要的设计原则</strong>：</p>\n<blockquote>\n<p>类应该对扩展开放，对修改关闭</p>\n</blockquote>\n<p>该设计原则的目标是：<u>允许类容易扩展，在不修改现有代码的情况下，可以搭配新的行为．使其具有弹性可以应对改变，可以接受新的功能来应对改变的需求．</u></p>\n<p>装饰者模式就是完全遵守开放-关闭原则的一个好例子．</p>\n<h3 id=\"2-装饰者模式\"><a href=\"#2-装饰者模式\" class=\"headerlink\" title=\"2 装饰者模式\"></a>2 装饰者模式</h3><p><strong>装饰者模式</strong>动态地将责任附加到对象上．若要扩展功能，装饰者提供了比继承更有弹性的替代方案．</p>\n<p>其UML图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Decorator_UML.png\" alt=\"Decorator_UML\"></p>\n<p><code>特征</code>：</p>\n<ul>\n<li>装饰者(<code>Decorator</code>)和被装饰对象(<code>ConcreteComponent</code>)有相同的超类型（<code>Component</code>）；</li>\n<li>可以用一个或多个装饰者包装一个对象；</li>\n<li>装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，都可以用装饰过的对象代替它．</li>\n<li>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的．</li>\n<li>对象可以在任何时候被装饰，所以可以在运行时动态地，不限量的用装饰者来装饰对象．</li>\n</ul>\n<h4 id=\"2-1-装饰器模式中继承和组合的关系\"><a href=\"#2-1-装饰器模式中继承和组合的关系\" class=\"headerlink\" title=\"2.1 装饰器模式中继承和组合的关系\"></a>2.1 装饰器模式中继承和组合的关系</h4><p>从装饰器模式的类图可见．<code>Decorator</code>继承了<code>Component</code>，这里用到继承．但是这里实际上是让装饰者和被装饰者拥有相同的超类．此处的继承是为了＂类型匹配＂，而不是＂继承行为＂；</p>\n<h3 id=\"3-装饰器模式示例\"><a href=\"#3-装饰器模式示例\" class=\"headerlink\" title=\"3 装饰器模式示例\"></a>3 装饰器模式示例</h3><p>根据以下类图实现一个简单的饮料系统：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/DecoratorExample.png\" alt=\"DecoratorExample\"></p>\n<blockquote>\n<p>在Head First设计模式书的示例中，Beverage抽象类中包含一个getDescription和cost两个方法，其中cost方法是抽象方法；CondimentDecorator抽象类继承于Beverage类，并将getDescription这个非抽象方法重载为抽象方法．</p>\n<p>对于PHP编码报出以下错误：PHP Fatal error:  Cannot make non abstract method Beverage::getDescription() abstract in class CondimentDecorator</p>\n<p>即对于PHP语言，不能将一个已声明为非抽象的方法，重新声明为抽象方法．</p>\n</blockquote>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Beverage是一个抽象类．</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Beverage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $description = <span class=\"string\">&quot;Unknown Beverage&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDescription</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 子类必须实现此方法．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cost</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">// 由于PHP不支持将非抽象方法声明为抽象方法，因此测试时，先将该方法注释掉．</span></span><br><span class=\"line\"><span class=\"comment\">// 装饰器类必须与被装饰类拥有相同的超类.</span></span><br><span class=\"line\"><span class=\"comment\">abstract class CondimentDecorator extends Beverage</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    // 所有的装饰者都必须重新实现getDescription方法.</span></span><br><span class=\"line\"><span class=\"comment\">    public abstract function getDescription();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 浓缩饮料．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Espresso</span> <span class=\"keyword\">extends</span> <span class=\"title\">Beverage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;description = <span class=\"string\">&#x27;Espresso&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cost</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1.99</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HouseBlend</span> <span class=\"keyword\">extends</span> <span class=\"title\">Beverage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;description = <span class=\"string\">&#x27;House Blend Coffee&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cost</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.89</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Mocha是一个装饰者，所以让他继承CondimentDecorator</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mocha</span> <span class=\"keyword\">extends</span> <span class=\"title\">Beverage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@var</span> Beverage $beverage 用于让Mocha引用一个Beverage*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> $beverage;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将Beverage实例传给Mocha的实例变量中.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\">Beverage $beverage</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;beverage = $beverage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加Mocha的描述．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDescription</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;beverage-&gt;getDescription() . <span class=\"string\">&quot;, Mocha&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加摩卡的价格．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cost</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.2</span> + <span class=\"keyword\">$this</span>-&gt;beverage-&gt;cost();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个被浓缩咖啡．</span></span><br><span class=\"line\">$beverage = <span class=\"keyword\">new</span> Espresso();</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;&#123;$beverage-&gt;getDescription()&#125; \\$&#123;$beverage-&gt;cost()&#125;\\n&quot;</span>;　<span class=\"comment\">// Espresso $1.99</span></span><br><span class=\"line\"><span class=\"comment\">// 做成一杯摩卡．</span></span><br><span class=\"line\">$beverage = <span class=\"keyword\">new</span> Mocha($beverage);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;&#123;$beverage-&gt;getDescription()&#125; \\$&#123;$beverage-&gt;cost()&#125;\\n&quot;</span>; <span class=\"comment\">// Espresso, Mocha $2.19</span></span><br><span class=\"line\"></span><br><span class=\"line\">$beverage１ = <span class=\"keyword\">new</span> HouseBlend();</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;&#123;$beverage１-&gt;getDescription()&#125; \\$&#123;$beverage１-&gt;cost()&#125;\\n&quot;</span>; <span class=\"comment\">// House Blend Coffee $0.89</span></span><br><span class=\"line\"></span><br><span class=\"line\">$beverage１ = <span class=\"keyword\">new</span> Mocha($beverage１);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;&#123;$beverage１-&gt;getDescription()&#125; \\$&#123;$beverage１-&gt;cost()&#125;\\n&quot;</span>; <span class=\"comment\">// House Blend Coffee, Mocha $1.09</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-装饰器模式的应用\"><a href=\"#4-装饰器模式的应用\" class=\"headerlink\" title=\"4 装饰器模式的应用\"></a>4 装饰器模式的应用</h3><p>在JAVA语言中，java.io包里面很多都应用了装饰器模式，例如<code>FileInputStream--&gt;BufferedInputStream--&gt;LineNumberInputStream</code>，其中：</p>\n<ul>\n<li>FileInputStream是被装饰的组件，Java I/O程序库提供了几个组件，包括FileInputStream，StringBufferInputStream，ByteArrayInputStream等，这些都提供了最基本的字节读取功能；</li>\n<li>BufferedInputStream是一个具体的装饰者，它加入来嗯中行为：利用缓冲输入来改进性能，用一个readline()方法来增强接口；</li>\n<li>LineNumberInputStream也是一个具体的装饰者，他加上了计算行数的能力．</li>\n</ul>\n<p>如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/JavaIO-Decorator.png\" alt=\"JavaIO-Decorator\"></p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>Head First设计模式 装饰对象：装饰者模式（P79）</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h3><p>我们知道OOP的＂继承＂功能非常强大，利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为，达到复用的目的．但实际上使用继承的方式却不总是最有弹性的，可能造成的问题有：类数量爆炸，设计死板，基类加入新功能并不适用与所有的子类．</p>","more":"<p>利用组合（composition）和委托（delegation）可以在运行时具有继承的效果．通过动态地组合对象，可以写新的代码添加新功能，而无须修改现有代码．既然没有改变现有代码，那么引进bug或产生意外副作用的机会将大大减少．</p>\n<p>这里有一个<strong>重要的设计原则</strong>：</p>\n<blockquote>\n<p>类应该对扩展开放，对修改关闭</p>\n</blockquote>\n<p>该设计原则的目标是：<u>允许类容易扩展，在不修改现有代码的情况下，可以搭配新的行为．使其具有弹性可以应对改变，可以接受新的功能来应对改变的需求．</u></p>\n<p>装饰者模式就是完全遵守开放-关闭原则的一个好例子．</p>\n<h3 id=\"2-装饰者模式\"><a href=\"#2-装饰者模式\" class=\"headerlink\" title=\"2 装饰者模式\"></a>2 装饰者模式</h3><p><strong>装饰者模式</strong>动态地将责任附加到对象上．若要扩展功能，装饰者提供了比继承更有弹性的替代方案．</p>\n<p>其UML图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Decorator_UML.png\" alt=\"Decorator_UML\"></p>\n<p><code>特征</code>：</p>\n<ul>\n<li>装饰者(<code>Decorator</code>)和被装饰对象(<code>ConcreteComponent</code>)有相同的超类型（<code>Component</code>）；</li>\n<li>可以用一个或多个装饰者包装一个对象；</li>\n<li>装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，都可以用装饰过的对象代替它．</li>\n<li>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的．</li>\n<li>对象可以在任何时候被装饰，所以可以在运行时动态地，不限量的用装饰者来装饰对象．</li>\n</ul>\n<h4 id=\"2-1-装饰器模式中继承和组合的关系\"><a href=\"#2-1-装饰器模式中继承和组合的关系\" class=\"headerlink\" title=\"2.1 装饰器模式中继承和组合的关系\"></a>2.1 装饰器模式中继承和组合的关系</h4><p>从装饰器模式的类图可见．<code>Decorator</code>继承了<code>Component</code>，这里用到继承．但是这里实际上是让装饰者和被装饰者拥有相同的超类．此处的继承是为了＂类型匹配＂，而不是＂继承行为＂；</p>\n<h3 id=\"3-装饰器模式示例\"><a href=\"#3-装饰器模式示例\" class=\"headerlink\" title=\"3 装饰器模式示例\"></a>3 装饰器模式示例</h3><p>根据以下类图实现一个简单的饮料系统：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/DecoratorExample.png\" alt=\"DecoratorExample\"></p>\n<blockquote>\n<p>在Head First设计模式书的示例中，Beverage抽象类中包含一个getDescription和cost两个方法，其中cost方法是抽象方法；CondimentDecorator抽象类继承于Beverage类，并将getDescription这个非抽象方法重载为抽象方法．</p>\n<p>对于PHP编码报出以下错误：PHP Fatal error:  Cannot make non abstract method Beverage::getDescription() abstract in class CondimentDecorator</p>\n<p>即对于PHP语言，不能将一个已声明为非抽象的方法，重新声明为抽象方法．</p>\n</blockquote>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Beverage是一个抽象类．</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Beverage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $description = <span class=\"string\">&quot;Unknown Beverage&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDescription</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 子类必须实现此方法．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cost</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">// 由于PHP不支持将非抽象方法声明为抽象方法，因此测试时，先将该方法注释掉．</span></span><br><span class=\"line\"><span class=\"comment\">// 装饰器类必须与被装饰类拥有相同的超类.</span></span><br><span class=\"line\"><span class=\"comment\">abstract class CondimentDecorator extends Beverage</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    // 所有的装饰者都必须重新实现getDescription方法.</span></span><br><span class=\"line\"><span class=\"comment\">    public abstract function getDescription();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 浓缩饮料．</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Espresso</span> <span class=\"keyword\">extends</span> <span class=\"title\">Beverage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;description = <span class=\"string\">&#x27;Espresso&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cost</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1.99</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HouseBlend</span> <span class=\"keyword\">extends</span> <span class=\"title\">Beverage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;description = <span class=\"string\">&#x27;House Blend Coffee&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cost</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.89</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Mocha是一个装饰者，所以让他继承CondimentDecorator</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mocha</span> <span class=\"keyword\">extends</span> <span class=\"title\">Beverage</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@var</span> Beverage $beverage 用于让Mocha引用一个Beverage*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> $beverage;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将Beverage实例传给Mocha的实例变量中.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\">Beverage $beverage</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;beverage = $beverage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加Mocha的描述．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDescription</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;beverage-&gt;getDescription() . <span class=\"string\">&quot;, Mocha&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加摩卡的价格．</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cost</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.2</span> + <span class=\"keyword\">$this</span>-&gt;beverage-&gt;cost();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个被浓缩咖啡．</span></span><br><span class=\"line\">$beverage = <span class=\"keyword\">new</span> Espresso();</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;&#123;$beverage-&gt;getDescription()&#125; \\$&#123;$beverage-&gt;cost()&#125;\\n&quot;</span>;　<span class=\"comment\">// Espresso $1.99</span></span><br><span class=\"line\"><span class=\"comment\">// 做成一杯摩卡．</span></span><br><span class=\"line\">$beverage = <span class=\"keyword\">new</span> Mocha($beverage);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;&#123;$beverage-&gt;getDescription()&#125; \\$&#123;$beverage-&gt;cost()&#125;\\n&quot;</span>; <span class=\"comment\">// Espresso, Mocha $2.19</span></span><br><span class=\"line\"></span><br><span class=\"line\">$beverage１ = <span class=\"keyword\">new</span> HouseBlend();</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;&#123;$beverage１-&gt;getDescription()&#125; \\$&#123;$beverage１-&gt;cost()&#125;\\n&quot;</span>; <span class=\"comment\">// House Blend Coffee $0.89</span></span><br><span class=\"line\"></span><br><span class=\"line\">$beverage１ = <span class=\"keyword\">new</span> Mocha($beverage１);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;&#123;$beverage１-&gt;getDescription()&#125; \\$&#123;$beverage１-&gt;cost()&#125;\\n&quot;</span>; <span class=\"comment\">// House Blend Coffee, Mocha $1.09</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"4-装饰器模式的应用\"><a href=\"#4-装饰器模式的应用\" class=\"headerlink\" title=\"4 装饰器模式的应用\"></a>4 装饰器模式的应用</h3><p>在JAVA语言中，java.io包里面很多都应用了装饰器模式，例如<code>FileInputStream--&gt;BufferedInputStream--&gt;LineNumberInputStream</code>，其中：</p>\n<ul>\n<li>FileInputStream是被装饰的组件，Java I/O程序库提供了几个组件，包括FileInputStream，StringBufferInputStream，ByteArrayInputStream等，这些都提供了最基本的字节读取功能；</li>\n<li>BufferedInputStream是一个具体的装饰者，它加入来嗯中行为：利用缓冲输入来改进性能，用一个readline()方法来增强接口；</li>\n<li>LineNumberInputStream也是一个具体的装饰者，他加上了计算行数的能力．</li>\n</ul>\n<p>如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/JavaIO-Decorator.png\" alt=\"JavaIO-Decorator\"></p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p>Head First设计模式 装饰对象：装饰者模式（P79）</p>"},{"title":"DesignPattern-Adapter(适配器模式)","date":"2020-09-29T03:17:34.000Z","_content":"\n1 概述\n\n适配器其实很好理解，生活中也其实充满了适配器，比如：壁式插座是三角孔，而标准的交流电插头是两头的，若需要将两头插头插入三角孔内，则可能需要一个交流电适配器．\n\n<!--more-->\n\n该交流电的适配器的作用：位于插头和插座之间，将插头转换为三角插头，将交流电经过一定的转换以匹配插座．\n\n\n\n2 Adapter（适配器模式）\n\n定义：适配器模式将一个类的接口，转换成客户期望的另一个接口．适配器让原本接口不兼容的类可以合作无间．\n\n\n\n作用：\n\n- ①、通过创建适配器进行接口转换，让不兼容的接口变成兼容，让客户从实现的接口解耦。\n- ②、若后续有改变接口，适配器可以将改变部分封装起来，无需客户进行修改。\n\n\n\n适配器的分类：\n- 对象适配器——“组合”方式适配\n- 类适配器——“继承”方式适配\n\n\n\n| 优缺点     | 优点                                                         | 缺点                          |\n| ---------- | ------------------------------------------------------------ | ----------------------------- |\n| 对象适配器 | ①、采用组合的方式，步进可以适配某个类，也可以适配该类的任何子类。<br />②、只需要写很少的代码，将工作委托给适配者，更加有弹性。 | ①、需重新实现整个被适配者。   |\n| 类适配器   | ①、采用继承的方式，无需重新实现整个被适配者，且可以覆盖被适配者的行为。<br/>②、只需要一个类适配器，不需要一个适配器和一个被适配者。 | ①、只能采用某个特定被适配类。 |\n\n\n\n2.1 对象适配器\n\n对象适配器是通过＂组合＂方式适配．其类图如下：\n\n![Adapter_UML](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Adapter_UML.png)\n\n\n\n对象适配器优点：\n\n- ①、采用组合的方式，步进可以适配某个类，也可以适配该类的任何子类。\n- ②、只需要写很少的代码，将工作委托给适配者，更加有弹性。\n\n\n\n对象适配器缺点：\n\n- ①、需重新实现整个被适配者。\n\n\n\n2.2 类适配器\n\n类适配器采用＂继承＂的方式适配．（*类适配器需要多重继承才能实现，而对于Java, PHP是不支持多重继承的*）\n\n\n\n其类图如下：\n\n![AdapterClassUml](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AdapterClassUml.png)\n\n\n\n类适配器的优点：\n\n- ①、采用继承的方式，无需重新实现整个被适配者，且可以覆盖被适配者的行为。\n- ②、只需要一个类适配器，不需要一个适配器和一个被适配者。\n\n\n\n类是配器的缺点：\n\n- ①、只能采用某个特定被适配类。\n\n\n\n3 适配器模式的应用\n\n假设有一个带有`fly()`和gobble()方法的Turkey类。还有一个带有fly()和quack()方法的Duck类。让我们假设你是Duck对象的简称，你想在他们的位置使用Turkey对象。Turkey有一些类似的功能，但实现了不同的接口，所以我们不能直接使用它们。所以我们将使用适配器模式。在这里，我们的客户将是Duck，而adaptee将是Turkey。\n\n（*由于PHP并不支持多重继承，因此此处只分析对象适配器的情况*）\n\n其类图如下：\n\n![AdapterObjectExample](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AdapterObjectExample.png)\n\n\n\n```php\n// 鸭子接口,具备呱呱叫和飞行的能力.\ninterface Duck\n{\n    public function quack(); // 鸭子叫.\n    public function fly();  // 飞行能力.\n}\n\n// 火鸡接口.\ninterface Turkey\n{\n    public function gobble(); // 火鸡咯咯叫.\n    public function fly(); // 火鸡会飞,但飞不远.\n}\n\n// 绿头鸭是鸭子的实现.\nclass MallardDuck implements Duck\n{\n    public function quack()\n    {\n        echo \"Quack\\n\";\n    }\n\n    public function fly()\n    {\n        echo \"I'm flying\\n\";\n    }\n}\n\n// 野火鸡是火鸡的实现.\nclass WildTurkey implements Turkey\n{\n\n    public function gobble()\n    {\n        echo \"Gobble gobble\\n\";\n    }\n\n    public function fly()\n    {\n        echo \"I'm flying a short distance\\n\"; // 火鸡只能飞很短的距离．\n    }\n}\n\n// 鸭子适配器(让火鸡来充当鸭子),首先需要实现想要转换成的类型接口,也就是客户所期望看到的接口.\nclass TurkeyAdapter implements Duck\n{\n    /**@var Turkey $turkey 传入的火鸡对象*/\n    private $turkey;\n\n    // 接着需要取得适配的对象引用.\n    public function __construct(Turkey $turkey)\n    {\n        $this->turkey = $turkey;\n    }\n\n    // 实现接口中的所有方法,试下转换.\n    public function quack()\n    {\n        $this->turkey->gobble();　// 在鸭子的相应方法里面，调用传入的火鸡对象的接口．\n    }\n\n    // 虽然两个接口都具备了fly方法,火鸡的飞行距离短,不像鸭子可以长途飞行,要让鸭子的飞行和火鸡的飞行对应,必须连续调用火鸡的fly来完成.\n    public function fly()\n    {\n        for ($i = 0; $i < 5; $i++) {\n            $this->turkey->fly();\n        }\n    }\n\n}\n\n// 测试.\n$duck = new MallardDuck();　// 创建一只鸭子.\n$turkey = new WildTurkey();　//  创建一只火鸡.\n\n// 将火鸡包装进一个火鸡适配器,使它看起来象一只鸭子.\n$turkeyAdapter = new TurkeyAdapter($turkey);\necho \"The Turkey says...\\n\";\n$turkey->gobble();　// Gobble gobble\n$turkey->fly(); // I'm flying a short distance\n\necho \"\\nThe Duck says...\\n\";\n$duck->quack(); // Quack\n$duck->fly(); // I'm flying\n\necho \"\\nThe TurkeyAdapter says...\\n\";\n$turkeyAdapter->quack(); // Gobble gobble\n$turkeyAdapter->fly(); // I'm flying a short distance\\nI'm flying a short distance\\nI'm flying a short distance\\nI'm flying a short distance\\nI'm flying a short distance\n```\n\n\n\n------\n\n参考资料\nHead First Design Pattern\n适配器模式（https://www.geeksforgeeks.org/adapter-pattern/）","source":"_posts/DesignPattern-Adapter.md","raw":"---\ntitle: DesignPattern-Adapter(适配器模式)\ndate: 2020-09-29 11:17:34\ntags: [\"DesignPattern\",\"Adapter\"]\ncategories: [\"DesignPattern\"]\n---\n\n1 概述\n\n适配器其实很好理解，生活中也其实充满了适配器，比如：壁式插座是三角孔，而标准的交流电插头是两头的，若需要将两头插头插入三角孔内，则可能需要一个交流电适配器．\n\n<!--more-->\n\n该交流电的适配器的作用：位于插头和插座之间，将插头转换为三角插头，将交流电经过一定的转换以匹配插座．\n\n\n\n2 Adapter（适配器模式）\n\n定义：适配器模式将一个类的接口，转换成客户期望的另一个接口．适配器让原本接口不兼容的类可以合作无间．\n\n\n\n作用：\n\n- ①、通过创建适配器进行接口转换，让不兼容的接口变成兼容，让客户从实现的接口解耦。\n- ②、若后续有改变接口，适配器可以将改变部分封装起来，无需客户进行修改。\n\n\n\n适配器的分类：\n- 对象适配器——“组合”方式适配\n- 类适配器——“继承”方式适配\n\n\n\n| 优缺点     | 优点                                                         | 缺点                          |\n| ---------- | ------------------------------------------------------------ | ----------------------------- |\n| 对象适配器 | ①、采用组合的方式，步进可以适配某个类，也可以适配该类的任何子类。<br />②、只需要写很少的代码，将工作委托给适配者，更加有弹性。 | ①、需重新实现整个被适配者。   |\n| 类适配器   | ①、采用继承的方式，无需重新实现整个被适配者，且可以覆盖被适配者的行为。<br/>②、只需要一个类适配器，不需要一个适配器和一个被适配者。 | ①、只能采用某个特定被适配类。 |\n\n\n\n2.1 对象适配器\n\n对象适配器是通过＂组合＂方式适配．其类图如下：\n\n![Adapter_UML](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Adapter_UML.png)\n\n\n\n对象适配器优点：\n\n- ①、采用组合的方式，步进可以适配某个类，也可以适配该类的任何子类。\n- ②、只需要写很少的代码，将工作委托给适配者，更加有弹性。\n\n\n\n对象适配器缺点：\n\n- ①、需重新实现整个被适配者。\n\n\n\n2.2 类适配器\n\n类适配器采用＂继承＂的方式适配．（*类适配器需要多重继承才能实现，而对于Java, PHP是不支持多重继承的*）\n\n\n\n其类图如下：\n\n![AdapterClassUml](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AdapterClassUml.png)\n\n\n\n类适配器的优点：\n\n- ①、采用继承的方式，无需重新实现整个被适配者，且可以覆盖被适配者的行为。\n- ②、只需要一个类适配器，不需要一个适配器和一个被适配者。\n\n\n\n类是配器的缺点：\n\n- ①、只能采用某个特定被适配类。\n\n\n\n3 适配器模式的应用\n\n假设有一个带有`fly()`和gobble()方法的Turkey类。还有一个带有fly()和quack()方法的Duck类。让我们假设你是Duck对象的简称，你想在他们的位置使用Turkey对象。Turkey有一些类似的功能，但实现了不同的接口，所以我们不能直接使用它们。所以我们将使用适配器模式。在这里，我们的客户将是Duck，而adaptee将是Turkey。\n\n（*由于PHP并不支持多重继承，因此此处只分析对象适配器的情况*）\n\n其类图如下：\n\n![AdapterObjectExample](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AdapterObjectExample.png)\n\n\n\n```php\n// 鸭子接口,具备呱呱叫和飞行的能力.\ninterface Duck\n{\n    public function quack(); // 鸭子叫.\n    public function fly();  // 飞行能力.\n}\n\n// 火鸡接口.\ninterface Turkey\n{\n    public function gobble(); // 火鸡咯咯叫.\n    public function fly(); // 火鸡会飞,但飞不远.\n}\n\n// 绿头鸭是鸭子的实现.\nclass MallardDuck implements Duck\n{\n    public function quack()\n    {\n        echo \"Quack\\n\";\n    }\n\n    public function fly()\n    {\n        echo \"I'm flying\\n\";\n    }\n}\n\n// 野火鸡是火鸡的实现.\nclass WildTurkey implements Turkey\n{\n\n    public function gobble()\n    {\n        echo \"Gobble gobble\\n\";\n    }\n\n    public function fly()\n    {\n        echo \"I'm flying a short distance\\n\"; // 火鸡只能飞很短的距离．\n    }\n}\n\n// 鸭子适配器(让火鸡来充当鸭子),首先需要实现想要转换成的类型接口,也就是客户所期望看到的接口.\nclass TurkeyAdapter implements Duck\n{\n    /**@var Turkey $turkey 传入的火鸡对象*/\n    private $turkey;\n\n    // 接着需要取得适配的对象引用.\n    public function __construct(Turkey $turkey)\n    {\n        $this->turkey = $turkey;\n    }\n\n    // 实现接口中的所有方法,试下转换.\n    public function quack()\n    {\n        $this->turkey->gobble();　// 在鸭子的相应方法里面，调用传入的火鸡对象的接口．\n    }\n\n    // 虽然两个接口都具备了fly方法,火鸡的飞行距离短,不像鸭子可以长途飞行,要让鸭子的飞行和火鸡的飞行对应,必须连续调用火鸡的fly来完成.\n    public function fly()\n    {\n        for ($i = 0; $i < 5; $i++) {\n            $this->turkey->fly();\n        }\n    }\n\n}\n\n// 测试.\n$duck = new MallardDuck();　// 创建一只鸭子.\n$turkey = new WildTurkey();　//  创建一只火鸡.\n\n// 将火鸡包装进一个火鸡适配器,使它看起来象一只鸭子.\n$turkeyAdapter = new TurkeyAdapter($turkey);\necho \"The Turkey says...\\n\";\n$turkey->gobble();　// Gobble gobble\n$turkey->fly(); // I'm flying a short distance\n\necho \"\\nThe Duck says...\\n\";\n$duck->quack(); // Quack\n$duck->fly(); // I'm flying\n\necho \"\\nThe TurkeyAdapter says...\\n\";\n$turkeyAdapter->quack(); // Gobble gobble\n$turkeyAdapter->fly(); // I'm flying a short distance\\nI'm flying a short distance\\nI'm flying a short distance\\nI'm flying a short distance\\nI'm flying a short distance\n```\n\n\n\n------\n\n参考资料\nHead First Design Pattern\n适配器模式（https://www.geeksforgeeks.org/adapter-pattern/）","slug":"DesignPattern-Adapter","published":1,"updated":"2020-09-29T09:51:23.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfnsf8cc0000gyg3dscscp57","content":"<p>1 概述</p>\n<p>适配器其实很好理解，生活中也其实充满了适配器，比如：壁式插座是三角孔，而标准的交流电插头是两头的，若需要将两头插头插入三角孔内，则可能需要一个交流电适配器．</p>\n<a id=\"more\"></a>\n\n<p>该交流电的适配器的作用：位于插头和插座之间，将插头转换为三角插头，将交流电经过一定的转换以匹配插座．</p>\n<p>2 Adapter（适配器模式）</p>\n<p>定义：适配器模式将一个类的接口，转换成客户期望的另一个接口．适配器让原本接口不兼容的类可以合作无间．</p>\n<p>作用：</p>\n<ul>\n<li>①、通过创建适配器进行接口转换，让不兼容的接口变成兼容，让客户从实现的接口解耦。</li>\n<li>②、若后续有改变接口，适配器可以将改变部分封装起来，无需客户进行修改。</li>\n</ul>\n<p>适配器的分类：</p>\n<ul>\n<li>对象适配器——“组合”方式适配</li>\n<li>类适配器——“继承”方式适配</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>优缺点</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>对象适配器</td>\n<td>①、采用组合的方式，步进可以适配某个类，也可以适配该类的任何子类。<br />②、只需要写很少的代码，将工作委托给适配者，更加有弹性。</td>\n<td>①、需重新实现整个被适配者。</td>\n</tr>\n<tr>\n<td>类适配器</td>\n<td>①、采用继承的方式，无需重新实现整个被适配者，且可以覆盖被适配者的行为。<br/>②、只需要一个类适配器，不需要一个适配器和一个被适配者。</td>\n<td>①、只能采用某个特定被适配类。</td>\n</tr>\n</tbody></table>\n<p>2.1 对象适配器</p>\n<p>对象适配器是通过＂组合＂方式适配．其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Adapter_UML.png\" alt=\"Adapter_UML\"></p>\n<p>对象适配器优点：</p>\n<ul>\n<li>①、采用组合的方式，步进可以适配某个类，也可以适配该类的任何子类。</li>\n<li>②、只需要写很少的代码，将工作委托给适配者，更加有弹性。</li>\n</ul>\n<p>对象适配器缺点：</p>\n<ul>\n<li>①、需重新实现整个被适配者。</li>\n</ul>\n<p>2.2 类适配器</p>\n<p>类适配器采用＂继承＂的方式适配．（<em>类适配器需要多重继承才能实现，而对于Java, PHP是不支持多重继承的</em>）</p>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AdapterClassUml.png\" alt=\"AdapterClassUml\"></p>\n<p>类适配器的优点：</p>\n<ul>\n<li>①、采用继承的方式，无需重新实现整个被适配者，且可以覆盖被适配者的行为。</li>\n<li>②、只需要一个类适配器，不需要一个适配器和一个被适配者。</li>\n</ul>\n<p>类是配器的缺点：</p>\n<ul>\n<li>①、只能采用某个特定被适配类。</li>\n</ul>\n<p>3 适配器模式的应用</p>\n<p>假设有一个带有<code>fly()</code>和gobble()方法的Turkey类。还有一个带有fly()和quack()方法的Duck类。让我们假设你是Duck对象的简称，你想在他们的位置使用Turkey对象。Turkey有一些类似的功能，但实现了不同的接口，所以我们不能直接使用它们。所以我们将使用适配器模式。在这里，我们的客户将是Duck，而adaptee将是Turkey。</p>\n<p>（<em>由于PHP并不支持多重继承，因此此处只分析对象适配器的情况</em>）</p>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AdapterObjectExample.png\" alt=\"AdapterObjectExample\"></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 鸭子接口,具备呱呱叫和飞行的能力.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Duck</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quack</span>(<span class=\"params\"></span>)</span>; <span class=\"comment\">// 鸭子叫.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span>;  <span class=\"comment\">// 飞行能力.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 火鸡接口.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Turkey</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gobble</span>(<span class=\"params\"></span>)</span>; <span class=\"comment\">// 火鸡咯咯叫.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span>; <span class=\"comment\">// 火鸡会飞,但飞不远.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绿头鸭是鸭子的实现.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MallardDuck</span> <span class=\"keyword\">implements</span> <span class=\"title\">Duck</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quack</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Quack\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;I&#x27;m flying\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 野火鸡是火鸡的实现.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WildTurkey</span> <span class=\"keyword\">implements</span> <span class=\"title\">Turkey</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gobble</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Gobble gobble\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;I&#x27;m flying a short distance\\n&quot;</span>; <span class=\"comment\">// 火鸡只能飞很短的距离．</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 鸭子适配器(让火鸡来充当鸭子),首先需要实现想要转换成的类型接口,也就是客户所期望看到的接口.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TurkeyAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Duck</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**<span class=\"doctag\">@var</span> Turkey $turkey 传入的火鸡对象*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> $turkey;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接着需要取得适配的对象引用.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\">Turkey $turkey</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;turkey = $turkey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现接口中的所有方法,试下转换.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quack</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;turkey-&gt;gobble();　<span class=\"comment\">// 在鸭子的相应方法里面，调用传入的火鸡对象的接口．</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 虽然两个接口都具备了fly方法,火鸡的飞行距离短,不像鸭子可以长途飞行,要让鸭子的飞行和火鸡的飞行对应,必须连续调用火鸡的fly来完成.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ($i = <span class=\"number\">0</span>; $i &lt; <span class=\"number\">5</span>; $i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;turkey-&gt;fly();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试.</span></span><br><span class=\"line\">$duck = <span class=\"keyword\">new</span> MallardDuck();　<span class=\"comment\">// 创建一只鸭子.</span></span><br><span class=\"line\">$turkey = <span class=\"keyword\">new</span> WildTurkey();　<span class=\"comment\">//  创建一只火鸡.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将火鸡包装进一个火鸡适配器,使它看起来象一只鸭子.</span></span><br><span class=\"line\">$turkeyAdapter = <span class=\"keyword\">new</span> TurkeyAdapter($turkey);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;The Turkey says...\\n&quot;</span>;</span><br><span class=\"line\">$turkey-&gt;gobble();　<span class=\"comment\">// Gobble gobble</span></span><br><span class=\"line\">$turkey-&gt;fly(); <span class=\"comment\">// I&#x27;m flying a short distance</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;\\nThe Duck says...\\n&quot;</span>;</span><br><span class=\"line\">$duck-&gt;quack(); <span class=\"comment\">// Quack</span></span><br><span class=\"line\">$duck-&gt;fly(); <span class=\"comment\">// I&#x27;m flying</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;\\nThe TurkeyAdapter says...\\n&quot;</span>;</span><br><span class=\"line\">$turkeyAdapter-&gt;quack(); <span class=\"comment\">// Gobble gobble</span></span><br><span class=\"line\">$turkeyAdapter-&gt;fly(); <span class=\"comment\">// I&#x27;m flying a short distance\\nI&#x27;m flying a short distance\\nI&#x27;m flying a short distance\\nI&#x27;m flying a short distance\\nI&#x27;m flying a short distance</span></span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<p>参考资料<br>Head First Design Pattern<br>适配器模式（<a href=\"https://www.geeksforgeeks.org/adapter-pattern/%EF%BC%89\">https://www.geeksforgeeks.org/adapter-pattern/）</a></p>\n","site":{"data":{}},"excerpt":"<p>1 概述</p>\n<p>适配器其实很好理解，生活中也其实充满了适配器，比如：壁式插座是三角孔，而标准的交流电插头是两头的，若需要将两头插头插入三角孔内，则可能需要一个交流电适配器．</p>","more":"<p>该交流电的适配器的作用：位于插头和插座之间，将插头转换为三角插头，将交流电经过一定的转换以匹配插座．</p>\n<p>2 Adapter（适配器模式）</p>\n<p>定义：适配器模式将一个类的接口，转换成客户期望的另一个接口．适配器让原本接口不兼容的类可以合作无间．</p>\n<p>作用：</p>\n<ul>\n<li>①、通过创建适配器进行接口转换，让不兼容的接口变成兼容，让客户从实现的接口解耦。</li>\n<li>②、若后续有改变接口，适配器可以将改变部分封装起来，无需客户进行修改。</li>\n</ul>\n<p>适配器的分类：</p>\n<ul>\n<li>对象适配器——“组合”方式适配</li>\n<li>类适配器——“继承”方式适配</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>优缺点</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>对象适配器</td>\n<td>①、采用组合的方式，步进可以适配某个类，也可以适配该类的任何子类。<br />②、只需要写很少的代码，将工作委托给适配者，更加有弹性。</td>\n<td>①、需重新实现整个被适配者。</td>\n</tr>\n<tr>\n<td>类适配器</td>\n<td>①、采用继承的方式，无需重新实现整个被适配者，且可以覆盖被适配者的行为。<br/>②、只需要一个类适配器，不需要一个适配器和一个被适配者。</td>\n<td>①、只能采用某个特定被适配类。</td>\n</tr>\n</tbody></table>\n<p>2.1 对象适配器</p>\n<p>对象适配器是通过＂组合＂方式适配．其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/Adapter_UML.png\" alt=\"Adapter_UML\"></p>\n<p>对象适配器优点：</p>\n<ul>\n<li>①、采用组合的方式，步进可以适配某个类，也可以适配该类的任何子类。</li>\n<li>②、只需要写很少的代码，将工作委托给适配者，更加有弹性。</li>\n</ul>\n<p>对象适配器缺点：</p>\n<ul>\n<li>①、需重新实现整个被适配者。</li>\n</ul>\n<p>2.2 类适配器</p>\n<p>类适配器采用＂继承＂的方式适配．（<em>类适配器需要多重继承才能实现，而对于Java, PHP是不支持多重继承的</em>）</p>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AdapterClassUml.png\" alt=\"AdapterClassUml\"></p>\n<p>类适配器的优点：</p>\n<ul>\n<li>①、采用继承的方式，无需重新实现整个被适配者，且可以覆盖被适配者的行为。</li>\n<li>②、只需要一个类适配器，不需要一个适配器和一个被适配者。</li>\n</ul>\n<p>类是配器的缺点：</p>\n<ul>\n<li>①、只能采用某个特定被适配类。</li>\n</ul>\n<p>3 适配器模式的应用</p>\n<p>假设有一个带有<code>fly()</code>和gobble()方法的Turkey类。还有一个带有fly()和quack()方法的Duck类。让我们假设你是Duck对象的简称，你想在他们的位置使用Turkey对象。Turkey有一些类似的功能，但实现了不同的接口，所以我们不能直接使用它们。所以我们将使用适配器模式。在这里，我们的客户将是Duck，而adaptee将是Turkey。</p>\n<p>（<em>由于PHP并不支持多重继承，因此此处只分析对象适配器的情况</em>）</p>\n<p>其类图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/DesignPattern/AdapterObjectExample.png\" alt=\"AdapterObjectExample\"></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 鸭子接口,具备呱呱叫和飞行的能力.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Duck</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quack</span>(<span class=\"params\"></span>)</span>; <span class=\"comment\">// 鸭子叫.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span>;  <span class=\"comment\">// 飞行能力.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 火鸡接口.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Turkey</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gobble</span>(<span class=\"params\"></span>)</span>; <span class=\"comment\">// 火鸡咯咯叫.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span>; <span class=\"comment\">// 火鸡会飞,但飞不远.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绿头鸭是鸭子的实现.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MallardDuck</span> <span class=\"keyword\">implements</span> <span class=\"title\">Duck</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quack</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Quack\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;I&#x27;m flying\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 野火鸡是火鸡的实现.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WildTurkey</span> <span class=\"keyword\">implements</span> <span class=\"title\">Turkey</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gobble</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;Gobble gobble\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"string\">&quot;I&#x27;m flying a short distance\\n&quot;</span>; <span class=\"comment\">// 火鸡只能飞很短的距离．</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 鸭子适配器(让火鸡来充当鸭子),首先需要实现想要转换成的类型接口,也就是客户所期望看到的接口.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TurkeyAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Duck</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**<span class=\"doctag\">@var</span> Turkey $turkey 传入的火鸡对象*/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> $turkey;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接着需要取得适配的对象引用.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span>(<span class=\"params\">Turkey $turkey</span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;turkey = $turkey;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现接口中的所有方法,试下转换.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quack</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;turkey-&gt;gobble();　<span class=\"comment\">// 在鸭子的相应方法里面，调用传入的火鸡对象的接口．</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 虽然两个接口都具备了fly方法,火鸡的飞行距离短,不像鸭子可以长途飞行,要让鸭子的飞行和火鸡的飞行对应,必须连续调用火鸡的fly来完成.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fly</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ($i = <span class=\"number\">0</span>; $i &lt; <span class=\"number\">5</span>; $i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;turkey-&gt;fly();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试.</span></span><br><span class=\"line\">$duck = <span class=\"keyword\">new</span> MallardDuck();　<span class=\"comment\">// 创建一只鸭子.</span></span><br><span class=\"line\">$turkey = <span class=\"keyword\">new</span> WildTurkey();　<span class=\"comment\">//  创建一只火鸡.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将火鸡包装进一个火鸡适配器,使它看起来象一只鸭子.</span></span><br><span class=\"line\">$turkeyAdapter = <span class=\"keyword\">new</span> TurkeyAdapter($turkey);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;The Turkey says...\\n&quot;</span>;</span><br><span class=\"line\">$turkey-&gt;gobble();　<span class=\"comment\">// Gobble gobble</span></span><br><span class=\"line\">$turkey-&gt;fly(); <span class=\"comment\">// I&#x27;m flying a short distance</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;\\nThe Duck says...\\n&quot;</span>;</span><br><span class=\"line\">$duck-&gt;quack(); <span class=\"comment\">// Quack</span></span><br><span class=\"line\">$duck-&gt;fly(); <span class=\"comment\">// I&#x27;m flying</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">&quot;\\nThe TurkeyAdapter says...\\n&quot;</span>;</span><br><span class=\"line\">$turkeyAdapter-&gt;quack(); <span class=\"comment\">// Gobble gobble</span></span><br><span class=\"line\">$turkeyAdapter-&gt;fly(); <span class=\"comment\">// I&#x27;m flying a short distance\\nI&#x27;m flying a short distance\\nI&#x27;m flying a short distance\\nI&#x27;m flying a short distance\\nI&#x27;m flying a short distance</span></span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<p>参考资料<br>Head First Design Pattern<br>适配器模式（<a href=\"https://www.geeksforgeeks.org/adapter-pattern/%EF%BC%89\">https://www.geeksforgeeks.org/adapter-pattern/）</a></p>"},{"title":"PHP-Laravel简介及安装","date":"2020-10-05T08:43:13.000Z","_content":"\n1 简介\n\nLaravel是一套简洁、优雅的PHP Web开发框架(PHP Web Framework)。\n\n<!--more-->\n\n2 安装\n\n2.1 服务器要求\n\n确保服务器满足版本要求且已安装以下扩展：\n\n扩展：\n\n- BCMath\n- Ctype\n- Fileinfo\n- JSON\n- Mbstring\n- OpenSSL\n- PDO\n- Tokenizer\n- XML\n\n\n\n2.2 安装Laravel\n\nLaravel 使用 [Composer](https://getcomposer.org/) 来管理项目依赖。因此，在使用 Laravel 之前，请确保您的机器上已经安装了 Composer。\n\n2.2.1 通过Laravel安装器\n\n*注意：使用安装器安装为最新版本，当前安装的版本为laravel 8.x*\n\n2.2.1.1 使用composer安装Laravel安装器\n\n```\ncomposer global require laravel/installer\n```\n\n\n\n2.2.1.2 修改系统环境变量\n\n```txt ~/.bashrc\nexport LARAVEL_HOME=/root/.composer/vendor/bin\nexport PATH=$LARAVEL_HOME:$PATH\n```\n\n\n\n2.2.1.3 执行以下命令使其生效\n\n```\nsource ~/.bashrc\n```\n\n\n\n2.2.1.4 创建Laravel项目\n\n通过`laravel new`命令创建Laravel项目。\n\n示例：通过以下命令将创建一个名为blog的目录，并安装号Laravel所有依赖项。\n\n```\nlaravel new blog\n```\n\n\n\n2.2.2 通过Composer创建项目\n\n通过create-project命令来安装Laravel：\n\n```\ncomposer create-project --prefer-dist laravel/laravel blog <版本>\n```\n\n\n\n示例：由于我本机php版本为7.1.3，查看支持的Laravel版本，对应的应该为5.6\n\n```\ncomposer create-project --prefer-dist laravel/laravel blog 5.6.*\n```\n\n\n\n","source":"_posts/PHP-Laravel安装.md","raw":"---\ntitle: PHP-Laravel简介及安装\ndate: 2020-10-05 16:43:13\ntags: [\"PHP\",\"Laravel\"]\ncategories: [\"PHP\",\"Laravel\"]\n---\n\n1 简介\n\nLaravel是一套简洁、优雅的PHP Web开发框架(PHP Web Framework)。\n\n<!--more-->\n\n2 安装\n\n2.1 服务器要求\n\n确保服务器满足版本要求且已安装以下扩展：\n\n扩展：\n\n- BCMath\n- Ctype\n- Fileinfo\n- JSON\n- Mbstring\n- OpenSSL\n- PDO\n- Tokenizer\n- XML\n\n\n\n2.2 安装Laravel\n\nLaravel 使用 [Composer](https://getcomposer.org/) 来管理项目依赖。因此，在使用 Laravel 之前，请确保您的机器上已经安装了 Composer。\n\n2.2.1 通过Laravel安装器\n\n*注意：使用安装器安装为最新版本，当前安装的版本为laravel 8.x*\n\n2.2.1.1 使用composer安装Laravel安装器\n\n```\ncomposer global require laravel/installer\n```\n\n\n\n2.2.1.2 修改系统环境变量\n\n```txt ~/.bashrc\nexport LARAVEL_HOME=/root/.composer/vendor/bin\nexport PATH=$LARAVEL_HOME:$PATH\n```\n\n\n\n2.2.1.3 执行以下命令使其生效\n\n```\nsource ~/.bashrc\n```\n\n\n\n2.2.1.4 创建Laravel项目\n\n通过`laravel new`命令创建Laravel项目。\n\n示例：通过以下命令将创建一个名为blog的目录，并安装号Laravel所有依赖项。\n\n```\nlaravel new blog\n```\n\n\n\n2.2.2 通过Composer创建项目\n\n通过create-project命令来安装Laravel：\n\n```\ncomposer create-project --prefer-dist laravel/laravel blog <版本>\n```\n\n\n\n示例：由于我本机php版本为7.1.3，查看支持的Laravel版本，对应的应该为5.6\n\n```\ncomposer create-project --prefer-dist laravel/laravel blog 5.6.*\n```\n\n\n\n","slug":"PHP-Laravel安装","published":1,"updated":"2020-10-06T16:44:10.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgb0887o00001hvt6yjj15vk","content":"<p>1 简介</p>\n<p>Laravel是一套简洁、优雅的PHP Web开发框架(PHP Web Framework)。</p>\n<a id=\"more\"></a>\n\n<p>2 安装</p>\n<p>2.1 服务器要求</p>\n<p>确保服务器满足版本要求且已安装以下扩展：</p>\n<p>扩展：</p>\n<ul>\n<li>BCMath</li>\n<li>Ctype</li>\n<li>Fileinfo</li>\n<li>JSON</li>\n<li>Mbstring</li>\n<li>OpenSSL</li>\n<li>PDO</li>\n<li>Tokenizer</li>\n<li>XML</li>\n</ul>\n<p>2.2 安装Laravel</p>\n<p>Laravel 使用 <a href=\"https://getcomposer.org/\">Composer</a> 来管理项目依赖。因此，在使用 Laravel 之前，请确保您的机器上已经安装了 Composer。</p>\n<p>2.2.1 通过Laravel安装器</p>\n<p><em>注意：使用安装器安装为最新版本，当前安装的版本为laravel 8.x</em></p>\n<p>2.2.1.1 使用composer安装Laravel安装器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer global require laravel&#x2F;installer</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.2.1.2 修改系统环境变量</p>\n<figure class=\"highlight txt\"><figcaption><span>~/.bashrc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export LARAVEL_HOME=/root/.composer/vendor/bin</span><br><span class=\"line\">export PATH=$LARAVEL_HOME:$PATH</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.2.1.3 执行以下命令使其生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.2.1.4 创建Laravel项目</p>\n<p>通过<code>laravel new</code>命令创建Laravel项目。</p>\n<p>示例：通过以下命令将创建一个名为blog的目录，并安装号Laravel所有依赖项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">laravel new blog</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.2.2 通过Composer创建项目</p>\n<p>通过create-project命令来安装Laravel：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer create-project --prefer-dist laravel&#x2F;laravel blog &lt;版本&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例：由于我本机php版本为7.1.3，查看支持的Laravel版本，对应的应该为5.6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer create-project --prefer-dist laravel&#x2F;laravel blog 5.6.*</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<p>1 简介</p>\n<p>Laravel是一套简洁、优雅的PHP Web开发框架(PHP Web Framework)。</p>","more":"<p>2 安装</p>\n<p>2.1 服务器要求</p>\n<p>确保服务器满足版本要求且已安装以下扩展：</p>\n<p>扩展：</p>\n<ul>\n<li>BCMath</li>\n<li>Ctype</li>\n<li>Fileinfo</li>\n<li>JSON</li>\n<li>Mbstring</li>\n<li>OpenSSL</li>\n<li>PDO</li>\n<li>Tokenizer</li>\n<li>XML</li>\n</ul>\n<p>2.2 安装Laravel</p>\n<p>Laravel 使用 <a href=\"https://getcomposer.org/\">Composer</a> 来管理项目依赖。因此，在使用 Laravel 之前，请确保您的机器上已经安装了 Composer。</p>\n<p>2.2.1 通过Laravel安装器</p>\n<p><em>注意：使用安装器安装为最新版本，当前安装的版本为laravel 8.x</em></p>\n<p>2.2.1.1 使用composer安装Laravel安装器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer global require laravel&#x2F;installer</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.2.1.2 修改系统环境变量</p>\n<figure class=\"highlight txt\"><figcaption><span>~/.bashrc</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export LARAVEL_HOME=/root/.composer/vendor/bin</span><br><span class=\"line\">export PATH=$LARAVEL_HOME:$PATH</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.2.1.3 执行以下命令使其生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.2.1.4 创建Laravel项目</p>\n<p>通过<code>laravel new</code>命令创建Laravel项目。</p>\n<p>示例：通过以下命令将创建一个名为blog的目录，并安装号Laravel所有依赖项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">laravel new blog</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.2.2 通过Composer创建项目</p>\n<p>通过create-project命令来安装Laravel：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer create-project --prefer-dist laravel&#x2F;laravel blog &lt;版本&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例：由于我本机php版本为7.1.3，查看支持的Laravel版本，对应的应该为5.6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer create-project --prefer-dist laravel&#x2F;laravel blog 5.6.*</span><br></pre></td></tr></table></figure>"},{"title":"操作系统-进程","date":"2021-03-18T15:42:55.000Z","_content":"\n#### 1 简介\n\n进程是对正在运行程序的一种抽象，或者说是实例，它包括程序计数器、寄存器和变量的当前值。\n\n关于进程的一个重要思想：一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干个进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。\n\n<!--more-->\n\n#### 2 进程的创建\n\n有4种主要事件会导致进程的创建：\n\n- 系统初始化\n- 正在运行的程序执行了创建进程的系统调用\n- 用户请求创建一个新的进程\n- 一个批处理作业的初始化\n\n\n\n> Unix系统，只有一个系统调用用于创建进程：fork。这个系统调用会创建一个与调用进程相同的副本。对于不可写的内存区是共享的；但对于可写的内存是不可以共享的，而是会进程写时复制，即当两者之一想要修改这部分数据时，则这块内存被明确的复制，以保证修改发生在私有区域。\n\n\n\n> Windows系统，使用CreateProcess函数创建进程，父子进程的地址空间一开始就是不同的。\n\n\n\n#### 3 进程的终止\n\n以下条件将引起进程的终止：\n\n- 正常退出（自愿）：`执行结束后由编译器执行一个系统调用（Unix系统：exit；Windows：ExitProcess）`\n- 出错退出（自愿）：`程序错误，例如除零`\n- 严重错误（非自愿）\n- 被其他进程杀死（非自愿）：`另外一个进程通过一个系统调用杀死该进程（Unix系统：kill；Windows系统：TerminateProcess）`\n\n\n\n#### 4 进程的层次结构\n\n- 对于Unix系统，进程和它的所有子进程以及后裔共同组成**进程组**；整个系统中，所有进程都属于以init为根的一棵树。\n\n- 对于Windows系统，没有层次的概念，所有的进程地位相同。\n\n\n\n#### 5 进程的状态\n\n三状态：\n\n- 就绪态\n- 运行态\n- 阻塞态。\n\n\n\n状态转换图如下：\n\n```\n就绪态 ----> 运行态 ----> 阻塞态\n  ^   <----               |\n  |                       |\n  -------------------------\n```\n\n\n\n#### 6 进程的实现\n\n操作系统维护了一张**进程表**，每个进程占用一个进程表项（也称**进程控制块**），其中包含了<u>程序计数器、堆栈指针、内存分配状况、所打开文件的转台、账号和调度信息，以及其他在进程由运行态装换到就绪态或阻塞态时必须保存的信息</u>。\n\n","source":"_posts/操作系统-进程.md","raw":"---\ntitle: 操作系统-进程\ndate: 2021-03-18 23:42:55\ntags: [\"操作系统\",\"进程\", \"现代操作系统\"]\ncategories: [\"操作系统\",\"进程\", \"Note\"]\n---\n\n#### 1 简介\n\n进程是对正在运行程序的一种抽象，或者说是实例，它包括程序计数器、寄存器和变量的当前值。\n\n关于进程的一个重要思想：一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干个进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。\n\n<!--more-->\n\n#### 2 进程的创建\n\n有4种主要事件会导致进程的创建：\n\n- 系统初始化\n- 正在运行的程序执行了创建进程的系统调用\n- 用户请求创建一个新的进程\n- 一个批处理作业的初始化\n\n\n\n> Unix系统，只有一个系统调用用于创建进程：fork。这个系统调用会创建一个与调用进程相同的副本。对于不可写的内存区是共享的；但对于可写的内存是不可以共享的，而是会进程写时复制，即当两者之一想要修改这部分数据时，则这块内存被明确的复制，以保证修改发生在私有区域。\n\n\n\n> Windows系统，使用CreateProcess函数创建进程，父子进程的地址空间一开始就是不同的。\n\n\n\n#### 3 进程的终止\n\n以下条件将引起进程的终止：\n\n- 正常退出（自愿）：`执行结束后由编译器执行一个系统调用（Unix系统：exit；Windows：ExitProcess）`\n- 出错退出（自愿）：`程序错误，例如除零`\n- 严重错误（非自愿）\n- 被其他进程杀死（非自愿）：`另外一个进程通过一个系统调用杀死该进程（Unix系统：kill；Windows系统：TerminateProcess）`\n\n\n\n#### 4 进程的层次结构\n\n- 对于Unix系统，进程和它的所有子进程以及后裔共同组成**进程组**；整个系统中，所有进程都属于以init为根的一棵树。\n\n- 对于Windows系统，没有层次的概念，所有的进程地位相同。\n\n\n\n#### 5 进程的状态\n\n三状态：\n\n- 就绪态\n- 运行态\n- 阻塞态。\n\n\n\n状态转换图如下：\n\n```\n就绪态 ----> 运行态 ----> 阻塞态\n  ^   <----               |\n  |                       |\n  -------------------------\n```\n\n\n\n#### 6 进程的实现\n\n操作系统维护了一张**进程表**，每个进程占用一个进程表项（也称**进程控制块**），其中包含了<u>程序计数器、堆栈指针、内存分配状况、所打开文件的转台、账号和调度信息，以及其他在进程由运行态装换到就绪态或阻塞态时必须保存的信息</u>。\n\n","slug":"操作系统-进程","published":1,"updated":"2021-03-18T16:56:38.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmf4b6ah0000qetl15j64mbp","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>进程是对正在运行程序的一种抽象，或者说是实例，它包括程序计数器、寄存器和变量的当前值。</p>\n<p>关于进程的一个重要思想：一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干个进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"2-进程的创建\"><a href=\"#2-进程的创建\" class=\"headerlink\" title=\"2 进程的创建\"></a>2 进程的创建</h4><p>有4种主要事件会导致进程的创建：</p>\n<ul>\n<li>系统初始化</li>\n<li>正在运行的程序执行了创建进程的系统调用</li>\n<li>用户请求创建一个新的进程</li>\n<li>一个批处理作业的初始化</li>\n</ul>\n<blockquote>\n<p>Unix系统，只有一个系统调用用于创建进程：fork。这个系统调用会创建一个与调用进程相同的副本。对于不可写的内存区是共享的；但对于可写的内存是不可以共享的，而是会进程写时复制，即当两者之一想要修改这部分数据时，则这块内存被明确的复制，以保证修改发生在私有区域。</p>\n</blockquote>\n<blockquote>\n<p>Windows系统，使用CreateProcess函数创建进程，父子进程的地址空间一开始就是不同的。</p>\n</blockquote>\n<h4 id=\"3-进程的终止\"><a href=\"#3-进程的终止\" class=\"headerlink\" title=\"3 进程的终止\"></a>3 进程的终止</h4><p>以下条件将引起进程的终止：</p>\n<ul>\n<li>正常退出（自愿）：<code>执行结束后由编译器执行一个系统调用（Unix系统：exit；Windows：ExitProcess）</code></li>\n<li>出错退出（自愿）：<code>程序错误，例如除零</code></li>\n<li>严重错误（非自愿）</li>\n<li>被其他进程杀死（非自愿）：<code>另外一个进程通过一个系统调用杀死该进程（Unix系统：kill；Windows系统：TerminateProcess）</code></li>\n</ul>\n<h4 id=\"4-进程的层次结构\"><a href=\"#4-进程的层次结构\" class=\"headerlink\" title=\"4 进程的层次结构\"></a>4 进程的层次结构</h4><ul>\n<li><p>对于Unix系统，进程和它的所有子进程以及后裔共同组成<strong>进程组</strong>；整个系统中，所有进程都属于以init为根的一棵树。</p>\n</li>\n<li><p>对于Windows系统，没有层次的概念，所有的进程地位相同。</p>\n</li>\n</ul>\n<h4 id=\"5-进程的状态\"><a href=\"#5-进程的状态\" class=\"headerlink\" title=\"5 进程的状态\"></a>5 进程的状态</h4><p>三状态：</p>\n<ul>\n<li>就绪态</li>\n<li>运行态</li>\n<li>阻塞态。</li>\n</ul>\n<p>状态转换图如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">就绪态 ----&gt; 运行态 ----&gt; 阻塞态</span><br><span class=\"line\">  ^   &lt;----               |</span><br><span class=\"line\">  |                       |</span><br><span class=\"line\">  -------------------------</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"6-进程的实现\"><a href=\"#6-进程的实现\" class=\"headerlink\" title=\"6 进程的实现\"></a>6 进程的实现</h4><p>操作系统维护了一张<strong>进程表</strong>，每个进程占用一个进程表项（也称<strong>进程控制块</strong>），其中包含了<u>程序计数器、堆栈指针、内存分配状况、所打开文件的转台、账号和调度信息，以及其他在进程由运行态装换到就绪态或阻塞态时必须保存的信息</u>。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>进程是对正在运行程序的一种抽象，或者说是实例，它包括程序计数器、寄存器和变量的当前值。</p>\n<p>关于进程的一个重要思想：一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干个进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p>","more":"<h4 id=\"2-进程的创建\"><a href=\"#2-进程的创建\" class=\"headerlink\" title=\"2 进程的创建\"></a>2 进程的创建</h4><p>有4种主要事件会导致进程的创建：</p>\n<ul>\n<li>系统初始化</li>\n<li>正在运行的程序执行了创建进程的系统调用</li>\n<li>用户请求创建一个新的进程</li>\n<li>一个批处理作业的初始化</li>\n</ul>\n<blockquote>\n<p>Unix系统，只有一个系统调用用于创建进程：fork。这个系统调用会创建一个与调用进程相同的副本。对于不可写的内存区是共享的；但对于可写的内存是不可以共享的，而是会进程写时复制，即当两者之一想要修改这部分数据时，则这块内存被明确的复制，以保证修改发生在私有区域。</p>\n</blockquote>\n<blockquote>\n<p>Windows系统，使用CreateProcess函数创建进程，父子进程的地址空间一开始就是不同的。</p>\n</blockquote>\n<h4 id=\"3-进程的终止\"><a href=\"#3-进程的终止\" class=\"headerlink\" title=\"3 进程的终止\"></a>3 进程的终止</h4><p>以下条件将引起进程的终止：</p>\n<ul>\n<li>正常退出（自愿）：<code>执行结束后由编译器执行一个系统调用（Unix系统：exit；Windows：ExitProcess）</code></li>\n<li>出错退出（自愿）：<code>程序错误，例如除零</code></li>\n<li>严重错误（非自愿）</li>\n<li>被其他进程杀死（非自愿）：<code>另外一个进程通过一个系统调用杀死该进程（Unix系统：kill；Windows系统：TerminateProcess）</code></li>\n</ul>\n<h4 id=\"4-进程的层次结构\"><a href=\"#4-进程的层次结构\" class=\"headerlink\" title=\"4 进程的层次结构\"></a>4 进程的层次结构</h4><ul>\n<li><p>对于Unix系统，进程和它的所有子进程以及后裔共同组成<strong>进程组</strong>；整个系统中，所有进程都属于以init为根的一棵树。</p>\n</li>\n<li><p>对于Windows系统，没有层次的概念，所有的进程地位相同。</p>\n</li>\n</ul>\n<h4 id=\"5-进程的状态\"><a href=\"#5-进程的状态\" class=\"headerlink\" title=\"5 进程的状态\"></a>5 进程的状态</h4><p>三状态：</p>\n<ul>\n<li>就绪态</li>\n<li>运行态</li>\n<li>阻塞态。</li>\n</ul>\n<p>状态转换图如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">就绪态 ----&gt; 运行态 ----&gt; 阻塞态</span><br><span class=\"line\">  ^   &lt;----               |</span><br><span class=\"line\">  |                       |</span><br><span class=\"line\">  -------------------------</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"6-进程的实现\"><a href=\"#6-进程的实现\" class=\"headerlink\" title=\"6 进程的实现\"></a>6 进程的实现</h4><p>操作系统维护了一张<strong>进程表</strong>，每个进程占用一个进程表项（也称<strong>进程控制块</strong>），其中包含了<u>程序计数器、堆栈指针、内存分配状况、所打开文件的转台、账号和调度信息，以及其他在进程由运行态装换到就绪态或阻塞态时必须保存的信息</u>。</p>"},{"title":"操作系统-线程","date":"2021-03-19T16:33:50.000Z","_content":"\n#### 1 简介\n\n既然已经有了进程，为什么还要引入线程呢？或者说使用线程有何优点？\n\n- 线程拥有共享一个地址空间和所有可用数据的能力；\n- 线程比进程更轻量级，所以它们比进程更容易、更快创建及撤销；\n- 线程对于存在着大量的计算和大量的I/O处理的活动，能重叠执行，加快应用程序执行速度，提升性能。（注：`多线程对于CPU密集型活动，并不能获得性能上的提升`）\n\n<!--more-->\n\n进程拥有一个执行的线程，线程拥有：\n\n- 程序计数器：用于记录接着要执行的指令；\n- 寄存器：用于保存线程当前的工作变量（局部变量以及过程调用之后使用的返回地址）；\n- 堆栈：用于记录执行历史，其中每一帧保存了一个一调用，但还未从中返回的过程；\n- 状态：与进程一直，有运行、阻塞、就绪、终止状态。状态间的转换和进程一致。\n\n\n\n注：`进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。`\n\n\n\n#### 2 多线程\n\n在多线程的情况下，进程通常会从当前的单个线程开始。常见的线程调用如下：\n\n- 创建：这个线程有能力通过调用一个系统函数创建新线程（如：thread_create）。创建线程通常都会返回一个线程标识符，该标识符就是线程的名称。注：`线程间通常是平等的，不存在父子关系（特殊情况除外）。`\n- 退出：当一个线程执行完成后，可以通过调用一个库函数（如：thread_exit）退出。退出的线程不再被调度。\n- 等待其他线程：有时会需要等待其他线程退出，此时可通过调用一个库函数（如：thread_join）等待。此时当前线程将被阻塞，直到另一个线程退出。\n- 让出CPU：线程无法像进程一样通过时钟中断方式强制让出CPU，而某些场景下一个线程运行时间足够长，需要让另外一个线程执行，再进程操作。所以系统提供一个库函数（如：thread_yield）。\n\n\n\n#### 3 线程的实现\n\n线程的实现主要有两种方式：`在用户空间中实现`和在`内核中实现`。\n\n为了实现可移植的线程程序，IEEE在IEEE标准1003.1c中定义了线程的标准。它定义的线程包叫做pthread。大部分UNIX系统都支持该标准。\n\n##### 3.1 用户空间中实现线程\n\n在用户空间中实现线程，就是把整个线程包放在用户空间中，内核对线程包一无所知，即从内核的角度，就是按照正常的单线程进程管理方式。用户空间实现线程时，<u>每个进程需要有其专用的线程表</u>，用于跟踪进程中的线程。\n\n优点：\n\n- 用户级线程可以在不支持线程的操作系统上实现；\n- 线程的切换不需要陷入内核，无需上下文切换，也无需对内存高速缓存进行刷新，使得线程的调度更加快捷；\n- 用户级线程允许每个进程有自己定制的调度算法，拥有较好的可扩展性；\n\n\n\n不足：\n\n- 实现阻塞系统调用问题；\n- 缺页中断问题；\n- 从内核角度看，是按单线程进程管理的，即若一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。\n\n\n\n##### 3.2 内核中实现线程\n\n内核中实现线程，由<u>内核记录系统中所有线程的线程表</u>。当某个线程希望创建一个新线程或者撤销一个已有线程时，他进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。\n\n所有线程的调用都以系统调用形式实现，相比用户空间实现，代价更大。有些系统采用“环保”的处理方式，即回收线程。具体过程为：当一个线程被撤销时，就把它标记为不可运行，但其内核数据结构并没有受到影响，在后续需要创建新线程时，重启某个旧线程，从而节省一些开支。\n\n\n\n##### 3.3 混合实现\n\n使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/操作系统-线程.md","raw":"---\ntitle: 操作系统-线程\ndate: 2021-03-20 00:33:50\ntags: [\"操作系统\",\"线程\", \"现代操作系统\"]\ncategories: [\"操作系统\",\"线程\", \"Note\"]\n---\n\n#### 1 简介\n\n既然已经有了进程，为什么还要引入线程呢？或者说使用线程有何优点？\n\n- 线程拥有共享一个地址空间和所有可用数据的能力；\n- 线程比进程更轻量级，所以它们比进程更容易、更快创建及撤销；\n- 线程对于存在着大量的计算和大量的I/O处理的活动，能重叠执行，加快应用程序执行速度，提升性能。（注：`多线程对于CPU密集型活动，并不能获得性能上的提升`）\n\n<!--more-->\n\n进程拥有一个执行的线程，线程拥有：\n\n- 程序计数器：用于记录接着要执行的指令；\n- 寄存器：用于保存线程当前的工作变量（局部变量以及过程调用之后使用的返回地址）；\n- 堆栈：用于记录执行历史，其中每一帧保存了一个一调用，但还未从中返回的过程；\n- 状态：与进程一直，有运行、阻塞、就绪、终止状态。状态间的转换和进程一致。\n\n\n\n注：`进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。`\n\n\n\n#### 2 多线程\n\n在多线程的情况下，进程通常会从当前的单个线程开始。常见的线程调用如下：\n\n- 创建：这个线程有能力通过调用一个系统函数创建新线程（如：thread_create）。创建线程通常都会返回一个线程标识符，该标识符就是线程的名称。注：`线程间通常是平等的，不存在父子关系（特殊情况除外）。`\n- 退出：当一个线程执行完成后，可以通过调用一个库函数（如：thread_exit）退出。退出的线程不再被调度。\n- 等待其他线程：有时会需要等待其他线程退出，此时可通过调用一个库函数（如：thread_join）等待。此时当前线程将被阻塞，直到另一个线程退出。\n- 让出CPU：线程无法像进程一样通过时钟中断方式强制让出CPU，而某些场景下一个线程运行时间足够长，需要让另外一个线程执行，再进程操作。所以系统提供一个库函数（如：thread_yield）。\n\n\n\n#### 3 线程的实现\n\n线程的实现主要有两种方式：`在用户空间中实现`和在`内核中实现`。\n\n为了实现可移植的线程程序，IEEE在IEEE标准1003.1c中定义了线程的标准。它定义的线程包叫做pthread。大部分UNIX系统都支持该标准。\n\n##### 3.1 用户空间中实现线程\n\n在用户空间中实现线程，就是把整个线程包放在用户空间中，内核对线程包一无所知，即从内核的角度，就是按照正常的单线程进程管理方式。用户空间实现线程时，<u>每个进程需要有其专用的线程表</u>，用于跟踪进程中的线程。\n\n优点：\n\n- 用户级线程可以在不支持线程的操作系统上实现；\n- 线程的切换不需要陷入内核，无需上下文切换，也无需对内存高速缓存进行刷新，使得线程的调度更加快捷；\n- 用户级线程允许每个进程有自己定制的调度算法，拥有较好的可扩展性；\n\n\n\n不足：\n\n- 实现阻塞系统调用问题；\n- 缺页中断问题；\n- 从内核角度看，是按单线程进程管理的，即若一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。\n\n\n\n##### 3.2 内核中实现线程\n\n内核中实现线程，由<u>内核记录系统中所有线程的线程表</u>。当某个线程希望创建一个新线程或者撤销一个已有线程时，他进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。\n\n所有线程的调用都以系统调用形式实现，相比用户空间实现，代价更大。有些系统采用“环保”的处理方式，即回收线程。具体过程为：当一个线程被撤销时，就把它标记为不可运行，但其内核数据结构并没有受到影响，在后续需要创建新线程时，重启某个旧线程，从而节省一些开支。\n\n\n\n##### 3.3 混合实现\n\n使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"操作系统-线程","published":1,"updated":"2021-03-21T15:48:32.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmjc5he90000g5tlbwfv6ks1","content":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>既然已经有了进程，为什么还要引入线程呢？或者说使用线程有何优点？</p>\n<ul>\n<li>线程拥有共享一个地址空间和所有可用数据的能力；</li>\n<li>线程比进程更轻量级，所以它们比进程更容易、更快创建及撤销；</li>\n<li>线程对于存在着大量的计算和大量的I/O处理的活动，能重叠执行，加快应用程序执行速度，提升性能。（注：<code>多线程对于CPU密集型活动，并不能获得性能上的提升</code>）</li>\n</ul>\n<a id=\"more\"></a>\n\n<p>进程拥有一个执行的线程，线程拥有：</p>\n<ul>\n<li>程序计数器：用于记录接着要执行的指令；</li>\n<li>寄存器：用于保存线程当前的工作变量（局部变量以及过程调用之后使用的返回地址）；</li>\n<li>堆栈：用于记录执行历史，其中每一帧保存了一个一调用，但还未从中返回的过程；</li>\n<li>状态：与进程一直，有运行、阻塞、就绪、终止状态。状态间的转换和进程一致。</li>\n</ul>\n<p>注：<code>进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。</code></p>\n<h4 id=\"2-多线程\"><a href=\"#2-多线程\" class=\"headerlink\" title=\"2 多线程\"></a>2 多线程</h4><p>在多线程的情况下，进程通常会从当前的单个线程开始。常见的线程调用如下：</p>\n<ul>\n<li>创建：这个线程有能力通过调用一个系统函数创建新线程（如：thread_create）。创建线程通常都会返回一个线程标识符，该标识符就是线程的名称。注：<code>线程间通常是平等的，不存在父子关系（特殊情况除外）。</code></li>\n<li>退出：当一个线程执行完成后，可以通过调用一个库函数（如：thread_exit）退出。退出的线程不再被调度。</li>\n<li>等待其他线程：有时会需要等待其他线程退出，此时可通过调用一个库函数（如：thread_join）等待。此时当前线程将被阻塞，直到另一个线程退出。</li>\n<li>让出CPU：线程无法像进程一样通过时钟中断方式强制让出CPU，而某些场景下一个线程运行时间足够长，需要让另外一个线程执行，再进程操作。所以系统提供一个库函数（如：thread_yield）。</li>\n</ul>\n<h4 id=\"3-线程的实现\"><a href=\"#3-线程的实现\" class=\"headerlink\" title=\"3 线程的实现\"></a>3 线程的实现</h4><p>线程的实现主要有两种方式：<code>在用户空间中实现</code>和在<code>内核中实现</code>。</p>\n<p>为了实现可移植的线程程序，IEEE在IEEE标准1003.1c中定义了线程的标准。它定义的线程包叫做pthread。大部分UNIX系统都支持该标准。</p>\n<h5 id=\"3-1-用户空间中实现线程\"><a href=\"#3-1-用户空间中实现线程\" class=\"headerlink\" title=\"3.1 用户空间中实现线程\"></a>3.1 用户空间中实现线程</h5><p>在用户空间中实现线程，就是把整个线程包放在用户空间中，内核对线程包一无所知，即从内核的角度，就是按照正常的单线程进程管理方式。用户空间实现线程时，<u>每个进程需要有其专用的线程表</u>，用于跟踪进程中的线程。</p>\n<p>优点：</p>\n<ul>\n<li>用户级线程可以在不支持线程的操作系统上实现；</li>\n<li>线程的切换不需要陷入内核，无需上下文切换，也无需对内存高速缓存进行刷新，使得线程的调度更加快捷；</li>\n<li>用户级线程允许每个进程有自己定制的调度算法，拥有较好的可扩展性；</li>\n</ul>\n<p>不足：</p>\n<ul>\n<li>实现阻塞系统调用问题；</li>\n<li>缺页中断问题；</li>\n<li>从内核角度看，是按单线程进程管理的，即若一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。</li>\n</ul>\n<h5 id=\"3-2-内核中实现线程\"><a href=\"#3-2-内核中实现线程\" class=\"headerlink\" title=\"3.2 内核中实现线程\"></a>3.2 内核中实现线程</h5><p>内核中实现线程，由<u>内核记录系统中所有线程的线程表</u>。当某个线程希望创建一个新线程或者撤销一个已有线程时，他进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。</p>\n<p>所有线程的调用都以系统调用形式实现，相比用户空间实现，代价更大。有些系统采用“环保”的处理方式，即回收线程。具体过程为：当一个线程被撤销时，就把它标记为不可运行，但其内核数据结构并没有受到影响，在后续需要创建新线程时，重启某个旧线程，从而节省一些开支。</p>\n<h5 id=\"3-3-混合实现\"><a href=\"#3-3-混合实现\" class=\"headerlink\" title=\"3.3 混合实现\"></a>3.3 混合实现</h5><p>使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h4><p>既然已经有了进程，为什么还要引入线程呢？或者说使用线程有何优点？</p>\n<ul>\n<li>线程拥有共享一个地址空间和所有可用数据的能力；</li>\n<li>线程比进程更轻量级，所以它们比进程更容易、更快创建及撤销；</li>\n<li>线程对于存在着大量的计算和大量的I/O处理的活动，能重叠执行，加快应用程序执行速度，提升性能。（注：<code>多线程对于CPU密集型活动，并不能获得性能上的提升</code>）</li>\n</ul>","more":"<p>进程拥有一个执行的线程，线程拥有：</p>\n<ul>\n<li>程序计数器：用于记录接着要执行的指令；</li>\n<li>寄存器：用于保存线程当前的工作变量（局部变量以及过程调用之后使用的返回地址）；</li>\n<li>堆栈：用于记录执行历史，其中每一帧保存了一个一调用，但还未从中返回的过程；</li>\n<li>状态：与进程一直，有运行、阻塞、就绪、终止状态。状态间的转换和进程一致。</li>\n</ul>\n<p>注：<code>进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。</code></p>\n<h4 id=\"2-多线程\"><a href=\"#2-多线程\" class=\"headerlink\" title=\"2 多线程\"></a>2 多线程</h4><p>在多线程的情况下，进程通常会从当前的单个线程开始。常见的线程调用如下：</p>\n<ul>\n<li>创建：这个线程有能力通过调用一个系统函数创建新线程（如：thread_create）。创建线程通常都会返回一个线程标识符，该标识符就是线程的名称。注：<code>线程间通常是平等的，不存在父子关系（特殊情况除外）。</code></li>\n<li>退出：当一个线程执行完成后，可以通过调用一个库函数（如：thread_exit）退出。退出的线程不再被调度。</li>\n<li>等待其他线程：有时会需要等待其他线程退出，此时可通过调用一个库函数（如：thread_join）等待。此时当前线程将被阻塞，直到另一个线程退出。</li>\n<li>让出CPU：线程无法像进程一样通过时钟中断方式强制让出CPU，而某些场景下一个线程运行时间足够长，需要让另外一个线程执行，再进程操作。所以系统提供一个库函数（如：thread_yield）。</li>\n</ul>\n<h4 id=\"3-线程的实现\"><a href=\"#3-线程的实现\" class=\"headerlink\" title=\"3 线程的实现\"></a>3 线程的实现</h4><p>线程的实现主要有两种方式：<code>在用户空间中实现</code>和在<code>内核中实现</code>。</p>\n<p>为了实现可移植的线程程序，IEEE在IEEE标准1003.1c中定义了线程的标准。它定义的线程包叫做pthread。大部分UNIX系统都支持该标准。</p>\n<h5 id=\"3-1-用户空间中实现线程\"><a href=\"#3-1-用户空间中实现线程\" class=\"headerlink\" title=\"3.1 用户空间中实现线程\"></a>3.1 用户空间中实现线程</h5><p>在用户空间中实现线程，就是把整个线程包放在用户空间中，内核对线程包一无所知，即从内核的角度，就是按照正常的单线程进程管理方式。用户空间实现线程时，<u>每个进程需要有其专用的线程表</u>，用于跟踪进程中的线程。</p>\n<p>优点：</p>\n<ul>\n<li>用户级线程可以在不支持线程的操作系统上实现；</li>\n<li>线程的切换不需要陷入内核，无需上下文切换，也无需对内存高速缓存进行刷新，使得线程的调度更加快捷；</li>\n<li>用户级线程允许每个进程有自己定制的调度算法，拥有较好的可扩展性；</li>\n</ul>\n<p>不足：</p>\n<ul>\n<li>实现阻塞系统调用问题；</li>\n<li>缺页中断问题；</li>\n<li>从内核角度看，是按单线程进程管理的，即若一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。</li>\n</ul>\n<h5 id=\"3-2-内核中实现线程\"><a href=\"#3-2-内核中实现线程\" class=\"headerlink\" title=\"3.2 内核中实现线程\"></a>3.2 内核中实现线程</h5><p>内核中实现线程，由<u>内核记录系统中所有线程的线程表</u>。当某个线程希望创建一个新线程或者撤销一个已有线程时，他进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。</p>\n<p>所有线程的调用都以系统调用形式实现，相比用户空间实现，代价更大。有些系统采用“环保”的处理方式，即回收线程。具体过程为：当一个线程被撤销时，就把它标记为不可运行，但其内核数据结构并没有受到影响，在后续需要创建新线程时，重启某个旧线程，从而节省一些开支。</p>\n<h5 id=\"3-3-混合实现\"><a href=\"#3-3-混合实现\" class=\"headerlink\" title=\"3.3 混合实现\"></a>3.3 混合实现</h5><p>使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckfgoabin000145g3cxf6gz6j","category_id":"ckfgoabis000445g3beng43ot","_id":"ckfgoabj2000g45g38s6rcfly"},{"post_id":"ckfgoabir000345g3a7vo2uxg","category_id":"ckfgoabis000445g3beng43ot","_id":"ckfgoabj3000i45g3bvm0dm1i"},{"post_id":"ckfgoabj1000e45g32q3fhgf6","category_id":"ckfgoabj7000o45g3hsjcdykp","_id":"ckfgoabja000y45g36eeofaqo"},{"post_id":"ckfgoabiu000745g3hrype88h","category_id":"ckfgoabj2000f45g3fktxhv7n","_id":"ckfgoabjb001245g33hy50g64"},{"post_id":"ckfgoabiw000845g38c8ch3lo","category_id":"ckfgoabj2000f45g3fktxhv7n","_id":"ckfgoabjc001745g37yfv24ln"},{"post_id":"ckfgoabix000945g3godr1xz5","category_id":"ckfgoabj2000f45g3fktxhv7n","_id":"ckfgoabjd001c45g3b8ac6xzp"},{"post_id":"ckfgoabj0000d45g30fk267j5","category_id":"ckfgoabj7000o45g3hsjcdykp","_id":"ckfgoabje001g45g35luufyw3"},{"post_id":"ckfgoabj0000d45g30fk267j5","category_id":"ckfgoabjc001845g3e6psajoj","_id":"ckfgoabje001i45g3gje2hvrj"},{"post_id":"ckfgoabkb001m45g37sq76vsx","category_id":"ckfgoabj7000o45g3hsjcdykp","_id":"ckfgoabkf001s45g316cl0q4z"},{"post_id":"ckfgoabkc001n45g3fzxgact4","category_id":"ckfgoabj7000o45g3hsjcdykp","_id":"ckfgoabkh001v45g36ei0fkkw"},{"post_id":"ckfgoabkd001p45g3hpq40qgo","category_id":"ckfgoabj7000o45g3hsjcdykp","_id":"ckfgoabkj001z45g3bkpe0yi9"},{"post_id":"ckfgoabke001r45g39y9s4gao","category_id":"ckfgoabki001w45g3hrk58osp","_id":"ckfgoabko002745g3g36a4nqx"},{"post_id":"ckfgoabkh001u45g302329a65","category_id":"ckfgoabkl002245g356xoe9xw","_id":"ckfgoabkr002e45g3htzvd0kv"},{"post_id":"ckfgoabkp002a45g3gcrg6ab4","category_id":"ckfgoabki001w45g3hrk58osp","_id":"ckfgoabkv002k45g3bs02ew8p"},{"post_id":"ckfgoabki001y45g3432v2g2q","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabkx002o45g32myz8c9w"},{"post_id":"ckfgoabkl002145g3cgjkcsyb","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabl1002y45g32nwt6njv"},{"post_id":"ckfgoabkm002545g3gle12rfq","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabl4003345g317ymfuqc"},{"post_id":"ckfgoabkn002645g301gyg9ep","category_id":"ckfgoabki001w45g3hrk58osp","_id":"ckfgoabl9003845g3am013lkm"},{"post_id":"ckfgoabkn002645g301gyg9ep","category_id":"ckfgoabl1002x45g3glsdd15i","_id":"ckfgoablb003b45g3gg1v0gp6"},{"post_id":"ckfgoabkq002c45g33a3mhoay","category_id":"ckfgoabl4003445g3bhk8dny4","_id":"ckfgoablb003d45g3d26k0gd7"},{"post_id":"ckfgoabks002h45g373ts8rvr","category_id":"ckfgoabl9003945g3bfs03ljy","_id":"ckfgoabld003h45g3gbn70h7v"},{"post_id":"ckfgoabkk002045g3hjoleh4l","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoablg003l45g3adr7alpw"},{"post_id":"ckfgoabkk002045g3hjoleh4l","category_id":"ckfgoablb003f45g32gnr8qon","_id":"ckfgoablh003n45g36yx6a256"},{"post_id":"ckfgoabkv002j45g3c6wv3cyl","category_id":"ckfgoabl9003945g3bfs03ljy","_id":"ckfgoabli003q45g39taxhxuq"},{"post_id":"ckfgoabkw002n45g3c2d1epwx","category_id":"ckfgoabl9003945g3bfs03ljy","_id":"ckfgoablj003u45g3du7g8ffa"},{"post_id":"ckfgoabky002q45g3dmymg1en","category_id":"ckfgoabli003p45g3dyia87to","_id":"ckfgoabll004045g34b8ahop7"},{"post_id":"ckfgoabl3003245g303sz6nx8","category_id":"ckfgoablr004645g3394d7bp3","_id":"ckfgoabm3004c45g3hyjhhvm9"},{"post_id":"ckfgoabl4003645g3ghce4v53","category_id":"ckfgoabl9003945g3bfs03ljy","_id":"ckfgoabm4004g45g37fi0cqn9"},{"post_id":"ckfgoabkz002u45g37pgm04fj","category_id":"ckfgoablj003w45g3dlrhcyxv","_id":"ckfgoabm6004k45g3gg6t4s81"},{"post_id":"ckfgoabkz002u45g37pgm04fj","category_id":"ckfgoabm3004b45g3eahkcb2c","_id":"ckfgoabm8004m45g3ap1yhavy"},{"post_id":"ckfgoabl0002w45g3d5osfmen","category_id":"ckfgoablj003w45g3dlrhcyxv","_id":"ckfgoabm8004o45g303mt59m3"},{"post_id":"ckfgoabl0002w45g3d5osfmen","category_id":"ckfgoabm3004b45g3eahkcb2c","_id":"ckfgoabm8004r45g312wocpgr"},{"post_id":"ckfgoabl1002z45g39mg8h8le","category_id":"ckfgoablj003w45g3dlrhcyxv","_id":"ckfgoabma004t45g3g8je1lye"},{"post_id":"ckfgoabl1002z45g39mg8h8le","category_id":"ckfgoabm3004b45g3eahkcb2c","_id":"ckfgoabmb004v45g3916sfvk5"},{"post_id":"ckfgoabmv005u45g369w2euj9","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabn2006045g3d6mqcosi"},{"post_id":"ckfgoabmw005v45g34qnvddp8","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabn4006445g3facv9c83"},{"post_id":"ckfgoabmw005v45g34qnvddp8","category_id":"ckfgoablb003f45g32gnr8qon","_id":"ckfgoabn7006745g32a0xe0o6"},{"post_id":"ckfgoabmz005x45g3a6gi9z9i","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabna006b45g3712pdj4j"},{"post_id":"ckfgoabn1005z45g3dai026jk","category_id":"ckfgoabki001w45g3hrk58osp","_id":"ckfgoabnf006e45g382jv66zq"},{"post_id":"ckfgoabn3006345g34nhy5upt","category_id":"ckfgoabki001w45g3hrk58osp","_id":"ckfgoabo3006i45g311quf4i9"},{"post_id":"ckfgoabn5006645g3he0hb4zo","category_id":"ckfgoabki001w45g3hrk58osp","_id":"ckfgoabo5006l45g35dp40h1u"},{"post_id":"ckfgoabn7006945g3eoff7nnz","category_id":"ckfgoabki001w45g3hrk58osp","_id":"ckfgoabo7006o45g37ux4ech6"},{"post_id":"ckfgoabna006d45g369wshumf","category_id":"ckfgoabl9003945g3bfs03ljy","_id":"ckfgoabo9006s45g3bi1oesx6"},{"post_id":"ckfgoabng006g45g3g64f5s7g","category_id":"ckfgoabl9003945g3bfs03ljy","_id":"ckfgoabob006w45g38hvhdnep"},{"post_id":"ckfgoabo4006k45g3cmon9eaz","category_id":"ckfgoablj003w45g3dlrhcyxv","_id":"ckfgoaboc006y45g3arih6iiy"},{"post_id":"ckfgoabo4006k45g3cmon9eaz","category_id":"ckfgoabm3004b45g3eahkcb2c","_id":"ckfgoabof007145g3gctabh7l"},{"post_id":"ckfgoabo5006n45g3delg7512","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabol007e45g3b6rae3us"},{"post_id":"ckfgoabo5006n45g3delg7512","category_id":"ckfgoabob006v45g32nle6ilk","_id":"ckfgoabol007g45g39pohav4b"},{"post_id":"ckfgoabo5006n45g3delg7512","category_id":"ckfgoaboj007745g38l2n9m6z","_id":"ckfgoabom007i45g37d3bgtjm"},{"post_id":"ckfgoabo8006r45g33etl6yq5","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabom007k45g34lyc5o0u"},{"post_id":"ckfgoabo8006r45g33etl6yq5","category_id":"ckfgoabob006v45g32nle6ilk","_id":"ckfgoabon007m45g35mbff2e3"},{"post_id":"ckfgoabo8006r45g33etl6yq5","category_id":"ckfgoaboj007745g38l2n9m6z","_id":"ckfgoabon007o45g30max05sd"},{"post_id":"ckfgoabo9006u45g33ofy81py","category_id":"ckfgoabko002845g32wcr0i0j","_id":"ckfgoabon007q45g32nz7bl28"},{"post_id":"ckfgoabo9006u45g33ofy81py","category_id":"ckfgoabob006v45g32nle6ilk","_id":"ckfgoabon007r45g32td4a942"},{"post_id":"ckfgoabo9006u45g33ofy81py","category_id":"ckfgoaboj007745g38l2n9m6z","_id":"ckfgoabon007s45g39kqi6rc3"},{"post_id":"ckfi1xptk0000qbg3bou775yk","category_id":"ckfgoabj2000f45g3fktxhv7n","_id":"ckfi1xpug0002qbg3gjay2tg4"},{"post_id":"ckfjv880w00012svtgqukhd4w","category_id":"ckfjv881f00042svt8u2s1fi9","_id":"ckfjv881h00082svteoyyfzze"},{"post_id":"ckfkxsgte0000peg33dbw1sa1","category_id":"ckfjv880y00022svthri1c2x6","_id":"ckfkxsgth0003peg34sc0fi6g"},{"post_id":"ckfme10yg00003rg30a1t84ra","category_id":"ckfgoabj2000f45g3fktxhv7n","_id":"ckfme112a00023rg3aflkfcx8"},{"post_id":"ckfnsf8cc0000gyg3dscscp57","category_id":"ckfgoabj2000f45g3fktxhv7n","_id":"ckfnsf8cz0002gyg36r0x8egm"},{"post_id":"ckgb0887o00001hvt6yjj15vk","category_id":"ckfgoabki001w45g3hrk58osp","_id":"ckgb0888k00051hvthptkdltv"},{"post_id":"ckgb0887o00001hvt6yjj15vk","category_id":"ckgb0888h00021hvt7icra4cx","_id":"ckgb0888k00061hvtftnv99gp"},{"post_id":"ckmf4b6ah0000qetl15j64mbp","category_id":"ckmf4b6an0001qetl4jeh1af6","_id":"ckmf4b6b2000aqetl0nkg2a02"},{"post_id":"ckmf4b6ah0000qetl15j64mbp","category_id":"ckmf4b6az0004qetl8pcg4lbg","_id":"ckmf4b6b2000bqetl1eq2giui"},{"post_id":"ckmf4b6ah0000qetl15j64mbp","category_id":"ckmf4b6b00006qetl2did495e","_id":"ckmf4b6b2000cqetl6ekogr7o"},{"post_id":"ckmjc5he90000g5tlbwfv6ks1","category_id":"ckmf4b6an0001qetl4jeh1af6","_id":"ckmjc5heu0007g5tl8hxwbx37"},{"post_id":"ckmjc5he90000g5tlbwfv6ks1","category_id":"ckmjc5hes0002g5tlcf6le7au","_id":"ckmjc5heu0008g5tlbzm9f49l"},{"post_id":"ckmjc5he90000g5tlbwfv6ks1","category_id":"ckmjc5het0004g5tl1wjf9p9e","_id":"ckmjc5heu0009g5tla3j33zgr"}],"PostTag":[{"post_id":"ckfgoabin000145g3cxf6gz6j","tag_id":"ckfgoabit000545g307ry62ki","_id":"ckfgoabj0000c45g333nvh4b3"},{"post_id":"ckfgoabir000345g3a7vo2uxg","tag_id":"ckfgoabit000545g307ry62ki","_id":"ckfgoabj7000n45g33ou8g10r"},{"post_id":"ckfgoabir000345g3a7vo2uxg","tag_id":"ckfgoabj2000h45g329ag8cod","_id":"ckfgoabj7000p45g32r3m1gb7"},{"post_id":"ckfgoabir000345g3a7vo2uxg","tag_id":"ckfgoabj4000k45g35tfnd9qk","_id":"ckfgoabj8000r45g35g83894d"},{"post_id":"ckfgoabiu000745g3hrype88h","tag_id":"ckfgoabj6000m45g33lnv76ob","_id":"ckfgoabj9000u45g36laj33uz"},{"post_id":"ckfgoabiu000745g3hrype88h","tag_id":"ckfgoabj7000q45g3cqymfcpa","_id":"ckfgoabj9000w45g38bsh5dgb"},{"post_id":"ckfgoabiw000845g38c8ch3lo","tag_id":"ckfgoabj6000m45g33lnv76ob","_id":"ckfgoabjb001145g37r8e8u2q"},{"post_id":"ckfgoabiw000845g38c8ch3lo","tag_id":"ckfgoabj9000x45g3blk9863z","_id":"ckfgoabjb001445g36ct7759w"},{"post_id":"ckfgoabix000945g3godr1xz5","tag_id":"ckfgoabj6000m45g33lnv76ob","_id":"ckfgoabjd001b45g32mj67u06"},{"post_id":"ckfgoabix000945g3godr1xz5","tag_id":"ckfgoabjb001545g3fskagx0h","_id":"ckfgoabjd001d45g32nf22lvl"},{"post_id":"ckfgoabj0000d45g30fk267j5","tag_id":"ckfgoabjc001945g318tm3i85","_id":"ckfgoabjf001j45g38hid1lvt"},{"post_id":"ckfgoabj0000d45g30fk267j5","tag_id":"ckfgoabjd001e45g381fn2gur","_id":"ckfgoabjf001k45g33t8ffz62"},{"post_id":"ckfgoabj1000e45g32q3fhgf6","tag_id":"ckfgoabjc001945g318tm3i85","_id":"ckfgoabjf001l45g33jild01v"},{"post_id":"ckfgoabkb001m45g37sq76vsx","tag_id":"ckfgoabjc001945g318tm3i85","_id":"ckfgoabkd001o45g38y8yhdig"},{"post_id":"ckfgoabkc001n45g3fzxgact4","tag_id":"ckfgoabjc001945g318tm3i85","_id":"ckfgoabke001q45g34k6sg0yy"},{"post_id":"ckfgoabkd001p45g3hpq40qgo","tag_id":"ckfgoabjc001945g318tm3i85","_id":"ckfgoabkg001t45g3cmnk2guq"},{"post_id":"ckfgoabke001r45g39y9s4gao","tag_id":"ckfgoabki001x45g3f0cs69qy","_id":"ckfgoabkm002445g31u3ib9g8"},{"post_id":"ckfgoabkh001u45g302329a65","tag_id":"ckfgoabkl002345g360yk3x93","_id":"ckfgoabkq002b45g33a5i0rur"},{"post_id":"ckfgoabkh001u45g302329a65","tag_id":"ckfgoabj4000k45g35tfnd9qk","_id":"ckfgoabkr002d45g36t794or2"},{"post_id":"ckfgoabkp002a45g3gcrg6ab4","tag_id":"ckfgoabki001x45g3f0cs69qy","_id":"ckfgoabku002i45g37czi0xp5"},{"post_id":"ckfgoabki001y45g3432v2g2q","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoabky002p45g33jdv2vxl"},{"post_id":"ckfgoabki001y45g3432v2g2q","tag_id":"ckfgoabkr002g45g3ekeu0ww0","_id":"ckfgoabkz002s45g34xci097m"},{"post_id":"ckfgoabki001y45g3432v2g2q","tag_id":"ckfgoabj4000k45g35tfnd9qk","_id":"ckfgoabl0002v45g37xxxdrs5"},{"post_id":"ckfgoabkk002045g3hjoleh4l","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoabl3003145g34j8p14sn"},{"post_id":"ckfgoabkk002045g3hjoleh4l","tag_id":"ckfgoabkz002t45g3a2ou4leb","_id":"ckfgoabl4003545g30el38h5h"},{"post_id":"ckfgoabkl002145g3cgjkcsyb","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoablb003c45g3c16f7a92"},{"post_id":"ckfgoabkl002145g3cgjkcsyb","tag_id":"ckfgoabl5003745g3ad6tbwro","_id":"ckfgoablb003e45g38xxaa15b"},{"post_id":"ckfgoabkm002545g3gle12rfq","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoabli003o45g31qfh9woe"},{"post_id":"ckfgoabkm002545g3gle12rfq","tag_id":"ckfgoablc003g45g3holt1yi2","_id":"ckfgoabli003r45g3fts9aanj"},{"post_id":"ckfgoabkm002545g3gle12rfq","tag_id":"ckfgoable003j45g3du503f9c","_id":"ckfgoablj003t45g336lb47b2"},{"post_id":"ckfgoabkn002645g301gyg9ep","tag_id":"ckfgoabki001x45g3f0cs69qy","_id":"ckfgoablj003v45g395end0o0"},{"post_id":"ckfgoabkn002645g301gyg9ep","tag_id":"ckfgoablh003m45g3gd7a98o4","_id":"ckfgoablk003y45g3cwreg6b4"},{"post_id":"ckfgoabkq002c45g33a3mhoay","tag_id":"ckfgoablj003s45g3beeug1x5","_id":"ckfgoabll003z45g3f48c5yza"},{"post_id":"ckfgoabks002h45g373ts8rvr","tag_id":"ckfgoablk003x45g39ar5f30g","_id":"ckfgoabln004345g31x2ndvvi"},{"post_id":"ckfgoabkv002j45g3c6wv3cyl","tag_id":"ckfgoablk003x45g39ar5f30g","_id":"ckfgoabm3004a45g380x4dkr3"},{"post_id":"ckfgoabkv002j45g3c6wv3cyl","tag_id":"ckfgoablo004545g335js2u6g","_id":"ckfgoabm4004d45g39k8s5nkc"},{"post_id":"ckfgoabkv002j45g3c6wv3cyl","tag_id":"ckfgoablz004745g34f5vhoyq","_id":"ckfgoabm4004f45g33hkp2a8w"},{"post_id":"ckfgoabkw002n45g3c2d1epwx","tag_id":"ckfgoablk003x45g39ar5f30g","_id":"ckfgoabm8004n45g38xiqaws8"},{"post_id":"ckfgoabkw002n45g3c2d1epwx","tag_id":"ckfgoablo004545g335js2u6g","_id":"ckfgoabm8004p45g38tpi2q5m"},{"post_id":"ckfgoabkw002n45g3c2d1epwx","tag_id":"ckfgoablz004745g34f5vhoyq","_id":"ckfgoabm8004s45g352ah6r3a"},{"post_id":"ckfgoabky002q45g3dmymg1en","tag_id":"ckfgoabm7004l45g3ai991luz","_id":"ckfgoabma004u45g34m48ftot"},{"post_id":"ckfgoabky002q45g3dmymg1en","tag_id":"ckfgoabj4000k45g35tfnd9qk","_id":"ckfgoabmd004x45g3dn9352el"},{"post_id":"ckfgoabkz002u45g37pgm04fj","tag_id":"ckfgoabm8004q45g3h9y80yt0","_id":"ckfgoabmf005045g33snj0pa0"},{"post_id":"ckfgoabkz002u45g37pgm04fj","tag_id":"ckfgoabmb004w45g39ayz6kjw","_id":"ckfgoabmf005145g3bw2h9bod"},{"post_id":"ckfgoabkz002u45g37pgm04fj","tag_id":"ckfgoabme004y45g34pqsf3ju","_id":"ckfgoabmf005345g3b2ai1xrx"},{"post_id":"ckfgoabl0002w45g3d5osfmen","tag_id":"ckfgoabm8004q45g3h9y80yt0","_id":"ckfgoabmh005645g35h2xctze"},{"post_id":"ckfgoabl0002w45g3d5osfmen","tag_id":"ckfgoabmb004w45g39ayz6kjw","_id":"ckfgoabmh005745g3g3a5a5ru"},{"post_id":"ckfgoabl0002w45g3d5osfmen","tag_id":"ckfgoabmg005445g34asmgb91","_id":"ckfgoabmh005945g3ak04d2qn"},{"post_id":"ckfgoabl1002z45g39mg8h8le","tag_id":"ckfgoabm8004q45g3h9y80yt0","_id":"ckfgoabmi005c45g3as5fdx4l"},{"post_id":"ckfgoabl1002z45g39mg8h8le","tag_id":"ckfgoabmb004w45g39ayz6kjw","_id":"ckfgoabmi005d45g392okdyk2"},{"post_id":"ckfgoabl1002z45g39mg8h8le","tag_id":"ckfgoabmi005a45g368ww3jgb","_id":"ckfgoabmj005f45g3h9oleklc"},{"post_id":"ckfgoabl3003245g303sz6nx8","tag_id":"ckfgoabmi005b45g3bui7dv3n","_id":"ckfgoabmk005k45g32z3fc9l5"},{"post_id":"ckfgoabl3003245g303sz6nx8","tag_id":"ckfgoabmi005e45g3a84qfyqt","_id":"ckfgoabmk005l45g3hpn101rp"},{"post_id":"ckfgoabl3003245g303sz6nx8","tag_id":"ckfgoabmj005g45g377071dk1","_id":"ckfgoabmk005n45g343bx91rz"},{"post_id":"ckfgoabl3003245g303sz6nx8","tag_id":"ckfgoabmj005h45g32lwnee03","_id":"ckfgoabml005o45g34eyp724i"},{"post_id":"ckfgoabl3003245g303sz6nx8","tag_id":"ckfgoabmj005i45g36iaq7hor","_id":"ckfgoabml005q45g3fvfq9yha"},{"post_id":"ckfgoabl4003645g3ghce4v53","tag_id":"ckfgoablk003x45g39ar5f30g","_id":"ckfgoabml005r45g3g5ef20wu"},{"post_id":"ckfgoabl4003645g3ghce4v53","tag_id":"ckfgoablo004545g335js2u6g","_id":"ckfgoabmm005s45g3hjivb1e4"},{"post_id":"ckfgoabl4003645g3ghce4v53","tag_id":"ckfgoablz004745g34f5vhoyq","_id":"ckfgoabmm005t45g36ao22irh"},{"post_id":"ckfgoabmv005u45g369w2euj9","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoabmz005w45g3bynq0arn"},{"post_id":"ckfgoabmw005v45g34qnvddp8","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoabn1005y45g3focb6gms"},{"post_id":"ckfgoabmw005v45g34qnvddp8","tag_id":"ckfgoabkz002t45g3a2ou4leb","_id":"ckfgoabn3006245g328f5dby3"},{"post_id":"ckfgoabn1005z45g3dai026jk","tag_id":"ckfgoabki001x45g3f0cs69qy","_id":"ckfgoabn5006545g338wh0fwe"},{"post_id":"ckfgoabn3006345g34nhy5upt","tag_id":"ckfgoabki001x45g3f0cs69qy","_id":"ckfgoabn7006845g3gbk4c3vs"},{"post_id":"ckfgoabn5006645g3he0hb4zo","tag_id":"ckfgoabki001x45g3f0cs69qy","_id":"ckfgoabna006c45g3h5o356xn"},{"post_id":"ckfgoabn7006945g3eoff7nnz","tag_id":"ckfgoabki001x45g3f0cs69qy","_id":"ckfgoabng006f45g37ars4wmu"},{"post_id":"ckfgoabna006d45g369wshumf","tag_id":"ckfgoablk003x45g39ar5f30g","_id":"ckfgoabo4006j45g3epsi14jq"},{"post_id":"ckfgoabna006d45g369wshumf","tag_id":"ckfgoablo004545g335js2u6g","_id":"ckfgoabo5006m45g35jxyhnre"},{"post_id":"ckfgoabna006d45g369wshumf","tag_id":"ckfgoablz004745g34f5vhoyq","_id":"ckfgoabo7006q45g3g4341u8q"},{"post_id":"ckfgoabng006g45g3g64f5s7g","tag_id":"ckfgoablk003x45g39ar5f30g","_id":"ckfgoabo9006t45g3en004epc"},{"post_id":"ckfgoabng006g45g3g64f5s7g","tag_id":"ckfgoablo004545g335js2u6g","_id":"ckfgoabob006x45g34faghdia"},{"post_id":"ckfgoabng006g45g3g64f5s7g","tag_id":"ckfgoablz004745g34f5vhoyq","_id":"ckfgoaboc006z45g39t755cpo"},{"post_id":"ckfgoabmz005x45g3a6gi9z9i","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoabog007245g3ezrs19os"},{"post_id":"ckfgoabmz005x45g3a6gi9z9i","tag_id":"ckfgoable003j45g3du503f9c","_id":"ckfgoabog007345g3bvjef0s0"},{"post_id":"ckfgoabmz005x45g3a6gi9z9i","tag_id":"ckfgoabn2006145g35j60a9j7","_id":"ckfgoaboi007545g3h8p5e6u7"},{"post_id":"ckfgoabmz005x45g3a6gi9z9i","tag_id":"ckfgoabn9006a45g3bu9lhhxe","_id":"ckfgoaboi007645g342g40pft"},{"post_id":"ckfgoabmz005x45g3a6gi9z9i","tag_id":"ckfgoabo3006h45g3gig40x2z","_id":"ckfgoaboj007845g35kn48tnb"},{"post_id":"ckfgoabo5006n45g3delg7512","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoaboj007945g386mxhd1d"},{"post_id":"ckfgoabo5006n45g3delg7512","tag_id":"ckfgoablo004545g335js2u6g","_id":"ckfgoabok007b45g31hu0dr3c"},{"post_id":"ckfgoabo8006r45g33etl6yq5","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoabok007c45g33rye4isb"},{"post_id":"ckfgoabo8006r45g33etl6yq5","tag_id":"ckfgoablo004545g335js2u6g","_id":"ckfgoabol007f45g373irfofg"},{"post_id":"ckfgoabo9006u45g33ofy81py","tag_id":"ckfgoabko002945g3fzve5nva","_id":"ckfgoabol007h45g3778r9hoz"},{"post_id":"ckfgoabo9006u45g33ofy81py","tag_id":"ckfgoablo004545g335js2u6g","_id":"ckfgoabom007j45g3eewn9fwi"},{"post_id":"ckfgoabo4006k45g3cmon9eaz","tag_id":"ckfgoabm8004q45g3h9y80yt0","_id":"ckfgoabom007l45g36nme1vf1"},{"post_id":"ckfgoabo4006k45g3cmon9eaz","tag_id":"ckfgoabmb004w45g39ayz6kjw","_id":"ckfgoabon007n45g379bfawrb"},{"post_id":"ckfgoabo4006k45g3cmon9eaz","tag_id":"ckfgoabo7006p45g3g87j7ux6","_id":"ckfgoabon007p45g3evfsho34"},{"post_id":"ckfi1xptk0000qbg3bou775yk","tag_id":"ckfgoabj6000m45g33lnv76ob","_id":"ckfi1xpuh0003qbg3fxjyca3c"},{"post_id":"ckfi1xptk0000qbg3bou775yk","tag_id":"ckfi1xpu20001qbg33wshdcj7","_id":"ckfi1xpuh0004qbg30c0xfz0k"},{"post_id":"ckfjv880w00012svtgqukhd4w","tag_id":"ckfjv881h00092svt3wxbgnuz","_id":"ckfjv881k000e2svt3woi6600"},{"post_id":"ckfjv880w00012svtgqukhd4w","tag_id":"ckfjv881i000c2svt8upuhb7y","_id":"ckfjv881l000f2svt0kkydn0q"},{"post_id":"ckfkxsgte0000peg33dbw1sa1","tag_id":"ckfjv881d00032svtbn4fanz0","_id":"ckfkxsgth0001peg375le0i5p"},{"post_id":"ckfkxsgte0000peg33dbw1sa1","tag_id":"ckfjv881f00052svt2e24hgal","_id":"ckfkxsgth0002peg36ehxayt8"},{"post_id":"ckfkxsgte0000peg33dbw1sa1","tag_id":"ckfjv881g00072svtg7z5g8g6","_id":"ckfkxsgth0004peg3h52x4g1j"},{"post_id":"ckfme10yg00003rg30a1t84ra","tag_id":"ckfgoabj6000m45g33lnv76ob","_id":"ckfme112b00033rg3ati46r0u"},{"post_id":"ckfme10yg00003rg30a1t84ra","tag_id":"ckfme111y00013rg3ccsa15i1","_id":"ckfme112b00043rg31jv31anm"},{"post_id":"ckfnsf8cc0000gyg3dscscp57","tag_id":"ckfgoabj6000m45g33lnv76ob","_id":"ckfnsf8d00003gyg3gnxq4cto"},{"post_id":"ckfnsf8cc0000gyg3dscscp57","tag_id":"ckfnsf8ch0001gyg38i6gda6v","_id":"ckfnsf8d00004gyg34wfp6doi"},{"post_id":"ckgb0887o00001hvt6yjj15vk","tag_id":"ckfgoabki001x45g3f0cs69qy","_id":"ckgb0888j00031hvtesw7abk7"},{"post_id":"ckgb0887o00001hvt6yjj15vk","tag_id":"ckgb0888200011hvt14nwbdhh","_id":"ckgb0888k00041hvtdo2sc04x"},{"post_id":"ckmf4b6ah0000qetl15j64mbp","tag_id":"ckmf4b6ay0002qetl9omngsps","_id":"ckmf4b6b10007qetlbkyrd504"},{"post_id":"ckmf4b6ah0000qetl15j64mbp","tag_id":"ckmf4b6az0003qetlh3qp9bj6","_id":"ckmf4b6b10008qetl1c6z0ch1"},{"post_id":"ckmf4b6ah0000qetl15j64mbp","tag_id":"ckmf4b6b00005qetl3i2g9wlq","_id":"ckmf4b6b10009qetl5xf5awjn"},{"post_id":"ckmjc5he90000g5tlbwfv6ks1","tag_id":"ckmf4b6ay0002qetl9omngsps","_id":"ckmjc5het0003g5tl2a6z5ztu"},{"post_id":"ckmjc5he90000g5tlbwfv6ks1","tag_id":"ckmjc5heg0001g5tl7j9ode6x","_id":"ckmjc5het0005g5tlazv4blw0"},{"post_id":"ckmjc5he90000g5tlbwfv6ks1","tag_id":"ckmf4b6b00005qetl3i2g9wlq","_id":"ckmjc5heu0006g5tl9jv6e4qj"}],"Tag":[{"name":"Architecture","_id":"ckfgoabit000545g307ry62ki"},{"name":"RPC","_id":"ckfgoabj2000h45g329ag8cod"},{"name":"Interview","_id":"ckfgoabj4000k45g35tfnd9qk"},{"name":"DesignPattern","_id":"ckfgoabj6000m45g33lnv76ob"},{"name":"Factory","_id":"ckfgoabj7000q45g3cqymfcpa"},{"name":"Observer","_id":"ckfgoabj9000x45g3blk9863z"},{"name":"Singleton","_id":"ckfgoabjb001545g3fskagx0h"},{"name":"Docker","_id":"ckfgoabjc001945g318tm3i85"},{"name":"Dockerfile","_id":"ckfgoabjd001e45g381fn2gur"},{"name":"PHP","_id":"ckfgoabki001x45g3f0cs69qy"},{"name":"HTTP","_id":"ckfgoabkl002345g360yk3x93"},{"name":"MySQL","_id":"ckfgoabko002945g3fzve5nva"},{"name":"B+Tree","_id":"ckfgoabkr002g45g3ekeu0ww0"},{"name":"InnoDB","_id":"ckfgoabkz002t45g3a2ou4leb"},{"name":"索引","_id":"ckfgoabl5003745g3ad6tbwro"},{"name":"事务","_id":"ckfgoablc003g45g3holt1yi2"},{"name":"锁","_id":"ckfgoable003j45g3du503f9c"},{"name":"PDO","_id":"ckfgoablh003m45g3gd7a98o4"},{"name":"Protobuf","_id":"ckfgoablj003s45g3beeug1x5"},{"name":"Redis","_id":"ckfgoablk003x45g39ar5f30g"},{"name":"Note","_id":"ckfgoablo004545g335js2u6g"},{"name":"Redis设计与实现","_id":"ckfgoablz004745g34f5vhoyq"},{"name":"TCP/IP","_id":"ckfgoabm7004l45g3ai991luz"},{"name":"Ubuntu","_id":"ckfgoabm8004q45g3h9y80yt0"},{"name":"Config","_id":"ckfgoabmb004w45g39ayz6kjw"},{"name":"Git","_id":"ckfgoabme004y45g34pqsf3ju"},{"name":"Node.js","_id":"ckfgoabmg005445g34asmgb91"},{"name":"SSH","_id":"ckfgoabmi005a45g368ww3jgb"},{"name":"WEB","_id":"ckfgoabmi005b45g3bui7dv3n"},{"name":"SESSION","_id":"ckfgoabmi005e45g3a84qfyqt"},{"name":"COOKIE","_id":"ckfgoabmj005g45g377071dk1"},{"name":"TOKEN","_id":"ckfgoabmj005h45g32lwnee03"},{"name":"JWT","_id":"ckfgoabmj005i45g36iaq7hor"},{"name":"高性能MySQL","_id":"ckfgoabn2006145g35j60a9j7"},{"name":"死锁","_id":"ckfgoabn9006a45g3bu9lhhxe"},{"name":"一致性非锁定读","_id":"ckfgoabo3006h45g3gig40x2z"},{"name":"Hexo","_id":"ckfgoabo7006p45g3g87j7ux6"},{"name":"Command","_id":"ckfi1xpu20001qbg33wshdcj7"},{"name":"Differences","_id":"ckfjv881d00032svtbn4fanz0"},{"name":"OOP","_id":"ckfjv881f00052svt2e24hgal"},{"name":"POP","_id":"ckfjv881g00072svtg7z5g8g6"},{"name":"Concept","_id":"ckfjv881h00092svt3wxbgnuz"},{"name":"ORM","_id":"ckfjv881i000c2svt8upuhb7y"},{"name":"Decorator","_id":"ckfme111y00013rg3ccsa15i1"},{"name":"Adapter","_id":"ckfnsf8ch0001gyg38i6gda6v"},{"name":"Laravel","_id":"ckgb0888200011hvt14nwbdhh"},{"name":"操作系统","_id":"ckmf4b6ay0002qetl9omngsps"},{"name":"进程","_id":"ckmf4b6az0003qetlh3qp9bj6"},{"name":"现代操作系统","_id":"ckmf4b6b00005qetl3i2g9wlq"},{"name":"线程","_id":"ckmjc5heg0001g5tl7j9ode6x"}]}}