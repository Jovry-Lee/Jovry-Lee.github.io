---
title: Docker-Dockerfile指令
date: 2020-09-17 16:18:16
tags: ["Docker","Dockerfile"]
categories: ["Docker","Dockerfile"]
---



## 1 概述

Dockerfile 是一个文本文件，其内包含了一条条的 `指令(Instruction)`，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。

<!--more-->

Dockerfile功能很强大，它提供了十多个指令，如FROM, RUN, COPY等等．



## 2 Dockerfile指令解析

### 2.1 FROM指定基础镜像

`FROM` 是指定 **基础镜像**，在 `Dockerfile` 中 `FROM` 是必备的指令，并且`必须是第一条指令`。



Docker中有一个特殊的镜像，名为`scratch`。这个镜像是虚拟的概念，并不实际存在，他表示一个空白的镜像．若以scratch为基础镜像，以为这不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。



### 2.2 RUN执行命令

`RUN` 指令是用来执行命令行命令的。由于命令行的强大能力，`RUN` 指令在定制镜像时是最常用的指令之一。

其格式有两种：

- shell格式：`RUN <命令>`
- exec格式：`RUN ["可执行文件", "参数1", "参数2"]`



每一个 `RUN` 的行为，会新建立一层，在其上执行这些命令，执行结束后，`commit` 这一层的修改，构成新的镜像。因此`对于实现同一个目的的多条指令应该使用一个RUN指令，并使用&&将各个所需的命令串联起来`．

Dockerfile支持Shell类的行尾添加 `\` 的命令换行方式，以及行首 `#` 进行注释的格式．



注意：为了避免镜像过于臃肿，需要在每一层构建结束后清理掉无关的文件．



### 2.3 COPY复制文件

 `COPY` 指令将从构建上下文目录中 `<源路径>` 的文件/目录复制到新的一层的镜像内的 `<目标路径>` 位置。

- `<源路径>`可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [`filepath.Match`](https://golang.org/pkg/path/filepath/#Match) 规则．
- `<目标路径>` 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 `WORKDIR` 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。



COPY指令格式有两种：

- `COPY [--chown=<user>:<group>] <源路径>... <目标路径>`
- `COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]`



*注：使用 `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。*



### 2.4 ADD高级复制文件

 `ADD` 指令和 `COPY` 的格式和性质基本一致，都是实现复制文件．ADD指令增加了一些功能：

-  <源路径> 可以是一个 `URL`：这种情况下，Docker 引擎会试图去下载这个链接的文件放到 `<目标路径>` 去。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，那么还需要增加额外的一层 `RUN` 进行权限调整．（*若下载的是一个压缩包，需要使用一层RUN指令进行解压*）．（<u>此种情况并不推荐，不如直接使用RUN指令，用wget或curl工具下载，处理．</u>）
-  <源路径> 为一个 `tar` 压缩文件`：压缩格式为 `gzip`, `bzip2` 以及 `xz` 的情况下，`ADD` 指令将会自动解压缩这个压缩文件到 `<目标路径>` 去。



`ADD` 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 `ADD rootfs.tar.xz`。



#### 2.4.1 不推荐使用ADD复制文件的原因

- 因为`ADD` 语义不明。`COPY` 只支持简单将本地文件拷贝到容器中，而 `ADD` 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，`ADD` 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 `ADD rootfs.tar.xz`。
- `ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。



### 2.5 CMD容器启动命令

 `CMD` 指令就是用于指定默认的容器主进程的启动命令的。其格式有两种：

- shell格式：`CMD <命令>`
- exec 格式：`CMD ["可执行文件", "参数1", "参数2"...]`（<u>推荐，因为此类格式会被解析JSON数组，因此一定要使用双引号</u>）
- 参数列表格式：`CMD ["参数1", "参数2"...]`。在指定了 `ENTRYPOINT` 指令后，用 `CMD` 指定具体的参数。



注：在运行时可以指定新的命令来替代镜像设置中的这个默认命令．



`示例`：Ubuntu镜像默认的CMD是`/bin/bash`， 如果直接 `docker run -it ubuntu` 的话，会直接进入 `bash`。我们也可以在运行时指定运行别的命令，如 `docker run -it ubuntu cat /etc/os-release`．



### 2.6 ENTRYPOINT入口点

`ENTRYPOINT`的目的与`CMD`一样，都是在指定容器启动程序及参数。`ENTRYPOINT`在运行时也可以替代，不过比`CMD`要稍微繁琐一些，需要通过docker run的参数`--entrypoint`来指定。



当指定了ENTRYPOINT后，CMD的含义就变了，不再是直接的运行其命令，而是`将CMD的内容作为参数传给ENTRYPOINT指令`，即实际执行时，将变为：

```
<ENTRYPOINT> "<CMD>"
```



### 2.7 ENV设置环境变量

ENV指令用于设置环境变量，在后续的指令中，可以直接使用跟这里定义的环境变量。支持环境变量展开的指令包括：`ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。`

ENV指令格式有两种：

- `ENV <key> <value>`
- `ENV <key1>=<value1> <key2>=<value2>...`．eg：`ENV VERSION=1.0 DEBUG=on NAME="Happy Feet"`

注：*对于含有空格的值用双引号括起来*

后续使用时，使用`$符号+key`进行使用，eg：$NAME



### 2.8 AGR构建参数

构建参数和ENV指令效果一样，都是设置环境变量。不同的是，A`RG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。`

注：*不要使用ARG保存密码之类的，因为`docker history`还是可以看到所有值。*

指令格式：

```
ARG <参数名>[=<默认值>]
```



Dockerfile中的ARG指令是定义参数名称及默认值，可以在构建命令`docker build`中使用以下参数来覆盖。

```
--build-arg <参数名>=<值>
```



注：*ARG 指令有生效范围，如果在 `FROM` 指令之前指定，那么只能用于 `FROM` 指令中。*



### 2.9 VOLUME定义匿名卷

`容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的饮用，其数据库文件应该保存于卷中（VOLUME）中。`

为了防止运行时用户忘记将动态文件所保存目录挂在为卷，在Dockerfile中，可以事先指定某些目录挂在为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。



指令格式为：

- `VOLUME ["<路径1>", "<路径2>"...]`
- `VOLUME <路径>`



在运行时可以通过`-v`覆盖Dockerfile中设置的匿名卷．eg：`docker run -d -v mydata:/data xxxx`．



### 2.10 EXPOSE暴露端口

`EXPOSE`指令是声明运行时容器提供服务端口（注：<u>这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</u>）。



指令格式为：

```
EXPOSE <端口1> [<端口2>...]
```



#### 2.10.1 使用EXPOSR声明的好处

- ①、帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。
- ②、运行时使用随机端口映射时，也就是`docker run -p`命令时，会自动随机映射EXPOSE端口。



`EXPOSE`和`docker run -p <宿主端口>：<容器端口>的区别`？

- -p：映射宿主端口和容器端口，即将容器对应端口服务公开给外界访问。
- EXPOSE：仅仅是声明容器打算使用什么端口，并不会自动在宿主进行端口映射。



### 2.11 WORKDIR指定工作目录

使用`WORKDIR`指令可以指定工作目录（或当前目录），以后各层的当前目录就被改为指定的目录，若该目录不存在，WORKDIR会创建一个目录。



指令格式为：

```
WORKDIR <工作目录路径>
```

注：若 `WORKDIR` 指令使用的相对路径，那么所切换的路径与之前的 `WORKDIR` 有关：

```
WORKDIR /a
WORKDIR b
WORKDIR c

RUN pwd
```

结果为：`/a/b/c`



### 2.12 USER指定当前用户

`USER`指令和`WORKDIR`类似，都是改变环境状态并影响以后的层。WORKDIR是改变工作目录，USER则是改变之后层的适应`RUN`,`CMD`以及`ENTRYPOINT`这类命令的身份。

（注：<u>USER只是切换指定用户，这个用户必须存在。</u>）



指令格式：

```
USER <用户名>[:<用户组>]
```



### 2.13 HEALTHCHECK健康检查

`HEALTHCHECK`指令是告诉Docker应该如何进行判断容器的状态是否正常，这是Docker 1.12引入的新指令。



指令格式为：

- `HEALTHCHECK [选项] CMD <命令>`：设置检查容器健康状况的命令，支持的选项包括：
  - `--interval=<间隔>`：两次健康检查的间隔，默认为 30 秒；
  - `--timeout=<时长>`：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；
  - `--retries=<次数>`：当连续失败指定次数后，则将容器状态视为 `unhealthy`，默认 3 次。
- `HEALTHCHECK NONE`：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令



### 2.14 ONBUILD 为他人作嫁衣裳

`ONBUILD`是一个特殊的指令，他后面跟的是其他指令，比如RUN、COPY等，<u>在当前进项构建时并不会被执行，只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</u>



指令格式：

```
ONBUILD <其它指令>
```



### 2.15 SHELL 指令

SHELL指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell，Linux 中默认为 `["/bin/sh", "-c"]`.



