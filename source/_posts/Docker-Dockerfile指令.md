---
title: Docker-Dockerfile指令
date: 2020-09-17 16:18:16
tags: ["Docker"]
categories: ["Docker"]
---



#### 1 概述

Dockerfile 是一个文本文件，其内包含了一条条的 `指令(Instruction)`，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。

<!--more-->

Dockerfile功能很强大，它提供了十多个指令，如FROM, RUN, COPY等等．



#### 2 Dockerfile指令解析

##### 2.1 FROM指定基础镜像

`FROM` 是指定 **基础镜像**，在 `Dockerfile` 中 `FROM` 是必备的指令，并且`必须是第一条指令`。



Docker中有一个特殊的镜像，名为`scratch`。这个镜像是虚拟的概念，并不实际存在，他表示一个空白的镜像．若以scratch为基础镜像，以为这不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。



##### 2.2 RUN执行命令

`RUN` 指令是用来执行命令行命令的。由于命令行的强大能力，`RUN` 指令在定制镜像时是最常用的指令之一。其格式有两种：

- shell格式：`RUN <命令>`
- exec格式：`RUN ["可执行文件", "参数1", "参数2"]`



每一个 `RUN` 的行为，会新建立一层，在其上执行这些命令，执行结束后，`commit` 这一层的修改，构成新的镜像。因此`对于实现同一个目的的多条指令应该使用一个RUN指令，并使用&&将各个所需的命令串联起来`．

Dockerfile支持Shell类的行尾添加 `\` 的命令换行方式，以及行首 `#` 进行注释的格式．



注意：为了避免镜像过于臃肿，需要在每一层构建结束后清理掉无关的文件．



##### 2.3 COPY复制文件

 `COPY` 指令将从构建上下文目录中 `<源路径>` 的文件/目录复制到新的一层的镜像内的 `<目标路径>` 位置。

- `<源路径>`可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 [`filepath.Match`](https://golang.org/pkg/path/filepath/#Match) 规则．
- `<目标路径>` 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 `WORKDIR` 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。



COPY指令格式有两种：

- `COPY [--chown=<user>:<group>] <源路径>... <目标路径>`
- `COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]`



*注：使用 `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。*



##### 2.4 ADD高级复制文件

 `ADD` 指令和 `COPY` 的格式和性质基本一致，都是实现复制文件．ADD指令增加了一些功能：

-  <源路径> 可以是一个 `URL`：这种情况下，Docker 引擎会试图去下载这个链接的文件放到 `<目标路径>` 去。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，那么还需要增加额外的一层 `RUN` 进行权限调整．（*若下载的是一个压缩包，需要使用一层RUN指令进行解压*）．（<u>此种情况并不推荐，不如直接使用RUN指令，用wget或curl工具下载，处理．</u>）
-  <源路径> 为一个 `tar` 压缩文件`：压缩格式为 `gzip`, `bzip2` 以及 `xz` 的情况下，`ADD` 指令将会自动解压缩这个压缩文件到 `<目标路径>` 去。



`ADD` 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 `ADD rootfs.tar.xz`。



###### 2.4.1 不推荐使用ADD复制文件的原因

- 因为`ADD` 语义不明。`COPY` 只支持简单将本地文件拷贝到容器中，而 `ADD` 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，`ADD` 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 `ADD rootfs.tar.xz`。
- `ADD` 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。



##### 2.5 CMD容器启动命令

 `CMD` 指令就是用于指定默认的容器主进程的启动命令的。其格式有两种：

- shell格式：`CMD <命令>`
- exec 格式：`CMD ["可执行文件", "参数1", "参数2"...]`（<u>推荐，因为此类格式会被解析JSON数组，因此一定要使用双引号</u>）
- 参数列表格式：`CMD ["参数1", "参数2"...]`。在指定了 `ENTRYPOINT` 指令后，用 `CMD` 指定具体的参数。



注：在运行时可以指定新的命令来替代镜像设置中的这个默认命令．



`示例`：Ubuntu镜像默认的CMD是`/bin/bash`， 如果直接 `docker run -it ubuntu` 的话，会直接进入 `bash`。我们也可以在运行时指定运行别的命令，如 `docker run -it ubuntu cat /etc/os-release`．



##### 2.6 ENTRYPOINT入口点

ENTRYPOINT的目的与CMD一样，都是在指定容器启动程序及参数。ENTRYPOINT在运行时也可以替代，不过比CMD要稍微繁琐一些，需要通过docker run的参数`--entrypoint`来指定。



当指定了ENTRYPOINT后，CMD的含义就变了，不再是直接的运行其命令，而是`将CMD的内容作为参数传给ENTRYPOINT指令`，即实际执行时，将变为：

```
<ENTRYPOINT> "<CMD>"
```



##### 2.7 ENV设置环境变量

ENV指令用于设置环境变量，在后续的指令中，可以直接使用跟这里定义的环境变量。支持环境变量展开的指令包括：`ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。`

ENV指令格式有两种：

- `ENV <key> <value>`
- `ENV <key1>=<value1> <key2>=<value2>...`．eg：`ENV VERSION=1.0 DEBUG=on NAME="Happy Feet"`

注：*对于含有空格的值用双引号括起来*

后续使用时，使用`$符号+key`进行使用，eg：$NAME



##### 2.8 AGR构建参数

构建参数和ENV指令效果一样，都是设置环境变量。不同的是，A`RG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。`

注：*不要使用ARG保存密码之类的，因为`docker history`还是可以看到所有值。*

指令格式：

```
ARG <参数名>[=<默认值>]
```



Dockerfile中的ARG指令是定义参数名称及默认值，可以在构建命令`docker build`中使用以下参数来覆盖。

```
--build-arg <参数名>=<值>
```



注：*ARG 指令有生效范围，如果在 `FROM` 指令之前指定，那么只能用于 `FROM` 指令中。*



##### 2.9 VOLUME定义匿名卷

`容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的饮用，其数据库文件应该保存于卷中（VOLUME）中。`

为了防止运行时用户忘记将动态文件所保存目录挂在为卷，在Dockerfile中，可以事先指定某些目录挂在为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。



指令格式为：

- VOLUME ["<路径1>", "<路径2>"...]
- VOLUME <路径>



在运行时可以通过`-v`覆盖Dockerfile中设置的匿名卷．eg：`docker run -d -v mydata:/data xxxx`．



















