<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jovry-lee.github.io","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="1 概述FPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其核心功能是进程管理。FastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。注：FastCGI只是一种协议。">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP7内核-FPM">
<meta property="og:url" content="https://jovry-lee.github.io/2020/08/21/PHP7%E5%86%85%E6%A0%B8-FPM/index.html">
<meta property="og:site_name" content="Jovry&#39;s blog">
<meta property="og:description" content="1 概述FPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其核心功能是进程管理。FastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。注：FastCGI只是一种协议。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec">
<meta property="article:published_time" content="2020-08-21T10:15:16.000Z">
<meta property="article:modified_time" content="2020-08-30T12:42:36.923Z">
<meta property="article:author" content="Jovry Lee">
<meta property="article:tag" content="PHP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4">


<link rel="canonical" href="https://jovry-lee.github.io/2020/08/21/PHP7%E5%86%85%E6%A0%B8-FPM/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>PHP7内核-FPM | Jovry's blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Jovry's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="nav-text">2 基本实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-FPM%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">2.1 FPM的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-worker-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-text">2.2 worker-请求处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-master-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">2.3 master-进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-sp-1-%E7%AE%A1%E9%81%93%E5%8F%AF%E8%AF%BB%E4%BA%8B%E4%BB%B6%EF%BC%9A"><span class="nav-text">2.3.1. sp[1]管道可读事件：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat"><span class="nav-text">2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-fpm-pctl-heartbeat"><span class="nav-text">2.3.3 fpm_pctl_heartbeat():</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jovry Lee"
      src="/images/princess.jpg">
  <p class="site-author-name" itemprop="name">Jovry Lee</p>
  <div class="site-description" itemprop="description">Keeping learning and improving!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jovry-lee.github.io/2020/08/21/PHP7%E5%86%85%E6%A0%B8-FPM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/princess.jpg">
      <meta itemprop="name" content="Jovry Lee">
      <meta itemprop="description" content="Keeping learning and improving!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jovry's blog">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PHP7内核-FPM
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-08-21 18:15:16" itemprop="dateCreated datePublished" datetime="2020-08-21T18:15:16+08:00">2020-08-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-08-30 20:42:36" itemprop="dateModified" datetime="2020-08-30T20:42:36+08:00">2020-08-30</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PHP/" itemprop="url" rel="index"><span itemprop="name">PHP</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>FPM（FastCGI Process Manager）是PHP FastCGI运行模式的一个进程管理器， 其<u>核心功能是进程管理</u>。<br>FastCGI是Web服务器（如Nginx，Apache）和处理程序之间的一种通信协议， 类似于Http，是一种应用层通信协议。<u>注：FastCGI只是一种协议</u>。</p>
<a id="more"></a>

<p>PHP处理Http请求过程：<code>PHP接收请求</code>、<code>解析协议</code>，<code>处理完成返回请求</code>。<br>在网络应用场景下，PHP实现了FastCGI协议，然后与web服务器配合实现了http的处理，web服务器处理http请求，然后将解析的结果通过FastCGI协议转发给处理程序，处理程序处理完成后将结果返回给web服务器，web服务器再返回给用户，如下图所示：<br><img src="https://note.youdao.com/yws/api/personal/file/94A461E9A2D44F08BCA476D311390436?method=download&shareKey=b6ccb2591612fc2c28386720a51330f4" alt="fastcgi"></p>
<p><u>PHP实现了FastCGI协议的解析，但未具体实现网络处理</u>，一般的处理模型：<code>多进程</code>，<code>多线程</code>。</p>
<ul>
<li><strong>多进程模型</strong>：主进程只负责管理子进程，而基本的网络事件由各个子进程处理，例如：nginx、fpm。</li>
<li><strong>多线程模型</strong>：与多进程类似，只是它是线程粒度，这种模式通常由主线程监听、接收请求，然后交给子线程处理，例如：memcache。有的也用多进程的那种模式——主线程只负责管理子线程，各个子线程负责监听、接收、处理请求，例如：memcache使用udp协议的情况。</li>
</ul>
<p><em>进程拥有独立的地址空间及资源，而线程没有，线程之间共享进程的地址空间及资源，所以在资源管理上多进程模型比较简单，而多线程模型需考虑不同线程之间的资源冲突，及线程安全。</em></p>
<h3 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2 基本实现"></a>2 基本实现</h3><p>FPM是一个<code>多进程模型</code>，它由<code>一个master进程</code>和<code>多个worker进程</code>组成。master会创建一个socket，但不会接口处理进程，而是由fork出的worker进程处理接收请求和处理。</p>
<ul>
<li><strong>master进程</strong>：master进程的主要工作是管理worker进程，负责fork或kill掉worker进程。</li>
<li><strong>worker进程</strong>：worker进程的主要工作是处理请求，其生命周期为：<code>accept请求-&gt;解析FastCGI-&gt;执行相应脚本-&gt;关闭请求-&gt;等待新的请求</code>。  </li>
</ul>
<p><em>注：Fpm为阻塞式模型，即一个进程只会同时链接一个请求。（目的是为了简化PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突）</em></p>
<p><strong>FPM的实现概括</strong>：创建一个master进程，在master进程中创建并监听socket， 然后fork出多个子进程，这些子进程各自accept请求，有请求达到后开始读取请求数据，读取完成后开始处理然后返回。<u>（子进程启动后阻塞在accept上，直到有请求到达，且子进程同时只能响应一个请求。）</u></p>
<p>FPM的master进程与worker进程之间不会直接进行通信，master通过<code>共享内存</code>获取worker进程的信息（worker当前状态、已处理请求数等），当master进程要kill一个worker进程则通过<code>发信号的方式</code>通知worker进程（<strong>master进程管理woker进程通过发信号的方式</strong>）。</p>
<p><u>FPM可以监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程。</u><br><img src="https://note.youdao.com/yws/api/personal/file/54B0F0FF2171453D83B2C319E5A110B9?method=download&shareKey=fbf52aed774d116102a91aae2ab8f1bd" alt="worker_pool"></p>
<p>在<code>php-fpm.conf</code>（php-fpm.conf路径：<code>/etc/php/7.1/fpm/php-fpm.conf</code>）中通过[pool name]声明一个worker pool：<br>（php-fpm.conf文件中include了多个pool配置，相关配置在（<code>/etc/php/7.1/fpm/pool.d/*.conf</code>））</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[web1]</span><br><span class="line">listen &#x3D; 127.0.0.1:9000</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[web2]</span><br><span class="line">listen &#x3D; 127.0.0.1:9001</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>启动fpm后查看进程：ps -aux|grep fpm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (&#x2F;usr&#x2F;local&#x2F;php7&#x2F;etc&#x2F;php-fpm.conf)</span><br><span class="line">nobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class="line">nobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1</span><br><span class="line">nobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br><span class="line">nobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</span><br></pre></td></tr></table></figure>

<p><strong>具体实现</strong>：<br><code>worker pool</code>通过<code>fpm_worker_pool_s</code>这个结构表示，多个<code>worker pool</code>组成一个<strong>单链表</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_s</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个worker pool</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_config_s</span> *<span class="title">config</span>;</span> <span class="comment">//conf配置:pm、max_children、start_servers...</span></span><br><span class="line">    <span class="keyword">int</span> listening_socket; <span class="comment">//监听的套接字</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_child_s</span> *<span class="title">children</span>;</span> <span class="comment">// 当前pool的worker链表，每一个worker对应一个fpm_child_s结构</span></span><br><span class="line">    <span class="keyword">int</span> running_children; <span class="comment">//当前pool的worker运行总数</span></span><br><span class="line">    <span class="keyword">int</span> idle_spawn_rate;</span><br><span class="line">    <span class="keyword">int</span> warn_max_children;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_scoreboard_s</span> *<span class="title">scoreboard</span>;</span> <span class="comment">//记录worker的运行信息，比如空闲、忙碌worker数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-FPM的初始化"><a href="#2-1-FPM的初始化" class="headerlink" title="2.1 FPM的初始化"></a>2.1 FPM的初始化</h4><p>Fpm在启动后首先会进行<code>SAPI的注册操作</code>，接着会进入PHP生命周期的<code>module startup</code>阶段，在这个阶段会调用各个扩展定义的MINT钩子函数，然后进行一系列的初始化操作，最后master，worker进程进入不同的处理环节。</p>
<p><u>fpm的启动流程：</u></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sapi/fpm/fpm/fpm_main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注册SAPI:将全局变量sapi_module设置为cgi_sapi_module</span></span><br><span class="line">    sapi_startup(&amp;cgi_sapi_module);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//执行php_module_starup()</span></span><br><span class="line">    <span class="keyword">if</span> (cgi_sapi_module.startup(&amp;cgi_sapi_module) == FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span> FPM_EXIT_SOFTWARE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &gt; fpm_init(...))&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    fpm_is_running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    fcgi_fd = fpm_run(&amp;max_requests);<span class="comment">//后面都是worker进程的操作，master进程不会走到下面</span></span><br><span class="line">    parent = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fpm_init()</code>主要有以下几个关键操作：</p>
<ul>
<li><p>fpm_conf_init_main():  解析php-fpm.conf配置文件.<br>解析<code>php-fpm.conf</code>配置文件，分配worker pool内存结构并保存到全局变量中：fpm_worker_all_pools，各worker pool配置解析到<code>fpm_worker_pool_s-&gt;config</code>中，以下为config中的几个常用配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_config_s</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> *name; <span class="comment">// pool名称，即配置：[pool name]</span></span><br><span class="line">	<span class="keyword">char</span> *user; <span class="comment">// Fpm的启动用户：配置：user</span></span><br><span class="line">	<span class="keyword">char</span> *group; <span class="comment">// 配置：group</span></span><br><span class="line">	<span class="keyword">char</span> *listen_address; <span class="comment">// 监听的地址，配置：listen</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">int</span> pm; <span class="comment">// 进程模型：static、dynamic、ondemand</span></span><br><span class="line">	<span class="keyword">int</span> pm_max_children; <span class="comment">// 最大worker进程数</span></span><br><span class="line">	<span class="keyword">int</span> pm_start_servers; <span class="comment">// 启动时初始化的worker数</span></span><br><span class="line">	<span class="keyword">int</span> pm_min_spare_servers; <span class="comment">// 最小空闲worker数</span></span><br><span class="line">	<span class="keyword">int</span> pm_max_spare_servers; <span class="comment">// 最大空闲worker数</span></span><br><span class="line">	<span class="keyword">int</span> pm_process_idle_timeout; <span class="comment">// worker空闲时间</span></span><br><span class="line">	<span class="keyword">int</span> pm_max_requests; <span class="comment">// worker处理的最多请求数，超多这个值worker将被kill</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fpm_scoreboard_init_main():  分配用于记录worker进行运行信息的共享内存.<br>分配用于<code>记录worker进程运行信息的共享内存</code>。按照worker pool的最大worker进程数分配，每个worker pool分配一个<strong>fpm_scoreboard_s</strong>结构，pool下对应的每个worker进程分配一个<strong>fpm_scoreboard_proc_s</strong>结构，各结构的对应关系如下图。<br><img src="https://note.youdao.com/yws/api/personal/file/E8A679F76DF54280A4A4760C55D94B7A?method=download&shareKey=07fc4d0f2f25c4df01ae4109f6b2d738" alt="worker_pool_struct"></p>
</li>
<li><p>fpm_signals_init_mian():  mataer进行创建管道及注册信号管理worker进程.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sp[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpm_signals_init_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个全双工管道，该管道不是用于master与worker进程通信的，只在master进程中使用。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册信号处理handler</span></span><br><span class="line">    act.sa_handler = sig_handler;</span><br><span class="line">    sigfillset(&amp;act.sa_mask);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; sigaction(SIGTERM,  &amp;act, <span class="number">0</span>) ||</span><br><span class="line">        <span class="number">0</span> &gt; sigaction(SIGINT,   &amp;act, <span class="number">0</span>) ||</span><br><span class="line">        <span class="number">0</span> &gt; sigaction(SIGUSR1,  &amp;act, <span class="number">0</span>) ||</span><br><span class="line">        <span class="number">0</span> &gt; sigaction(SIGUSR2,  &amp;act, <span class="number">0</span>) ||</span><br><span class="line">        <span class="number">0</span> &gt; sigaction(SIGCHLD,  &amp;act, <span class="number">0</span>) ||</span><br><span class="line">        <span class="number">0</span> &gt; sigaction(SIGQUIT,  &amp;act, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过**socketpair()**创建一个管道，此管道只在master进程中使用。另外设置master的信号处理handler，当master收到SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT这些信号时将调用sig_handler()处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> sig_chars[NSIG + <span class="number">1</span>] = &#123;</span><br><span class="line">        [SIGTERM] = <span class="string">&#x27;T&#x27;</span>,</span><br><span class="line">        [SIGINT]  = <span class="string">&#x27;I&#x27;</span>,</span><br><span class="line">        [SIGUSR1] = <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        [SIGUSR2] = <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">        [SIGQUIT] = <span class="string">&#x27;Q&#x27;</span>,</span><br><span class="line">        [SIGCHLD] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">    ...</span><br><span class="line">    s = sig_chars[signo];</span><br><span class="line">    <span class="comment">//将信号通知写入管道sp[1]端</span></span><br><span class="line">    write(sp[<span class="number">1</span>], &amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fpm_sockets_init_main():  创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。</p>
</li>
<li><p>fpm_event_init_main():  启动master的事件管理.<br>启动master的事件管理，fpm实现了一个事件管理器用于管理IO、定时事件，其中IO事件通过kqueue、epoll、poll、select等管理，定时事件就是定时器，一定时间后触发某个事件。</p>
</li>
</ul>
<p>在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将fork子进程，启动进程管理器，另外master进程将不会再返回，只有各worker进程会返回，也就是说fpm_run()之后的操作均是worker进程的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpm_run</span><span class="params">(<span class="keyword">int</span> *max_requests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_s</span> *<span class="title">wp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (wp = fpm_worker_all_pools; wp; wp = wp-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//调用fpm_children_make() fork子进程</span></span><br><span class="line">        is_parent = fpm_children_create_initial(wp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!is_parent) &#123;</span><br><span class="line">            <span class="keyword">goto</span> run_child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//master进程将进入event循环，不再往下走</span></span><br><span class="line">    fpm_event_loop(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">run_child: <span class="comment">//只有worker进程会到这里</span></span><br><span class="line"></span><br><span class="line">    *max_requests = fpm_globals.max_requests;</span><br><span class="line">    <span class="keyword">return</span> fpm_globals.listening_socket; <span class="comment">//返回监听的套接字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在fork后worker进程返回了监听的套接字继续main()后面的处理，而master将永远阻塞在fpm_event_loop().</p>
<h4 id="2-2-worker-请求处理"><a href="#2-2-worker-请求处理" class="headerlink" title="2.2 worker-请求处理"></a>2.2 worker-请求处理</h4><p>fpm_run()执行后将fork出worker进程，worker进程返回main()中继续向下执行，后面的流程就是worker进程不断accept请求，然后执行PHP脚本并返回。整体流程如下：</p>
<ul>
<li><p><strong>等待请求</strong>： worker进程阻塞在fcgi_accept_request()等待请求。</p>
</li>
<li><p><strong>解析请求</strong>： fastcgi请求到达后被worker接收，然后开始接受并解析请求数据，直到request数据完全到达。</p>
</li>
<li><p><strong>请求初始化</strong>：执行php_request_startup(), 此阶段会调用每个扩展的PHP_RINI_FUNCTION();</p>
</li>
<li><p><strong>编译、执行</strong>：php_execute_script()完成PHP脚本的编译、执行。</p>
</li>
<li><p><strong>关闭请求</strong>：请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    fcgi_fd = fpm_run(&amp;max_requests);</span><br><span class="line">    parent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化fastcgi请求</span></span><br><span class="line">    request = fpm_init_request(fcgi_fd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//worker进程将阻塞在这，等待请求</span></span><br><span class="line">    <span class="keyword">while</span> (EXPECTED(fcgi_accept_request(request) &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        SG(server_context) = (<span class="keyword">void</span> *) request;</span><br><span class="line">        init_request_info();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//请求开始</span></span><br><span class="line">        <span class="keyword">if</span> (UNEXPECTED(php_request_startup() == FAILURE)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        fpm_request_executing();</span><br><span class="line">        <span class="comment">//编译、执行PHP脚本</span></span><br><span class="line">        php_execute_script(&amp;file_handle);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//请求结束</span></span><br><span class="line">        php_request_shutdown((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//worker进程退出</span></span><br><span class="line">    php_module_shutdown();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worker进程一次请求的处理被划分为5个阶段：</p>
</li>
<li><p><strong>FPM_REQUEST_ACCEPTING</strong>: 等待请求阶段</p>
</li>
<li><p><strong>FPM_REQUEST_READING_HEADERS</strong>: 读取fastcgi请求header阶段</p>
</li>
<li><p><strong>FPM_REQUEST_INFO</strong>: 获取请求信息阶段，此阶段是将请求的method、query stirng、request uri等信息保存到各worker进程的fpm_scoreboard_proc_s结构中，此操作需要加锁，因为master进程也会操作此结构</p>
</li>
<li><p><strong>FPM_REQUEST_EXECUTING</strong>: 执行请求阶段</p>
</li>
<li><p><strong>FPM_REQUEST_END</strong>: 没有使用</p>
</li>
<li><p><strong>FPM_REQUEST_FINISHED</strong>: 请求处理完成<br>worker处理到各个阶段时将会把当前阶段更新到==fpm_scoreboard_proc_s-&gt;request_stage==，master进程正是通过这个标识判断worker进程是否空闲的。</p>
</li>
</ul>
<h4 id="2-3-master-进程管理"><a href="#2-3-master-进程管理" class="headerlink" title="2.3 master-进程管理"></a>2.3 master-进程管理</h4><p><u>master进程管理woker进程管理方式:</u></p>
<ul>
<li><strong>static</strong><br>worker进程数固定不变。在启动时master按照pm.max_children配置fork出相应数量的worker进程。</li>
<li><strong>dynamic</strong><br>动态进程管理。 <ul>
<li>首先fpm启动时按照pm.start_servers初始化一定数量的worker（<em>默认情况为：pm.min_spare_servers + (max_spare_servers - min_spare_servers) / 2</em>）。</li>
<li>运行期间若master发现空闲的worker数低于pm.min_spare_servers(最小空闲数)配置数（请求较多，worker处理不过来）则会fork进程，但总worker数不能超过pm.max_children(最大进程数)；</li>
<li>若空闲worker数超过pm.max_spare_servers(最大空闲数)（空闲worker数过多），则kill掉一些wokrer，避免占用资源过多。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pm.start_servers: 初始worker数</span><br><span class="line">pm.min_spare_servers: 最小空闲worker数量</span><br><span class="line">pm.max_spare_servers: 最大空闲worker数量</span><br><span class="line">pm.max_children: 最大worker数</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>ondemand</strong><br>在启动时不分配worker进程，等到有请求了后再通知master进程fork worker进程，总的worker数不超过pm.max_children，处理完成后worker进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm.max_children: 最大worker数</span><br><span class="line">pm.process_idle_timeout: 空闲超时时间</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>master整体的处理，其进程管理主要依赖注册的几个事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fpm_event_loop</span><span class="params">(<span class="keyword">int</span> err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]</span></span><br><span class="line">    <span class="comment">//当sp[0]可读时将回调fpm_got_signal()</span></span><br><span class="line">    fpm_event_set(&amp;signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &amp;fpm_got_signal, <span class="literal">NULL</span>);</span><br><span class="line">    fpm_event_add(&amp;signal_fd_event, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查</span></span><br><span class="line">    <span class="keyword">if</span> (fpm_globals.heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fpm_pctl_heartbeat(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定时触发进程管理</span></span><br><span class="line">    fpm_pctl_perform_idle_server_maintenance_heartbeat(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进入事件循环，master进程将阻塞在此</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//等待IO事件</span></span><br><span class="line">        ret = <span class="keyword">module</span>-&gt;wait(fpm_event_queue_fd, timeout);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//检查定时器事件</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-1-sp-1-管道可读事件："><a href="#2-3-1-sp-1-管道可读事件：" class="headerlink" title="2.3.1. sp[1]管道可读事件："></a>2.3.1. sp[1]管道可读事件：</h5><p>在fpm_init()阶段master曾创建了一个全双工的管道：<code>sp</code>，然后在这里创建了一个sp[0]可读的事件，当sp[0]可读时将交由fpm_got_signal()处理，向sp[1]写数据时sp[0]才会可读，那么什么时机会向sp[1]写数据呢？前面已经提到了：当master收到注册的那几种信号时会写入sp[1]端，这个时候将触发sp[0]可读事件。<br><img src="https://note.youdao.com/yws/api/personal/file/0A7863804BB64BAF9886A6C51074E0BD?method=download&shareKey=8cf19b2b30511a2cc2fe04d4dfb8b2ec" alt="master_event_1"><br>信号用途：</p>
<ul>
<li>SIGINT/SIGTERM/SIGQUIT:<strong>退出fpm</strong>，在master收到退出信号后将向所有的worker进程发送退出信号，然后master退出.</li>
<li>SIGUSR1:<strong>重新加载日志文件</strong>，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果fpm不重新加载将无法继续写入日志，这个时候就需要向master发送一个USR1的信号</li>
<li>SIGUSR2:<strong>重启fpm</strong>，首先master也是会向所有的worker进程发送退出信号，然后master会调用execvp()重新启动fpm，最后旧的master退出</li>
<li>SIGCHLD:这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用wait或者waitpid函数查询子进程退出状态后子进程才告终止，fpm中当worker进程因为异常原因(比如coredump了)退出而非master主动杀掉时master将受到此信号，这个时候父进程将调用waitpid()查下子进程的退出，然后检查下是不是需要重新fork新的worker</li>
</ul>
<h5 id="2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat"><a href="#2-3-2-fpm-pctl-perform-idle-server-maintenance-heartbeat" class="headerlink" title="2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():"></a>2.3.2. fpm_pctl_perform_idle_server_maintenance_heartbeat():</h5><p>这是进程管理实现的主要事件，master启动了一个定时器，每隔<strong>1s</strong>触发一次，主要用于dynamic、ondemand模式下的worker管理，master会定时检查各worker pool的worker进程数，通过此定时器实现worker数量的控制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)</span><br><span class="line">&#123;</span><br><span class="line">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class="line">        struct fpm_child_s *last_idle_child &#x3D; NULL; &#x2F;&#x2F;空闲时间最久的worker</span><br><span class="line">        int idle &#x3D; 0; &#x2F;&#x2F;空闲worker数</span><br><span class="line">        int active &#x3D; 0; &#x2F;&#x2F;忙碌worker数</span><br><span class="line">        </span><br><span class="line">        for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class="line">            &#x2F;&#x2F;根据worker进程的fpm_scoreboard_proc_s-&gt;request_stage判断</span><br><span class="line">            if (fpm_request_is_idle(child)) &#123;</span><br><span class="line">                &#x2F;&#x2F;找空闲时间最久的worker</span><br><span class="line">                ...</span><br><span class="line">                idle++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                active++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;ondemand模式</span><br><span class="line">        if (wp-&gt;config-&gt;pm &#x3D;&#x3D; PM_STYLE_ONDEMAND) &#123;</span><br><span class="line">            if (!last_idle_child) continue;</span><br><span class="line"></span><br><span class="line">            fpm_request_last_activity(last_idle_child, &amp;last);</span><br><span class="line">            fpm_clock_get(&amp;now);</span><br><span class="line">            if (last.tv_sec &lt; now.tv_sec - wp-&gt;config-&gt;pm_process_idle_timeout) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker</span><br><span class="line">                last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class="line">                fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class="line">            &#125; </span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;dynamic</span><br><span class="line">        if (wp-&gt;config-&gt;pm !&#x3D; PM_STYLE_DYNAMIC) continue;</span><br><span class="line">        if (idle &gt; wp-&gt;config-&gt;pm_max_spare_servers &amp;&amp; last_idle_child) &#123;</span><br><span class="line">            &#x2F;&#x2F;空闲worker太多了，杀掉</span><br><span class="line">            last_idle_child-&gt;idle_kill &#x3D; 1;</span><br><span class="line">            fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);</span><br><span class="line">            wp-&gt;idle_spawn_rate &#x3D; 1;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (idle &lt; wp-&gt;config-&gt;pm_min_spare_servers) &#123;</span><br><span class="line">            &#x2F;&#x2F;空闲worker太少了，如果总worker数未达到max数则fork</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-3-fpm-pctl-heartbeat"><a href="#2-3-3-fpm-pctl-heartbeat" class="headerlink" title="2.3.3 fpm_pctl_heartbeat():"></a>2.3.3 fpm_pctl_heartbeat():</h5><p>这个事件是用于限制worker处理单个请求最大耗时的，php-fpm.conf中有一个request_terminate_timeout的配置项，如果worker处理一个请求的总时长超过了这个值那么master将会向此worker进程发送kill -TERM信号杀掉worker进程，此配置单位为秒，默认值为0表示关闭此机制，另外fpm打印的slow log也是在这里完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void fpm_pctl_check_request_timeout(struct timeval *now)</span><br><span class="line">&#123;   </span><br><span class="line">    struct fpm_worker_pool_s *wp;</span><br><span class="line"></span><br><span class="line">    for (wp &#x3D; fpm_worker_all_pools; wp; wp &#x3D; wp-&gt;next) &#123;</span><br><span class="line">        int terminate_timeout &#x3D; wp-&gt;config-&gt;request_terminate_timeout;</span><br><span class="line">        int slowlog_timeout &#x3D; wp-&gt;config-&gt;request_slowlog_timeout;</span><br><span class="line">        struct fpm_child_s *child;</span><br><span class="line"></span><br><span class="line">        if (terminate_timeout || slowlog_timeout) &#123; </span><br><span class="line">            for (child &#x3D; wp-&gt;children; child; child &#x3D; child-&gt;next) &#123;</span><br><span class="line">                &#x2F;&#x2F;检查当前当前worker处理的请求是否超时</span><br><span class="line">                fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：<em>ondemand模式下master监听的新请求到达的事件，因为ondemand模式下fpm启动时是不会预创建worker的，有请求时才会生成子进程，所以请求到达时需要通知master进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()。</em></p>
<hr>
<p>参考文档：<br>1、php内核剖析： <a target="_blank" rel="noopener" href="http://www.php.cn/manual/view/32905.html">http://www.php.cn/manual/view/32905.html</a><br>2、php7-integernal：<a target="_blank" rel="noopener" href="https://github.com/pangudashu/php7-internal">https://github.com/pangudashu/php7-internal</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/PHP/" rel="tag"># PHP</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/21/PHP7%E5%86%85%E6%A0%B8-Cli/" rel="prev" title="PHP7内核-Cli">
                  <i class="fa fa-chevron-left"></i> PHP7内核-Cli
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/25/FastCGI%E5%92%8CPHP-FPM%E7%9A%84%E5%85%B3%E7%B3%BB/" rel="next" title="FastCGI和PHP-FPM的关系">
                  FastCGI和PHP-FPM的关系 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jovry Lee</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5a984c2656b35662c599',
      clientSecret: '67fd127f911d50c0241d3292884f55d1b8405f51',
      repo        : 'gitalk-comments',
      owner       : 'Jovry-Lee',
      admin       : ['Jovry-Lee'],
      id          : '63048cdb9d83a5aa2aba95ac4f04771a',
        language: 'en',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
